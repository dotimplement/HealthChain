import asyncio
import logging
import threading
import uuid
import requests

from pathlib import Path
from time import sleep
from typing import Dict, Optional

from healthchain.service import Service
from healthchain.sandbox.apimethod import APIMethod
from healthchain.sandbox.base import BaseClient
from healthchain.sandbox.utils import ensure_directory_exists, save_data_to_directory
from healthchain.sandbox.workflows import UseCaseType
from healthchain.utils import UrlBuilder

log = logging.getLogger(__name__)


class SandboxEnvironment:
    """
    Manages the sandbox environment for testing and validation.
    Handles service initialization, client requests, and data management.
    """

    def __init__(
        self,
        service_api: Optional[APIMethod] = None,
        client: Optional[BaseClient] = None,
        service_config: Optional[Dict] = None,
        use_case_type: Optional[UseCaseType] = None,
        endpoints: Optional[Dict] = None,
    ):
        """
        Initialize the sandbox environment

        Args:
            service_api: The API method to use for the service
            client: The client to use for sending requests
            service_config: Configuration for the service
            use_case_type: Type of use case (clindoc, cds)
            endpoints: Service endpoints
        """
        self._service_api = service_api
        self._client = client
        self.service_config = service_config or {}
        self.type = use_case_type
        self.endpoints = endpoints

        self._service = Service(endpoints=endpoints) if endpoints else None
        self.responses = []
        self.sandbox_id = None
        self.url = None

    def start_sandbox(
        self,
        service_id: str = "1",
        save_data: bool = True,
        save_dir: str = "./output/",
        logging_config: Optional[Dict] = None,
    ) -> None:
        """
        Starts the sandbox: initializes service and sends request through the client.

        Args:
            service_id: Service identifier (default "1")
            save_data: Whether to save request/response data
            save_dir: Directory to save data
            logging_config: Optional logging configuration
        """
        if self._service_api is None or self._client is None:
            raise RuntimeError(
                "Service API or Client is not configured. Please check your class initialization."
            )

        self.sandbox_id = uuid.uuid4()

        if logging_config:
            logging.config.dictConfig(logging_config)
        else:
            # Set up default logging configuration
            logging.basicConfig(
                level=logging.INFO,
                format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
            )

        log = logging.getLogger(__name__)

        # Start service on thread
        log.info(
            f"Starting sandbox {self.sandbox_id} with use case type {self.type.value}..."
        )
        server_thread = threading.Thread(
            target=lambda: self._service.run(config=self.service_config)
        )
        server_thread.start()

        # Wait for service to start
        sleep(5)

        self.url = UrlBuilder.build_from_config(
            config=self.service_config,
            endpoints=self.endpoints,
            service_id=service_id,
        )

        # Send async request from client
        log.info(
            f"Sending {len(self._client.request_data)} requests generated by {self._client.__class__.__name__} to {self.url.route}"
        )

        try:
            self.responses = asyncio.run(
                self._client.send_request(url=self.url.service)
            )
        except Exception as e:
            log.error(f"Couldn't start client: {e}", exc_info=True)

        if save_data:
            save_dir = Path(save_dir)
            request_path = ensure_directory_exists(save_dir / "requests")

            if self.type == UseCaseType.clindoc:
                extension = "xml"
                save_data_to_directory(
                    [request.model_dump_xml() for request in self._client.request_data],
                    "request",
                    self.sandbox_id,
                    request_path,
                    extension,
                )
            else:
                extension = "json"
                save_data_to_directory(
                    [
                        request.model_dump(exclude_none=True)
                        for request in self._client.request_data
                    ],
                    "request",
                    self.sandbox_id,
                    request_path,
                    extension,
                )

            log.info(f"Saved request data at {request_path}/")

            response_path = ensure_directory_exists(save_dir / "responses")
            save_data_to_directory(
                self.responses,
                "response",
                self.sandbox_id,
                response_path,
                extension,
            )
            log.info(f"Saved response data at {response_path}/")

    def stop_sandbox(self) -> None:
        """Shuts down sandbox instance"""
        log.info("Shutting down server...")
        requests.get(self.url.base + "/shutdown")
