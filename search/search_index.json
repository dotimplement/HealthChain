{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to HealthChain \ud83d\udcab \ud83c\udfe5","text":"<p>HealthChain is an open-source Python toolkit that streamlines productionizing healthcare AI. Built for AI/ML practitioners, it simplifies the complexity of real-time EHR integrations by providing seamless FHIR integration, unified data pipelines, and production-ready deployment.</p> <p>  Join our Discord  Quickstart Guide</p>"},{"location":"#what-are-the-main-features","title":"What are the main features?","text":"<ul> <li> <p> FHIR-native ML Pipelines</p> <p>Create custom pipelines or use pre-built ones for healthcare NLP and ML tasks with automatic FHIR output</p> <p> Pipeline</p> </li> <li> <p> Multi-EHR Gateway</p> <p>Connect to multiple healthcare systems with unified API supporting FHIR, CDS Hooks, and SOAP/CDA protocols</p> <p> Gateway</p> </li> <li> <p> Healthcare Data Conversion</p> <p>Convert between FHIR, CDA, and HL7v2 formats using configuration-driven InteropEngine</p> <p> Interoperability</p> </li> <li> <p> Developer Utilities</p> <p>Type-safe FHIR resources, validation helpers, and sandbox environments for rapid development</p> <p> Utilities</p> </li> </ul>"},{"location":"#getting-started-with-healthcare-ai","title":"Getting Started with Healthcare AI","text":"<p>HealthChain provides the missing middleware layer between healthcare systems and modern AI/ML development. Whether you're building clinical decision support tools, processing medical documents, or creating multi-system integrations, these docs will guide you through:</p> <ul> <li>\ud83d\udd27 Core concepts - Understand FHIR resources, pipelines, and gateway patterns</li> <li>\ud83d\udcda Real examples - Step-by-step tutorials for common healthcare AI use cases</li> <li>\ud83c\udfd7\ufe0f Advanced patterns - Production deployment, authentication, and multi-EHR workflows</li> <li>\ud83e\uddea Testing tools - Sandbox environments and utilities for development</li> </ul>"},{"location":"#what-you-can-build-with-healthchain","title":"What You Can Build with HealthChain","text":"Use Case Description \ud83d\udea8 CDS alerts for discharge summaries Generate clinical recommendations directly in Epic workflows \ud83d\udccb Automatic medical coding Extract ICD-10 or SNOMED-CT codes from physician notes with confidence scores \ud83d\udd17 Multi-EHR patient aggregation Combine patient records from Epic, Cerner, and specialty systems \ud83e\udd16 ML model deployment Serve your trained healthcare models as FHIR-compliant APIs \ud83d\udd04 Legacy document conversion Transform CDA documents to modern FHIR resources <p>New to healthcare AI? Start with our Quickstart Guide to build your first medical NLP pipeline in under 10 minutes.</p> <p>Ready to integrate with EHRs? Jump to our Cookbook for complete examples including CDS Hooks and FHIR integration.</p> <p>HealthChain is made by a small team with experience in software engineering, machine learning, and healthcare NLP. We understand that good data science is about more than just building models, and that good engineering is about more than just building systems. This rings especially true in healthcare, where people, processes, and technology all play a role in making an impact.</p> <p>For inquiries and collaborations, please get in touch!</p>"},{"location":"distribution/","title":"Licence and citations","text":"<p>HealthChain is licensed under Apache 2.0. To comply with the licence you need to add the following notice at the top every file that uses part of HealthChain code:</p> <pre><code>Copyright 2024 - dotimplement\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>You can install HealthChain with <code>pip</code>:</p> <pre><code>pip install healthchain\n</code></pre> <p>Note you need to download any libraries that you require separetly:</p> <pre><code>pip install langchain\npip install transformers\npip install torch\n...\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>After installing HealthChain, get up to speed quickly with the core components before diving further into the full documentation!</p> <p>HealthChain provides three core tools for healthcare AI integration: Gateway for connecting to multiple healthcare systems, Pipelines for FHIR-native AI workflows, and InteropEngine for healthcare data format conversion between FHIR, CDA, and HL7v2.</p>"},{"location":"quickstart/#core-components","title":"Core Components","text":""},{"location":"quickstart/#healthchainapi-gateway","title":"HealthChainAPI Gateway \ud83d\udd0c","text":"<p>The HealthChainAPI provides a unified interface for connecting your AI models to multiple healthcare systems through a single API. Handle FHIR, CDS Hooks, and SOAP/CDA protocols with OAuth2 authentication.</p> <p>(Full Documentation on Gateway)</p> <pre><code>from healthchain.gateway import HealthChainAPI, FHIRGateway\nfrom fhir.resources.patient import Patient\n\n# Create your healthcare application\napp = HealthChainAPI(title=\"My Healthcare AI App\")\n\n# Connect to multiple FHIR servers\nfhir = FHIRGateway()\nfhir.add_source(\"epic\", \"fhir://fhir.epic.com/r4?client_id=...\")\nfhir.add_source(\"medplum\", \"fhir://api.medplum.com/fhir/R4/?client_id=...\")\n\n# Add AI transformations to FHIR data\n@fhir.transform(Patient)\ndef enhance_patient(id: str, source: str = None) -&gt; Patient:\n    patient = fhir.read(Patient, id, source)\n    # Your AI logic here\n    patient.active = True\n    fhir.update(patient, source)\n    return patient\n\n# Register and run\napp.register_gateway(fhir)\n\n# Available at: GET /fhir/transform/Patient/123?source=epic\n</code></pre>"},{"location":"quickstart/#pipeline","title":"Pipeline \ud83d\udee0\ufe0f","text":"<p>HealthChain Pipelines provide a flexible way to build and manage processing pipelines for NLP and ML tasks that can easily integrate with electronic health record (EHR) systems.</p> <p>You can build pipelines with three different approaches:</p>"},{"location":"quickstart/#1-build-your-own-pipeline-with-inline-functions","title":"1. Build Your Own Pipeline with Inline Functions","text":"<p>This is the most flexible approach, ideal for quick experiments and prototyping. Initialize a pipeline type hinted with the container type you want to process, then add components to your pipeline with the <code>@add_node</code> decorator.</p> <p>Compile the pipeline with <code>.build()</code> to use it.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io import Document\n\nnlp_pipeline = Pipeline[Document]()\n\n@nlp_pipeline.add_node\ndef tokenize(doc: Document) -&gt; Document:\n    doc.tokens = doc.text.split()\n    return doc\n\n@nlp_pipeline.add_node\ndef pos_tag(doc: Document) -&gt; Document:\n    doc.pos_tags = [\"NOUN\" if token[0].isupper() else \"VERB\" for token in doc.tokens]\n    return doc\n\nnlp = nlp_pipeline.build()\n\ndoc = Document(\"Patient has a fracture of the left femur.\")\ndoc = nlp(doc)\n\nprint(doc.tokens)\nprint(doc.pos_tags)\n\n# ['Patient', 'has', 'fracture', 'of', 'left', 'femur.']\n# ['NOUN', 'VERB', 'VERB', 'VERB', 'VERB', 'VERB']\n</code></pre>"},{"location":"quickstart/#2-build-your-own-pipeline-with-components-models-and-connectors","title":"2. Build Your Own Pipeline with Components, Models, and Connectors","text":"<p>Components are stateful - they're classes instead of functions. They can be useful for grouping related processing steps together, setting configurations, or wrapping specific model loading steps.</p> <p>HealthChain comes with a few pre-built components, but you can also easily add your own. You can find more details on the Components and Integrations documentation pages.</p> <p>Add components to your pipeline with the <code>.add_node()</code> method and compile with <code>.build()</code>.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import TextPreProcessor, SpacyNLP, TextPostProcessor\nfrom healthchain.io import Document\n\npipeline = Pipeline[Document]()\n\npipeline.add_node(TextPreProcessor())\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_sci_sm\"))\npipeline.add_node(TextPostProcessor())\n\npipe = pipeline.build()\n\ndoc = Document(\"Patient presents with hypertension.\")\noutput = pipe(doc)\n</code></pre> <p>Let's go one step further! You can use Adapters to work directly with CDA and FHIR data received from healthcare system APIs. Adapters handle format conversion while keeping your pipeline pure ML processing.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import SpacyNLP\nfrom healthchain.io import CdaAdapter\nfrom healthchain.models import CdaRequest\n\npipeline = Pipeline()\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_sci_sm\"))\npipe = pipeline.build()\n\n# Use adapter for format conversion\nadapter = CdaAdapter()\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\n\n# Parse, process, format\ndoc = adapter.parse(cda_request)\nprocessed_doc = pipe(doc)\noutput = adapter.format(processed_doc)\n</code></pre>"},{"location":"quickstart/#3-use-prebuilt-pipelines","title":"3. Use Prebuilt Pipelines","text":"<p>Prebuilt pipelines are pre-configured collections of Components and Models optimized for specific healthcare AI use cases. They offer the highest level of abstraction and are the easiest way to get started.</p> <p>For a full list of available prebuilt pipelines and details on how to configure and customize them, see the Pipelines documentation page.</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\n# Load from pre-built chain\nchain = ChatPromptTemplate.from_template(\"Summarize: {text}\") | ChatOpenAI()\npipeline = MedicalCodingPipeline.load(chain, source=\"langchain\")\n\n# Or load from model ID\npipeline = MedicalCodingPipeline.from_model_id(\"facebook/bart-large-cnn\", source=\"huggingface\")\n\n# Or load from local model\npipeline = MedicalCodingPipeline.from_local_model(\"./path/to/model\", source=\"spacy\")\n\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\noutput = pipeline.process_request(cda_request)\n</code></pre>"},{"location":"quickstart/#interoperability","title":"Interoperability \ud83d\udd04","text":"<p>The HealthChain Interoperability module provides tools for converting between different healthcare data formats, including HL7 FHIR, HL7 CDA, and HL7v2 messages.</p> <p>(Full Documentation on Interoperability Engine)</p> <pre><code>from healthchain.interop import create_interop, FormatType\n\n# Uses bundled configs - basic CDA \u2194 FHIR conversion\nengine = create_interop()\n\n# Load a CDA document\nwith open(\"tests/data/test_cda.xml\", \"r\") as f:\n    cda_xml = f.read()\n\n# Convert CDA XML to FHIR resources\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Convert FHIR resources back to CDA\ncda_document = engine.from_fhir(fhir_resources, dest_format=FormatType.CDA)\n</code></pre>"},{"location":"quickstart/#utilities","title":"Utilities \u2699\ufe0f","text":""},{"location":"quickstart/#sandbox-testing","title":"Sandbox Testing","text":"<p>Test your AI applications in realistic healthcare contexts with <code>SandboxClient</code> for CDS Hooks and clinical documentation workflows.</p> <p>(Full Documentation on Sandbox)</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create client and load test data\nclient = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load from datasets or files\nclient.load_from_registry(\"synthea\", num_patients=5)\nresponses = client.send_requests()\n</code></pre>"},{"location":"quickstart/#fhir-helpers","title":"FHIR Helpers","text":"<p>The <code>fhir</code> module provides a set of helper functions for working with FHIR resources.</p> <pre><code>from healthchain.fhir import create_condition\n\ncondition = create_condition(\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\",\n    subject=\"Patient/Foo\",\n    clinical_status=\"active\"\n)\n</code></pre> <p>(Full Documentation on FHIR Helpers)</p>"},{"location":"quickstart/#data-generator","title":"Data Generator","text":"<p>You can use the data generator to generate synthetic FHIR data for testing.</p> <p>The <code>CdsDataGenerator</code> generates synthetic FHIR data as Pydantic models suitable for different CDS workflows. Use it standalone or with <code>SandboxClient.load_free_text()</code> to include text-based data.</p> <p>(Full Documentation on Data Generators)</p> <pre><code>from healthchain.sandbox.generators import CdsDataGenerator\nfrom healthchain.sandbox.workflows import Workflow\n\n# Initialize data generator\ndata_generator = CdsDataGenerator()\n\n# Generate FHIR resources for specific workflow\ndata_generator.set_workflow(Workflow.encounter_discharge)\ndata = data_generator.generate_prefetch()\n\nprint(data.model_dump())\n\n# {\n#    \"prefetch\": {\n#        \"encounter\": {\n#            \"resourceType\": ...\n#        }\n#    }\n# }\n</code></pre>"},{"location":"quickstart/#going-further","title":"Going further \u2728","text":"<p>Check out our Cookbook section for more worked examples! HealthChain is still in its early stages, so if you have any questions please feel free to reach us on Github or Discord.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/adapters/","title":"Adapters","text":""},{"location":"api/adapters/#healthchain.io.adapters.cdaadapter.CdaAdapter","title":"<code>CdaAdapter</code>","text":"<p>               Bases: <code>BaseAdapter[CdaRequest, CdaResponse]</code></p> <p>CdaAdapter class for handling CDA (Clinical Document Architecture) documents.</p> <p>This adapter facilitates parsing CDA documents into Document objects and formatting Document objects back into CDA responses. It uses the InteropEngine to convert between CDA and FHIR formats, preserving clinical content while allowing for manipulation of the data within HealthChain pipelines.</p> ATTRIBUTE DESCRIPTION <code>engine</code> <p>The interoperability engine for CDA conversions. If not provided, the default engine is used.</p> <p> TYPE: <code>InteropEngine</code> </p> <code>original_cda</code> <p>The original CDA document for use in output.</p> <p> TYPE: <code>str</code> </p> <code>note_document_reference</code> <p>Reference to the note document                                         extracted from the CDA.</p> <p> TYPE: <code>DocumentReference</code> </p> METHOD DESCRIPTION <code>parse</code> <p>Parses a CDA document and extracts clinical data into a Document.</p> <code>format</code> <p>Converts a Document back to CDA format and returns a CdaResponse.</p> Source code in <code>healthchain/io/adapters/cdaadapter.py</code> <pre><code>class CdaAdapter(BaseAdapter[CdaRequest, CdaResponse]):\n    \"\"\"\n    CdaAdapter class for handling CDA (Clinical Document Architecture) documents.\n\n    This adapter facilitates parsing CDA documents into Document objects and formatting\n    Document objects back into CDA responses. It uses the InteropEngine to convert\n    between CDA and FHIR formats, preserving clinical content while allowing for\n    manipulation of the data within HealthChain pipelines.\n\n    Attributes:\n        engine (InteropEngine): The interoperability engine for CDA conversions. If not provided, the default engine is used.\n        original_cda (str): The original CDA document for use in output.\n        note_document_reference (DocumentReference): Reference to the note document\n                                                    extracted from the CDA.\n\n    Methods:\n        parse: Parses a CDA document and extracts clinical data into a Document.\n        format: Converts a Document back to CDA format and returns a CdaResponse.\n    \"\"\"\n\n    def __init__(self, engine: Optional[InteropEngine] = None):\n        \"\"\"\n        Initialize CdaAdapter with optional interop engine.\n\n        Args:\n            engine (Optional[InteropEngine]): Custom interop engine for CDA conversions.\n                                            If None, creates a default engine.\n        \"\"\"\n        # Initialize engine with default if not provided\n        initialized_engine = engine or create_interop()\n        super().__init__(engine=initialized_engine)\n        self.engine = initialized_engine\n        self.original_cda = None\n        self.note_document_reference = None\n\n    def parse(self, cda_request: CdaRequest) -&gt; Document:\n        \"\"\"\n        Parse a CDA document and extract clinical data into a HealthChain Document object.\n\n        This method takes a CdaRequest object as input, parses it using the InteropEngine to convert\n        CDA to FHIR resources, and creates a Document object with the extracted data. It creates a\n        DocumentReference for the original CDA XML and extracts clinical data (problems, medications,\n        allergies) into FHIR resources.\n\n        Args:\n            cda_request (CdaRequest): Request object containing the CDA XML document to process.\n\n        Returns:\n            Document: A Document object containing:\n                - The extracted note text as the document data\n                - FHIR resources organized into appropriate lists:\n                  - problem_list: List of Condition resources\n                  - medication_list: List of MedicationStatement resources\n                  - allergy_list: List of AllergyIntolerance resources\n                - DocumentReference resources for the original CDA and extracted notes\n\n        Note:\n            If a DocumentReference resource is found in the converted FHIR resources,\n            it is assumed to contain the note text and is stored for later use.\n        \"\"\"\n        # Store original CDA for later use\n        self.original_cda = cda_request.document\n\n        # Convert CDA to FHIR using the InteropEngine\n        fhir_resources = self.engine.to_fhir(\n            self.original_cda, src_format=FormatType.CDA\n        )\n\n        # Create a FHIR DocumentReference for the original CDA document\n        cda_document_reference = create_document_reference(\n            data=self.original_cda,\n            content_type=\"text/xml\",\n            description=\"Original CDA Document processed by HealthChain\",\n            attachment_title=\"Original CDA document in XML format\",\n        )\n\n        # Extract any DocumentReference resources for notes\n        note_text = \"\"\n        doc = Document(data=note_text)  # Create document with empty text initially\n\n        # Create FHIR Bundle and add documents\n        doc.fhir.bundle = create_bundle()\n        doc.fhir.add_document_reference(cda_document_reference)\n\n        problem_list = []\n        medication_list = []\n        allergy_list = []\n\n        for resource in fhir_resources:\n            if isinstance(resource, Condition):\n                problem_list.append(resource)\n                set_condition_category(resource, \"problem-list-item\")\n            elif isinstance(resource, MedicationStatement):\n                medication_list.append(resource)\n            elif isinstance(resource, AllergyIntolerance):\n                allergy_list.append(resource)\n            elif isinstance(resource, DocumentReference):\n                if (\n                    resource.content\n                    and resource.content[0].attachment\n                    and resource.content[0].attachment.data is not None\n                ):\n                    content = read_content_attachment(resource)\n                    if content is not None:\n                        note_text = content[0][\"data\"]\n                        self.note_document_reference = resource\n                    else:\n                        log.warning(\n                            f\"No content found in DocumentReference: {resource.id}\"\n                        )\n\n        doc.fhir.problem_list = problem_list\n        doc.fhir.medication_list = medication_list\n        doc.fhir.allergy_list = allergy_list\n\n        # Update document text\n        doc.data = note_text\n\n        # Add the note document reference\n        if self.note_document_reference is not None:\n            doc.fhir.add_document_reference(\n                self.note_document_reference, parent_id=cda_document_reference.id\n            )\n\n        return doc\n\n    def format(self, document: Document) -&gt; CdaResponse:\n        \"\"\"\n        Convert a Document object back to CDA format and return the response.\n\n        This method takes a Document object containing FHIR resources (problems,\n        medications, allergies) and converts them back to CDA format using the\n        InteropEngine. It combines all resources from the document's FHIR lists\n        and includes the note document reference if available.\n\n        Args:\n            document (Document): A Document object containing FHIR resources\n                                 in problem_list, medication_list, and allergy_list.\n\n        Returns:\n            CdaResponse: A response object containing the CDA document generated\n                        from the FHIR resources.\n        \"\"\"\n        # Collect all FHIR resources to convert to CDA\n        resources = []\n\n        if document.fhir.problem_list:\n            resources.extend(document.fhir.problem_list)\n\n        if document.fhir.allergy_list:\n            resources.extend(document.fhir.allergy_list)\n\n        if document.fhir.medication_list:\n            resources.extend(document.fhir.medication_list)\n\n        # Add the note document reference\n        if self.note_document_reference is not None:\n            resources.append(self.note_document_reference)\n\n        # Convert FHIR resources to CDA using InteropEngine\n        response_document = self.engine.from_fhir(resources, dest_format=FormatType.CDA)\n\n        return CdaResponse(document=response_document)\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdaadapter.CdaAdapter.__init__","title":"<code>__init__(engine=None)</code>","text":"<p>Initialize CdaAdapter with optional interop engine.</p> PARAMETER DESCRIPTION <code>engine</code> <p>Custom interop engine for CDA conversions.                             If None, creates a default engine.</p> <p> TYPE: <code>Optional[InteropEngine]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/io/adapters/cdaadapter.py</code> <pre><code>def __init__(self, engine: Optional[InteropEngine] = None):\n    \"\"\"\n    Initialize CdaAdapter with optional interop engine.\n\n    Args:\n        engine (Optional[InteropEngine]): Custom interop engine for CDA conversions.\n                                        If None, creates a default engine.\n    \"\"\"\n    # Initialize engine with default if not provided\n    initialized_engine = engine or create_interop()\n    super().__init__(engine=initialized_engine)\n    self.engine = initialized_engine\n    self.original_cda = None\n    self.note_document_reference = None\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdaadapter.CdaAdapter.format","title":"<code>format(document)</code>","text":"<p>Convert a Document object back to CDA format and return the response.</p> <p>This method takes a Document object containing FHIR resources (problems, medications, allergies) and converts them back to CDA format using the InteropEngine. It combines all resources from the document's FHIR lists and includes the note document reference if available.</p> PARAMETER DESCRIPTION <code>document</code> <p>A Document object containing FHIR resources                  in problem_list, medication_list, and allergy_list.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>CdaResponse</code> <p>A response object containing the CDA document generated         from the FHIR resources.</p> <p> TYPE: <code>CdaResponse</code> </p> Source code in <code>healthchain/io/adapters/cdaadapter.py</code> <pre><code>def format(self, document: Document) -&gt; CdaResponse:\n    \"\"\"\n    Convert a Document object back to CDA format and return the response.\n\n    This method takes a Document object containing FHIR resources (problems,\n    medications, allergies) and converts them back to CDA format using the\n    InteropEngine. It combines all resources from the document's FHIR lists\n    and includes the note document reference if available.\n\n    Args:\n        document (Document): A Document object containing FHIR resources\n                             in problem_list, medication_list, and allergy_list.\n\n    Returns:\n        CdaResponse: A response object containing the CDA document generated\n                    from the FHIR resources.\n    \"\"\"\n    # Collect all FHIR resources to convert to CDA\n    resources = []\n\n    if document.fhir.problem_list:\n        resources.extend(document.fhir.problem_list)\n\n    if document.fhir.allergy_list:\n        resources.extend(document.fhir.allergy_list)\n\n    if document.fhir.medication_list:\n        resources.extend(document.fhir.medication_list)\n\n    # Add the note document reference\n    if self.note_document_reference is not None:\n        resources.append(self.note_document_reference)\n\n    # Convert FHIR resources to CDA using InteropEngine\n    response_document = self.engine.from_fhir(resources, dest_format=FormatType.CDA)\n\n    return CdaResponse(document=response_document)\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdaadapter.CdaAdapter.parse","title":"<code>parse(cda_request)</code>","text":"<p>Parse a CDA document and extract clinical data into a HealthChain Document object.</p> <p>This method takes a CdaRequest object as input, parses it using the InteropEngine to convert CDA to FHIR resources, and creates a Document object with the extracted data. It creates a DocumentReference for the original CDA XML and extracts clinical data (problems, medications, allergies) into FHIR resources.</p> PARAMETER DESCRIPTION <code>cda_request</code> <p>Request object containing the CDA XML document to process.</p> <p> TYPE: <code>CdaRequest</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>A Document object containing: - The extracted note text as the document data - FHIR resources organized into appropriate lists:   - problem_list: List of Condition resources   - medication_list: List of MedicationStatement resources   - allergy_list: List of AllergyIntolerance resources - DocumentReference resources for the original CDA and extracted notes</p> <p> TYPE: <code>Document</code> </p> Note <p>If a DocumentReference resource is found in the converted FHIR resources, it is assumed to contain the note text and is stored for later use.</p> Source code in <code>healthchain/io/adapters/cdaadapter.py</code> <pre><code>def parse(self, cda_request: CdaRequest) -&gt; Document:\n    \"\"\"\n    Parse a CDA document and extract clinical data into a HealthChain Document object.\n\n    This method takes a CdaRequest object as input, parses it using the InteropEngine to convert\n    CDA to FHIR resources, and creates a Document object with the extracted data. It creates a\n    DocumentReference for the original CDA XML and extracts clinical data (problems, medications,\n    allergies) into FHIR resources.\n\n    Args:\n        cda_request (CdaRequest): Request object containing the CDA XML document to process.\n\n    Returns:\n        Document: A Document object containing:\n            - The extracted note text as the document data\n            - FHIR resources organized into appropriate lists:\n              - problem_list: List of Condition resources\n              - medication_list: List of MedicationStatement resources\n              - allergy_list: List of AllergyIntolerance resources\n            - DocumentReference resources for the original CDA and extracted notes\n\n    Note:\n        If a DocumentReference resource is found in the converted FHIR resources,\n        it is assumed to contain the note text and is stored for later use.\n    \"\"\"\n    # Store original CDA for later use\n    self.original_cda = cda_request.document\n\n    # Convert CDA to FHIR using the InteropEngine\n    fhir_resources = self.engine.to_fhir(\n        self.original_cda, src_format=FormatType.CDA\n    )\n\n    # Create a FHIR DocumentReference for the original CDA document\n    cda_document_reference = create_document_reference(\n        data=self.original_cda,\n        content_type=\"text/xml\",\n        description=\"Original CDA Document processed by HealthChain\",\n        attachment_title=\"Original CDA document in XML format\",\n    )\n\n    # Extract any DocumentReference resources for notes\n    note_text = \"\"\n    doc = Document(data=note_text)  # Create document with empty text initially\n\n    # Create FHIR Bundle and add documents\n    doc.fhir.bundle = create_bundle()\n    doc.fhir.add_document_reference(cda_document_reference)\n\n    problem_list = []\n    medication_list = []\n    allergy_list = []\n\n    for resource in fhir_resources:\n        if isinstance(resource, Condition):\n            problem_list.append(resource)\n            set_condition_category(resource, \"problem-list-item\")\n        elif isinstance(resource, MedicationStatement):\n            medication_list.append(resource)\n        elif isinstance(resource, AllergyIntolerance):\n            allergy_list.append(resource)\n        elif isinstance(resource, DocumentReference):\n            if (\n                resource.content\n                and resource.content[0].attachment\n                and resource.content[0].attachment.data is not None\n            ):\n                content = read_content_attachment(resource)\n                if content is not None:\n                    note_text = content[0][\"data\"]\n                    self.note_document_reference = resource\n                else:\n                    log.warning(\n                        f\"No content found in DocumentReference: {resource.id}\"\n                    )\n\n    doc.fhir.problem_list = problem_list\n    doc.fhir.medication_list = medication_list\n    doc.fhir.allergy_list = allergy_list\n\n    # Update document text\n    doc.data = note_text\n\n    # Add the note document reference\n    if self.note_document_reference is not None:\n        doc.fhir.add_document_reference(\n            self.note_document_reference, parent_id=cda_document_reference.id\n        )\n\n    return doc\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdsfhiradapter.CdsFhirAdapter","title":"<code>CdsFhirAdapter</code>","text":"<p>               Bases: <code>BaseAdapter[CDSRequest, CDSResponse]</code></p> <p>CdsFhirAdapter class for handling FHIR (Fast Healthcare Interoperability Resources) documents for CDS Hooks.</p> <p>This adapter facilitates the conversion between CDSRequest objects and Document objects, as well as the creation of CDSResponse objects from processed Documents. Unlike CdaAdapter, this adapter works directly with FHIR data and does not require interop conversion.</p> ATTRIBUTE DESCRIPTION <code>hook_name</code> <p>The name of the CDS Hook being used.</p> <p> TYPE: <code>str</code> </p> <code>engine</code> <p>Optional interoperability engine (not used by this adapter).</p> <p> TYPE: <code>Optional[Any]</code> </p> METHOD DESCRIPTION <code>parse</code> <p>Converts a CDSRequest object into a Document object.</p> <code>format</code> <p>Converts a Document object into a CDSResponse object.</p> Source code in <code>healthchain/io/adapters/cdsfhiradapter.py</code> <pre><code>class CdsFhirAdapter(BaseAdapter[CDSRequest, CDSResponse]):\n    \"\"\"\n    CdsFhirAdapter class for handling FHIR (Fast Healthcare Interoperability Resources) documents\n    for CDS Hooks.\n\n    This adapter facilitates the conversion between CDSRequest objects and Document objects,\n    as well as the creation of CDSResponse objects from processed Documents. Unlike CdaAdapter,\n    this adapter works directly with FHIR data and does not require interop conversion.\n\n    Attributes:\n        hook_name (str): The name of the CDS Hook being used.\n        engine (Optional[Any]): Optional interoperability engine (not used by this adapter).\n\n    Methods:\n        parse: Converts a CDSRequest object into a Document object.\n        format: Converts a Document object into a CDSResponse object.\n    \"\"\"\n\n    def __init__(self, hook_name: str = None, engine: Optional[Any] = None):\n        \"\"\"\n        Initialize CdsFhirAdapter with hook name and optional engine.\n\n        Args:\n            hook_name (str): The name of the CDS Hook being used. Defaults to None.\n            engine (Optional[Any]): Optional interoperability engine (not used by this adapter).\n        \"\"\"\n        super().__init__(engine=engine)\n        self.hook_name = hook_name\n\n    def parse(\n        self, cds_request: CDSRequest, prefetch_document_key: Optional[str] = \"document\"\n    ) -&gt; Document:\n        \"\"\"\n        Convert a CDSRequest object into a Document object.\n\n        Takes a CDSRequest containing FHIR resources and extracts them into a Document object.\n        The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources.\n        If a DocumentReference resource is provided via prefetch_document_key, its text content\n        will be extracted into Document.data. For multiple attachments, the text content will be\n        concatenated with newlines.\n\n        Args:\n            cds_request (CDSRequest): The CDSRequest containing FHIR resources in its prefetch\n                and/or a FHIR server URL.\n            prefetch_document_key (str, optional): Key in the prefetch data containing a\n                DocumentReference resource whose text content should be extracted.\n                Defaults to \"document\".\n\n        Returns:\n            Document: A Document object containing:\n                - All prefetched FHIR resources in fhir.prefetch_resources\n                - Any text content from the DocumentReference in data (empty string if none found)\n                - For multiple attachments, text content is concatenated with newlines\n\n        Raises:\n            ValueError: If neither prefetch nor fhirServer is provided in cds_request\n            ValueError: If the prefetch data is invalid or cannot be processed\n            NotImplementedError: If fhirServer is provided (FHIR server support not implemented)\n        \"\"\"\n        if cds_request.prefetch is None and cds_request.fhirServer is None:\n            raise ValueError(\n                \"Either prefetch or fhirServer must be provided to extract FHIR data!\"\n            )\n\n        if cds_request.fhirServer is not None:\n            raise NotImplementedError(\"FHIR server is not implemented yet!\")\n\n        # Create an empty Document object\n        doc = Document(data=\"\")\n\n        # Validate the prefetch data\n        validated_prefetch = Prefetch(prefetch=cds_request.prefetch)\n\n        # Set the prefetch resources\n        doc.fhir.prefetch_resources = validated_prefetch.prefetch\n\n        # Extract text content from DocumentReference resource if provided\n        document_resource = validated_prefetch.prefetch.get(prefetch_document_key)\n\n        if not document_resource:\n            log.warning(\n                f\"No DocumentReference resource found in prefetch data with key {prefetch_document_key}\"\n            )\n        elif isinstance(document_resource, DocumentReference):\n            try:\n                attachments = read_content_attachment(\n                    document_resource, include_data=True\n                )\n                for attachment in attachments:\n                    if len(attachments) &gt; 1:\n                        doc.data += attachment.get(\"data\", \"\") + \"\\n\"\n                    else:\n                        doc.data += attachment.get(\"data\", \"\")\n            except Exception as e:\n                log.warning(f\"Error extracting text from DocumentReference: {e}\")\n\n        return doc\n\n    def format(self, document: Document) -&gt; CDSResponse:\n        \"\"\"\n        Convert Document to CDSResponse.\n\n        This method takes a Document object containing CDS cards and actions,\n        and converts them into a CDSResponse object that follows the CDS Hooks\n        specification.\n\n        Args:\n            document (Document): The Document object containing CDS results.\n\n        Returns:\n            CDSResponse: A response object containing CDS cards and optional system actions.\n                         If no cards are found in the Document, an empty list of cards is returned.\n        \"\"\"\n        if document.cds.cards is None:\n            log.warning(\"No CDS cards found in Document, returning empty list of cards\")\n            return CDSResponse(cards=[])\n\n        return CDSResponse(cards=document.cds.cards, systemActions=document.cds.actions)\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdsfhiradapter.CdsFhirAdapter.__init__","title":"<code>__init__(hook_name=None, engine=None)</code>","text":"<p>Initialize CdsFhirAdapter with hook name and optional engine.</p> PARAMETER DESCRIPTION <code>hook_name</code> <p>The name of the CDS Hook being used. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>engine</code> <p>Optional interoperability engine (not used by this adapter).</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/io/adapters/cdsfhiradapter.py</code> <pre><code>def __init__(self, hook_name: str = None, engine: Optional[Any] = None):\n    \"\"\"\n    Initialize CdsFhirAdapter with hook name and optional engine.\n\n    Args:\n        hook_name (str): The name of the CDS Hook being used. Defaults to None.\n        engine (Optional[Any]): Optional interoperability engine (not used by this adapter).\n    \"\"\"\n    super().__init__(engine=engine)\n    self.hook_name = hook_name\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdsfhiradapter.CdsFhirAdapter.format","title":"<code>format(document)</code>","text":"<p>Convert Document to CDSResponse.</p> <p>This method takes a Document object containing CDS cards and actions, and converts them into a CDSResponse object that follows the CDS Hooks specification.</p> PARAMETER DESCRIPTION <code>document</code> <p>The Document object containing CDS results.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>CDSResponse</code> <p>A response object containing CDS cards and optional system actions.          If no cards are found in the Document, an empty list of cards is returned.</p> <p> TYPE: <code>CDSResponse</code> </p> Source code in <code>healthchain/io/adapters/cdsfhiradapter.py</code> <pre><code>def format(self, document: Document) -&gt; CDSResponse:\n    \"\"\"\n    Convert Document to CDSResponse.\n\n    This method takes a Document object containing CDS cards and actions,\n    and converts them into a CDSResponse object that follows the CDS Hooks\n    specification.\n\n    Args:\n        document (Document): The Document object containing CDS results.\n\n    Returns:\n        CDSResponse: A response object containing CDS cards and optional system actions.\n                     If no cards are found in the Document, an empty list of cards is returned.\n    \"\"\"\n    if document.cds.cards is None:\n        log.warning(\"No CDS cards found in Document, returning empty list of cards\")\n        return CDSResponse(cards=[])\n\n    return CDSResponse(cards=document.cds.cards, systemActions=document.cds.actions)\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdsfhiradapter.CdsFhirAdapter.parse","title":"<code>parse(cds_request, prefetch_document_key='document')</code>","text":"<p>Convert a CDSRequest object into a Document object.</p> <p>Takes a CDSRequest containing FHIR resources and extracts them into a Document object. The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources. If a DocumentReference resource is provided via prefetch_document_key, its text content will be extracted into Document.data. For multiple attachments, the text content will be concatenated with newlines.</p> PARAMETER DESCRIPTION <code>cds_request</code> <p>The CDSRequest containing FHIR resources in its prefetch and/or a FHIR server URL.</p> <p> TYPE: <code>CDSRequest</code> </p> <code>prefetch_document_key</code> <p>Key in the prefetch data containing a DocumentReference resource whose text content should be extracted. Defaults to \"document\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'document'</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>A Document object containing: - All prefetched FHIR resources in fhir.prefetch_resources - Any text content from the DocumentReference in data (empty string if none found) - For multiple attachments, text content is concatenated with newlines</p> <p> TYPE: <code>Document</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither prefetch nor fhirServer is provided in cds_request</p> <code>ValueError</code> <p>If the prefetch data is invalid or cannot be processed</p> <code>NotImplementedError</code> <p>If fhirServer is provided (FHIR server support not implemented)</p> Source code in <code>healthchain/io/adapters/cdsfhiradapter.py</code> <pre><code>def parse(\n    self, cds_request: CDSRequest, prefetch_document_key: Optional[str] = \"document\"\n) -&gt; Document:\n    \"\"\"\n    Convert a CDSRequest object into a Document object.\n\n    Takes a CDSRequest containing FHIR resources and extracts them into a Document object.\n    The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources.\n    If a DocumentReference resource is provided via prefetch_document_key, its text content\n    will be extracted into Document.data. For multiple attachments, the text content will be\n    concatenated with newlines.\n\n    Args:\n        cds_request (CDSRequest): The CDSRequest containing FHIR resources in its prefetch\n            and/or a FHIR server URL.\n        prefetch_document_key (str, optional): Key in the prefetch data containing a\n            DocumentReference resource whose text content should be extracted.\n            Defaults to \"document\".\n\n    Returns:\n        Document: A Document object containing:\n            - All prefetched FHIR resources in fhir.prefetch_resources\n            - Any text content from the DocumentReference in data (empty string if none found)\n            - For multiple attachments, text content is concatenated with newlines\n\n    Raises:\n        ValueError: If neither prefetch nor fhirServer is provided in cds_request\n        ValueError: If the prefetch data is invalid or cannot be processed\n        NotImplementedError: If fhirServer is provided (FHIR server support not implemented)\n    \"\"\"\n    if cds_request.prefetch is None and cds_request.fhirServer is None:\n        raise ValueError(\n            \"Either prefetch or fhirServer must be provided to extract FHIR data!\"\n        )\n\n    if cds_request.fhirServer is not None:\n        raise NotImplementedError(\"FHIR server is not implemented yet!\")\n\n    # Create an empty Document object\n    doc = Document(data=\"\")\n\n    # Validate the prefetch data\n    validated_prefetch = Prefetch(prefetch=cds_request.prefetch)\n\n    # Set the prefetch resources\n    doc.fhir.prefetch_resources = validated_prefetch.prefetch\n\n    # Extract text content from DocumentReference resource if provided\n    document_resource = validated_prefetch.prefetch.get(prefetch_document_key)\n\n    if not document_resource:\n        log.warning(\n            f\"No DocumentReference resource found in prefetch data with key {prefetch_document_key}\"\n        )\n    elif isinstance(document_resource, DocumentReference):\n        try:\n            attachments = read_content_attachment(\n                document_resource, include_data=True\n            )\n            for attachment in attachments:\n                if len(attachments) &gt; 1:\n                    doc.data += attachment.get(\"data\", \"\") + \"\\n\"\n                else:\n                    doc.data += attachment.get(\"data\", \"\")\n        except Exception as e:\n            log.warning(f\"Error extracting text from DocumentReference: {e}\")\n\n    return doc\n</code></pre>"},{"location":"api/cds_hooks/","title":"CDS Hooks","text":"<p>https://cds-hooks.org/specification/current/#discovery</p> <p>This is not compulsary</p> <p>https://cds-hooks.org/specification/current/#feedback</p>"},{"location":"api/cds_hooks/#healthchain.models.hooks.encounterdischarge.EncounterDischargeContext","title":"<code>EncounterDischargeContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: This hook is triggered during the discharge process for typically inpatient encounters. It can be invoked at any point from the start to the end of the discharge process. The purpose is to allow hook services to intervene in various aspects of the discharge decision. This includes verifying discharge medications, ensuring continuity of care planning, and verifying necessary documentation for discharge processing.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. The ID of the current user, expected to be a Practitioner or PractitionerRole.           For example, 'Practitioner/123'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id of the patient being discharged.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>REQUIRED. The FHIR Encounter.id of the encounter being ended.</p> <p> TYPE: <code>str</code> </p> <p>Documentation: https://cds-hooks.org/hooks/encounter-discharge/</p> Source code in <code>healthchain/models/hooks/encounterdischarge.py</code> <pre><code>class EncounterDischargeContext(BaseHookContext):\n    \"\"\"\n    Workflow:\n    This hook is triggered during the discharge process for typically inpatient encounters. It can be invoked\n    at any point from the start to the end of the discharge process. The purpose is to allow hook services to\n    intervene in various aspects of the discharge decision. This includes verifying discharge medications,\n    ensuring continuity of care planning, and verifying necessary documentation for discharge processing.\n\n    Attributes:\n        userId (str): REQUIRED. The ID of the current user, expected to be a Practitioner or PractitionerRole.\n                      For example, 'Practitioner/123'.\n        patientId (str): REQUIRED. The FHIR Patient.id of the patient being discharged.\n        encounterId (str): REQUIRED. The FHIR Encounter.id of the encounter being ended.\n\n    Documentation: https://cds-hooks.org/hooks/encounter-discharge/\n    \"\"\"\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"The ID of the current user, expected to be in the format 'Practitioner/123'.\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id of the patient being discharged.\",\n    )\n    encounterId: str = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the encounter being ended.\",\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.orderselect.OrderSelectContext","title":"<code>OrderSelectContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The order-select hook occurs after the clinician selects the order and before signing. This hook occurs when a clinician initially selects one or more new orders from a list of potential orders for a specific patient (including orders for medications, procedures, labs and other orders). The newly selected order defines that medication, procedure, lab, etc, but may or may not define the additional details necessary to finalize the order.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. An identifier of the current user, in the format [ResourceType]/[id],           where ResourceType is either 'Practitioner' or 'PractitionerRole'. Examples: 'PractitionerRole/123',           'Practitioner/abc'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>OPTIONAL. The FHIR Encounter.id representing the current encounter in context,                          if applicable.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>selections</code> <p>REQUIRED. A list of the FHIR id(s) of the newly selected orders, referencing resources                 in the draftOrders Bundle. Example: 'MedicationRequest/103'.</p> <p> TYPE: <code>[str]</code> </p> <code>draftOrders</code> <p>REQUIRED. A Bundle of FHIR request resources with a draft status, representing all unsigned                   orders from the current session, including newly selected orders.</p> <p> TYPE: <code>object</code> </p> <p>Documentation: https://cds-hooks.org/hooks/order-select/</p> Source code in <code>healthchain/models/hooks/orderselect.py</code> <pre><code>class OrderSelectContext(BaseHookContext):\n    \"\"\"\n    Workflow: The order-select hook occurs after the clinician selects the order and before signing.\n    This hook occurs when a clinician initially selects one or more new orders from a list of\n    potential orders for a specific patient (including orders for medications, procedures, labs\n    and other orders). The newly selected order defines that medication, procedure, lab, etc,\n    but may or may not define the additional details necessary to finalize the order.\n\n    Attributes:\n        userId (str): REQUIRED. An identifier of the current user, in the format [ResourceType]/[id],\n                      where ResourceType is either 'Practitioner' or 'PractitionerRole'. Examples: 'PractitionerRole/123',\n                      'Practitioner/abc'.\n        patientId (str): REQUIRED. The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): OPTIONAL. The FHIR Encounter.id representing the current encounter in context,\n                                     if applicable.\n        selections ([str]): REQUIRED. A list of the FHIR id(s) of the newly selected orders, referencing resources\n                            in the draftOrders Bundle. Example: 'MedicationRequest/103'.\n        draftOrders (object): REQUIRED. A Bundle of FHIR request resources with a draft status, representing all unsigned\n                              orders from the current session, including newly selected orders.\n\n    Documentation: https://cds-hooks.org/hooks/order-select/\n    \"\"\"\n\n    # TODO: validate selection and FHIR Bundle resource\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"An identifier of the current user in the format [ResourceType]/[id].\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id representing the current patient in context.\",\n    )\n    encounterId: Optional[str] = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the current encounter, if applicable.\",\n    )\n    selections: List[str] = Field(\n        ..., description=\"A list of the FHIR ids of the newly selected orders.\"\n    )\n    draftOrders: Dict[str, Any] = Field(\n        ..., description=\"A Bundle of FHIR request resources with a draft status.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\n            \"userId\",\n            \"patientId\",\n            \"encounterId\",\n            \"selections\",\n            \"draftOrders\",\n        }\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n\n    @model_validator(mode=\"after\")\n    def validate_selections(self) -&gt; Self:\n        for selection in self.selections:\n            if \"/\" not in selection:\n                raise ValueError(\n                    \"Each selection must be a valid FHIR resource identifier in the format 'ResourceType/ResourceID'.\"\n                )\n        return self\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.ordersign.OrderSignContext","title":"<code>OrderSignContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The order-sign hook is triggered when a clinician is ready to sign one or more orders for a patient. This includes orders for medications, procedures, labs, and other orders. It is one of the last workflow events before an order is promoted from a draft status. The context includes all order details such as dose, quantity, route, etc., even though the order is still in a draft status. This hook is also applicable for re-signing revised orders, which may have a status other than 'draft'. The hook replaces the medication-prescribe and order-review hooks.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. The ID of the current user, expected to be of type 'Practitioner' or 'PractitionerRole'.           Examples include 'PractitionerRole/123' or 'Practitioner/abc'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>OPTIONAL. The FHIR Encounter.id of the current encounter in context.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>draftOrders</code> <p>REQUIRED. A Bundle of FHIR request resources with a draft status, representing orders that                 aren't yet signed from the current ordering session.</p> <p> TYPE: <code>dict</code> </p> <p>Documentation: https://cds-hooks.org/hooks/order-sign/</p> Source code in <code>healthchain/models/hooks/ordersign.py</code> <pre><code>class OrderSignContext(BaseHookContext):\n    \"\"\"\n    Workflow:\n    The order-sign hook is triggered when a clinician is ready to sign one or more orders for a patient.\n    This includes orders for medications, procedures, labs, and other orders. It is one of the last workflow\n    events before an order is promoted from a draft status. The context includes all order details such as\n    dose, quantity, route, etc., even though the order is still in a draft status. This hook is also applicable\n    for re-signing revised orders, which may have a status other than 'draft'. The hook replaces the\n    medication-prescribe and order-review hooks.\n\n    Attributes:\n        userId (str): REQUIRED. The ID of the current user, expected to be of type 'Practitioner' or 'PractitionerRole'.\n                      Examples include 'PractitionerRole/123' or 'Practitioner/abc'.\n        patientId (str): REQUIRED. The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): OPTIONAL. The FHIR Encounter.id of the current encounter in context.\n        draftOrders (dict): REQUIRED. A Bundle of FHIR request resources with a draft status, representing orders that\n                            aren't yet signed from the current ordering session.\n\n    Documentation: https://cds-hooks.org/hooks/order-sign/\n    \"\"\"\n\n    # TODO: validate draftOrders\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"The ID of the current user in the format [ResourceType]/[id].\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id representing the current patient in context.\",\n    )\n    encounterId: Optional[str] = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the current encounter, if applicable.\",\n    )\n    draftOrders: Dict[str, Any] = Field(\n        ..., description=\"A Bundle of FHIR request resources with a draft status.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\", \"draftOrders\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.patientview.PatientViewContext","title":"<code>PatientViewContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The user has just opened a patient's record; typically called only once at the beginning of a user's interaction with a specific patient's record.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>An identifier of the current user, in the format [ResourceType]/[id],           where ResourceType is one of 'Practitioner', 'PractitionerRole', 'Patient',           or 'RelatedPerson'. Examples: 'Practitioner/abc', 'Patient/123'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>The FHIR Encounter.id representing the current encounter in context,                          if applicable. This field is optional.</p> <p> TYPE: <code>Optional[str]</code> </p> <p>Documentation: https://cds-hooks.org/hooks/patient-view/</p> Source code in <code>healthchain/models/hooks/patientview.py</code> <pre><code>class PatientViewContext(BaseHookContext):\n    \"\"\"\n    Workflow: The user has just opened a patient's record; typically called only once at the beginning of a user's\n    interaction with a specific patient's record.\n\n    Attributes:\n        userId (str): An identifier of the current user, in the format [ResourceType]/[id],\n                      where ResourceType is one of 'Practitioner', 'PractitionerRole', 'Patient',\n                      or 'RelatedPerson'. Examples: 'Practitioner/abc', 'Patient/123'.\n        patientId (str): The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): The FHIR Encounter.id representing the current encounter in context,\n                                     if applicable. This field is optional.\n\n    Documentation: https://cds-hooks.org/hooks/patient-view/\n    \"\"\"\n\n    # TODO: more comprehensive validator? for now regex should suffice\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole|Patient|RelatedPerson)/[^\\s]+$\",\n        description=\"The ID of the current user, expected to be in the format 'Practitioner/123'.\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id of the patient.\",\n    )\n    encounterId: Optional[str] = Field(\n        None, description=\"The FHIR Encounter.id of the encounter, if applicable.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsdiscovery.CDSService","title":"<code>CDSService</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing a CDS service configuration.</p> ATTRIBUTE DESCRIPTION <code>hook</code> <p>The hook this service should be invoked on. This should correspond to one of the predefined hooks.</p> <p> TYPE: <code>str</code> </p> <code>title</code> <p>The human-friendly name of this service. It is recommended to provide this for better usability.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>description</code> <p>A detailed description of what this service does and its purpose within the CDS framework.</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>The unique identifier of this service. It forms part of the URL as {baseUrl}/cds-services/{id}.</p> <p> TYPE: <code>str</code> </p> <code>prefetch</code> <p>Optional FHIR queries that the service requests the CDS Client to perform                                 and provide on each service call. Keys describe the type of data and values are the actual FHIR query strings.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> </p> <code>usageRequirements</code> <p>Human-friendly description of any preconditions for the use of this CDS service.</p> <p> TYPE: <code>Optional[str]</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#response</p> Source code in <code>healthchain/models/responses/cdsdiscovery.py</code> <pre><code>class CDSService(BaseModel):\n    \"\"\"\n    A model representing a CDS service configuration.\n\n    Attributes:\n        hook (str): The hook this service should be invoked on. This should correspond to one of the predefined hooks.\n        title (Optional[str]): The human-friendly name of this service. It is recommended to provide this for better usability.\n        description (str): A detailed description of what this service does and its purpose within the CDS framework.\n        id (str): The unique identifier of this service. It forms part of the URL as {baseUrl}/cds-services/{id}.\n        prefetch (Optional[Dict[str, str]]): Optional FHIR queries that the service requests the CDS Client to perform\n                                            and provide on each service call. Keys describe the type of data and values are the actual FHIR query strings.\n        usageRequirements (Optional[str]): Human-friendly description of any preconditions for the use of this CDS service.\n\n    Documentation: https://cds-hooks.org/specification/current/#response\n    \"\"\"\n\n    hook: str\n    description: str\n    id: str\n    title: Optional[str] = None\n    prefetch: Optional[Dict[str, Any]] = None\n    usageRequirements: Optional[str] = None\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsdiscovery.CDSServiceInformation","title":"<code>CDSServiceInformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A CDS Service is discoverable via a stable endpoint by CDS Clients. The Discovery endpoint includes information such as a description of the CDS Service, when it should be invoked, and any data that is requested to be prefetched.</p> Source code in <code>healthchain/models/responses/cdsdiscovery.py</code> <pre><code>class CDSServiceInformation(BaseModel):\n    \"\"\"\n    A CDS Service is discoverable via a stable endpoint by CDS Clients. The Discovery endpoint includes information such as a\n    description of the CDS Service, when it should be invoked, and any data that is requested to be prefetched.\n    \"\"\"\n\n    services: List[CDSService] = []\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsfeedback.CDSFeedback","title":"<code>CDSFeedback</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A feedback endpoint enables suggestion tracking &amp; analytics. A CDS Service MAY support a feedback endpoint; a CDS Client SHOULD be capable of sending feedback.</p> ATTRIBUTE DESCRIPTION <code>card</code> <p>The card.uuid from the CDS Hooks response. Uniquely identifies the card.</p> <p> TYPE: <code>str</code> </p> <code>outcome</code> <p>The outcome of the action, either 'accepted' or 'overridden'.</p> <p> TYPE: <code>str</code> </p> <code>acceptedSuggestions</code> <p>An array of accepted suggestions, required if the outcome is 'accepted'.</p> <p> TYPE: <code>List[AcceptedSuggestion]</code> </p> <code>overrideReason</code> <p>The reason for overriding, including any coding and comments.</p> <p> TYPE: <code>Optional[OverrideReason]</code> </p> <code>outcomeTimestamp</code> <p>The ISO8601 timestamp of when the action was taken on the card.</p> <p> TYPE: <code>datetime</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#feedback</p> Source code in <code>healthchain/models/responses/cdsfeedback.py</code> <pre><code>class CDSFeedback(BaseModel):\n    \"\"\"\n    A feedback endpoint enables suggestion tracking &amp; analytics.\n    A CDS Service MAY support a feedback endpoint; a CDS Client SHOULD be capable of sending feedback.\n\n    Attributes:\n        card (str): The card.uuid from the CDS Hooks response. Uniquely identifies the card.\n        outcome (str): The outcome of the action, either 'accepted' or 'overridden'.\n        acceptedSuggestions (List[AcceptedSuggestion]): An array of accepted suggestions, required if the outcome is 'accepted'.\n        overrideReason (Optional[OverrideReason]): The reason for overriding, including any coding and comments.\n        outcomeTimestamp (datetime): The ISO8601 timestamp of when the action was taken on the card.\n\n    Documentation: https://cds-hooks.org/specification/current/#feedback\n    \"\"\"\n\n    card: str\n    outcome: OutcomeEnum\n    outcomeTimestamp: str\n    acceptedSuggestion: Optional[Dict[str, Any]] = None\n    overriddeReason: Optional[OverrideReason] = None\n</code></pre>"},{"location":"api/component/","title":"Component","text":""},{"location":"api/component/#healthchain.pipeline.components.base.BaseComponent","title":"<code>BaseComponent</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for all components in the pipeline.</p> <p>This class should be subclassed to create specific components. Subclasses must implement the call method.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>class BaseComponent(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for all components in the pipeline.\n\n    This class should be subclassed to create specific components.\n    Subclasses must implement the __call__ method.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        \"\"\"\n        Process the input data and return the processed data.\n\n        Args:\n            data (DataContainer[T]): The input data to be processed.\n\n        Returns:\n            DataContainer[T]: The processed data.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.base.BaseComponent.__call__","title":"<code>__call__(data)</code>  <code>abstractmethod</code>","text":"<p>Process the input data and return the processed data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The input data to be processed.</p> <p> TYPE: <code>DataContainer[T]</code> </p> RETURNS DESCRIPTION <code>DataContainer[T]</code> <p>DataContainer[T]: The processed data.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>@abstractmethod\ndef __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n    \"\"\"\n    Process the input data and return the processed data.\n\n    Args:\n        data (DataContainer[T]): The input data to be processed.\n\n    Returns:\n        DataContainer[T]: The processed data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.base.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>BaseComponent[T]</code></p> <p>A concrete implementation of the BaseComponent class.</p> <p>This class can be used as a base for creating specific components that do not require any additional processing logic.</p> METHOD DESCRIPTION <code>__call__</code> <p>DataContainer[T]) -&gt; DataContainer[T]: Process the input data and return the processed data. In this implementation, the input data is returned unmodified.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>class Component(BaseComponent[T]):\n    \"\"\"\n    A concrete implementation of the BaseComponent class.\n\n    This class can be used as a base for creating specific components\n    that do not require any additional processing logic.\n\n    Methods:\n        __call__(data: DataContainer[T]) -&gt; DataContainer[T]:\n            Process the input data and return the processed data.\n            In this implementation, the input data is returned unmodified.\n    \"\"\"\n\n    def __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        return data\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer","title":"<code>HFTransformer</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates Hugging Face transformers models into the pipeline.</p> <p>This component allows using any Hugging Face model and task within the pipeline by wrapping the transformers.pipeline API. The model outputs are stored in the document's model_outputs container under the \"huggingface\" source key.</p> <p>Note that this component is only recommended for non-conversational language tasks. For chat-based tasks, consider using LangChainLLM instead.</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A pre-configured HuggingFace pipeline object to use for inference. Must be an instance of transformers.pipelines.base.Pipeline.</p> <p> TYPE: <code>Any</code> </p> ATTRIBUTE DESCRIPTION <code>task</code> <p>The task name of the underlying pipeline, e.g. \"sentiment-analysis\", \"ner\". Automatically extracted from the pipeline object.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If the transformers package is not installed</p> <code>TypeError</code> <p>If pipeline is not a valid HuggingFace Pipeline instance</p> Example Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class HFTransformer(BaseComponent[str]):\n    \"\"\"\n    A component that integrates Hugging Face transformers models into the pipeline.\n\n    This component allows using any Hugging Face model and task within the pipeline\n    by wrapping the transformers.pipeline API. The model outputs are stored in the\n    document's model_outputs container under the \"huggingface\" source key.\n\n    Note that this component is only recommended for non-conversational language tasks.\n    For chat-based tasks, consider using LangChainLLM instead.\n\n    Args:\n        pipeline (Any): A pre-configured HuggingFace pipeline object to use for inference.\n            Must be an instance of transformers.pipelines.base.Pipeline.\n\n    Attributes:\n        task (str): The task name of the underlying pipeline, e.g. \"sentiment-analysis\", \"ner\".\n            Automatically extracted from the pipeline object.\n\n    Raises:\n        ImportError: If the transformers package is not installed\n        TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n\n    Example:\n        &gt;&gt;&gt; # Initialize for sentiment analysis\n        &gt;&gt;&gt; from transformers import pipeline\n        &gt;&gt;&gt; nlp = pipeline(\"sentiment-analysis\", model=\"distilbert-base-uncased-finetuned-sst-2-english\")\n        &gt;&gt;&gt; component = HFTransformer(pipeline=nlp)\n        &gt;&gt;&gt; doc = component(doc)  # Analyzes sentiment of doc.data\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or use the factory method\n        &gt;&gt;&gt; component = HFTransformer.from_model_id(\n        ...     model=\"facebook/bart-large-cnn\",\n        ...     task=\"summarization\",\n        ...     max_length=130,\n        ...     min_length=30,\n        ...     do_sample=False\n        ... )\n        &gt;&gt;&gt; doc = component(doc)  # Generates summary of doc.data\n    \"\"\"\n\n    @requires_package(\"transformers\", \"transformers.pipelines\")\n    def __init__(self, pipeline: Any):\n        \"\"\"Initialize with a pre-configured HuggingFace pipeline.\n\n        Args:\n            pipeline: A pre-configured HuggingFace pipeline object from transformers.pipeline().\n                     Must be an instance of transformers.pipelines.base.Pipeline.\n\n        Raises:\n            ImportError: If transformers package is not installed\n            TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n        \"\"\"\n        from transformers.pipelines.base import Pipeline\n\n        if not isinstance(pipeline, Pipeline):\n            raise TypeError(\n                f\"Expected HuggingFace Pipeline object, got {type(pipeline)}\"\n            )\n        self._pipe = pipeline\n        self.task = pipeline.task\n\n    @classmethod\n    @requires_package(\"transformers\", \"transformers.pipelines\")\n    def from_model_id(cls, model: str, task: str, **kwargs: Any) -&gt; \"HFTransformer\":\n        \"\"\"Create a transformer component from a model identifier.\n\n        Factory method that initializes a HuggingFace pipeline with the specified model and task,\n        then wraps it in a HFTransformer component.\n\n        Args:\n            model: The model identifier or path to load. Can be:\n                - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\")\n                - A local path to a saved model\n            task: The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")\n            **kwargs: Additional configuration options passed to transformers.pipeline()\n                Common options include:\n                - device: Device to run on (\"cpu\", \"cuda\", etc.)\n                - batch_size: Batch size for inference\n                - model_kwargs: Dict of model-specific args\n\n        Returns:\n            HFTransformer: Initialized transformer component wrapping the pipeline\n\n        Raises:\n            TypeError: If invalid kwargs are passed to pipeline initialization\n            ValueError: If pipeline initialization fails for any other reason\n            ImportError: If transformers package is not installed\n        \"\"\"\n        from transformers import pipeline\n\n        try:\n            pipe = pipeline(task=task, model=model, **kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for transformers.pipeline: {str(e)}\")\n        except Exception as e:\n            raise ValueError(f\"Error initializing transformer pipeline: {str(e)}\")\n\n        return cls(pipeline=pipe)\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].\"\"\"\n        output = self._pipe(doc.data)\n        doc.models.add_output(\"huggingface\", self.task, output)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer--initialize-for-sentiment-analysis","title":"Initialize for sentiment analysis","text":"<p>from transformers import pipeline nlp = pipeline(\"sentiment-analysis\", model=\"distilbert-base-uncased-finetuned-sst-2-english\") component = HFTransformer(pipeline=nlp) doc = component(doc)  # Analyzes sentiment of doc.data</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer--or-use-the-factory-method","title":"Or use the factory method","text":"<p>component = HFTransformer.from_model_id( ...     model=\"facebook/bart-large-cnn\", ...     task=\"summarization\", ...     max_length=130, ...     min_length=30, ...     do_sample=False ... ) doc = component(doc)  # Generates summary of doc.data</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].\"\"\"\n    output = self._pipe(doc.data)\n    doc.models.add_output(\"huggingface\", self.task, output)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.__init__","title":"<code>__init__(pipeline)</code>","text":"<p>Initialize with a pre-configured HuggingFace pipeline.</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A pre-configured HuggingFace pipeline object from transformers.pipeline().      Must be an instance of transformers.pipelines.base.Pipeline.</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If transformers package is not installed</p> <code>TypeError</code> <p>If pipeline is not a valid HuggingFace Pipeline instance</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@requires_package(\"transformers\", \"transformers.pipelines\")\ndef __init__(self, pipeline: Any):\n    \"\"\"Initialize with a pre-configured HuggingFace pipeline.\n\n    Args:\n        pipeline: A pre-configured HuggingFace pipeline object from transformers.pipeline().\n                 Must be an instance of transformers.pipelines.base.Pipeline.\n\n    Raises:\n        ImportError: If transformers package is not installed\n        TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n    \"\"\"\n    from transformers.pipelines.base import Pipeline\n\n    if not isinstance(pipeline, Pipeline):\n        raise TypeError(\n            f\"Expected HuggingFace Pipeline object, got {type(pipeline)}\"\n        )\n    self._pipe = pipeline\n    self.task = pipeline.task\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.from_model_id","title":"<code>from_model_id(model, task, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a transformer component from a model identifier.</p> <p>Factory method that initializes a HuggingFace pipeline with the specified model and task, then wraps it in a HFTransformer component.</p> PARAMETER DESCRIPTION <code>model</code> <p>The model identifier or path to load. Can be: - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\") - A local path to a saved model</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to transformers.pipeline() Common options include: - device: Device to run on (\"cpu\", \"cuda\", etc.) - batch_size: Batch size for inference - model_kwargs: Dict of model-specific args</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>HFTransformer</code> <p>Initialized transformer component wrapping the pipeline</p> <p> TYPE: <code>HFTransformer</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If invalid kwargs are passed to pipeline initialization</p> <code>ValueError</code> <p>If pipeline initialization fails for any other reason</p> <code>ImportError</code> <p>If transformers package is not installed</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@classmethod\n@requires_package(\"transformers\", \"transformers.pipelines\")\ndef from_model_id(cls, model: str, task: str, **kwargs: Any) -&gt; \"HFTransformer\":\n    \"\"\"Create a transformer component from a model identifier.\n\n    Factory method that initializes a HuggingFace pipeline with the specified model and task,\n    then wraps it in a HFTransformer component.\n\n    Args:\n        model: The model identifier or path to load. Can be:\n            - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\")\n            - A local path to a saved model\n        task: The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")\n        **kwargs: Additional configuration options passed to transformers.pipeline()\n            Common options include:\n            - device: Device to run on (\"cpu\", \"cuda\", etc.)\n            - batch_size: Batch size for inference\n            - model_kwargs: Dict of model-specific args\n\n    Returns:\n        HFTransformer: Initialized transformer component wrapping the pipeline\n\n    Raises:\n        TypeError: If invalid kwargs are passed to pipeline initialization\n        ValueError: If pipeline initialization fails for any other reason\n        ImportError: If transformers package is not installed\n    \"\"\"\n    from transformers import pipeline\n\n    try:\n        pipe = pipeline(task=task, model=model, **kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for transformers.pipeline: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Error initializing transformer pipeline: {str(e)}\")\n\n    return cls(pipeline=pipe)\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM","title":"<code>LangChainLLM</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates LangChain chains into the pipeline.</p> <p>This component allows using any LangChain chain within the pipeline by wrapping the chain's invoke method. The chain outputs are stored in the document's model_outputs container under the \"langchain\" source key.</p> PARAMETER DESCRIPTION <code>chain</code> <p>The LangChain chain to run on the document text. Must be a Runnable object from the LangChain library.</p> <p> TYPE: <code>Runnable</code> </p> <code>task</code> <p>The task name to use when storing outputs, e.g. \"summarization\", \"chat\". Used as key to organize model outputs in the document's model container.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional parameters to pass to the chain's invoke method. These are forwarded directly to the chain's invoke() call.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If chain is not a LangChain Runnable object or if invalid kwargs are passed</p> <code>ValueError</code> <p>If there is an error during chain invocation</p> <code>ImportError</code> <p>If langchain-core package is not installed</p> Example <p>from langchain_core.prompts import ChatPromptTemplate from langchain_openai import ChatOpenAI</p> <p>chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI() component = LangChainLLM(chain=chain, task=\"chat\") doc = component(doc)  # Runs the chain on doc.data and stores output</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class LangChainLLM(BaseComponent[str]):\n    \"\"\"\n    A component that integrates LangChain chains into the pipeline.\n\n    This component allows using any LangChain chain within the pipeline by wrapping\n    the chain's invoke method. The chain outputs are stored in the document's\n    model_outputs container under the \"langchain\" source key.\n\n    Args:\n        chain (Runnable): The LangChain chain to run on the document text.\n            Must be a Runnable object from the LangChain library.\n        task (str): The task name to use when storing outputs, e.g. \"summarization\", \"chat\".\n            Used as key to organize model outputs in the document's model container.\n        **kwargs: Additional parameters to pass to the chain's invoke method.\n            These are forwarded directly to the chain's invoke() call.\n\n    Raises:\n        TypeError: If chain is not a LangChain Runnable object or if invalid kwargs are passed\n        ValueError: If there is an error during chain invocation\n        ImportError: If langchain-core package is not installed\n\n    Example:\n        &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n        &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n\n        &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n        &gt;&gt;&gt; component = LangChainLLM(chain=chain, task=\"chat\")\n        &gt;&gt;&gt; doc = component(doc)  # Runs the chain on doc.data and stores output\n    \"\"\"\n\n    @requires_package(\"langchain-core\", \"langchain_core.runnables\")\n    def __init__(self, chain: Any, task: str, **kwargs: Any):\n        \"\"\"Initialize with a LangChain chain.\"\"\"\n        from langchain_core.runnables import Runnable\n\n        if not isinstance(chain, Runnable):\n            raise TypeError(f\"Expected LangChain Runnable object, got {type(chain)}\")\n\n        self.chain = chain\n        self.task = task\n        self.kwargs = kwargs\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].\"\"\"\n        try:\n            output = self.chain.invoke(doc.data, **self.kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for chain.invoke: {str(e)}\")\n        except Exception as e:\n            raise ValueError(f\"Error during chain invocation: {str(e)}\")\n\n        doc.models.add_output(\"langchain\", self.task, output)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].\"\"\"\n    try:\n        output = self.chain.invoke(doc.data, **self.kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for chain.invoke: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Error during chain invocation: {str(e)}\")\n\n    doc.models.add_output(\"langchain\", self.task, output)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM.__init__","title":"<code>__init__(chain, task, **kwargs)</code>","text":"<p>Initialize with a LangChain chain.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@requires_package(\"langchain-core\", \"langchain_core.runnables\")\ndef __init__(self, chain: Any, task: str, **kwargs: Any):\n    \"\"\"Initialize with a LangChain chain.\"\"\"\n    from langchain_core.runnables import Runnable\n\n    if not isinstance(chain, Runnable):\n        raise TypeError(f\"Expected LangChain Runnable object, got {type(chain)}\")\n\n    self.chain = chain\n    self.task = task\n    self.kwargs = kwargs\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP","title":"<code>SpacyNLP</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates spaCy models into the pipeline.</p> <p>This component allows using any spaCy model within the pipeline by loading and applying it to process text documents. The spaCy doc outputs are stored in the document's nlp annotations container under .spacy_docs.</p> PARAMETER DESCRIPTION <code>nlp</code> <p>A pre-configured spaCy Language object.</p> <p> TYPE: <code>Language</code> </p> Example Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class SpacyNLP(BaseComponent[str]):\n    \"\"\"\n    A component that integrates spaCy models into the pipeline.\n\n    This component allows using any spaCy model within the pipeline by loading\n    and applying it to process text documents. The spaCy doc outputs are stored\n    in the document's nlp annotations container under .spacy_docs.\n\n    Args:\n        nlp: A pre-configured spaCy Language object.\n\n    Example:\n        &gt;&gt;&gt; # Using pre-configured pipeline\n        &gt;&gt;&gt; import spacy\n        &gt;&gt;&gt; nlp = spacy.load(\"en_core_web_sm\", disable=[\"parser\"])\n        &gt;&gt;&gt; component = SpacyNLP(nlp)\n        &gt;&gt;&gt; doc = component(doc)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using model name\n        &gt;&gt;&gt; component = SpacyNLP.from_model_id(\"en_core_web_sm\", disable=[\"parser\"])\n        &gt;&gt;&gt; doc = component(doc)\n    \"\"\"\n\n    def __init__(self, nlp: \"Language\"):\n        \"\"\"Initialize with a pre-configured spaCy Language object.\"\"\"\n        self._nlp = nlp\n\n    @classmethod\n    def from_model_id(cls, model: str, **kwargs: Any) -&gt; \"SpacyNLP\":\n        \"\"\"\n        Create a SpacyNLP component from a model identifier.\n\n        Args:\n            model (str): The name or path of the spaCy model to load.\n                Can be a model name like 'en_core_web_sm' or path to saved model.\n            **kwargs: Additional configuration options passed to spacy.load.\n                Common options include disable, exclude, enable.\n\n        Returns:\n            SpacyNLP: Initialized spaCy component\n\n        Raises:\n            ImportError: If spaCy or the specified model is not installed\n            TypeError: If invalid kwargs are passed to spacy.load\n        \"\"\"\n        try:\n            import spacy\n        except ImportError:\n            raise ImportError(\n                \"Could not import spacy. Please install it with: \" \"`pip install spacy`\"\n            )\n\n        try:\n            nlp = spacy.load(model, **kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for spacy.load: {str(e)}\")\n        except Exception as e:\n            raise ImportError(\n                f\"Could not load spaCy model {model}! \"\n                \"Make sure you have installed it with: \"\n                f\"`python -m spacy download {model}`\"\n            ) from e\n\n        return cls(nlp)\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.\"\"\"\n        spacy_doc = self._nlp(doc.data)\n        doc.nlp.add_spacy_doc(spacy_doc)\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP--using-pre-configured-pipeline","title":"Using pre-configured pipeline","text":"<p>import spacy nlp = spacy.load(\"en_core_web_sm\", disable=[\"parser\"]) component = SpacyNLP(nlp) doc = component(doc)</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP--or-using-model-name","title":"Or using model name","text":"<p>component = SpacyNLP.from_model_id(\"en_core_web_sm\", disable=[\"parser\"]) doc = component(doc)</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.\"\"\"\n    spacy_doc = self._nlp(doc.data)\n    doc.nlp.add_spacy_doc(spacy_doc)\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.__init__","title":"<code>__init__(nlp)</code>","text":"<p>Initialize with a pre-configured spaCy Language object.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __init__(self, nlp: \"Language\"):\n    \"\"\"Initialize with a pre-configured spaCy Language object.\"\"\"\n    self._nlp = nlp\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.from_model_id","title":"<code>from_model_id(model, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a SpacyNLP component from a model identifier.</p> PARAMETER DESCRIPTION <code>model</code> <p>The name or path of the spaCy model to load. Can be a model name like 'en_core_web_sm' or path to saved model.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to spacy.load. Common options include disable, exclude, enable.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>SpacyNLP</code> <p>Initialized spaCy component</p> <p> TYPE: <code>SpacyNLP</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If spaCy or the specified model is not installed</p> <code>TypeError</code> <p>If invalid kwargs are passed to spacy.load</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@classmethod\ndef from_model_id(cls, model: str, **kwargs: Any) -&gt; \"SpacyNLP\":\n    \"\"\"\n    Create a SpacyNLP component from a model identifier.\n\n    Args:\n        model (str): The name or path of the spaCy model to load.\n            Can be a model name like 'en_core_web_sm' or path to saved model.\n        **kwargs: Additional configuration options passed to spacy.load.\n            Common options include disable, exclude, enable.\n\n    Returns:\n        SpacyNLP: Initialized spaCy component\n\n    Raises:\n        ImportError: If spaCy or the specified model is not installed\n        TypeError: If invalid kwargs are passed to spacy.load\n    \"\"\"\n    try:\n        import spacy\n    except ImportError:\n        raise ImportError(\n            \"Could not import spacy. Please install it with: \" \"`pip install spacy`\"\n        )\n\n    try:\n        nlp = spacy.load(model, **kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for spacy.load: {str(e)}\")\n    except Exception as e:\n        raise ImportError(\n            f\"Could not load spaCy model {model}! \"\n            \"Make sure you have installed it with: \"\n            f\"`python -m spacy download {model}`\"\n        ) from e\n\n    return cls(nlp)\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.requires_package","title":"<code>requires_package(package_name, import_path)</code>","text":"<p>Decorator to check if an optional package is available.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Name of the package to install (e.g., 'langchain-core')</p> <p> TYPE: <code>str</code> </p> <code>import_path</code> <p>Import path to check (e.g., 'langchain_core.runnables')</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def requires_package(package_name: str, import_path: str) -&gt; Callable:\n    \"\"\"Decorator to check if an optional package is available.\n\n    Args:\n        package_name: Name of the package to install (e.g., 'langchain-core')\n        import_path: Import path to check (e.g., 'langchain_core.runnables')\n    \"\"\"\n\n    def decorator(func: Callable[..., T]) -&gt; Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -&gt; T:\n            try:\n                __import__(import_path)\n            except ImportError:\n                raise ImportError(\n                    f\"This feature requires {package_name}. \"\n                    f\"Please install it with: `pip install {package_name}`\"\n                )\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor","title":"<code>TextPreProcessor</code>","text":"<p>               Bases: <code>BaseComponent[Document]</code></p> <p>A component for preprocessing text documents.</p> <p>This class applies various cleaning and tokenization steps to a Document object, based on the provided configuration.</p> ATTRIBUTE DESCRIPTION <code>tokenizer</code> <p>The tokenizer to use. Can be \"basic\" or a custom tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".</p> <p> TYPE: <code>Union[str, Callable[[str], List[str]]]</code> </p> <code>lowercase</code> <p>Whether to convert text to lowercase. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>remove_punctuation</code> <p>Whether to remove punctuation. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>standardize_spaces</code> <p>Whether to standardize spaces. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>regex</code> <p>List of regex patterns and replacements. Defaults to an empty list.</p> <p> TYPE: <code>List[Tuple[str, str]]</code> </p> <code>tokenizer_func</code> <p>The tokenization function.</p> <p> TYPE: <code>Callable[[str], List[str]]</code> </p> <code>cleaning_steps</code> <p>List of text cleaning functions.</p> <p> TYPE: <code>List[Callable[[str], str]]</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>class TextPreProcessor(BaseComponent[Document]):\n    \"\"\"\n    A component for preprocessing text documents.\n\n    This class applies various cleaning and tokenization steps to a Document object,\n    based on the provided configuration.\n\n    Attributes:\n        tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n            tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n        lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n        remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n        standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n        regex (List[Tuple[str, str]]): List of regex patterns and replacements. Defaults to an empty list.\n        tokenizer_func (Callable[[str], List[str]]): The tokenization function.\n        cleaning_steps (List[Callable[[str], str]]): List of text cleaning functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        tokenizer: Union[str, Callable[[str], List[str]]] = \"basic\",\n        lowercase: bool = False,\n        remove_punctuation: bool = False,\n        standardize_spaces: bool = False,\n        regex: List[Tuple[str, str]] = None,\n    ):\n        \"\"\"\n        Initialize the TextPreprocessor with the given configuration.\n\n        Args:\n            tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n                tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n            lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n            remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n            standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n            regex (List[Tuple[str, str]], optional): List of regex patterns and replacements. Defaults to None.\n        \"\"\"\n        self.lowercase = lowercase\n        self.remove_punctuation = remove_punctuation\n        self.standardize_spaces = standardize_spaces\n        self.regex = regex or []\n        self.tokenizer = self._get_tokenizer(tokenizer)\n        self.cleaning_steps = self._configure_cleaning_steps()\n\n    def _get_tokenizer(\n        self, tokenizer: Union[str, Callable[[str], List[str]]]\n    ) -&gt; Callable[[str], List[str]]:\n        \"\"\"\n        Get the tokenization function based on the specified tokenizer.\n\n        Args:\n            tokenizer: Either \"basic\" or a custom tokenization function.\n\n        Returns:\n            Callable[[str], List[str]]: The tokenization function.\n\n        Raises:\n            ValueError: If an unsupported tokenizer string is specified.\n        \"\"\"\n        if callable(tokenizer):\n            return tokenizer\n        elif tokenizer == \"basic\":\n            return lambda text: text.split()\n        else:\n            raise ValueError(\n                f\"Unsupported tokenizer: {tokenizer}. Use 'basic' or provide a custom tokenization function.\"\n            )\n\n    def _configure_cleaning_steps(self) -&gt; List[Callable[[str], str]]:\n        \"\"\"\n        Configure the text cleaning steps based on the preprocessor configuration.\n\n        Returns:\n            List[Callable[[str], str]]: List of text cleaning functions.\n        \"\"\"\n        steps = []\n        if self.lowercase:\n            steps.append(lambda text: text.lower())\n\n        regex_steps = []\n        if self.regex:\n            regex_steps.extend(self.regex)\n        else:\n            if self.remove_punctuation:\n                regex_steps.append((r\"[^\\w\\s]\", \"\"))\n            if self.standardize_spaces:\n                regex_steps.append((r\"\\s+\", \" \"))\n\n        for pattern, repl in regex_steps:\n            steps.append(self._create_regex_step(pattern, repl))\n\n        if self.standardize_spaces:\n            steps.append(str.strip)\n\n        return steps\n\n    @staticmethod\n    def _create_regex_step(pattern: str, repl: str) -&gt; Callable[[str], str]:\n        \"\"\"\n        Create a regex-based cleaning step. This can be used in place of other cleaning steps, if required.\n\n        Args:\n            pattern (str): The regex pattern to match.\n            repl (str): The replacement string.\n\n        Returns:\n            Callable[[str], str]: A function that applies the regex substitution.\n        \"\"\"\n        return lambda text: re.sub(pattern, repl, text)\n\n    def _clean_text(self, text: str) -&gt; str:\n        \"\"\"\n        Apply all cleaning steps to the input text.\n\n        Args:\n            text (str): The input text to clean.\n\n        Returns:\n            str: The cleaned text.\n        \"\"\"\n        for step in self.cleaning_steps:\n            text = step(text)\n        return text\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Preprocess the given Document.\n\n        This method applies the configured cleaning steps and tokenization to the document's text (in that order).\n\n        Args:\n            doc (Document): The document to preprocess.\n\n        Returns:\n            Document: The preprocessed document with updated tokens and preprocessed text.\n        \"\"\"\n        # Preprocess text\n        preprocessed_text = self._clean_text(doc.text)\n        doc.preprocessed_text = preprocessed_text\n\n        if self.tokenizer:\n            tokens = self.tokenizer(preprocessed_text)\n            doc.tokens = tokens\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor.__call__","title":"<code>__call__(doc)</code>","text":"<p>Preprocess the given Document.</p> <p>This method applies the configured cleaning steps and tokenization to the document's text (in that order).</p> PARAMETER DESCRIPTION <code>doc</code> <p>The document to preprocess.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The preprocessed document with updated tokens and preprocessed text.</p> <p> TYPE: <code>Document</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Preprocess the given Document.\n\n    This method applies the configured cleaning steps and tokenization to the document's text (in that order).\n\n    Args:\n        doc (Document): The document to preprocess.\n\n    Returns:\n        Document: The preprocessed document with updated tokens and preprocessed text.\n    \"\"\"\n    # Preprocess text\n    preprocessed_text = self._clean_text(doc.text)\n    doc.preprocessed_text = preprocessed_text\n\n    if self.tokenizer:\n        tokens = self.tokenizer(preprocessed_text)\n        doc.tokens = tokens\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor.__init__","title":"<code>__init__(tokenizer='basic', lowercase=False, remove_punctuation=False, standardize_spaces=False, regex=None)</code>","text":"<p>Initialize the TextPreprocessor with the given configuration.</p> PARAMETER DESCRIPTION <code>tokenizer</code> <p>The tokenizer to use. Can be \"basic\" or a custom tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".</p> <p> TYPE: <code>Union[str, Callable[[str], List[str]]]</code> DEFAULT: <code>'basic'</code> </p> <code>lowercase</code> <p>Whether to convert text to lowercase. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>remove_punctuation</code> <p>Whether to remove punctuation. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>standardize_spaces</code> <p>Whether to standardize spaces. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>regex</code> <p>List of regex patterns and replacements. Defaults to None.</p> <p> TYPE: <code>List[Tuple[str, str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: Union[str, Callable[[str], List[str]]] = \"basic\",\n    lowercase: bool = False,\n    remove_punctuation: bool = False,\n    standardize_spaces: bool = False,\n    regex: List[Tuple[str, str]] = None,\n):\n    \"\"\"\n    Initialize the TextPreprocessor with the given configuration.\n\n    Args:\n        tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n            tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n        lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n        remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n        standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n        regex (List[Tuple[str, str]], optional): List of regex patterns and replacements. Defaults to None.\n    \"\"\"\n    self.lowercase = lowercase\n    self.remove_punctuation = remove_punctuation\n    self.standardize_spaces = standardize_spaces\n    self.regex = regex or []\n    self.tokenizer = self._get_tokenizer(tokenizer)\n    self.cleaning_steps = self._configure_cleaning_steps()\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor","title":"<code>TextPostProcessor</code>","text":"<p>               Bases: <code>BaseComponent[Document]</code></p> <p>A component for post-processing text documents, specifically for refining entities.</p> <p>This class applies post-coordination rules to entities in a Document object, replacing entities with their refined versions based on a lookup dictionary.</p> ATTRIBUTE DESCRIPTION <code>entity_lookup</code> <p>A dictionary for entity refinement lookups.</p> <p> TYPE: <code>Dict[str, str]</code> </p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>class TextPostProcessor(BaseComponent[Document]):\n    \"\"\"\n    A component for post-processing text documents, specifically for refining entities.\n\n    This class applies post-coordination rules to entities in a Document object,\n    replacing entities with their refined versions based on a lookup dictionary.\n\n    Attributes:\n        entity_lookup (Dict[str, str]): A dictionary for entity refinement lookups.\n    \"\"\"\n\n    def __init__(self, postcoordination_lookup: Dict[str, str] = None):\n        \"\"\"\n        Initialize the TextPostProcessor with an optional postcoordination lookup.\n\n        Args:\n            postcoordination_lookup (Dict[str, str], optional): A dictionary for entity refinement lookups.\n                If not provided, an empty dictionary will be used.\n        \"\"\"\n        self.entity_lookup = postcoordination_lookup or {}\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Apply post-processing to the given Document.\n\n        This method refines the entities in the document based on the entity_lookup.\n        If an entity exists in the lookup, it is replaced with its refined version.\n\n        Args:\n            doc (Document): The document to be post-processed.\n\n        Returns:\n            Document: The post-processed document with refined entities.\n\n        Note:\n            If the entity_lookup is empty or the document has no 'entities' attribute,\n            the document is returned unchanged.\n        \"\"\"\n        if not self.entity_lookup or not hasattr(doc._nlp, \"_entities\"):\n            return doc\n\n        refined_entities = []\n        for entity in doc.nlp.get_entities():\n            entity_text = entity[\"text\"]\n            if entity_text in self.entity_lookup:\n                entity[\"text\"] = self.entity_lookup[entity_text]\n            refined_entities.append(entity)\n\n        doc.nlp.set_entities(refined_entities)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor.__call__","title":"<code>__call__(doc)</code>","text":"<p>Apply post-processing to the given Document.</p> <p>This method refines the entities in the document based on the entity_lookup. If an entity exists in the lookup, it is replaced with its refined version.</p> PARAMETER DESCRIPTION <code>doc</code> <p>The document to be post-processed.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The post-processed document with refined entities.</p> <p> TYPE: <code>Document</code> </p> Note <p>If the entity_lookup is empty or the document has no 'entities' attribute, the document is returned unchanged.</p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Apply post-processing to the given Document.\n\n    This method refines the entities in the document based on the entity_lookup.\n    If an entity exists in the lookup, it is replaced with its refined version.\n\n    Args:\n        doc (Document): The document to be post-processed.\n\n    Returns:\n        Document: The post-processed document with refined entities.\n\n    Note:\n        If the entity_lookup is empty or the document has no 'entities' attribute,\n        the document is returned unchanged.\n    \"\"\"\n    if not self.entity_lookup or not hasattr(doc._nlp, \"_entities\"):\n        return doc\n\n    refined_entities = []\n    for entity in doc.nlp.get_entities():\n        entity_text = entity[\"text\"]\n        if entity_text in self.entity_lookup:\n            entity[\"text\"] = self.entity_lookup[entity_text]\n        refined_entities.append(entity)\n\n    doc.nlp.set_entities(refined_entities)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor.__init__","title":"<code>__init__(postcoordination_lookup=None)</code>","text":"<p>Initialize the TextPostProcessor with an optional postcoordination lookup.</p> PARAMETER DESCRIPTION <code>postcoordination_lookup</code> <p>A dictionary for entity refinement lookups. If not provided, an empty dictionary will be used.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>def __init__(self, postcoordination_lookup: Dict[str, str] = None):\n    \"\"\"\n    Initialize the TextPostProcessor with an optional postcoordination lookup.\n\n    Args:\n        postcoordination_lookup (Dict[str, str], optional): A dictionary for entity refinement lookups.\n            If not provided, an empty dictionary will be used.\n    \"\"\"\n    self.entity_lookup = postcoordination_lookup or {}\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator","title":"<code>CdsCardCreator</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <pre><code>Component that creates CDS Hooks cards from model outputs or static content.\n\nThis component formats text into CDS Hooks cards that can be displayed in an EHR system.\nIt can create cards from either:\n1. Model-generated text stored in a document's model outputs container\n2. Static content provided during initialization\n\nThe component uses Jinja2 templates to format the text into valid CDS Hooks card JSON.\nThe generated cards are added to the document's CDS container.\n\nArgs:\n    template (str, optional): Jinja2 template string for card creation. If not provided,\n        uses a default template that creates an info card.\n    template_path (Union[str, Path], optional): Path to a Jinja2 template file.\n    static_content (str, optional): Static text to use instead of model output.\n    source (str, optional): Source framework to get model output from (e.g. \"huggingface\").\n    task (str, optional): Task name to get model output from (e.g. \"summarization\").\n    delimiter (str, optional): String to split model output into multiple cards.\n    default_source (Dict[str, Any], optional): Default source info for cards.\n        Defaults to {\"label\": \"Card Generated by HealthChain\"}.\n\nExample:\n    &gt;&gt;&gt; # Create cards from model output\n    &gt;&gt;&gt; creator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\n    &gt;&gt;&gt; doc = creator(doc)  # Creates cards from model output\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create cards with static content\n    &gt;&gt;&gt; creator = CdsCardCreator(static_content=\"Static card message\")\n    &gt;&gt;&gt; doc = creator(doc)  # Creates card with static content\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create cards with custom template\n    &gt;&gt;&gt; template = '''\n    ... {\n    ...     \"summary\": \"{{ model_output[:140] }}\",\n    ...     \"indicator\": \"info\",\n    ...     \"source\": {{ default_source | tojson }},\n    ...     \"detail\": \"{{ model_output }}\"\n    ... }\n    ... '''\n    &gt;&gt;&gt; creator = CdsCardCreator(\n    ...     template=template,\n    ...     source=\"langchain\",\n    ...     task=\"chat\",\n    ...     delimiter=\"\n</code></pre> <p>\"         ... )         &gt;&gt;&gt; doc = creator(doc)  # Creates cards split by newlines</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>class CdsCardCreator(BaseComponent[str]):\n    \"\"\"\n    Component that creates CDS Hooks cards from model outputs or static content.\n\n    This component formats text into CDS Hooks cards that can be displayed in an EHR system.\n    It can create cards from either:\n    1. Model-generated text stored in a document's model outputs container\n    2. Static content provided during initialization\n\n    The component uses Jinja2 templates to format the text into valid CDS Hooks card JSON.\n    The generated cards are added to the document's CDS container.\n\n    Args:\n        template (str, optional): Jinja2 template string for card creation. If not provided,\n            uses a default template that creates an info card.\n        template_path (Union[str, Path], optional): Path to a Jinja2 template file.\n        static_content (str, optional): Static text to use instead of model output.\n        source (str, optional): Source framework to get model output from (e.g. \"huggingface\").\n        task (str, optional): Task name to get model output from (e.g. \"summarization\").\n        delimiter (str, optional): String to split model output into multiple cards.\n        default_source (Dict[str, Any], optional): Default source info for cards.\n            Defaults to {\"label\": \"Card Generated by HealthChain\"}.\n\n    Example:\n        &gt;&gt;&gt; # Create cards from model output\n        &gt;&gt;&gt; creator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\n        &gt;&gt;&gt; doc = creator(doc)  # Creates cards from model output\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create cards with static content\n        &gt;&gt;&gt; creator = CdsCardCreator(static_content=\"Static card message\")\n        &gt;&gt;&gt; doc = creator(doc)  # Creates card with static content\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create cards with custom template\n        &gt;&gt;&gt; template = '''\n        ... {\n        ...     \"summary\": \"{{ model_output[:140] }}\",\n        ...     \"indicator\": \"info\",\n        ...     \"source\": {{ default_source | tojson }},\n        ...     \"detail\": \"{{ model_output }}\"\n        ... }\n        ... '''\n        &gt;&gt;&gt; creator = CdsCardCreator(\n        ...     template=template,\n        ...     source=\"langchain\",\n        ...     task=\"chat\",\n        ...     delimiter=\"\\n\"\n        ... )\n        &gt;&gt;&gt; doc = creator(doc)  # Creates cards split by newlines\n    \"\"\"\n\n    # TODO: make source and other fields configurable from model too\n    DEFAULT_TEMPLATE = \"\"\"\n    {\n        \"summary\": \"{{ model_output[:140] }}\",\n        \"indicator\": \"info\",\n        \"source\": {{ default_source | tojson }},\n        \"detail\": \"{{ model_output }}\"\n    }\n    \"\"\"\n\n    def __init__(\n        self,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        static_content: Optional[str] = None,\n        source: Optional[str] = None,\n        task: Optional[str] = None,\n        delimiter: Optional[str] = None,\n        default_source: Optional[Dict[str, Any]] = None,\n    ):\n        # Load template from file or use string template\n        if template_path:\n            try:\n                template_path = Path(template_path)\n                if not template_path.exists():\n                    raise FileNotFoundError(f\"Template file not found: {template_path}\")\n                with open(template_path) as f:\n                    template = f.read()\n            except Exception as e:\n                logger.error(f\"Error loading template from {template_path}: {str(e)}\")\n                template = self.DEFAULT_TEMPLATE\n\n        self.template = Template(\n            template if template is not None else self.DEFAULT_TEMPLATE\n        )\n        self.static_content = static_content\n        self.source = source\n        self.task = task\n        self.delimiter = delimiter\n        self.default_source = default_source or {\n            \"label\": \"Card Generated by HealthChain\"\n        }\n\n    def create_card(self, content: str) -&gt; Card:\n        \"\"\"Creates a CDS Card using the template and model output.\"\"\"\n        try:\n            # Clean and escape the content\n            # TODO: format to html that can be rendered in card\n            content = content.replace(\"\\n\", \" \").replace(\"\\r\", \" \").strip()\n            content = content.replace('\"', '\\\\\"')  # Escape double quotes\n\n            try:\n                card_json = self.template.render(\n                    model_output=content, default_source=self.default_source\n                )\n            except Exception as e:\n                raise ValueError(f\"Error rendering template: {str(e)}\")\n\n            # Parse the rendered JSON into card fields\n            card_fields = json.loads(card_json)\n\n            return Card(\n                summary=card_fields[\"summary\"][:140],  # Enforce max length\n                indicator=IndicatorEnum(card_fields[\"indicator\"]),\n                source=Source(**card_fields[\"source\"]),\n                detail=card_fields.get(\"detail\"),\n                suggestions=card_fields.get(\"suggestions\"),\n                selectionBehavior=card_fields.get(\"selectionBehavior\"),\n                overrideReasons=card_fields.get(\"overrideReasons\"),\n                links=card_fields.get(\"links\"),\n            )\n        except Exception as e:\n            raise ValueError(\n                f\"Error creating CDS card: Failed to render template or parse card fields: {str(e)}\"\n            )\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Process a document and create CDS Hooks cards from model outputs or static content.\n\n        Creates cards in one of two ways:\n        1. From model-generated text stored in the document's model outputs container,\n           accessed using the configured source and task\n        2. From static content provided during initialization\n\n        The generated text can optionally be split into multiple cards using a delimiter.\n        Each piece of text is formatted using the configured template into a CDS Hooks card\n        and added to the document's CDS container.\n\n        Args:\n            doc (Document): Document containing model outputs and CDS container\n\n        Returns:\n            Document: The input document with generated CDS cards added to its CDS container\n\n        Raises:\n            ValueError: If neither model configuration (source and task) nor static content\n                is provided for card creation\n        \"\"\"\n        if self.source and self.task:\n            generated_text = doc.models.get_generated_text(self.source, self.task)\n            if not generated_text:\n                logger.warning(\n                    f\"No generated text for {self.source}/{self.task} found for CDS card creation!\"\n                )\n                return doc\n        elif self.static_content:\n            generated_text = [self.static_content]\n        else:\n            raise ValueError(\n                \"Either model output (source and task) or content need to be provided for CDS card creation!\"\n            )\n\n        # Create card from model output\n        cards = []\n        for text in generated_text:\n            texts = [text] if not self.delimiter else text.split(self.delimiter)\n            for t in texts:\n                try:\n                    cards.append(self.create_card(t))\n                except Exception as e:\n                    logger.warning(f\"Error creating card: {str(e)}\")\n\n        if cards:\n            doc.cds.cards = cards\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process a document and create CDS Hooks cards from model outputs or static content.</p> <p>Creates cards in one of two ways: 1. From model-generated text stored in the document's model outputs container,    accessed using the configured source and task 2. From static content provided during initialization</p> <p>The generated text can optionally be split into multiple cards using a delimiter. Each piece of text is formatted using the configured template into a CDS Hooks card and added to the document's CDS container.</p> PARAMETER DESCRIPTION <code>doc</code> <p>Document containing model outputs and CDS container</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The input document with generated CDS cards added to its CDS container</p> <p> TYPE: <code>Document</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither model configuration (source and task) nor static content is provided for card creation</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Process a document and create CDS Hooks cards from model outputs or static content.\n\n    Creates cards in one of two ways:\n    1. From model-generated text stored in the document's model outputs container,\n       accessed using the configured source and task\n    2. From static content provided during initialization\n\n    The generated text can optionally be split into multiple cards using a delimiter.\n    Each piece of text is formatted using the configured template into a CDS Hooks card\n    and added to the document's CDS container.\n\n    Args:\n        doc (Document): Document containing model outputs and CDS container\n\n    Returns:\n        Document: The input document with generated CDS cards added to its CDS container\n\n    Raises:\n        ValueError: If neither model configuration (source and task) nor static content\n            is provided for card creation\n    \"\"\"\n    if self.source and self.task:\n        generated_text = doc.models.get_generated_text(self.source, self.task)\n        if not generated_text:\n            logger.warning(\n                f\"No generated text for {self.source}/{self.task} found for CDS card creation!\"\n            )\n            return doc\n    elif self.static_content:\n        generated_text = [self.static_content]\n    else:\n        raise ValueError(\n            \"Either model output (source and task) or content need to be provided for CDS card creation!\"\n        )\n\n    # Create card from model output\n    cards = []\n    for text in generated_text:\n        texts = [text] if not self.delimiter else text.split(self.delimiter)\n        for t in texts:\n            try:\n                cards.append(self.create_card(t))\n            except Exception as e:\n                logger.warning(f\"Error creating card: {str(e)}\")\n\n    if cards:\n        doc.cds.cards = cards\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator.create_card","title":"<code>create_card(content)</code>","text":"<p>Creates a CDS Card using the template and model output.</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>def create_card(self, content: str) -&gt; Card:\n    \"\"\"Creates a CDS Card using the template and model output.\"\"\"\n    try:\n        # Clean and escape the content\n        # TODO: format to html that can be rendered in card\n        content = content.replace(\"\\n\", \" \").replace(\"\\r\", \" \").strip()\n        content = content.replace('\"', '\\\\\"')  # Escape double quotes\n\n        try:\n            card_json = self.template.render(\n                model_output=content, default_source=self.default_source\n            )\n        except Exception as e:\n            raise ValueError(f\"Error rendering template: {str(e)}\")\n\n        # Parse the rendered JSON into card fields\n        card_fields = json.loads(card_json)\n\n        return Card(\n            summary=card_fields[\"summary\"][:140],  # Enforce max length\n            indicator=IndicatorEnum(card_fields[\"indicator\"]),\n            source=Source(**card_fields[\"source\"]),\n            detail=card_fields.get(\"detail\"),\n            suggestions=card_fields.get(\"suggestions\"),\n            selectionBehavior=card_fields.get(\"selectionBehavior\"),\n            overrideReasons=card_fields.get(\"overrideReasons\"),\n            links=card_fields.get(\"links\"),\n        )\n    except Exception as e:\n        raise ValueError(\n            f\"Error creating CDS card: Failed to render template or parse card fields: {str(e)}\"\n        )\n</code></pre>"},{"location":"api/containers/","title":"Containers","text":""},{"location":"api/containers/#healthchain.io.containers.BaseDocument","title":"<code>BaseDocument</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[str]</code></p> <p>Base document container for raw text content.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass BaseDocument(DataContainer[str]):\n    \"\"\"Base document container for raw text content.\"\"\"\n\n    data: str\n    text: str = field(init=False)\n\n    def __post_init__(self):\n        self.text = self.data\n\n    def char_count(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.DataContainer","title":"<code>DataContainer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A generic container for data.</p> <p>This class represents a container for data with a specific type T.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The data stored in the container.</p> <p> TYPE: <code>T</code> </p> METHOD DESCRIPTION <code>to_dict</code> <p>Converts the container's data to a dictionary.</p> <code>to_json</code> <p>Converts the container's data to a JSON string.</p> <code>from_dict</code> <p>Dict[str, Any]) -&gt; \"DataContainer\": Creates a DataContainer instance from a dictionary.</p> <code>from_json</code> <p>str) -&gt; \"DataContainer\": Creates a DataContainer instance from a JSON string.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass DataContainer(Generic[T]):\n    \"\"\"\n    A generic container for data.\n\n    This class represents a container for data with a specific type T.\n\n    Attributes:\n        data (T): The data stored in the container.\n\n    Methods:\n        to_dict() -&gt; Dict[str, Any]:\n            Converts the container's data to a dictionary.\n\n        to_json() -&gt; str:\n            Converts the container's data to a JSON string.\n\n        from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a dictionary.\n\n        from_json(cls, json_str: str) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a JSON string.\n    \"\"\"\n\n    data: T\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    def to_json(self) -&gt; str:\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n        return cls(**data)\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"DataContainer\":\n        return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseDocument</code></p> <p>Main document container for processing textual and clinical data in HealthChain.</p> <p>The Document class is the primary structure used throughout annotation and analytics pipelines, accumulating transformations, extractions, and results from each stage. It seamlessly integrates raw text, NLP annotations, FHIR resources, clinical decision support (CDS) results, and ML model outputs in one object.</p> Features <ul> <li>Accepts text, FHIR Bundles/resources, or lists of FHIR resources as input.</li> <li>Provides basic tokenization and supports integration with NLP models (spaCy, transformers).</li> <li>Stores and manipulates clinical FHIR data via the .fhir property (access to bundles, problem lists, meds, allergies, etc.).</li> <li>Encapsulates CDS Hooks-style decision support cards and suggested actions via the .cds property.</li> <li>Stores outputs from external ML/LLM models: HuggingFace, LangChain, etc.</li> </ul> ATTRIBUTE DESCRIPTION <code>nlp</code> <p>NLP output (tokens, entities, embeddings, spaCy doc)</p> <p> TYPE: <code>NlpAnnotations</code> </p> <code>fhir</code> <p>FHIR resources and context (problem list, medication, allergy, etc.)</p> <p> TYPE: <code>FhirData</code> </p> <code>cds</code> <p>Clinical decision support (cards and actions)</p> <p> TYPE: <code>CdsAnnotations</code> </p> <code>models</code> <p>Results from ML/LLM models (HuggingFace, LangChain, etc.)</p> <p> TYPE: <code>ModelOutputs</code> </p> <code>text</code> <p>The text content of the document (if available).</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>The original input supplied (raw text, Bundle, resource, or list of resources)</p> <p> TYPE: <code>str</code> </p> Usage example <p>doc = Document(data=\"Patient has hypertension\") doc.nlp._tokens ['Patient', 'has', 'hypertension'] doc.fhir.problem_list = [Condition(...)] doc.cds.cards = [Card(...)] doc.models.huggingface_results = ... for token in doc: ...     print(token)</p> Inherits from <p>BaseDocument</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass Document(BaseDocument):\n    \"\"\"\n    Main document container for processing textual and clinical data in HealthChain.\n\n    The Document class is the primary structure used throughout annotation and analytics\n    pipelines, accumulating transformations, extractions, and results from each stage. It\n    seamlessly integrates raw text, NLP annotations, FHIR resources, clinical decision\n    support (CDS) results, and ML model outputs in one object.\n\n    Features:\n        - Accepts text, FHIR Bundles/resources, or lists of FHIR resources as input.\n        - Provides basic tokenization and supports integration with NLP models (spaCy, transformers).\n        - Stores and manipulates clinical FHIR data via the .fhir property (access to bundles, problem lists, meds, allergies, etc.).\n        - Encapsulates CDS Hooks-style decision support cards and suggested actions via the .cds property.\n        - Stores outputs from external ML/LLM models: HuggingFace, LangChain, etc.\n\n    Attributes:\n        nlp (NlpAnnotations): NLP output (tokens, entities, embeddings, spaCy doc)\n        fhir (FhirData): FHIR resources and context (problem list, medication, allergy, etc.)\n        cds (CdsAnnotations): Clinical decision support (cards and actions)\n        models (ModelOutputs): Results from ML/LLM models (HuggingFace, LangChain, etc.)\n        text (str): The text content of the document (if available).\n        data: The original input supplied (raw text, Bundle, resource, or list of resources)\n\n    Usage example:\n        &gt;&gt;&gt; doc = Document(data=\"Patient has hypertension\")\n        &gt;&gt;&gt; doc.nlp._tokens\n        ['Patient', 'has', 'hypertension']\n        &gt;&gt;&gt; doc.fhir.problem_list = [Condition(...)]\n        &gt;&gt;&gt; doc.cds.cards = [Card(...)]\n        &gt;&gt;&gt; doc.models.huggingface_results = ...\n        &gt;&gt;&gt; for token in doc:\n        ...     print(token)\n\n    Inherits from:\n        BaseDocument\n    \"\"\"\n\n    _nlp: NlpAnnotations = field(default_factory=NlpAnnotations)\n    _fhir: FhirData = field(default_factory=FhirData)\n    _cds: CdsAnnotations = field(default_factory=CdsAnnotations)\n    _models: ModelOutputs = field(default_factory=ModelOutputs)\n\n    @property\n    def nlp(self) -&gt; NlpAnnotations:\n        return self._nlp\n\n    @property\n    def fhir(self) -&gt; FhirData:\n        return self._fhir\n\n    @property\n    def cds(self) -&gt; CdsAnnotations:\n        return self._cds\n\n    @property\n    def models(self) -&gt; ModelOutputs:\n        return self._models\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization setup to process textual or FHIR data.\n\n        - If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.\n        - If input data is a list of FHIR resources, wraps them in a Bundle.\n        - For text input, sets .text field accordingly.\n        - Performs basic whitespace tokenization if necessary.\n        \"\"\"\n        super().__post_init__()\n\n        # Handle FHIR Bundle data\n        if isinstance(self.data, Bundle):\n            self._fhir._bundle = self.data\n\n            # Extract OperationOutcome resources (operation results/errors)\n            outcomes = extract_resources(self._fhir._bundle, \"OperationOutcome\")\n            if outcomes:\n                self._fhir._operation_outcomes = outcomes\n\n            # Extract Provenance resources (data lineage/origin)\n            provenances = extract_resources(self._fhir._bundle, \"Provenance\")\n            if provenances:\n                self._fhir._provenances = provenances\n\n            self.text = \"\"  # No text content for bundle-only documents\n        # Handle list of FHIR resources\n        elif (\n            isinstance(self.data, list)\n            and self.data\n            and isinstance(self.data[0], Resource)\n        ):\n            self._fhir._bundle = create_bundle()\n            for resource in self.data:\n                add_resource(self._fhir._bundle, resource)\n            self.text = \"\"  # No text content for resource-only documents\n        else:\n            # Handle text data\n            self.text = self.data if isinstance(self.data, str) else str(self.data)\n\n        if not self._nlp._tokens and self.text:\n            self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n\n    def word_count(self) -&gt; int:\n        \"\"\"\n        Return the number of word tokens in the document.\n\n        Returns:\n            int: The count of tokenized words in the document.\n        \"\"\"\n        return len(self._nlp._tokens)\n\n    def update_problem_list_from_nlp(\n        self,\n        patient_ref: str = \"Patient/123\",\n        coding_system: str = \"http://snomed.info/sct\",\n        code_attribute: str = \"cui\",\n    ):\n        \"\"\"\n        Populate or update the problem list using entities extracted via NLP.\n\n        This method looks for entities with associated medical codes and creates FHIR Condition\n        resources from them. It supports a two-step process:\n        1. NER: Extract entities from text (spaCy, HuggingFace, etc.)\n        2. Entity Linking: Add medical codes to those entities\n        3. Problem List Creation: Convert linked entities to FHIR conditions (this method)\n\n        The method extracts from:\n        1. spaCy entities with extension attributes (e.g., ent._.cui)\n        2. Generic entities in the NLP annotations container (framework-agnostic)\n\n        TODO: make this more generic and support other resource types\n\n        Args:\n            patient_ref: FHIR reference to the patient (default: \"Patient/123\")\n            coding_system: Coding system URI for the conditions (default: SNOMED CT)\n            code_attribute: Name of the attribute containing the medical code (default: \"cui\")\n\n        Notes:\n            - Preserves any existing problem list Conditions.\n            - Supports framework-agnostic extraction (spaCy and dict entities).\n            - For spaCy, looks for entity extension attribute (e.g. ent._.cui).\n            - For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).\n        \"\"\"\n        # Start with existing conditions to preserve them\n        existing_conditions = self.fhir.problem_list.copy()\n        new_conditions = []\n\n        # 1. Extract from spaCy entities (if available)\n        if self.nlp._spacy_doc and self.nlp._spacy_doc.ents:\n            for ent in self.nlp._spacy_doc.ents:\n                if not Span.has_extension(code_attribute):\n                    logger.debug(\n                        f\"Extension '{code_attribute}' not found for spaCy entity {ent.text}\"\n                    )\n                    continue\n\n                code_value = getattr(ent._, code_attribute, None)\n                if code_value is None:\n                    logger.debug(\n                        f\"No {code_attribute} found for spaCy entity {ent.text}\"\n                    )\n                    continue\n\n                condition = create_condition(\n                    subject=patient_ref,\n                    code=code_value,\n                    display=ent.text,\n                    system=coding_system,\n                )\n                set_condition_category(condition, \"problem-list-item\")\n                logger.debug(\n                    f\"Adding condition from spaCy: {condition.model_dump(exclude_none=True)}\"\n                )\n                new_conditions.append(condition)\n\n        # 2. Extract from generic NLP entities (framework-agnostic)\n        generic_entities = self.nlp.get_entities()\n        if generic_entities:\n            for ent_dict in generic_entities:\n                # Skip if no linked code\n                code_value = ent_dict.get(code_attribute)\n                if code_value is None:\n                    logger.debug(\n                        f\"No {code_attribute} found for entity {ent_dict.get('text', 'unknown')}\"\n                    )\n                    continue\n\n                entity_text = ent_dict.get(\"text\", \"unknown\")\n\n                condition = create_condition(\n                    subject=patient_ref,\n                    code=code_value,\n                    display=entity_text,\n                    system=coding_system,\n                )\n                set_condition_category(condition, \"problem-list-item\")\n                logger.debug(\n                    f\"Adding condition from entities: {condition.model_dump(exclude_none=True)}\"\n                )\n                new_conditions.append(condition)\n\n        # Update problem list with combined conditions (replace to avoid duplication)\n        if new_conditions:\n            all_conditions = existing_conditions + new_conditions\n            self.fhir.add_resources(all_conditions, \"Condition\", replace=True)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        \"\"\"\n        Iterate through the document's tokens.\n\n        Returns:\n            Iterator[str]: Iterator over the document tokens.\n        \"\"\"\n        return iter(self._nlp._tokens)\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Return the length of the document's text.\n\n        Returns:\n            int: Character length of the document text.\n        \"\"\"\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate through the document's tokens.</p> RETURNS DESCRIPTION <code>Iterator[str]</code> <p>Iterator[str]: Iterator over the document tokens.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n    \"\"\"\n    Iterate through the document's tokens.\n\n    Returns:\n        Iterator[str]: Iterator over the document tokens.\n    \"\"\"\n    return iter(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the document's text.</p> RETURNS DESCRIPTION <code>int</code> <p>Character length of the document text.</p> <p> TYPE: <code>int</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Return the length of the document's text.\n\n    Returns:\n        int: Character length of the document text.\n    \"\"\"\n    return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization setup to process textual or FHIR data.</p> <ul> <li>If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.</li> <li>If input data is a list of FHIR resources, wraps them in a Bundle.</li> <li>For text input, sets .text field accordingly.</li> <li>Performs basic whitespace tokenization if necessary.</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization setup to process textual or FHIR data.\n\n    - If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.\n    - If input data is a list of FHIR resources, wraps them in a Bundle.\n    - For text input, sets .text field accordingly.\n    - Performs basic whitespace tokenization if necessary.\n    \"\"\"\n    super().__post_init__()\n\n    # Handle FHIR Bundle data\n    if isinstance(self.data, Bundle):\n        self._fhir._bundle = self.data\n\n        # Extract OperationOutcome resources (operation results/errors)\n        outcomes = extract_resources(self._fhir._bundle, \"OperationOutcome\")\n        if outcomes:\n            self._fhir._operation_outcomes = outcomes\n\n        # Extract Provenance resources (data lineage/origin)\n        provenances = extract_resources(self._fhir._bundle, \"Provenance\")\n        if provenances:\n            self._fhir._provenances = provenances\n\n        self.text = \"\"  # No text content for bundle-only documents\n    # Handle list of FHIR resources\n    elif (\n        isinstance(self.data, list)\n        and self.data\n        and isinstance(self.data[0], Resource)\n    ):\n        self._fhir._bundle = create_bundle()\n        for resource in self.data:\n            add_resource(self._fhir._bundle, resource)\n        self.text = \"\"  # No text content for resource-only documents\n    else:\n        # Handle text data\n        self.text = self.data if isinstance(self.data, str) else str(self.data)\n\n    if not self._nlp._tokens and self.text:\n        self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.update_problem_list_from_nlp","title":"<code>update_problem_list_from_nlp(patient_ref='Patient/123', coding_system='http://snomed.info/sct', code_attribute='cui')</code>","text":"<p>Populate or update the problem list using entities extracted via NLP.</p> <p>This method looks for entities with associated medical codes and creates FHIR Condition resources from them. It supports a two-step process: 1. NER: Extract entities from text (spaCy, HuggingFace, etc.) 2. Entity Linking: Add medical codes to those entities 3. Problem List Creation: Convert linked entities to FHIR conditions (this method)</p> <p>The method extracts from: 1. spaCy entities with extension attributes (e.g., ent._.cui) 2. Generic entities in the NLP annotations container (framework-agnostic)</p> <p>TODO: make this more generic and support other resource types</p> PARAMETER DESCRIPTION <code>patient_ref</code> <p>FHIR reference to the patient (default: \"Patient/123\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Patient/123'</code> </p> <code>coding_system</code> <p>Coding system URI for the conditions (default: SNOMED CT)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>code_attribute</code> <p>Name of the attribute containing the medical code (default: \"cui\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cui'</code> </p> Notes <ul> <li>Preserves any existing problem list Conditions.</li> <li>Supports framework-agnostic extraction (spaCy and dict entities).</li> <li>For spaCy, looks for entity extension attribute (e.g. ent._.cui).</li> <li>For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def update_problem_list_from_nlp(\n    self,\n    patient_ref: str = \"Patient/123\",\n    coding_system: str = \"http://snomed.info/sct\",\n    code_attribute: str = \"cui\",\n):\n    \"\"\"\n    Populate or update the problem list using entities extracted via NLP.\n\n    This method looks for entities with associated medical codes and creates FHIR Condition\n    resources from them. It supports a two-step process:\n    1. NER: Extract entities from text (spaCy, HuggingFace, etc.)\n    2. Entity Linking: Add medical codes to those entities\n    3. Problem List Creation: Convert linked entities to FHIR conditions (this method)\n\n    The method extracts from:\n    1. spaCy entities with extension attributes (e.g., ent._.cui)\n    2. Generic entities in the NLP annotations container (framework-agnostic)\n\n    TODO: make this more generic and support other resource types\n\n    Args:\n        patient_ref: FHIR reference to the patient (default: \"Patient/123\")\n        coding_system: Coding system URI for the conditions (default: SNOMED CT)\n        code_attribute: Name of the attribute containing the medical code (default: \"cui\")\n\n    Notes:\n        - Preserves any existing problem list Conditions.\n        - Supports framework-agnostic extraction (spaCy and dict entities).\n        - For spaCy, looks for entity extension attribute (e.g. ent._.cui).\n        - For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).\n    \"\"\"\n    # Start with existing conditions to preserve them\n    existing_conditions = self.fhir.problem_list.copy()\n    new_conditions = []\n\n    # 1. Extract from spaCy entities (if available)\n    if self.nlp._spacy_doc and self.nlp._spacy_doc.ents:\n        for ent in self.nlp._spacy_doc.ents:\n            if not Span.has_extension(code_attribute):\n                logger.debug(\n                    f\"Extension '{code_attribute}' not found for spaCy entity {ent.text}\"\n                )\n                continue\n\n            code_value = getattr(ent._, code_attribute, None)\n            if code_value is None:\n                logger.debug(\n                    f\"No {code_attribute} found for spaCy entity {ent.text}\"\n                )\n                continue\n\n            condition = create_condition(\n                subject=patient_ref,\n                code=code_value,\n                display=ent.text,\n                system=coding_system,\n            )\n            set_condition_category(condition, \"problem-list-item\")\n            logger.debug(\n                f\"Adding condition from spaCy: {condition.model_dump(exclude_none=True)}\"\n            )\n            new_conditions.append(condition)\n\n    # 2. Extract from generic NLP entities (framework-agnostic)\n    generic_entities = self.nlp.get_entities()\n    if generic_entities:\n        for ent_dict in generic_entities:\n            # Skip if no linked code\n            code_value = ent_dict.get(code_attribute)\n            if code_value is None:\n                logger.debug(\n                    f\"No {code_attribute} found for entity {ent_dict.get('text', 'unknown')}\"\n                )\n                continue\n\n            entity_text = ent_dict.get(\"text\", \"unknown\")\n\n            condition = create_condition(\n                subject=patient_ref,\n                code=code_value,\n                display=entity_text,\n                system=coding_system,\n            )\n            set_condition_category(condition, \"problem-list-item\")\n            logger.debug(\n                f\"Adding condition from entities: {condition.model_dump(exclude_none=True)}\"\n            )\n            new_conditions.append(condition)\n\n    # Update problem list with combined conditions (replace to avoid duplication)\n    if new_conditions:\n        all_conditions = existing_conditions + new_conditions\n        self.fhir.add_resources(all_conditions, \"Condition\", replace=True)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.word_count","title":"<code>word_count()</code>","text":"<p>Return the number of word tokens in the document.</p> RETURNS DESCRIPTION <code>int</code> <p>The count of tokenized words in the document.</p> <p> TYPE: <code>int</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def word_count(self) -&gt; int:\n    \"\"\"\n    Return the number of word tokens in the document.\n\n    Returns:\n        int: The count of tokenized words in the document.\n    \"\"\"\n    return len(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Tabular","title":"<code>Tabular</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[DataFrame]</code></p> <p>A container for tabular data, wrapping a pandas DataFrame.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The pandas DataFrame containing the tabular data.</p> <p> TYPE: <code>DataFrame</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Validates that the data is a pandas DataFrame.</p> <code>columns</code> <p>Property that returns a list of column names.</p> <code>index</code> <p>Property that returns the DataFrame's index.</p> <code>dtypes</code> <p>Property that returns a dictionary of column names and their data types.</p> <code>column_count</code> <p>Returns the number of columns in the DataFrame.</p> <code>row_count</code> <p>Returns the number of rows in the DataFrame.</p> <code>get_dtype</code> <p>str): Returns the data type of a specific column.</p> <code>__iter__</code> <p>Returns an iterator over the column names.</p> <code>__len__</code> <p>Returns the number of rows in the DataFrame.</p> <code>describe</code> <p>Returns a string description of the tabular data.</p> <code>remove_column</code> <p>str): Removes a column from the DataFrame.</p> <code>from_csv</code> <p>str, **kwargs): Class method to create a Tabular object from a CSV file.</p> <code>from_dict</code> <p>Dict[str, Any]): Class method to create a Tabular object from a dictionary.</p> <code>to_csv</code> <p>str, **kwargs): Saves the DataFrame to a CSV file.</p> Source code in <code>healthchain/io/containers/tabular.py</code> <pre><code>@dataclass\nclass Tabular(DataContainer[pd.DataFrame]):\n    \"\"\"\n    A container for tabular data, wrapping a pandas DataFrame.\n\n    Attributes:\n        data (pd.DataFrame): The pandas DataFrame containing the tabular data.\n\n    Methods:\n        __post_init__(): Validates that the data is a pandas DataFrame.\n        columns: Property that returns a list of column names.\n        index: Property that returns the DataFrame's index.\n        dtypes: Property that returns a dictionary of column names and their data types.\n        column_count(): Returns the number of columns in the DataFrame.\n        row_count(): Returns the number of rows in the DataFrame.\n        get_dtype(column: str): Returns the data type of a specific column.\n        __iter__(): Returns an iterator over the column names.\n        __len__(): Returns the number of rows in the DataFrame.\n        describe(): Returns a string description of the tabular data.\n        remove_column(name: str): Removes a column from the DataFrame.\n        from_csv(path: str, **kwargs): Class method to create a Tabular object from a CSV file.\n        from_dict(data: Dict[str, Any]): Class method to create a Tabular object from a dictionary.\n        to_csv(path: str, **kwargs): Saves the DataFrame to a CSV file.\n    \"\"\"\n\n    def __post_init__(self):\n        if not isinstance(self.data, pd.DataFrame):\n            raise TypeError(\"data must be a pandas DataFrame\")\n\n    @property\n    def columns(self) -&gt; List[str]:\n        return list(self.data.columns)\n\n    @property\n    def index(self) -&gt; pd.Index:\n        return self.data.index\n\n    @property\n    def dtypes(self) -&gt; Dict[str, str]:\n        return {col: str(dtype) for col, dtype in self.data.dtypes.items()}\n\n    def column_count(self) -&gt; int:\n        return len(self.columns)\n\n    def row_count(self) -&gt; int:\n        return len(self.data)\n\n    def get_dtype(self, column: str) -&gt; str:\n        return str(self.data[column].dtype)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.columns)\n\n    def __len__(self) -&gt; int:\n        return self.row_count()\n\n    def describe(self) -&gt; str:\n        return f\"Tabular data with {self.column_count()} columns and {self.row_count()} rows\"\n\n    def remove_column(self, name: str) -&gt; None:\n        self.data.drop(columns=[name], inplace=True)\n\n    @classmethod\n    def from_csv(cls, path: str, **kwargs) -&gt; \"Tabular\":\n        return cls(pd.read_csv(path, **kwargs))\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Tabular\":\n        df = pd.DataFrame(**data[\"data\"])\n        return cls(df)\n\n    def to_csv(self, path: str, **kwargs) -&gt; None:\n        self.data.to_csv(path, **kwargs)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.base","title":"<code>base</code>","text":""},{"location":"api/containers/#healthchain.io.containers.base.BaseDocument","title":"<code>BaseDocument</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[str]</code></p> <p>Base document container for raw text content.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass BaseDocument(DataContainer[str]):\n    \"\"\"Base document container for raw text content.\"\"\"\n\n    data: str\n    text: str = field(init=False)\n\n    def __post_init__(self):\n        self.text = self.data\n\n    def char_count(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.base.DataContainer","title":"<code>DataContainer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A generic container for data.</p> <p>This class represents a container for data with a specific type T.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The data stored in the container.</p> <p> TYPE: <code>T</code> </p> METHOD DESCRIPTION <code>to_dict</code> <p>Converts the container's data to a dictionary.</p> <code>to_json</code> <p>Converts the container's data to a JSON string.</p> <code>from_dict</code> <p>Dict[str, Any]) -&gt; \"DataContainer\": Creates a DataContainer instance from a dictionary.</p> <code>from_json</code> <p>str) -&gt; \"DataContainer\": Creates a DataContainer instance from a JSON string.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass DataContainer(Generic[T]):\n    \"\"\"\n    A generic container for data.\n\n    This class represents a container for data with a specific type T.\n\n    Attributes:\n        data (T): The data stored in the container.\n\n    Methods:\n        to_dict() -&gt; Dict[str, Any]:\n            Converts the container's data to a dictionary.\n\n        to_json() -&gt; str:\n            Converts the container's data to a JSON string.\n\n        from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a dictionary.\n\n        from_json(cls, json_str: str) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a JSON string.\n    \"\"\"\n\n    data: T\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    def to_json(self) -&gt; str:\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n        return cls(**data)\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"DataContainer\":\n        return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document","title":"<code>document</code>","text":""},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations","title":"<code>CdsAnnotations</code>  <code>dataclass</code>","text":"<p>Container for Clinical Decision Support (CDS) results.</p> <p>This class stores and manages outputs from clinical decision support systems, including CDS Hooks cards and suggested clinical actions. The cards contain recommendations, warnings, and other decision support content that can be displayed to clinicians. Actions represent specific clinical tasks or interventions that are suggested based on the analysis.</p> ATTRIBUTE DESCRIPTION <code>_cards</code> <p>CDS Hooks cards containing clinical recommendations, warnings, or other decision support content.</p> <p> TYPE: <code>Optional[List[Card]]</code> </p> <code>_actions</code> <p>Suggested clinical actions that could be taken based on the CDS analysis.</p> <p> TYPE: <code>Optional[List[Action]]</code> </p> Example <p>cds = CdsAnnotations() cds.cards = [Card(summary=\"Consider aspirin\")] cds.actions = [Action(type=\"create\", description=\"Order aspirin\")]</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass CdsAnnotations:\n    \"\"\"\n    Container for Clinical Decision Support (CDS) results.\n\n    This class stores and manages outputs from clinical decision support systems,\n    including CDS Hooks cards and suggested clinical actions. The cards contain\n    recommendations, warnings, and other decision support content that can be\n    displayed to clinicians. Actions represent specific clinical tasks or\n    interventions that are suggested based on the analysis.\n\n    Attributes:\n        _cards (Optional[List[Card]]): CDS Hooks cards containing clinical\n            recommendations, warnings, or other decision support content.\n        _actions (Optional[List[Action]]): Suggested clinical actions that\n            could be taken based on the CDS analysis.\n\n    Example:\n        &gt;&gt;&gt; cds = CdsAnnotations()\n        &gt;&gt;&gt; cds.cards = [Card(summary=\"Consider aspirin\")]\n        &gt;&gt;&gt; cds.actions = [Action(type=\"create\", description=\"Order aspirin\")]\n    \"\"\"\n\n    _cards: Optional[List[Card]] = None\n    _actions: Optional[List[Action]] = None\n\n    @property\n    def cards(self) -&gt; Optional[List[Card]]:\n        \"\"\"Get the current list of CDS Hooks cards.\"\"\"\n        return self._cards\n\n    @cards.setter\n    def cards(self, cards: Union[List[Card], List[Dict[str, Any]]]) -&gt; None:\n        \"\"\"\n        Set CDS Hooks cards, converting from dictionaries if needed.\n\n        Args:\n            cards: List of Card objects or dictionaries that can be converted to Cards.\n\n        Raises:\n            ValueError: If cards list is empty or has invalid format.\n            TypeError: If cards are neither Card objects nor dictionaries.\n        \"\"\"\n        if not cards:\n            raise ValueError(\"Cards must be provided as a list!\")\n\n        try:\n            if isinstance(cards[0], dict):\n                self._cards = [Card(**card) for card in cards]\n            elif isinstance(cards[0], Card):\n                self._cards = cards\n            else:\n                raise TypeError(\"Cards must be either Card objects or dictionaries\")\n        except (IndexError, KeyError) as e:\n            raise ValueError(\"Invalid card format\") from e\n\n    @property\n    def actions(self) -&gt; Optional[List[Action]]:\n        \"\"\"Get the current list of suggested clinical actions.\"\"\"\n        return self._actions\n\n    @actions.setter\n    def actions(self, actions: Union[List[Action], List[Dict[str, Any]]]) -&gt; None:\n        \"\"\"\n        Set suggested clinical actions, converting from dictionaries if needed.\n\n        Args:\n            actions: List of Action objects or dictionaries that can be converted to Actions.\n\n        Raises:\n            ValueError: If actions list is empty or has invalid format.\n            TypeError: If actions are neither Action objects nor dictionaries.\n        \"\"\"\n        if not actions:\n            raise ValueError(\"Actions must be provided as a list!\")\n\n        try:\n            if isinstance(actions[0], dict):\n                self._actions = [Action(**action) for action in actions]\n            elif isinstance(actions[0], Action):\n                self._actions = actions\n            else:\n                raise TypeError(\"Actions must be either Action objects or dictionaries\")\n        except (IndexError, KeyError) as e:\n            raise ValueError(\"Invalid action format\") from e\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations.actions","title":"<code>actions</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current list of suggested clinical actions.</p>"},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations.cards","title":"<code>cards</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current list of CDS Hooks cards.</p>"},{"location":"api/containers/#healthchain.io.containers.document.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseDocument</code></p> <p>Main document container for processing textual and clinical data in HealthChain.</p> <p>The Document class is the primary structure used throughout annotation and analytics pipelines, accumulating transformations, extractions, and results from each stage. It seamlessly integrates raw text, NLP annotations, FHIR resources, clinical decision support (CDS) results, and ML model outputs in one object.</p> Features <ul> <li>Accepts text, FHIR Bundles/resources, or lists of FHIR resources as input.</li> <li>Provides basic tokenization and supports integration with NLP models (spaCy, transformers).</li> <li>Stores and manipulates clinical FHIR data via the .fhir property (access to bundles, problem lists, meds, allergies, etc.).</li> <li>Encapsulates CDS Hooks-style decision support cards and suggested actions via the .cds property.</li> <li>Stores outputs from external ML/LLM models: HuggingFace, LangChain, etc.</li> </ul> ATTRIBUTE DESCRIPTION <code>nlp</code> <p>NLP output (tokens, entities, embeddings, spaCy doc)</p> <p> TYPE: <code>NlpAnnotations</code> </p> <code>fhir</code> <p>FHIR resources and context (problem list, medication, allergy, etc.)</p> <p> TYPE: <code>FhirData</code> </p> <code>cds</code> <p>Clinical decision support (cards and actions)</p> <p> TYPE: <code>CdsAnnotations</code> </p> <code>models</code> <p>Results from ML/LLM models (HuggingFace, LangChain, etc.)</p> <p> TYPE: <code>ModelOutputs</code> </p> <code>text</code> <p>The text content of the document (if available).</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>The original input supplied (raw text, Bundle, resource, or list of resources)</p> <p> TYPE: <code>str</code> </p> Usage example <p>doc = Document(data=\"Patient has hypertension\") doc.nlp._tokens ['Patient', 'has', 'hypertension'] doc.fhir.problem_list = [Condition(...)] doc.cds.cards = [Card(...)] doc.models.huggingface_results = ... for token in doc: ...     print(token)</p> Inherits from <p>BaseDocument</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass Document(BaseDocument):\n    \"\"\"\n    Main document container for processing textual and clinical data in HealthChain.\n\n    The Document class is the primary structure used throughout annotation and analytics\n    pipelines, accumulating transformations, extractions, and results from each stage. It\n    seamlessly integrates raw text, NLP annotations, FHIR resources, clinical decision\n    support (CDS) results, and ML model outputs in one object.\n\n    Features:\n        - Accepts text, FHIR Bundles/resources, or lists of FHIR resources as input.\n        - Provides basic tokenization and supports integration with NLP models (spaCy, transformers).\n        - Stores and manipulates clinical FHIR data via the .fhir property (access to bundles, problem lists, meds, allergies, etc.).\n        - Encapsulates CDS Hooks-style decision support cards and suggested actions via the .cds property.\n        - Stores outputs from external ML/LLM models: HuggingFace, LangChain, etc.\n\n    Attributes:\n        nlp (NlpAnnotations): NLP output (tokens, entities, embeddings, spaCy doc)\n        fhir (FhirData): FHIR resources and context (problem list, medication, allergy, etc.)\n        cds (CdsAnnotations): Clinical decision support (cards and actions)\n        models (ModelOutputs): Results from ML/LLM models (HuggingFace, LangChain, etc.)\n        text (str): The text content of the document (if available).\n        data: The original input supplied (raw text, Bundle, resource, or list of resources)\n\n    Usage example:\n        &gt;&gt;&gt; doc = Document(data=\"Patient has hypertension\")\n        &gt;&gt;&gt; doc.nlp._tokens\n        ['Patient', 'has', 'hypertension']\n        &gt;&gt;&gt; doc.fhir.problem_list = [Condition(...)]\n        &gt;&gt;&gt; doc.cds.cards = [Card(...)]\n        &gt;&gt;&gt; doc.models.huggingface_results = ...\n        &gt;&gt;&gt; for token in doc:\n        ...     print(token)\n\n    Inherits from:\n        BaseDocument\n    \"\"\"\n\n    _nlp: NlpAnnotations = field(default_factory=NlpAnnotations)\n    _fhir: FhirData = field(default_factory=FhirData)\n    _cds: CdsAnnotations = field(default_factory=CdsAnnotations)\n    _models: ModelOutputs = field(default_factory=ModelOutputs)\n\n    @property\n    def nlp(self) -&gt; NlpAnnotations:\n        return self._nlp\n\n    @property\n    def fhir(self) -&gt; FhirData:\n        return self._fhir\n\n    @property\n    def cds(self) -&gt; CdsAnnotations:\n        return self._cds\n\n    @property\n    def models(self) -&gt; ModelOutputs:\n        return self._models\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization setup to process textual or FHIR data.\n\n        - If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.\n        - If input data is a list of FHIR resources, wraps them in a Bundle.\n        - For text input, sets .text field accordingly.\n        - Performs basic whitespace tokenization if necessary.\n        \"\"\"\n        super().__post_init__()\n\n        # Handle FHIR Bundle data\n        if isinstance(self.data, Bundle):\n            self._fhir._bundle = self.data\n\n            # Extract OperationOutcome resources (operation results/errors)\n            outcomes = extract_resources(self._fhir._bundle, \"OperationOutcome\")\n            if outcomes:\n                self._fhir._operation_outcomes = outcomes\n\n            # Extract Provenance resources (data lineage/origin)\n            provenances = extract_resources(self._fhir._bundle, \"Provenance\")\n            if provenances:\n                self._fhir._provenances = provenances\n\n            self.text = \"\"  # No text content for bundle-only documents\n        # Handle list of FHIR resources\n        elif (\n            isinstance(self.data, list)\n            and self.data\n            and isinstance(self.data[0], Resource)\n        ):\n            self._fhir._bundle = create_bundle()\n            for resource in self.data:\n                add_resource(self._fhir._bundle, resource)\n            self.text = \"\"  # No text content for resource-only documents\n        else:\n            # Handle text data\n            self.text = self.data if isinstance(self.data, str) else str(self.data)\n\n        if not self._nlp._tokens and self.text:\n            self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n\n    def word_count(self) -&gt; int:\n        \"\"\"\n        Return the number of word tokens in the document.\n\n        Returns:\n            int: The count of tokenized words in the document.\n        \"\"\"\n        return len(self._nlp._tokens)\n\n    def update_problem_list_from_nlp(\n        self,\n        patient_ref: str = \"Patient/123\",\n        coding_system: str = \"http://snomed.info/sct\",\n        code_attribute: str = \"cui\",\n    ):\n        \"\"\"\n        Populate or update the problem list using entities extracted via NLP.\n\n        This method looks for entities with associated medical codes and creates FHIR Condition\n        resources from them. It supports a two-step process:\n        1. NER: Extract entities from text (spaCy, HuggingFace, etc.)\n        2. Entity Linking: Add medical codes to those entities\n        3. Problem List Creation: Convert linked entities to FHIR conditions (this method)\n\n        The method extracts from:\n        1. spaCy entities with extension attributes (e.g., ent._.cui)\n        2. Generic entities in the NLP annotations container (framework-agnostic)\n\n        TODO: make this more generic and support other resource types\n\n        Args:\n            patient_ref: FHIR reference to the patient (default: \"Patient/123\")\n            coding_system: Coding system URI for the conditions (default: SNOMED CT)\n            code_attribute: Name of the attribute containing the medical code (default: \"cui\")\n\n        Notes:\n            - Preserves any existing problem list Conditions.\n            - Supports framework-agnostic extraction (spaCy and dict entities).\n            - For spaCy, looks for entity extension attribute (e.g. ent._.cui).\n            - For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).\n        \"\"\"\n        # Start with existing conditions to preserve them\n        existing_conditions = self.fhir.problem_list.copy()\n        new_conditions = []\n\n        # 1. Extract from spaCy entities (if available)\n        if self.nlp._spacy_doc and self.nlp._spacy_doc.ents:\n            for ent in self.nlp._spacy_doc.ents:\n                if not Span.has_extension(code_attribute):\n                    logger.debug(\n                        f\"Extension '{code_attribute}' not found for spaCy entity {ent.text}\"\n                    )\n                    continue\n\n                code_value = getattr(ent._, code_attribute, None)\n                if code_value is None:\n                    logger.debug(\n                        f\"No {code_attribute} found for spaCy entity {ent.text}\"\n                    )\n                    continue\n\n                condition = create_condition(\n                    subject=patient_ref,\n                    code=code_value,\n                    display=ent.text,\n                    system=coding_system,\n                )\n                set_condition_category(condition, \"problem-list-item\")\n                logger.debug(\n                    f\"Adding condition from spaCy: {condition.model_dump(exclude_none=True)}\"\n                )\n                new_conditions.append(condition)\n\n        # 2. Extract from generic NLP entities (framework-agnostic)\n        generic_entities = self.nlp.get_entities()\n        if generic_entities:\n            for ent_dict in generic_entities:\n                # Skip if no linked code\n                code_value = ent_dict.get(code_attribute)\n                if code_value is None:\n                    logger.debug(\n                        f\"No {code_attribute} found for entity {ent_dict.get('text', 'unknown')}\"\n                    )\n                    continue\n\n                entity_text = ent_dict.get(\"text\", \"unknown\")\n\n                condition = create_condition(\n                    subject=patient_ref,\n                    code=code_value,\n                    display=entity_text,\n                    system=coding_system,\n                )\n                set_condition_category(condition, \"problem-list-item\")\n                logger.debug(\n                    f\"Adding condition from entities: {condition.model_dump(exclude_none=True)}\"\n                )\n                new_conditions.append(condition)\n\n        # Update problem list with combined conditions (replace to avoid duplication)\n        if new_conditions:\n            all_conditions = existing_conditions + new_conditions\n            self.fhir.add_resources(all_conditions, \"Condition\", replace=True)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        \"\"\"\n        Iterate through the document's tokens.\n\n        Returns:\n            Iterator[str]: Iterator over the document tokens.\n        \"\"\"\n        return iter(self._nlp._tokens)\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Return the length of the document's text.\n\n        Returns:\n            int: Character length of the document text.\n        \"\"\"\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate through the document's tokens.</p> RETURNS DESCRIPTION <code>Iterator[str]</code> <p>Iterator[str]: Iterator over the document tokens.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n    \"\"\"\n    Iterate through the document's tokens.\n\n    Returns:\n        Iterator[str]: Iterator over the document tokens.\n    \"\"\"\n    return iter(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the document's text.</p> RETURNS DESCRIPTION <code>int</code> <p>Character length of the document text.</p> <p> TYPE: <code>int</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Return the length of the document's text.\n\n    Returns:\n        int: Character length of the document text.\n    \"\"\"\n    return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization setup to process textual or FHIR data.</p> <ul> <li>If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.</li> <li>If input data is a list of FHIR resources, wraps them in a Bundle.</li> <li>For text input, sets .text field accordingly.</li> <li>Performs basic whitespace tokenization if necessary.</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization setup to process textual or FHIR data.\n\n    - If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.\n    - If input data is a list of FHIR resources, wraps them in a Bundle.\n    - For text input, sets .text field accordingly.\n    - Performs basic whitespace tokenization if necessary.\n    \"\"\"\n    super().__post_init__()\n\n    # Handle FHIR Bundle data\n    if isinstance(self.data, Bundle):\n        self._fhir._bundle = self.data\n\n        # Extract OperationOutcome resources (operation results/errors)\n        outcomes = extract_resources(self._fhir._bundle, \"OperationOutcome\")\n        if outcomes:\n            self._fhir._operation_outcomes = outcomes\n\n        # Extract Provenance resources (data lineage/origin)\n        provenances = extract_resources(self._fhir._bundle, \"Provenance\")\n        if provenances:\n            self._fhir._provenances = provenances\n\n        self.text = \"\"  # No text content for bundle-only documents\n    # Handle list of FHIR resources\n    elif (\n        isinstance(self.data, list)\n        and self.data\n        and isinstance(self.data[0], Resource)\n    ):\n        self._fhir._bundle = create_bundle()\n        for resource in self.data:\n            add_resource(self._fhir._bundle, resource)\n        self.text = \"\"  # No text content for resource-only documents\n    else:\n        # Handle text data\n        self.text = self.data if isinstance(self.data, str) else str(self.data)\n\n    if not self._nlp._tokens and self.text:\n        self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.update_problem_list_from_nlp","title":"<code>update_problem_list_from_nlp(patient_ref='Patient/123', coding_system='http://snomed.info/sct', code_attribute='cui')</code>","text":"<p>Populate or update the problem list using entities extracted via NLP.</p> <p>This method looks for entities with associated medical codes and creates FHIR Condition resources from them. It supports a two-step process: 1. NER: Extract entities from text (spaCy, HuggingFace, etc.) 2. Entity Linking: Add medical codes to those entities 3. Problem List Creation: Convert linked entities to FHIR conditions (this method)</p> <p>The method extracts from: 1. spaCy entities with extension attributes (e.g., ent._.cui) 2. Generic entities in the NLP annotations container (framework-agnostic)</p> <p>TODO: make this more generic and support other resource types</p> PARAMETER DESCRIPTION <code>patient_ref</code> <p>FHIR reference to the patient (default: \"Patient/123\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Patient/123'</code> </p> <code>coding_system</code> <p>Coding system URI for the conditions (default: SNOMED CT)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>code_attribute</code> <p>Name of the attribute containing the medical code (default: \"cui\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cui'</code> </p> Notes <ul> <li>Preserves any existing problem list Conditions.</li> <li>Supports framework-agnostic extraction (spaCy and dict entities).</li> <li>For spaCy, looks for entity extension attribute (e.g. ent._.cui).</li> <li>For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def update_problem_list_from_nlp(\n    self,\n    patient_ref: str = \"Patient/123\",\n    coding_system: str = \"http://snomed.info/sct\",\n    code_attribute: str = \"cui\",\n):\n    \"\"\"\n    Populate or update the problem list using entities extracted via NLP.\n\n    This method looks for entities with associated medical codes and creates FHIR Condition\n    resources from them. It supports a two-step process:\n    1. NER: Extract entities from text (spaCy, HuggingFace, etc.)\n    2. Entity Linking: Add medical codes to those entities\n    3. Problem List Creation: Convert linked entities to FHIR conditions (this method)\n\n    The method extracts from:\n    1. spaCy entities with extension attributes (e.g., ent._.cui)\n    2. Generic entities in the NLP annotations container (framework-agnostic)\n\n    TODO: make this more generic and support other resource types\n\n    Args:\n        patient_ref: FHIR reference to the patient (default: \"Patient/123\")\n        coding_system: Coding system URI for the conditions (default: SNOMED CT)\n        code_attribute: Name of the attribute containing the medical code (default: \"cui\")\n\n    Notes:\n        - Preserves any existing problem list Conditions.\n        - Supports framework-agnostic extraction (spaCy and dict entities).\n        - For spaCy, looks for entity extension attribute (e.g. ent._.cui).\n        - For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).\n    \"\"\"\n    # Start with existing conditions to preserve them\n    existing_conditions = self.fhir.problem_list.copy()\n    new_conditions = []\n\n    # 1. Extract from spaCy entities (if available)\n    if self.nlp._spacy_doc and self.nlp._spacy_doc.ents:\n        for ent in self.nlp._spacy_doc.ents:\n            if not Span.has_extension(code_attribute):\n                logger.debug(\n                    f\"Extension '{code_attribute}' not found for spaCy entity {ent.text}\"\n                )\n                continue\n\n            code_value = getattr(ent._, code_attribute, None)\n            if code_value is None:\n                logger.debug(\n                    f\"No {code_attribute} found for spaCy entity {ent.text}\"\n                )\n                continue\n\n            condition = create_condition(\n                subject=patient_ref,\n                code=code_value,\n                display=ent.text,\n                system=coding_system,\n            )\n            set_condition_category(condition, \"problem-list-item\")\n            logger.debug(\n                f\"Adding condition from spaCy: {condition.model_dump(exclude_none=True)}\"\n            )\n            new_conditions.append(condition)\n\n    # 2. Extract from generic NLP entities (framework-agnostic)\n    generic_entities = self.nlp.get_entities()\n    if generic_entities:\n        for ent_dict in generic_entities:\n            # Skip if no linked code\n            code_value = ent_dict.get(code_attribute)\n            if code_value is None:\n                logger.debug(\n                    f\"No {code_attribute} found for entity {ent_dict.get('text', 'unknown')}\"\n                )\n                continue\n\n            entity_text = ent_dict.get(\"text\", \"unknown\")\n\n            condition = create_condition(\n                subject=patient_ref,\n                code=code_value,\n                display=entity_text,\n                system=coding_system,\n            )\n            set_condition_category(condition, \"problem-list-item\")\n            logger.debug(\n                f\"Adding condition from entities: {condition.model_dump(exclude_none=True)}\"\n            )\n            new_conditions.append(condition)\n\n    # Update problem list with combined conditions (replace to avoid duplication)\n    if new_conditions:\n        all_conditions = existing_conditions + new_conditions\n        self.fhir.add_resources(all_conditions, \"Condition\", replace=True)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.word_count","title":"<code>word_count()</code>","text":"<p>Return the number of word tokens in the document.</p> RETURNS DESCRIPTION <code>int</code> <p>The count of tokenized words in the document.</p> <p> TYPE: <code>int</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def word_count(self) -&gt; int:\n    \"\"\"\n    Return the number of word tokens in the document.\n\n    Returns:\n        int: The count of tokenized words in the document.\n    \"\"\"\n    return len(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData","title":"<code>FhirData</code>  <code>dataclass</code>","text":"<p>Container for FHIR resource data and its context.</p> <p>Stores and manages clinical data in FHIR format. Access document references within resources easily through convenience functions.</p> <p>Also allows you to set common continuity of care lists, such as a problem list, medication list, and allergy list. These collections are accessible as properties of the class instance.</p> <p>TODO: make problem, meds, allergy lists configurable</p> Properties <p>bundle: The FHIR bundle containing resources prefetch_resources: Dictionary of CDS Hooks prefetch resources problem_list: List of Condition resources medication_list: List of MedicationStatement resources allergy_list: List of AllergyIntolerance resources</p> Example <p>fhir = FhirData()</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass FhirData:\n    \"\"\"\n    Container for FHIR resource data and its context.\n\n    Stores and manages clinical data in FHIR format.\n    Access document references within resources easily through convenience functions.\n\n    Also allows you to set common continuity of care lists,\n    such as a problem list, medication list, and allergy list.\n    These collections are accessible as properties of the class instance.\n\n    TODO: make problem, meds, allergy lists configurable\n\n    Properties:\n        bundle: The FHIR bundle containing resources\n        prefetch_resources: Dictionary of CDS Hooks prefetch resources\n        problem_list: List of Condition resources\n        medication_list: List of MedicationStatement resources\n        allergy_list: List of AllergyIntolerance resources\n\n    Example:\n        &gt;&gt;&gt; fhir = FhirData()\n        &gt;&gt;&gt; # Add prefetch resources from CDS request\n        &gt;&gt;&gt; fhir.prefetch_resources = {\"patient\": patient_resource}\n        &gt;&gt;&gt; # Add document to bundle\n        &gt;&gt;&gt; doc_id = fhir.add_document_reference(document)\n        &gt;&gt;&gt; # Get document with relationships\n        &gt;&gt;&gt; doc_family = fhir.get_document_reference_family(doc_id)\n        &gt;&gt;&gt; # Access clinical lists\n        &gt;&gt;&gt; conditions = fhir.problem_list\n    \"\"\"\n\n    _prefetch_resources: Optional[Dict[str, Resource]] = None\n    _bundle: Optional[Bundle] = None\n    _operation_outcomes: List[OperationOutcome] = field(default_factory=list)\n    _provenances: List[Provenance] = field(default_factory=list)\n\n    @property\n    def bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"Returns the FHIR Bundle if it exists.\"\"\"\n        return self._bundle\n\n    @bundle.setter\n    def bundle(self, bundle: Bundle):\n        \"\"\"Sets the FHIR Bundle.\n        The bundle is a collection of FHIR resources.\n        See: https://www.hl7.org/fhir/bundle.html\n        \"\"\"\n        self._bundle = bundle\n\n    @property\n    def prefetch_resources(self) -&gt; Optional[Dict[str, Resource]]:\n        \"\"\"Returns the prefetch FHIR resources.\"\"\"\n        return self._prefetch_resources\n\n    @prefetch_resources.setter\n    def prefetch_resources(self, resources: Dict[str, Resource]):\n        \"\"\"Sets the prefetch FHIR resources from CDS service requests.\"\"\"\n        self._prefetch_resources = resources\n\n    @property\n    def operation_outcomes(self) -&gt; List[OperationOutcome]:\n        \"\"\"Get extracted OperationOutcome resources separated from the bundle.\"\"\"\n        return self._operation_outcomes\n\n    @operation_outcomes.setter\n    def operation_outcomes(self, outcomes: List[OperationOutcome]) -&gt; None:\n        self._operation_outcomes = outcomes or []\n\n    @property\n    def provenances(self) -&gt; List[Provenance]:\n        \"\"\"Get extracted Provenance resources separated from the bundle.\"\"\"\n        return self._provenances\n\n    @provenances.setter\n    def provenances(self, provenances: List[Provenance]) -&gt; None:\n        self._provenances = provenances or []\n\n    @property\n    def patient(self) -&gt; Optional[Patient]:\n        \"\"\"Get the first Patient resource from the bundle (convenience accessor).\n\n        Returns None if no Patient resources are present in the bundle.\n        For bundles with multiple patients, use the patients property instead.\n        \"\"\"\n        patients = self.get_resources(\"Patient\")\n        return patients[0] if patients else None\n\n    @property\n    def patients(self) -&gt; List[Patient]:\n        \"\"\"Get all Patient resources from the bundle.\n\n        Most bundles contain a single patient, but some queries (e.g., family history,\n        population queries) may return multiple patients. This property provides access\n        to all Patient resources without removing them from the bundle.\n        \"\"\"\n        return self.get_resources(\"Patient\")\n\n    @property\n    def problem_list(self) -&gt; List[Condition]:\n        \"\"\"Get problem list from the bundle.\n        Problem list items are stored as Condition resources in the bundle.\n        See: https://www.hl7.org/fhir/condition.html\n        \"\"\"\n        return self.get_resources(\"Condition\")\n\n    @problem_list.setter\n    def problem_list(self, conditions: List[Condition]) -&gt; None:\n        # TODO: should make this behaviour more explicit whether it's adding or replacing\n        \"\"\"Set problem list in the bundle.\"\"\"\n        self.add_resources(conditions, \"Condition\")\n\n    @property\n    def medication_list(self) -&gt; List[MedicationStatement]:\n        \"\"\"Get medication list from the bundle.\"\"\"\n        return self.get_resources(\"MedicationStatement\")\n\n    @medication_list.setter\n    def medication_list(self, medications: List[MedicationStatement]) -&gt; None:\n        \"\"\"Set medication list in the bundle.\n        Medication statements are stored as MedicationStatement resources in the bundle.\n        See: https://www.hl7.org/fhir/medicationstatement.html\n        \"\"\"\n        self.add_resources(medications, \"MedicationStatement\")\n\n    @property\n    def allergy_list(self) -&gt; List[AllergyIntolerance]:\n        \"\"\"Get allergy list from the bundle.\"\"\"\n        return self.get_resources(\"AllergyIntolerance\")\n\n    @allergy_list.setter\n    def allergy_list(self, allergies: List[AllergyIntolerance]) -&gt; None:\n        \"\"\"Set allergy list in the bundle.\n        Allergy intolerances are stored as AllergyIntolerance resources in the bundle.\n        See: https://www.hl7.org/fhir/allergyintolerance.html\n        \"\"\"\n        self.add_resources(allergies, \"AllergyIntolerance\")\n\n    def get_prefetch_resources(self, key: str) -&gt; List[Any]:\n        \"\"\"Get resources of a specific type from the prefetch bundle.\"\"\"\n        if not self._prefetch_resources:\n            return []\n        return self._prefetch_resources.get(key, [])\n\n    def get_resources(self, resource_type: str) -&gt; List[Any]:\n        \"\"\"Get resources of a specific type from the working bundle.\"\"\"\n        if not self._bundle:\n            return []\n        return get_resources(self._bundle, resource_type)\n\n    def add_resources(\n        self, resources: List[Any], resource_type: str, replace: bool = False\n    ):\n        \"\"\"Add resources to the working bundle.\"\"\"\n        if not self._bundle:\n            self._bundle = create_bundle()\n        set_resources(self._bundle, resources, resource_type, replace=replace)\n\n    def add_document_reference(\n        self,\n        document: DocumentReference,\n        parent_id: Optional[str] = None,\n        relationship_type: Optional[str] = \"transforms\",\n    ) -&gt; str:\n        \"\"\"\n        Adds a DocumentReference resource to the FHIR bundle and establishes\n        relationships between documents if a parent_id is provided. The relationship is\n        tracked using the FHIR relatesTo element with a specified relationship type.\n        See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n        Args:\n            document: The DocumentReference to add to the bundle\n            parent_id: Optional ID of the parent document. If provided, establishes a\n                relationship between this document and its parent.\n            relationship_type: The type of relationship to establish with the parent\n                document. Defaults to \"transforms\". This is used in the FHIR relatesTo\n                element's code. See: http://hl7.org/fhir/valueset-document-relationship-type\n\n        Returns:\n            str: The ID of the added document. If the document had no ID, a new UUID-based\n                ID is generated.\n        \"\"\"\n        # Generate a consistent ID if not present\n        if not document.id:\n            document.id = f\"doc-{uuid4()}\"\n\n        # Add relationship metadata if there's a parent\n        if parent_id:\n            if not hasattr(document, \"relatesTo\") or not document.relatesTo:\n                document.relatesTo = []\n            document.relatesTo.append(\n                DocumentReferenceRelatesTo(\n                    target=Reference(reference=f\"DocumentReference/{parent_id}\"),\n                    code=create_single_codeable_concept(\n                        code=relationship_type,\n                        display=relationship_type.capitalize(),\n                        system=\"http://hl7.org/fhir/ValueSet/document-relationship-type\",\n                    ),\n                )\n            )\n\n        self.add_resources([document], \"DocumentReference\", replace=False)\n\n        return document.id\n\n    def get_document_references_readable(\n        self, include_data: bool = True, include_relationships: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get DocumentReferences resources with their content and optional relationship data\n        in a human-readable dictionary format.\n\n        Args:\n            include_data: If True, decode and include the document data (default: True)\n            include_relationships: If True, include related document information (default: True)\n\n        Returns:\n            List of documents with metadata and optionally their content and relationships\n        \"\"\"\n        documents = []\n        for doc in self.get_resources(\"DocumentReference\"):\n            doc_data = {\n                \"id\": doc.id,\n                \"description\": doc.description,\n                \"status\": doc.status,\n            }\n\n            attachments = read_content_attachment(doc, include_data=include_data)\n            if attachments:\n                doc_data[\"attachments\"] = []\n                for attachment in attachments:\n                    if include_data:\n                        doc_data[\"attachments\"].append(\n                            {\n                                \"data\": attachment.get(\"data\"),\n                                \"metadata\": attachment.get(\"metadata\"),\n                            }\n                        )\n                    else:\n                        doc_data[\"attachments\"].append(\n                            {\"metadata\": attachment.get(\"metadata\")}\n                        )\n\n            if include_relationships:\n                family = self.get_document_reference_family(doc.id)\n                doc_data[\"relationships\"] = {\n                    \"parents\": [\n                        {\"id\": p.id, \"description\": p.description}\n                        for p in family[\"parents\"]\n                    ],\n                    \"children\": [\n                        {\"id\": c.id, \"description\": c.description}\n                        for c in family[\"children\"]\n                    ],\n                    \"siblings\": [\n                        {\"id\": s.id, \"description\": s.description}\n                        for s in family[\"siblings\"]\n                    ],\n                }\n\n            documents.append(doc_data)\n\n        return documents\n\n    def get_document_reference_family(self, document_id: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get a DocumentReference resource and all its related resources\n        based on the relatesTo element in the FHIR standard.\n        See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n        Args:\n            document_id: ID of the DocumentReference resource to find relationships for\n\n        Returns:\n            Dict containing:\n                'document': The requested DocumentReference resource\n                'parents': List of parent DocumentReference resources\n                'children': List of child DocumentReference resources\n                'siblings': List of DocumentReference resources sharing the same parent\n        \"\"\"\n        documents = self.get_resources(\"DocumentReference\")\n        family = {\"document\": None, \"parents\": [], \"children\": [], \"siblings\": []}\n\n        # Find the requested document\n        target_doc = next((doc for doc in documents if doc.id == document_id), None)\n        if not target_doc:\n            return family\n\n        family[\"document\"] = target_doc\n\n        # Find direct relationships\n        if hasattr(target_doc, \"relatesTo\") and target_doc.relatesTo:\n            # Find parents from target's relationships\n            for relation in target_doc.relatesTo:\n                parent_ref = relation.target.reference\n                parent_id = parent_ref.split(\"/\")[-1]\n                parent = next((doc for doc in documents if doc.id == parent_id), None)\n                if parent:\n                    family[\"parents\"].append(parent)\n\n        # Find children and siblings\n        for doc in documents:\n            if not hasattr(doc, \"relatesTo\") or not doc.relatesTo:\n                continue\n\n            for relation in doc.relatesTo:\n                target_ref = relation.target.reference\n                related_id = target_ref.split(\"/\")[-1]\n\n                # Check if this doc is a child of our target\n                if related_id == document_id:\n                    family[\"children\"].append(doc)\n\n                # For siblings, check if they share the same parent\n                elif family[\"parents\"] and related_id == family[\"parents\"][0].id:\n                    if doc.id != document_id:  # Don't include self as sibling\n                        family[\"siblings\"].append(doc)\n\n        return family\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--add-prefetch-resources-from-cds-request","title":"Add prefetch resources from CDS request","text":"<p>fhir.prefetch_resources = {\"patient\": patient_resource}</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--add-document-to-bundle","title":"Add document to bundle","text":"<p>doc_id = fhir.add_document_reference(document)</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--get-document-with-relationships","title":"Get document with relationships","text":"<p>doc_family = fhir.get_document_reference_family(doc_id)</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--access-clinical-lists","title":"Access clinical lists","text":"<p>conditions = fhir.problem_list</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.allergy_list","title":"<code>allergy_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get allergy list from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.bundle","title":"<code>bundle</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the FHIR Bundle if it exists.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.medication_list","title":"<code>medication_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get medication list from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.operation_outcomes","title":"<code>operation_outcomes</code>  <code>property</code> <code>writable</code>","text":"<p>Get extracted OperationOutcome resources separated from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.patient","title":"<code>patient</code>  <code>property</code>","text":"<p>Get the first Patient resource from the bundle (convenience accessor).</p> <p>Returns None if no Patient resources are present in the bundle. For bundles with multiple patients, use the patients property instead.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.patients","title":"<code>patients</code>  <code>property</code>","text":"<p>Get all Patient resources from the bundle.</p> <p>Most bundles contain a single patient, but some queries (e.g., family history, population queries) may return multiple patients. This property provides access to all Patient resources without removing them from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.prefetch_resources","title":"<code>prefetch_resources</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the prefetch FHIR resources.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.problem_list","title":"<code>problem_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get problem list from the bundle. Problem list items are stored as Condition resources in the bundle. See: https://www.hl7.org/fhir/condition.html</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.provenances","title":"<code>provenances</code>  <code>property</code> <code>writable</code>","text":"<p>Get extracted Provenance resources separated from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.add_document_reference","title":"<code>add_document_reference(document, parent_id=None, relationship_type='transforms')</code>","text":"<p>Adds a DocumentReference resource to the FHIR bundle and establishes relationships between documents if a parent_id is provided. The relationship is tracked using the FHIR relatesTo element with a specified relationship type. See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo</p> PARAMETER DESCRIPTION <code>document</code> <p>The DocumentReference to add to the bundle</p> <p> TYPE: <code>DocumentReference</code> </p> <code>parent_id</code> <p>Optional ID of the parent document. If provided, establishes a relationship between this document and its parent.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>relationship_type</code> <p>The type of relationship to establish with the parent document. Defaults to \"transforms\". This is used in the FHIR relatesTo element's code. See: http://hl7.org/fhir/valueset-document-relationship-type</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'transforms'</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The ID of the added document. If the document had no ID, a new UUID-based ID is generated.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def add_document_reference(\n    self,\n    document: DocumentReference,\n    parent_id: Optional[str] = None,\n    relationship_type: Optional[str] = \"transforms\",\n) -&gt; str:\n    \"\"\"\n    Adds a DocumentReference resource to the FHIR bundle and establishes\n    relationships between documents if a parent_id is provided. The relationship is\n    tracked using the FHIR relatesTo element with a specified relationship type.\n    See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n    Args:\n        document: The DocumentReference to add to the bundle\n        parent_id: Optional ID of the parent document. If provided, establishes a\n            relationship between this document and its parent.\n        relationship_type: The type of relationship to establish with the parent\n            document. Defaults to \"transforms\". This is used in the FHIR relatesTo\n            element's code. See: http://hl7.org/fhir/valueset-document-relationship-type\n\n    Returns:\n        str: The ID of the added document. If the document had no ID, a new UUID-based\n            ID is generated.\n    \"\"\"\n    # Generate a consistent ID if not present\n    if not document.id:\n        document.id = f\"doc-{uuid4()}\"\n\n    # Add relationship metadata if there's a parent\n    if parent_id:\n        if not hasattr(document, \"relatesTo\") or not document.relatesTo:\n            document.relatesTo = []\n        document.relatesTo.append(\n            DocumentReferenceRelatesTo(\n                target=Reference(reference=f\"DocumentReference/{parent_id}\"),\n                code=create_single_codeable_concept(\n                    code=relationship_type,\n                    display=relationship_type.capitalize(),\n                    system=\"http://hl7.org/fhir/ValueSet/document-relationship-type\",\n                ),\n            )\n        )\n\n    self.add_resources([document], \"DocumentReference\", replace=False)\n\n    return document.id\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.add_resources","title":"<code>add_resources(resources, resource_type, replace=False)</code>","text":"<p>Add resources to the working bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def add_resources(\n    self, resources: List[Any], resource_type: str, replace: bool = False\n):\n    \"\"\"Add resources to the working bundle.\"\"\"\n    if not self._bundle:\n        self._bundle = create_bundle()\n    set_resources(self._bundle, resources, resource_type, replace=replace)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_document_reference_family","title":"<code>get_document_reference_family(document_id)</code>","text":"<p>Get a DocumentReference resource and all its related resources based on the relatesTo element in the FHIR standard. See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo</p> PARAMETER DESCRIPTION <code>document_id</code> <p>ID of the DocumentReference resource to find relationships for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict containing: 'document': The requested DocumentReference resource 'parents': List of parent DocumentReference resources 'children': List of child DocumentReference resources 'siblings': List of DocumentReference resources sharing the same parent</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_document_reference_family(self, document_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get a DocumentReference resource and all its related resources\n    based on the relatesTo element in the FHIR standard.\n    See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n    Args:\n        document_id: ID of the DocumentReference resource to find relationships for\n\n    Returns:\n        Dict containing:\n            'document': The requested DocumentReference resource\n            'parents': List of parent DocumentReference resources\n            'children': List of child DocumentReference resources\n            'siblings': List of DocumentReference resources sharing the same parent\n    \"\"\"\n    documents = self.get_resources(\"DocumentReference\")\n    family = {\"document\": None, \"parents\": [], \"children\": [], \"siblings\": []}\n\n    # Find the requested document\n    target_doc = next((doc for doc in documents if doc.id == document_id), None)\n    if not target_doc:\n        return family\n\n    family[\"document\"] = target_doc\n\n    # Find direct relationships\n    if hasattr(target_doc, \"relatesTo\") and target_doc.relatesTo:\n        # Find parents from target's relationships\n        for relation in target_doc.relatesTo:\n            parent_ref = relation.target.reference\n            parent_id = parent_ref.split(\"/\")[-1]\n            parent = next((doc for doc in documents if doc.id == parent_id), None)\n            if parent:\n                family[\"parents\"].append(parent)\n\n    # Find children and siblings\n    for doc in documents:\n        if not hasattr(doc, \"relatesTo\") or not doc.relatesTo:\n            continue\n\n        for relation in doc.relatesTo:\n            target_ref = relation.target.reference\n            related_id = target_ref.split(\"/\")[-1]\n\n            # Check if this doc is a child of our target\n            if related_id == document_id:\n                family[\"children\"].append(doc)\n\n            # For siblings, check if they share the same parent\n            elif family[\"parents\"] and related_id == family[\"parents\"][0].id:\n                if doc.id != document_id:  # Don't include self as sibling\n                    family[\"siblings\"].append(doc)\n\n    return family\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_document_references_readable","title":"<code>get_document_references_readable(include_data=True, include_relationships=True)</code>","text":"<p>Get DocumentReferences resources with their content and optional relationship data in a human-readable dictionary format.</p> PARAMETER DESCRIPTION <code>include_data</code> <p>If True, decode and include the document data (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>include_relationships</code> <p>If True, include related document information (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List of documents with metadata and optionally their content and relationships</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_document_references_readable(\n    self, include_data: bool = True, include_relationships: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get DocumentReferences resources with their content and optional relationship data\n    in a human-readable dictionary format.\n\n    Args:\n        include_data: If True, decode and include the document data (default: True)\n        include_relationships: If True, include related document information (default: True)\n\n    Returns:\n        List of documents with metadata and optionally their content and relationships\n    \"\"\"\n    documents = []\n    for doc in self.get_resources(\"DocumentReference\"):\n        doc_data = {\n            \"id\": doc.id,\n            \"description\": doc.description,\n            \"status\": doc.status,\n        }\n\n        attachments = read_content_attachment(doc, include_data=include_data)\n        if attachments:\n            doc_data[\"attachments\"] = []\n            for attachment in attachments:\n                if include_data:\n                    doc_data[\"attachments\"].append(\n                        {\n                            \"data\": attachment.get(\"data\"),\n                            \"metadata\": attachment.get(\"metadata\"),\n                        }\n                    )\n                else:\n                    doc_data[\"attachments\"].append(\n                        {\"metadata\": attachment.get(\"metadata\")}\n                    )\n\n        if include_relationships:\n            family = self.get_document_reference_family(doc.id)\n            doc_data[\"relationships\"] = {\n                \"parents\": [\n                    {\"id\": p.id, \"description\": p.description}\n                    for p in family[\"parents\"]\n                ],\n                \"children\": [\n                    {\"id\": c.id, \"description\": c.description}\n                    for c in family[\"children\"]\n                ],\n                \"siblings\": [\n                    {\"id\": s.id, \"description\": s.description}\n                    for s in family[\"siblings\"]\n                ],\n            }\n\n        documents.append(doc_data)\n\n    return documents\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_prefetch_resources","title":"<code>get_prefetch_resources(key)</code>","text":"<p>Get resources of a specific type from the prefetch bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_prefetch_resources(self, key: str) -&gt; List[Any]:\n    \"\"\"Get resources of a specific type from the prefetch bundle.\"\"\"\n    if not self._prefetch_resources:\n        return []\n    return self._prefetch_resources.get(key, [])\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_resources","title":"<code>get_resources(resource_type)</code>","text":"<p>Get resources of a specific type from the working bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_resources(self, resource_type: str) -&gt; List[Any]:\n    \"\"\"Get resources of a specific type from the working bundle.\"\"\"\n    if not self._bundle:\n        return []\n    return get_resources(self._bundle, resource_type)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.ModelOutputs","title":"<code>ModelOutputs</code>  <code>dataclass</code>","text":"<p>Container for storing and managing third-party integration model outputs.</p> <p>This class stores outputs from different NLP/ML frameworks like Hugging Face and LangChain, organizing them by task type. It also maintains a list of generated text outputs across frameworks.</p> ATTRIBUTE DESCRIPTION <code>_huggingface_results</code> <p>Dictionary storing Hugging Face model outputs, keyed by task name.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>_langchain_results</code> <p>Dictionary storing LangChain outputs, keyed by task name.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> METHOD DESCRIPTION <code>add_output</code> <p>str, task: str, output: Any): Adds a model output for a specific source and task. For text generation tasks, also extracts and stores the generated text.</p> <code>get_output</code> <p>str, task: str, default: Any = None) -&gt; Any: Gets the model output for a specific source and task. Returns default if not found.</p> <code>get_generated_text</code> <p>Returns the list of generated text outputs</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass ModelOutputs:\n    \"\"\"\n    Container for storing and managing third-party integration model outputs.\n\n    This class stores outputs from different NLP/ML frameworks like Hugging Face\n    and LangChain, organizing them by task type. It also maintains a list of\n    generated text outputs across frameworks.\n\n    Attributes:\n        _huggingface_results (Dict[str, Any]): Dictionary storing Hugging Face model\n            outputs, keyed by task name.\n        _langchain_results (Dict[str, Any]): Dictionary storing LangChain outputs,\n            keyed by task name.\n\n    Methods:\n        add_output(source: str, task: str, output: Any): Adds a model output for a\n            specific source and task. For text generation tasks, also extracts and\n            stores the generated text.\n        get_output(source: str, task: str, default: Any = None) -&gt; Any: Gets the model\n            output for a specific source and task. Returns default if not found.\n        get_generated_text() -&gt; List[str]: Returns the list of generated text outputs\n    \"\"\"\n\n    _huggingface_results: Dict[str, Any] = field(default_factory=dict)\n    _langchain_results: Dict[str, Any] = field(default_factory=dict)\n\n    def add_output(self, source: str, task: str, output: Any):\n        if source == \"huggingface\":\n            self._huggingface_results[task] = output\n        elif source == \"langchain\":\n            self._langchain_results[task] = output\n        else:\n            raise ValueError(f\"Unknown source: {source}\")\n\n    def get_output(self, source: str, task: str) -&gt; Any:\n        if source == \"huggingface\":\n            return self._huggingface_results.get(task, {})\n        elif source == \"langchain\":\n            return self._langchain_results.get(task, {})\n        raise ValueError(f\"Unknown source: {source}\")\n\n    def get_generated_text(self, source: str, task: str) -&gt; List[str]:\n        \"\"\"\n        Returns generated text outputs for a given source and task.\n\n        Handles different output formats for Hugging Face and LangChain. For\n        Hugging Face, it extracts the last message content from chat-style\n        outputs and common keys like \"generated_text\", \"summary_text\", and\n        \"translation\". For LangChain, it converts JSON outputs to strings, and returns\n        the output as is if it is already a string.\n\n        Args:\n            source (str): Framework name (e.g., \"huggingface\", \"langchain\").\n            task (str): Task name for retrieving generated text.\n\n        Returns:\n            List[str]: List of generated text outputs, or an empty list if none.\n        \"\"\"\n        generated_text = []\n\n        if source == \"huggingface\":\n            # Handle chat-style output format\n            output = self._huggingface_results.get(task)\n            if isinstance(output, list):\n                for entry in output:\n                    text = entry.get(\"generated_text\")\n                    if isinstance(text, list):\n                        last_msg = text[-1]\n                        if isinstance(last_msg, dict) and \"content\" in last_msg:\n                            generated_text.append(last_msg[\"content\"])\n                    # Otherwise get common huggingface output keys\n                    elif any(\n                        key in entry\n                        for key in [\"generated_text\", \"summary_text\", \"translation\"]\n                    ):\n                        generated_text.append(\n                            text\n                            or entry.get(\"summary_text\")\n                            or entry.get(\"translation\")\n                        )\n            else:\n                logger.warning(\"HuggingFace output is not a list of dictionaries. \")\n        elif source == \"langchain\":\n            output = self._langchain_results.get(task)\n            # Check if output is a string\n            if isinstance(output, str):\n                generated_text.append(output)\n            # Try to convert JSON to string\n            elif isinstance(output, dict):\n                try:\n                    import json\n\n                    output_str = json.dumps(output)\n                    generated_text.append(output_str)\n                except Exception:\n                    logger.warning(\n                        \"LangChain output is not a string and could not be converted to JSON string. \"\n                        \"Chains should output either a string or a JSON object.\"\n                    )\n            else:\n                logger.warning(\n                    \"LangChain output is not a string. Chains should output either a string or a JSON object.\"\n                )\n\n        return generated_text\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.ModelOutputs.get_generated_text","title":"<code>get_generated_text(source, task)</code>","text":"<p>Returns generated text outputs for a given source and task.</p> <p>Handles different output formats for Hugging Face and LangChain. For Hugging Face, it extracts the last message content from chat-style outputs and common keys like \"generated_text\", \"summary_text\", and \"translation\". For LangChain, it converts JSON outputs to strings, and returns the output as is if it is already a string.</p> PARAMETER DESCRIPTION <code>source</code> <p>Framework name (e.g., \"huggingface\", \"langchain\").</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>Task name for retrieving generated text.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: List of generated text outputs, or an empty list if none.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_generated_text(self, source: str, task: str) -&gt; List[str]:\n    \"\"\"\n    Returns generated text outputs for a given source and task.\n\n    Handles different output formats for Hugging Face and LangChain. For\n    Hugging Face, it extracts the last message content from chat-style\n    outputs and common keys like \"generated_text\", \"summary_text\", and\n    \"translation\". For LangChain, it converts JSON outputs to strings, and returns\n    the output as is if it is already a string.\n\n    Args:\n        source (str): Framework name (e.g., \"huggingface\", \"langchain\").\n        task (str): Task name for retrieving generated text.\n\n    Returns:\n        List[str]: List of generated text outputs, or an empty list if none.\n    \"\"\"\n    generated_text = []\n\n    if source == \"huggingface\":\n        # Handle chat-style output format\n        output = self._huggingface_results.get(task)\n        if isinstance(output, list):\n            for entry in output:\n                text = entry.get(\"generated_text\")\n                if isinstance(text, list):\n                    last_msg = text[-1]\n                    if isinstance(last_msg, dict) and \"content\" in last_msg:\n                        generated_text.append(last_msg[\"content\"])\n                # Otherwise get common huggingface output keys\n                elif any(\n                    key in entry\n                    for key in [\"generated_text\", \"summary_text\", \"translation\"]\n                ):\n                    generated_text.append(\n                        text\n                        or entry.get(\"summary_text\")\n                        or entry.get(\"translation\")\n                    )\n        else:\n            logger.warning(\"HuggingFace output is not a list of dictionaries. \")\n    elif source == \"langchain\":\n        output = self._langchain_results.get(task)\n        # Check if output is a string\n        if isinstance(output, str):\n            generated_text.append(output)\n        # Try to convert JSON to string\n        elif isinstance(output, dict):\n            try:\n                import json\n\n                output_str = json.dumps(output)\n                generated_text.append(output_str)\n            except Exception:\n                logger.warning(\n                    \"LangChain output is not a string and could not be converted to JSON string. \"\n                    \"Chains should output either a string or a JSON object.\"\n                )\n        else:\n            logger.warning(\n                \"LangChain output is not a string. Chains should output either a string or a JSON object.\"\n            )\n\n    return generated_text\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.NlpAnnotations","title":"<code>NlpAnnotations</code>  <code>dataclass</code>","text":"<p>Container for NLP-specific annotations and results.</p> <p>This class stores various NLP annotations and processing results from text analysis, including preprocessed text, tokens, named entities, embeddings and spaCy documents.</p> ATTRIBUTE DESCRIPTION <code>_preprocessed_text</code> <p>The preprocessed version of the input text.</p> <p> TYPE: <code>str</code> </p> <code>_tokens</code> <p>List of tokenized words from the text.</p> <p> TYPE: <code>List[str]</code> </p> <code>_entities</code> <p>Named entities extracted from the text, with their labels and positions.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>_embeddings</code> <p>Vector embeddings generated from the text.</p> <p> TYPE: <code>Optional[List[float]]</code> </p> <code>_spacy_doc</code> <p>The processed spaCy Doc object.</p> <p> TYPE: <code>Optional[Doc]</code> </p> METHOD DESCRIPTION <code>add_spacy_doc</code> <p>SpacyDoc): Processes a spaCy Doc to extract tokens and entities.</p> <code>get_spacy_doc</code> <p>Returns the stored spaCy Doc object.</p> <code>get_tokens</code> <p>Returns the list of tokens.</p> <code>set_tokens</code> <p>List[str]): Sets the token list.</p> <code>set_entities</code> <p>List[Dict[str, Any]]): Sets the named entities list.</p> <code>get_entities</code> <p>Returns the list of named entities.</p> <code>get_embeddings</code> <p>Returns the vector embeddings.</p> <code>set_embeddings</code> <p>List[float]): Sets the vector embeddings.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass NlpAnnotations:\n    \"\"\"\n    Container for NLP-specific annotations and results.\n\n    This class stores various NLP annotations and processing results from text analysis,\n    including preprocessed text, tokens, named entities, embeddings and spaCy documents.\n\n    Attributes:\n        _preprocessed_text (str): The preprocessed version of the input text.\n        _tokens (List[str]): List of tokenized words from the text.\n        _entities (List[Dict[str, Any]]): Named entities extracted from the text, with their labels and positions.\n        _embeddings (Optional[List[float]]): Vector embeddings generated from the text.\n        _spacy_doc (Optional[SpacyDoc]): The processed spaCy Doc object.\n\n    Methods:\n        add_spacy_doc(doc: SpacyDoc): Processes a spaCy Doc to extract tokens and entities.\n        get_spacy_doc() -&gt; Optional[SpacyDoc]: Returns the stored spaCy Doc object.\n        get_tokens() -&gt; List[str]: Returns the list of tokens.\n        set_tokens(tokens: List[str]): Sets the token list.\n        set_entities(entities: List[Dict[str, Any]]): Sets the named entities list.\n        get_entities() -&gt; List[Dict[str, Any]]: Returns the list of named entities.\n        get_embeddings() -&gt; Optional[List[float]]: Returns the vector embeddings.\n        set_embeddings(embeddings: List[float]): Sets the vector embeddings.\n    \"\"\"\n\n    _preprocessed_text: str = \"\"\n    _tokens: List[str] = field(default_factory=list)\n    _entities: List[Dict[str, Any]] = field(default_factory=list)\n    _embeddings: Optional[List[float]] = None\n    _spacy_doc: Optional[SpacyDoc] = None\n\n    def add_spacy_doc(self, doc: SpacyDoc):\n        self._spacy_doc = doc\n        self._tokens = [token.text for token in doc]\n        self._entities = [\n            {\n                \"text\": ent.text,\n                \"label\": ent.label_,\n                \"start\": ent.start_char,\n                \"end\": ent.end_char,\n            }\n            for ent in doc.ents\n        ]\n\n    def get_spacy_doc(self) -&gt; Optional[SpacyDoc]:\n        return self._spacy_doc\n\n    def get_tokens(self) -&gt; List[str]:\n        return self._tokens\n\n    def set_tokens(self, tokens: List[str]):\n        self._tokens = tokens\n\n    def set_entities(self, entities: List[Dict[str, Any]]):\n        self._entities = entities\n\n    def get_entities(self) -&gt; List[Dict[str, Any]]:\n        return self._entities\n\n    def get_embeddings(self) -&gt; Optional[List[float]]:\n        return self._embeddings\n\n    def set_embeddings(self, embeddings: List[float]):\n        self._embeddings = embeddings\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.tabular","title":"<code>tabular</code>","text":""},{"location":"api/containers/#healthchain.io.containers.tabular.Tabular","title":"<code>Tabular</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[DataFrame]</code></p> <p>A container for tabular data, wrapping a pandas DataFrame.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The pandas DataFrame containing the tabular data.</p> <p> TYPE: <code>DataFrame</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Validates that the data is a pandas DataFrame.</p> <code>columns</code> <p>Property that returns a list of column names.</p> <code>index</code> <p>Property that returns the DataFrame's index.</p> <code>dtypes</code> <p>Property that returns a dictionary of column names and their data types.</p> <code>column_count</code> <p>Returns the number of columns in the DataFrame.</p> <code>row_count</code> <p>Returns the number of rows in the DataFrame.</p> <code>get_dtype</code> <p>str): Returns the data type of a specific column.</p> <code>__iter__</code> <p>Returns an iterator over the column names.</p> <code>__len__</code> <p>Returns the number of rows in the DataFrame.</p> <code>describe</code> <p>Returns a string description of the tabular data.</p> <code>remove_column</code> <p>str): Removes a column from the DataFrame.</p> <code>from_csv</code> <p>str, **kwargs): Class method to create a Tabular object from a CSV file.</p> <code>from_dict</code> <p>Dict[str, Any]): Class method to create a Tabular object from a dictionary.</p> <code>to_csv</code> <p>str, **kwargs): Saves the DataFrame to a CSV file.</p> Source code in <code>healthchain/io/containers/tabular.py</code> <pre><code>@dataclass\nclass Tabular(DataContainer[pd.DataFrame]):\n    \"\"\"\n    A container for tabular data, wrapping a pandas DataFrame.\n\n    Attributes:\n        data (pd.DataFrame): The pandas DataFrame containing the tabular data.\n\n    Methods:\n        __post_init__(): Validates that the data is a pandas DataFrame.\n        columns: Property that returns a list of column names.\n        index: Property that returns the DataFrame's index.\n        dtypes: Property that returns a dictionary of column names and their data types.\n        column_count(): Returns the number of columns in the DataFrame.\n        row_count(): Returns the number of rows in the DataFrame.\n        get_dtype(column: str): Returns the data type of a specific column.\n        __iter__(): Returns an iterator over the column names.\n        __len__(): Returns the number of rows in the DataFrame.\n        describe(): Returns a string description of the tabular data.\n        remove_column(name: str): Removes a column from the DataFrame.\n        from_csv(path: str, **kwargs): Class method to create a Tabular object from a CSV file.\n        from_dict(data: Dict[str, Any]): Class method to create a Tabular object from a dictionary.\n        to_csv(path: str, **kwargs): Saves the DataFrame to a CSV file.\n    \"\"\"\n\n    def __post_init__(self):\n        if not isinstance(self.data, pd.DataFrame):\n            raise TypeError(\"data must be a pandas DataFrame\")\n\n    @property\n    def columns(self) -&gt; List[str]:\n        return list(self.data.columns)\n\n    @property\n    def index(self) -&gt; pd.Index:\n        return self.data.index\n\n    @property\n    def dtypes(self) -&gt; Dict[str, str]:\n        return {col: str(dtype) for col, dtype in self.data.dtypes.items()}\n\n    def column_count(self) -&gt; int:\n        return len(self.columns)\n\n    def row_count(self) -&gt; int:\n        return len(self.data)\n\n    def get_dtype(self, column: str) -&gt; str:\n        return str(self.data[column].dtype)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.columns)\n\n    def __len__(self) -&gt; int:\n        return self.row_count()\n\n    def describe(self) -&gt; str:\n        return f\"Tabular data with {self.column_count()} columns and {self.row_count()} rows\"\n\n    def remove_column(self, name: str) -&gt; None:\n        self.data.drop(columns=[name], inplace=True)\n\n    @classmethod\n    def from_csv(cls, path: str, **kwargs) -&gt; \"Tabular\":\n        return cls(pd.read_csv(path, **kwargs))\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Tabular\":\n        df = pd.DataFrame(**data[\"data\"])\n        return cls(df)\n\n    def to_csv(self, path: str, **kwargs) -&gt; None:\n        self.data.to_csv(path, **kwargs)\n</code></pre>"},{"location":"api/fhir_helpers/","title":"FHIR Helpers","text":"<p>FHIR utilities for HealthChain.</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_coding_to_codeable_concept","title":"<code>add_coding_to_codeable_concept(codeable_concept, code, system, display=None)</code>","text":"<p>Add a coding to an existing CodeableConcept.</p> <p>Useful for adding standardized codes (e.g., SNOMED CT) to resources that already have codes from other systems (e.g., ICD-10).</p> PARAMETER DESCRIPTION <code>codeable_concept</code> <p>The CodeableConcept to add coding to</p> <p> TYPE: <code>CodeableConcept</code> </p> <code>code</code> <p>The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>system</code> <p>The code system URI</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>Optional display text for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>The updated CodeableConcept with the new coding added</p> <p> TYPE: <code>CodeableConcept</code> </p> Example Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def add_coding_to_codeable_concept(\n    codeable_concept: CodeableConcept,\n    code: str,\n    system: str,\n    display: Optional[str] = None,\n) -&gt; CodeableConcept:\n    \"\"\"Add a coding to an existing CodeableConcept.\n\n    Useful for adding standardized codes (e.g., SNOMED CT) to resources that already\n    have codes from other systems (e.g., ICD-10).\n\n    Args:\n        codeable_concept: The CodeableConcept to add coding to\n        code: The code value from the code system\n        system: The code system URI\n        display: Optional display text for the code\n\n    Returns:\n        CodeableConcept: The updated CodeableConcept with the new coding added\n\n    Example:\n        &gt;&gt;&gt; # Add SNOMED CT code to a condition that has ICD-10\n        &gt;&gt;&gt; condition_code = condition.code\n        &gt;&gt;&gt; condition_code = add_coding_to_codeable_concept(\n        ...     condition_code,\n        ...     code=\"44054006\",\n        ...     system=\"http://snomed.info/sct\",\n        ...     display=\"Type 2 diabetes mellitus\"\n        ... )\n    \"\"\"\n    if not codeable_concept.coding:\n        codeable_concept.coding = []\n\n    codeable_concept.coding.append(Coding(system=system, code=code, display=display))\n\n    return codeable_concept\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_coding_to_codeable_concept--add-snomed-ct-code-to-a-condition-that-has-icd-10","title":"Add SNOMED CT code to a condition that has ICD-10","text":"<p>condition_code = condition.code condition_code = add_coding_to_codeable_concept( ...     condition_code, ...     code=\"44054006\", ...     system=\"http://snomed.info/sct\", ...     display=\"Type 2 diabetes mellitus\" ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_provenance_metadata","title":"<code>add_provenance_metadata(resource, source, tag_code=None, tag_display=None)</code>","text":"<p>Add provenance metadata to a FHIR resource.</p> <p>Adds source system identifier, timestamp, and optional processing tags to track data lineage and transformations for audit trails.</p> PARAMETER DESCRIPTION <code>resource</code> <p>The FHIR resource to annotate</p> <p> TYPE: <code>Resource</code> </p> <code>source</code> <p>Name of the source system (e.g., \"epic\", \"cerner\")</p> <p> TYPE: <code>str</code> </p> <code>tag_code</code> <p>Optional tag code for processing operations (e.g., \"aggregated\", \"deduplicated\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>tag_display</code> <p>Optional display text for the tag</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Resource</code> <p>The resource with added provenance metadata</p> <p> TYPE: <code>Resource</code> </p> Example <p>condition = create_condition(subject=\"Patient/123\", code=\"E11.9\") condition = add_provenance_metadata(condition, \"epic\", \"aggregated\", \"Aggregated from source\")</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def add_provenance_metadata(\n    resource: Resource,\n    source: str,\n    tag_code: Optional[str] = None,\n    tag_display: Optional[str] = None,\n) -&gt; Resource:\n    \"\"\"Add provenance metadata to a FHIR resource.\n\n    Adds source system identifier, timestamp, and optional processing tags to track\n    data lineage and transformations for audit trails.\n\n    Args:\n        resource: The FHIR resource to annotate\n        source: Name of the source system (e.g., \"epic\", \"cerner\")\n        tag_code: Optional tag code for processing operations (e.g., \"aggregated\", \"deduplicated\")\n        tag_display: Optional display text for the tag\n\n    Returns:\n        Resource: The resource with added provenance metadata\n\n    Example:\n        &gt;&gt;&gt; condition = create_condition(subject=\"Patient/123\", code=\"E11.9\")\n        &gt;&gt;&gt; condition = add_provenance_metadata(condition, \"epic\", \"aggregated\", \"Aggregated from source\")\n    \"\"\"\n    if not resource.meta:\n        resource.meta = Meta()\n\n    # Add source system identifier\n    resource.meta.source = f\"urn:healthchain:source:{source}\"\n\n    # Update timestamp\n    resource.meta.lastUpdated = datetime.datetime.now(datetime.timezone.utc).isoformat()\n\n    # Add processing tag if provided\n    if tag_code:\n        if not resource.meta.tag:\n            resource.meta.tag = []\n\n        resource.meta.tag.append(\n            Coding(\n                system=\"https://dotimplement.github.io/HealthChain/fhir/tags\",\n                code=tag_code,\n                display=tag_display or tag_code,\n            )\n        )\n\n    return resource\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_resource","title":"<code>add_resource(bundle, resource, full_url=None)</code>","text":"<p>Add a resource to a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to add to</p> <p> TYPE: <code>Bundle</code> </p> <code>resource</code> <p>The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance</p> <p> TYPE: <code>Resource</code> </p> <code>full_url</code> <p>Optional full URL for the resource</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def add_resource(\n    bundle: Bundle, resource: Resource, full_url: Optional[str] = None\n) -&gt; None:\n    \"\"\"Add a resource to a bundle.\n\n    Args:\n        bundle: The bundle to add to\n        resource: The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance\n        full_url: Optional full URL for the resource\n    \"\"\"\n    entry = BundleEntry(resource=resource)\n    if full_url:\n        entry.fullUrl = full_url\n    bundle.entry = (bundle.entry or []) + [entry]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_allergy_intolerance","title":"<code>create_allergy_intolerance(patient, code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal active FHIR AllergyIntolerance. If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly. https://build.fhir.org/allergyintolerance.html</p> PARAMETER DESCRIPTION <code>patient</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>code</code> <p>The allergen code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the allergen</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>AllergyIntolerance</code> <p>A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>AllergyIntolerance</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_allergy_intolerance(\n    patient: str,\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; AllergyIntolerance:\n    \"\"\"\n    Create a minimal active FHIR AllergyIntolerance.\n    If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly.\n    https://build.fhir.org/allergyintolerance.html\n\n    Args:\n        patient: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        code: The allergen code\n        display: The display name for the allergen\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        AllergyIntolerance: A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        allergy_code = create_single_codeable_concept(code, display, system)\n    else:\n        allergy_code = None\n\n    allergy = AllergyIntolerance(\n        id=_generate_id(),\n        patient=Reference(reference=patient),\n        code=allergy_code,\n    )\n\n    return allergy\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_bundle","title":"<code>create_bundle(bundle_type='collection')</code>","text":"<p>Create an empty FHIR Bundle. https://www.hl7.org/fhir/bundle.html</p> PARAMETER DESCRIPTION <code>bundle_type</code> <p>The type of bundle (default: collection) Valid types: document, message, transaction, transaction-response, batch, batch-response, history, searchset, collection</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def create_bundle(bundle_type: str = \"collection\") -&gt; Bundle:\n    \"\"\"Create an empty FHIR Bundle.\n    https://www.hl7.org/fhir/bundle.html\n\n    Args:\n        bundle_type: The type of bundle (default: collection)\n            Valid types: document, message, transaction, transaction-response,\n            batch, batch-response, history, searchset, collection\n    \"\"\"\n    return Bundle(type=bundle_type, entry=[])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_condition","title":"<code>create_condition(subject, clinical_status='active', code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal active FHIR Condition. If you need to create a more complex condition, use the FHIR Condition resource directly. https://build.fhir.org/condition.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>clinical_status</code> <p>REQUIRED. Clinical status (default: active)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'active'</code> </p> <code>code</code> <p>The condition code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the condition</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Condition</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_condition(\n    subject: str,\n    clinical_status: str = \"active\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; Condition:\n    \"\"\"\n    Create a minimal active FHIR Condition.\n    If you need to create a more complex condition, use the FHIR Condition resource directly.\n    https://build.fhir.org/condition.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        clinical_status: REQUIRED. Clinical status (default: active)\n        code: The condition code\n        display: The display name for the condition\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        Condition: A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        condition_code = create_single_codeable_concept(code, display, system)\n    else:\n        condition_code = None\n\n    condition = Condition(\n        id=_generate_id(),\n        subject=Reference(reference=subject),\n        clinicalStatus=create_single_codeable_concept(\n            code=clinical_status,\n            display=clinical_status.capitalize(),\n            system=\"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n        ),\n        code=condition_code,\n    )\n\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_document_reference","title":"<code>create_document_reference(data=None, url=None, content_type=None, status='current', description='DocumentReference created by HealthChain', attachment_title='Attachment created by HealthChain')</code>","text":"<p>Create a minimal FHIR DocumentReference. If you need to create a more complex document reference, use the FHIR DocumentReference resource directly. https://build.fhir.org/documentreference.html</p> PARAMETER DESCRIPTION <code>data</code> <p>The data content of the document attachment</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>URL where the document can be accessed</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content_type</code> <p>MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>REQUIRED. Status of the document reference (default: current)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>description</code> <p>Description of the document reference</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'DocumentReference created by HealthChain'</code> </p> <code>attachment_title</code> <p>Title for the document attachment</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> RETURNS DESCRIPTION <code>DocumentReference</code> <p>A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>DocumentReference</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_document_reference(\n    data: Optional[Any] = None,\n    url: Optional[str] = None,\n    content_type: Optional[str] = None,\n    status: str = \"current\",\n    description: Optional[str] = \"DocumentReference created by HealthChain\",\n    attachment_title: Optional[str] = \"Attachment created by HealthChain\",\n) -&gt; DocumentReference:\n    \"\"\"\n    Create a minimal FHIR DocumentReference.\n    If you need to create a more complex document reference, use the FHIR DocumentReference resource directly.\n    https://build.fhir.org/documentreference.html\n\n    Args:\n        data: The data content of the document attachment\n        url: URL where the document can be accessed\n        content_type: MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")\n        status: REQUIRED. Status of the document reference (default: current)\n        description: Description of the document reference\n        attachment_title: Title for the document attachment\n\n    Returns:\n        DocumentReference: A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    document_reference = DocumentReference(\n        id=_generate_id(),\n        status=status,\n        date=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n        description=description,\n        content=[\n            {\n                \"attachment\": create_single_attachment(\n                    content_type=content_type,\n                    data=data,\n                    url=url,\n                    title=attachment_title,\n                )\n            }\n        ],\n    )\n\n    return document_reference\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_medication_statement","title":"<code>create_medication_statement(subject, status='recorded', code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal recorded FHIR MedicationStatement. If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly. https://build.fhir.org/medicationstatement.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>status</code> <p>REQUIRED. Status of the medication (default: recorded)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'recorded'</code> </p> <code>code</code> <p>The medication code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the medication</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>MedicationStatement</code> <p>A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>MedicationStatement</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_medication_statement(\n    subject: str,\n    status: Optional[str] = \"recorded\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; MedicationStatement:\n    \"\"\"\n    Create a minimal recorded FHIR MedicationStatement.\n    If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly.\n    https://build.fhir.org/medicationstatement.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        status: REQUIRED. Status of the medication (default: recorded)\n        code: The medication code\n        display: The display name for the medication\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        MedicationStatement: A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        medication_concept = create_single_codeable_concept(code, display, system)\n    else:\n        medication_concept = None\n\n    medication = MedicationStatement(\n        id=_generate_id(),\n        subject=Reference(reference=subject),\n        status=status,\n        medication={\"concept\": medication_concept},\n    )\n\n    return medication\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_resource_from_dict","title":"<code>create_resource_from_dict(resource_dict, resource_type)</code>","text":"<p>Create a FHIR resource instance from a dictionary</p> PARAMETER DESCRIPTION <code>resource_dict</code> <p>Dictionary representation of the resource</p> <p> TYPE: <code>Dict</code> </p> <code>resource_type</code> <p>Type of FHIR resource to create</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Resource]</code> <p>Optional[Resource]: FHIR resource instance or None if creation failed</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_resource_from_dict(\n    resource_dict: Dict, resource_type: str\n) -&gt; Optional[Resource]:\n    \"\"\"Create a FHIR resource instance from a dictionary\n\n    Args:\n        resource_dict: Dictionary representation of the resource\n        resource_type: Type of FHIR resource to create\n\n    Returns:\n        Optional[Resource]: FHIR resource instance or None if creation failed\n    \"\"\"\n    try:\n        resource_module = importlib.import_module(\n            f\"fhir.resources.{resource_type.lower()}\"\n        )\n        resource_class = getattr(resource_module, resource_type)\n        return resource_class(**resource_dict)\n    except Exception as e:\n        logger.error(f\"Failed to create FHIR resource: {str(e)}\")\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_attachment","title":"<code>create_single_attachment(content_type=None, data=None, url=None, title='Attachment created by HealthChain')</code>","text":"<p>Create a minimal FHIR Attachment.</p> <p>Creates a FHIR Attachment resource with basic fields. Either data or url should be provided. If data is provided, it will be base64 encoded.</p> PARAMETER DESCRIPTION <code>content_type</code> <p>The MIME type of the content</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>data</code> <p>The actual data content to be base64 encoded</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>The URL where the data can be found</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>A title for the attachment (default: \"Attachment created by HealthChain\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> RETURNS DESCRIPTION <code>Attachment</code> <p>A FHIR Attachment resource with basic metadata and content</p> <p> TYPE: <code>Attachment</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_attachment(\n    content_type: Optional[str] = None,\n    data: Optional[str] = None,\n    url: Optional[str] = None,\n    title: Optional[str] = \"Attachment created by HealthChain\",\n) -&gt; Attachment:\n    \"\"\"Create a minimal FHIR Attachment.\n\n    Creates a FHIR Attachment resource with basic fields. Either data or url should be provided.\n    If data is provided, it will be base64 encoded.\n\n    Args:\n        content_type: The MIME type of the content\n        data: The actual data content to be base64 encoded\n        url: The URL where the data can be found\n        title: A title for the attachment (default: \"Attachment created by HealthChain\")\n\n    Returns:\n        Attachment: A FHIR Attachment resource with basic metadata and content\n    \"\"\"\n\n    if not data and not url:\n        logger.warning(\"No data or url provided for attachment\")\n\n    if data:\n        data = base64.b64encode(data.encode(\"utf-8\")).decode(\"utf-8\")\n\n    return Attachment(\n        contentType=content_type,\n        data=data,\n        url=url,\n        title=title,\n        creation=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n    )\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_codeable_concept","title":"<code>create_single_codeable_concept(code, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal FHIR CodeableConcept with a single coding.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>A FHIR CodeableConcept resource with a single coding</p> <p> TYPE: <code>CodeableConcept</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_codeable_concept(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; CodeableConcept:\n    \"\"\"\n    Create a minimal FHIR CodeableConcept with a single coding.\n\n    Args:\n        code: REQUIRED. The code value from the code system\n        display: The display name for the code\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        CodeableConcept: A FHIR CodeableConcept resource with a single coding\n    \"\"\"\n    return CodeableConcept(coding=[Coding(system=system, code=code, display=display)])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_reaction","title":"<code>create_single_reaction(code, display=None, system='http://snomed.info/sct', severity=None)</code>","text":"<p>Create a minimal FHIR Reaction with a single coding.</p> <p>Creates a FHIR Reaction object with a single manifestation coding. The manifestation describes the clinical reaction that was observed. The severity indicates how severe the reaction was.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system representing the reaction manifestation</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the manifestation code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system for the manifestation code (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>severity</code> <p>The severity of the reaction (mild, moderate, severe)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>A list containing a single FHIR Reaction dictionary with manifestation and severity fields</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_reaction(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    severity: Optional[str] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create a minimal FHIR Reaction with a single coding.\n\n    Creates a FHIR Reaction object with a single manifestation coding. The manifestation\n    describes the clinical reaction that was observed. The severity indicates how severe\n    the reaction was.\n\n    Args:\n        code: REQUIRED. The code value from the code system representing the reaction manifestation\n        display: The display name for the manifestation code\n        system: The code system for the manifestation code (default: SNOMED CT)\n        severity: The severity of the reaction (mild, moderate, severe)\n\n    Returns:\n        A list containing a single FHIR Reaction dictionary with manifestation and severity fields\n    \"\"\"\n    return [\n        {\n            \"manifestation\": [\n                CodeableReference(\n                    concept=CodeableConcept(\n                        coding=[Coding(system=system, code=code, display=display)]\n                    )\n                )\n            ],\n            \"severity\": severity,\n        }\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.extract_resources","title":"<code>extract_resources(bundle, resource_type)</code>","text":"<p>Remove resources of a given type from a bundle and return them.</p> <p>Useful for extracting and separating specific resource types (e.g., OperationOutcome) from a FHIR Bundle, modifying the bundle in place.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The FHIR Bundle to process (modified in place)</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>The FHIR resource class or string name to extract (e.g., OperationOutcome or \"OperationOutcome\")</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List[Resource]: All resources of the specified type that were in the bundle</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def extract_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Remove resources of a given type from a bundle and return them.\n\n    Useful for extracting and separating specific resource types (e.g., OperationOutcome)\n    from a FHIR Bundle, modifying the bundle in place.\n\n    Args:\n        bundle: The FHIR Bundle to process (modified in place)\n        resource_type: The FHIR resource class or string name to extract (e.g., OperationOutcome or \"OperationOutcome\")\n\n    Returns:\n        List[Resource]: All resources of the specified type that were in the bundle\n    \"\"\"\n    if not bundle or not bundle.entry:\n        return []\n\n    type_class = get_resource_type(resource_type)\n\n    extracted: List[Resource] = []\n    remaining_entries: List[BundleEntry] = []\n\n    for entry in bundle.entry:\n        resource = entry.resource\n        if isinstance(resource, type_class):\n            extracted.append(resource)\n            continue\n        remaining_entries.append(entry)\n\n    bundle.entry = remaining_entries\n    return extracted\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources","title":"<code>get_resources(bundle, resource_type)</code>","text":"<p>Get all resources of a specific type from a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to search</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List of resources of the specified type</p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def get_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Get all resources of a specific type from a bundle.\n\n    Args:\n        bundle: The bundle to search\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n\n    Returns:\n        List of resources of the specified type\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Using string identifier\n        &gt;&gt;&gt; conditions = get_resources(bundle, \"Condition\")\n        &gt;&gt;&gt; medications = get_resources(bundle, \"MedicationStatement\")\n        &gt;&gt;&gt; allergies = get_resources(bundle, \"AllergyIntolerance\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; conditions = get_resources(bundle, Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n    return [\n        entry.resource\n        for entry in (bundle.entry or [])\n        if isinstance(entry.resource, type_class)\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources--using-string-identifier","title":"Using string identifier","text":"<p>conditions = get_resources(bundle, \"Condition\") medications = get_resources(bundle, \"MedicationStatement\") allergies = get_resources(bundle, \"AllergyIntolerance\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition conditions = get_resources(bundle, Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.merge_bundles","title":"<code>merge_bundles(bundles, bundle_type='collection', deduplicate=False, dedupe_key='id')</code>","text":"<p>Merge multiple FHIR bundles into a single bundle.</p> <p>Combines entries from multiple bundles while preserving resource metadata. Useful for aggregating search results from multiple FHIR sources.</p> PARAMETER DESCRIPTION <code>bundles</code> <p>List of bundles to merge</p> <p> TYPE: <code>List[Bundle]</code> </p> <code>bundle_type</code> <p>Type for the merged bundle (default: \"collection\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> <code>deduplicate</code> <p>If True, remove duplicate resources based on dedupe_key</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>dedupe_key</code> <p>Resource attribute to use for deduplication (default: \"id\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'id'</code> </p> RETURNS DESCRIPTION <code>Bundle</code> <p>A new bundle containing all entries from input bundles</p> Example Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def merge_bundles(\n    bundles: List[Bundle],\n    bundle_type: str = \"collection\",\n    deduplicate: bool = False,\n    dedupe_key: str = \"id\",\n) -&gt; Bundle:\n    \"\"\"Merge multiple FHIR bundles into a single bundle.\n\n    Combines entries from multiple bundles while preserving resource metadata.\n    Useful for aggregating search results from multiple FHIR sources.\n\n    Args:\n        bundles: List of bundles to merge\n        bundle_type: Type for the merged bundle (default: \"collection\")\n        deduplicate: If True, remove duplicate resources based on dedupe_key\n        dedupe_key: Resource attribute to use for deduplication (default: \"id\")\n\n    Returns:\n        A new bundle containing all entries from input bundles\n\n    Example:\n        &gt;&gt;&gt; # Merge search results from multiple sources\n        &gt;&gt;&gt; epic_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"epic\")\n        &gt;&gt;&gt; cerner_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"cerner\")\n        &gt;&gt;&gt; merged = merge_bundles([epic_bundle, cerner_bundle], deduplicate=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Use in Document workflow\n        &gt;&gt;&gt; doc = Document(data=merged)\n        &gt;&gt;&gt; doc.fhir.bundle  # Contains all conditions from both sources\n    \"\"\"\n    merged = create_bundle(bundle_type=bundle_type)\n\n    if deduplicate:\n        # Track seen resources by dedupe_key to avoid duplicates\n        seen_keys = set()\n\n        for bundle in bundles:\n            if not bundle or not bundle.entry:\n                continue\n\n            for entry in bundle.entry:\n                if not entry.resource:\n                    continue\n\n                # Get the deduplication key value\n                key_value = getattr(entry.resource, dedupe_key, None)\n\n                # Skip if we've seen this key before\n                if key_value and key_value in seen_keys:\n                    continue\n\n                # Add to merged bundle and track the key\n                add_resource(merged, entry.resource, entry.fullUrl)\n                if key_value:\n                    seen_keys.add(key_value)\n    else:\n        # No deduplication - just merge all entries\n        for bundle in bundles:\n            if not bundle or not bundle.entry:\n                continue\n\n            for entry in bundle.entry:\n                if entry.resource:\n                    add_resource(merged, entry.resource, entry.fullUrl)\n\n    return merged\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.merge_bundles--merge-search-results-from-multiple-sources","title":"Merge search results from multiple sources","text":"<p>epic_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"epic\") cerner_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"cerner\") merged = merge_bundles([epic_bundle, cerner_bundle], deduplicate=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.merge_bundles--use-in-document-workflow","title":"Use in Document workflow","text":"<p>doc = Document(data=merged) doc.fhir.bundle  # Contains all conditions from both sources</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.read_content_attachment","title":"<code>read_content_attachment(document_reference, include_data=True)</code>","text":"<p>Read the attachments in a human readable format from a FHIR DocumentReference content field.</p> PARAMETER DESCRIPTION <code>document_reference</code> <p>The FHIR DocumentReference resource</p> <p> TYPE: <code>DocumentReference</code> </p> <code>include_data</code> <p>Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[List[Dict[str, Any]]]</code> <p>Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata, or None if no attachments are found: [     {         \"data\": str,         \"metadata\": Dict[str, Any]     } ]</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def read_content_attachment(\n    document_reference: DocumentReference,\n    include_data: bool = True,\n) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"Read the attachments in a human readable format from a FHIR DocumentReference content field.\n\n    Args:\n        document_reference: The FHIR DocumentReference resource\n        include_data: Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)\n\n    Returns:\n        Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata,\n            or None if no attachments are found:\n            [\n                {\n                    \"data\": str,\n                    \"metadata\": Dict[str, Any]\n                }\n            ]\n    \"\"\"\n    if not document_reference.content:\n        return None\n\n    attachments = []\n    for content in document_reference.content:\n        attachment = content.attachment\n        result = {}\n\n        if include_data:\n            result[\"data\"] = (\n                attachment.url if attachment.url else attachment.data.decode(\"utf-8\")\n            )\n\n        result[\"metadata\"] = {\n            \"content_type\": attachment.contentType,\n            \"title\": attachment.title,\n            \"creation\": attachment.creation,\n        }\n\n        attachments.append(result)\n\n    return attachments\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_condition_category","title":"<code>set_condition_category(condition, category)</code>","text":"<p>Set the category of a FHIR Condition to either 'problem-list-item' or 'encounter-diagnosis'.</p> PARAMETER DESCRIPTION <code>condition</code> <p>The FHIR Condition resource to modify</p> <p> TYPE: <code>Condition</code> </p> <code>category</code> <p>The category to set. Must be 'problem-list-item' or 'encounter-diagnosis'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>The modified FHIR Condition resource with the specified category set</p> <p> TYPE: <code>Condition</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the category is not one of the allowed values.</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def set_condition_category(condition: Condition, category: str) -&gt; Condition:\n    \"\"\"\n    Set the category of a FHIR Condition to either 'problem-list-item' or 'encounter-diagnosis'.\n\n    Args:\n        condition: The FHIR Condition resource to modify\n        category: The category to set. Must be 'problem-list-item' or 'encounter-diagnosis'.\n\n    Returns:\n        Condition: The modified FHIR Condition resource with the specified category set\n\n    Raises:\n        ValueError: If the category is not one of the allowed values.\n    \"\"\"\n    allowed_categories = {\n        \"problem-list-item\": {\n            \"code\": \"problem-list-item\",\n            \"display\": \"Problem List Item\",\n        },\n        \"encounter-diagnosis\": {\n            \"code\": \"encounter-diagnosis\",\n            \"display\": \"Encounter Diagnosis\",\n        },\n    }\n    if category not in allowed_categories:\n        raise ValueError(\n            f\"Invalid category '{category}'. Must be one of: {list(allowed_categories.keys())}\"\n        )\n\n    cat_info = allowed_categories[category]\n    condition.category = [\n        create_single_codeable_concept(\n            code=cat_info[\"code\"],\n            display=cat_info[\"display\"],\n            system=\"http://terminology.hl7.org/CodeSystem/condition-category\",\n        )\n    ]\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources","title":"<code>set_resources(bundle, resources, resource_type, replace=True)</code>","text":"<p>Set resources of a specific type in the bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to modify</p> <p> TYPE: <code>Bundle</code> </p> <code>resources</code> <p>The new resources to add</p> <p> TYPE: <code>List[Resource]</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> <code>replace</code> <p>If True, remove existing resources of this type before adding new ones.     If False, append new resources to existing ones. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def set_resources(\n    bundle: Bundle,\n    resources: List[Resource],\n    resource_type: Union[str, Type[Resource]],\n    replace: bool = True,\n) -&gt; None:\n    \"\"\"Set resources of a specific type in the bundle.\n\n    Args:\n        bundle: The bundle to modify\n        resources: The new resources to add\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n        replace: If True, remove existing resources of this type before adding new ones.\n                If False, append new resources to existing ones. Defaults to True.\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Append to existing resources (default behavior)\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], \"Condition\")\n        &gt;&gt;&gt; set_resources(bundle, [medication1], \"MedicationStatement\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Replace existing resources\n        &gt;&gt;&gt; set_resources(bundle, [condition3], \"Condition\", replace=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n\n    # Remove existing resources of this type if replace=True\n    if replace:\n        bundle.entry = [\n            entry\n            for entry in (bundle.entry or [])\n            if not isinstance(entry.resource, type_class)\n        ]\n\n    # Add new resources\n    for resource in resources:\n        if not isinstance(resource, type_class):\n            raise ValueError(\n                f\"Resource must be of type {type_class.__name__}, \"\n                f\"got {type(resource).__name__}\"\n            )\n        add_resource(bundle, resource)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--append-to-existing-resources-default-behavior","title":"Append to existing resources (default behavior)","text":"<p>set_resources(bundle, [condition1, condition2], \"Condition\") set_resources(bundle, [medication1], \"MedicationStatement\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--replace-existing-resources","title":"Replace existing resources","text":"<p>set_resources(bundle, [condition3], \"Condition\", replace=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition set_resources(bundle, [condition1, condition2], Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers","title":"<code>bundle_helpers</code>","text":"<p>Helper functions for working with FHIR Bundles. Patterns: - create_(): create a new FHIR bundle - add_(): add a resource to a bundle - get_(): get resources from a bundle - set_(): set resources in a bundle - merge_(): merge multiple bundles into a single bundle - extract_(): extract resources from a bundle</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.add_resource","title":"<code>add_resource(bundle, resource, full_url=None)</code>","text":"<p>Add a resource to a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to add to</p> <p> TYPE: <code>Bundle</code> </p> <code>resource</code> <p>The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance</p> <p> TYPE: <code>Resource</code> </p> <code>full_url</code> <p>Optional full URL for the resource</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def add_resource(\n    bundle: Bundle, resource: Resource, full_url: Optional[str] = None\n) -&gt; None:\n    \"\"\"Add a resource to a bundle.\n\n    Args:\n        bundle: The bundle to add to\n        resource: The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance\n        full_url: Optional full URL for the resource\n    \"\"\"\n    entry = BundleEntry(resource=resource)\n    if full_url:\n        entry.fullUrl = full_url\n    bundle.entry = (bundle.entry or []) + [entry]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.create_bundle","title":"<code>create_bundle(bundle_type='collection')</code>","text":"<p>Create an empty FHIR Bundle. https://www.hl7.org/fhir/bundle.html</p> PARAMETER DESCRIPTION <code>bundle_type</code> <p>The type of bundle (default: collection) Valid types: document, message, transaction, transaction-response, batch, batch-response, history, searchset, collection</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def create_bundle(bundle_type: str = \"collection\") -&gt; Bundle:\n    \"\"\"Create an empty FHIR Bundle.\n    https://www.hl7.org/fhir/bundle.html\n\n    Args:\n        bundle_type: The type of bundle (default: collection)\n            Valid types: document, message, transaction, transaction-response,\n            batch, batch-response, history, searchset, collection\n    \"\"\"\n    return Bundle(type=bundle_type, entry=[])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.extract_resources","title":"<code>extract_resources(bundle, resource_type)</code>","text":"<p>Remove resources of a given type from a bundle and return them.</p> <p>Useful for extracting and separating specific resource types (e.g., OperationOutcome) from a FHIR Bundle, modifying the bundle in place.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The FHIR Bundle to process (modified in place)</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>The FHIR resource class or string name to extract (e.g., OperationOutcome or \"OperationOutcome\")</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List[Resource]: All resources of the specified type that were in the bundle</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def extract_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Remove resources of a given type from a bundle and return them.\n\n    Useful for extracting and separating specific resource types (e.g., OperationOutcome)\n    from a FHIR Bundle, modifying the bundle in place.\n\n    Args:\n        bundle: The FHIR Bundle to process (modified in place)\n        resource_type: The FHIR resource class or string name to extract (e.g., OperationOutcome or \"OperationOutcome\")\n\n    Returns:\n        List[Resource]: All resources of the specified type that were in the bundle\n    \"\"\"\n    if not bundle or not bundle.entry:\n        return []\n\n    type_class = get_resource_type(resource_type)\n\n    extracted: List[Resource] = []\n    remaining_entries: List[BundleEntry] = []\n\n    for entry in bundle.entry:\n        resource = entry.resource\n        if isinstance(resource, type_class):\n            extracted.append(resource)\n            continue\n        remaining_entries.append(entry)\n\n    bundle.entry = remaining_entries\n    return extracted\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.get_resource_type","title":"<code>get_resource_type(resource_type)</code>","text":"<p>Get the resource type class from string or type.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>Type[Resource]</code> <p>The resource type class</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the resource type is not supported or cannot be imported</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def get_resource_type(resource_type: Union[str, Type[Resource]]) -&gt; Type[Resource]:\n    \"\"\"Get the resource type class from string or type.\n\n    Args:\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n\n    Returns:\n        The resource type class\n\n    Raises:\n        ValueError: If the resource type is not supported or cannot be imported\n    \"\"\"\n    if isinstance(resource_type, type) and issubclass(resource_type, Resource):\n        return resource_type\n\n    if not isinstance(resource_type, str):\n        raise ValueError(\n            f\"Resource type must be a string or Resource class, got {type(resource_type)}\"\n        )\n\n    try:\n        # Try to import the resource type dynamically from fhir.resources\n        module = __import__(\n            f\"fhir.resources.{resource_type.lower()}\", fromlist=[resource_type]\n        )\n        return getattr(module, resource_type)\n    except (ImportError, AttributeError) as e:\n        raise ValueError(\n            f\"Could not import resource type: {resource_type}. \"\n            \"Make sure it is a valid FHIR resource type.\"\n        ) from e\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.get_resources","title":"<code>get_resources(bundle, resource_type)</code>","text":"<p>Get all resources of a specific type from a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to search</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List of resources of the specified type</p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def get_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Get all resources of a specific type from a bundle.\n\n    Args:\n        bundle: The bundle to search\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n\n    Returns:\n        List of resources of the specified type\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Using string identifier\n        &gt;&gt;&gt; conditions = get_resources(bundle, \"Condition\")\n        &gt;&gt;&gt; medications = get_resources(bundle, \"MedicationStatement\")\n        &gt;&gt;&gt; allergies = get_resources(bundle, \"AllergyIntolerance\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; conditions = get_resources(bundle, Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n    return [\n        entry.resource\n        for entry in (bundle.entry or [])\n        if isinstance(entry.resource, type_class)\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.get_resources--using-string-identifier","title":"Using string identifier","text":"<p>conditions = get_resources(bundle, \"Condition\") medications = get_resources(bundle, \"MedicationStatement\") allergies = get_resources(bundle, \"AllergyIntolerance\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.get_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition conditions = get_resources(bundle, Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.merge_bundles","title":"<code>merge_bundles(bundles, bundle_type='collection', deduplicate=False, dedupe_key='id')</code>","text":"<p>Merge multiple FHIR bundles into a single bundle.</p> <p>Combines entries from multiple bundles while preserving resource metadata. Useful for aggregating search results from multiple FHIR sources.</p> PARAMETER DESCRIPTION <code>bundles</code> <p>List of bundles to merge</p> <p> TYPE: <code>List[Bundle]</code> </p> <code>bundle_type</code> <p>Type for the merged bundle (default: \"collection\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> <code>deduplicate</code> <p>If True, remove duplicate resources based on dedupe_key</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>dedupe_key</code> <p>Resource attribute to use for deduplication (default: \"id\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'id'</code> </p> RETURNS DESCRIPTION <code>Bundle</code> <p>A new bundle containing all entries from input bundles</p> Example Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def merge_bundles(\n    bundles: List[Bundle],\n    bundle_type: str = \"collection\",\n    deduplicate: bool = False,\n    dedupe_key: str = \"id\",\n) -&gt; Bundle:\n    \"\"\"Merge multiple FHIR bundles into a single bundle.\n\n    Combines entries from multiple bundles while preserving resource metadata.\n    Useful for aggregating search results from multiple FHIR sources.\n\n    Args:\n        bundles: List of bundles to merge\n        bundle_type: Type for the merged bundle (default: \"collection\")\n        deduplicate: If True, remove duplicate resources based on dedupe_key\n        dedupe_key: Resource attribute to use for deduplication (default: \"id\")\n\n    Returns:\n        A new bundle containing all entries from input bundles\n\n    Example:\n        &gt;&gt;&gt; # Merge search results from multiple sources\n        &gt;&gt;&gt; epic_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"epic\")\n        &gt;&gt;&gt; cerner_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"cerner\")\n        &gt;&gt;&gt; merged = merge_bundles([epic_bundle, cerner_bundle], deduplicate=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Use in Document workflow\n        &gt;&gt;&gt; doc = Document(data=merged)\n        &gt;&gt;&gt; doc.fhir.bundle  # Contains all conditions from both sources\n    \"\"\"\n    merged = create_bundle(bundle_type=bundle_type)\n\n    if deduplicate:\n        # Track seen resources by dedupe_key to avoid duplicates\n        seen_keys = set()\n\n        for bundle in bundles:\n            if not bundle or not bundle.entry:\n                continue\n\n            for entry in bundle.entry:\n                if not entry.resource:\n                    continue\n\n                # Get the deduplication key value\n                key_value = getattr(entry.resource, dedupe_key, None)\n\n                # Skip if we've seen this key before\n                if key_value and key_value in seen_keys:\n                    continue\n\n                # Add to merged bundle and track the key\n                add_resource(merged, entry.resource, entry.fullUrl)\n                if key_value:\n                    seen_keys.add(key_value)\n    else:\n        # No deduplication - just merge all entries\n        for bundle in bundles:\n            if not bundle or not bundle.entry:\n                continue\n\n            for entry in bundle.entry:\n                if entry.resource:\n                    add_resource(merged, entry.resource, entry.fullUrl)\n\n    return merged\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.merge_bundles--merge-search-results-from-multiple-sources","title":"Merge search results from multiple sources","text":"<p>epic_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"epic\") cerner_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"cerner\") merged = merge_bundles([epic_bundle, cerner_bundle], deduplicate=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.merge_bundles--use-in-document-workflow","title":"Use in Document workflow","text":"<p>doc = Document(data=merged) doc.fhir.bundle  # Contains all conditions from both sources</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.set_resources","title":"<code>set_resources(bundle, resources, resource_type, replace=True)</code>","text":"<p>Set resources of a specific type in the bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to modify</p> <p> TYPE: <code>Bundle</code> </p> <code>resources</code> <p>The new resources to add</p> <p> TYPE: <code>List[Resource]</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> <code>replace</code> <p>If True, remove existing resources of this type before adding new ones.     If False, append new resources to existing ones. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundle_helpers.py</code> <pre><code>def set_resources(\n    bundle: Bundle,\n    resources: List[Resource],\n    resource_type: Union[str, Type[Resource]],\n    replace: bool = True,\n) -&gt; None:\n    \"\"\"Set resources of a specific type in the bundle.\n\n    Args:\n        bundle: The bundle to modify\n        resources: The new resources to add\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n        replace: If True, remove existing resources of this type before adding new ones.\n                If False, append new resources to existing ones. Defaults to True.\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Append to existing resources (default behavior)\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], \"Condition\")\n        &gt;&gt;&gt; set_resources(bundle, [medication1], \"MedicationStatement\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Replace existing resources\n        &gt;&gt;&gt; set_resources(bundle, [condition3], \"Condition\", replace=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n\n    # Remove existing resources of this type if replace=True\n    if replace:\n        bundle.entry = [\n            entry\n            for entry in (bundle.entry or [])\n            if not isinstance(entry.resource, type_class)\n        ]\n\n    # Add new resources\n    for resource in resources:\n        if not isinstance(resource, type_class):\n            raise ValueError(\n                f\"Resource must be of type {type_class.__name__}, \"\n                f\"got {type(resource).__name__}\"\n            )\n        add_resource(bundle, resource)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.set_resources--append-to-existing-resources-default-behavior","title":"Append to existing resources (default behavior)","text":"<p>set_resources(bundle, [condition1, condition2], \"Condition\") set_resources(bundle, [medication1], \"MedicationStatement\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.set_resources--replace-existing-resources","title":"Replace existing resources","text":"<p>set_resources(bundle, [condition3], \"Condition\", replace=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_helpers.set_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition set_resources(bundle, [condition1, condition2], Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers","title":"<code>helpers</code>","text":"<p>Convenience functions for creating minimal FHIR resources. Patterns: - create_(): create a new FHIR resource with sensible defaults - useful for dev, use with caution - add_(): add data to resources with list fields safely (e.g. coding) - set_(): set the field of specific resources with soft validation (e.g. category) - read_(): return a human readable format of the data in a resource (e.g. attachments)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.add_coding_to_codeable_concept","title":"<code>add_coding_to_codeable_concept(codeable_concept, code, system, display=None)</code>","text":"<p>Add a coding to an existing CodeableConcept.</p> <p>Useful for adding standardized codes (e.g., SNOMED CT) to resources that already have codes from other systems (e.g., ICD-10).</p> PARAMETER DESCRIPTION <code>codeable_concept</code> <p>The CodeableConcept to add coding to</p> <p> TYPE: <code>CodeableConcept</code> </p> <code>code</code> <p>The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>system</code> <p>The code system URI</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>Optional display text for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>The updated CodeableConcept with the new coding added</p> <p> TYPE: <code>CodeableConcept</code> </p> Example Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def add_coding_to_codeable_concept(\n    codeable_concept: CodeableConcept,\n    code: str,\n    system: str,\n    display: Optional[str] = None,\n) -&gt; CodeableConcept:\n    \"\"\"Add a coding to an existing CodeableConcept.\n\n    Useful for adding standardized codes (e.g., SNOMED CT) to resources that already\n    have codes from other systems (e.g., ICD-10).\n\n    Args:\n        codeable_concept: The CodeableConcept to add coding to\n        code: The code value from the code system\n        system: The code system URI\n        display: Optional display text for the code\n\n    Returns:\n        CodeableConcept: The updated CodeableConcept with the new coding added\n\n    Example:\n        &gt;&gt;&gt; # Add SNOMED CT code to a condition that has ICD-10\n        &gt;&gt;&gt; condition_code = condition.code\n        &gt;&gt;&gt; condition_code = add_coding_to_codeable_concept(\n        ...     condition_code,\n        ...     code=\"44054006\",\n        ...     system=\"http://snomed.info/sct\",\n        ...     display=\"Type 2 diabetes mellitus\"\n        ... )\n    \"\"\"\n    if not codeable_concept.coding:\n        codeable_concept.coding = []\n\n    codeable_concept.coding.append(Coding(system=system, code=code, display=display))\n\n    return codeable_concept\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.add_coding_to_codeable_concept--add-snomed-ct-code-to-a-condition-that-has-icd-10","title":"Add SNOMED CT code to a condition that has ICD-10","text":"<p>condition_code = condition.code condition_code = add_coding_to_codeable_concept( ...     condition_code, ...     code=\"44054006\", ...     system=\"http://snomed.info/sct\", ...     display=\"Type 2 diabetes mellitus\" ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.add_provenance_metadata","title":"<code>add_provenance_metadata(resource, source, tag_code=None, tag_display=None)</code>","text":"<p>Add provenance metadata to a FHIR resource.</p> <p>Adds source system identifier, timestamp, and optional processing tags to track data lineage and transformations for audit trails.</p> PARAMETER DESCRIPTION <code>resource</code> <p>The FHIR resource to annotate</p> <p> TYPE: <code>Resource</code> </p> <code>source</code> <p>Name of the source system (e.g., \"epic\", \"cerner\")</p> <p> TYPE: <code>str</code> </p> <code>tag_code</code> <p>Optional tag code for processing operations (e.g., \"aggregated\", \"deduplicated\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>tag_display</code> <p>Optional display text for the tag</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Resource</code> <p>The resource with added provenance metadata</p> <p> TYPE: <code>Resource</code> </p> Example <p>condition = create_condition(subject=\"Patient/123\", code=\"E11.9\") condition = add_provenance_metadata(condition, \"epic\", \"aggregated\", \"Aggregated from source\")</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def add_provenance_metadata(\n    resource: Resource,\n    source: str,\n    tag_code: Optional[str] = None,\n    tag_display: Optional[str] = None,\n) -&gt; Resource:\n    \"\"\"Add provenance metadata to a FHIR resource.\n\n    Adds source system identifier, timestamp, and optional processing tags to track\n    data lineage and transformations for audit trails.\n\n    Args:\n        resource: The FHIR resource to annotate\n        source: Name of the source system (e.g., \"epic\", \"cerner\")\n        tag_code: Optional tag code for processing operations (e.g., \"aggregated\", \"deduplicated\")\n        tag_display: Optional display text for the tag\n\n    Returns:\n        Resource: The resource with added provenance metadata\n\n    Example:\n        &gt;&gt;&gt; condition = create_condition(subject=\"Patient/123\", code=\"E11.9\")\n        &gt;&gt;&gt; condition = add_provenance_metadata(condition, \"epic\", \"aggregated\", \"Aggregated from source\")\n    \"\"\"\n    if not resource.meta:\n        resource.meta = Meta()\n\n    # Add source system identifier\n    resource.meta.source = f\"urn:healthchain:source:{source}\"\n\n    # Update timestamp\n    resource.meta.lastUpdated = datetime.datetime.now(datetime.timezone.utc).isoformat()\n\n    # Add processing tag if provided\n    if tag_code:\n        if not resource.meta.tag:\n            resource.meta.tag = []\n\n        resource.meta.tag.append(\n            Coding(\n                system=\"https://dotimplement.github.io/HealthChain/fhir/tags\",\n                code=tag_code,\n                display=tag_display or tag_code,\n            )\n        )\n\n    return resource\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_allergy_intolerance","title":"<code>create_allergy_intolerance(patient, code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal active FHIR AllergyIntolerance. If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly. https://build.fhir.org/allergyintolerance.html</p> PARAMETER DESCRIPTION <code>patient</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>code</code> <p>The allergen code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the allergen</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>AllergyIntolerance</code> <p>A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>AllergyIntolerance</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_allergy_intolerance(\n    patient: str,\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; AllergyIntolerance:\n    \"\"\"\n    Create a minimal active FHIR AllergyIntolerance.\n    If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly.\n    https://build.fhir.org/allergyintolerance.html\n\n    Args:\n        patient: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        code: The allergen code\n        display: The display name for the allergen\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        AllergyIntolerance: A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        allergy_code = create_single_codeable_concept(code, display, system)\n    else:\n        allergy_code = None\n\n    allergy = AllergyIntolerance(\n        id=_generate_id(),\n        patient=Reference(reference=patient),\n        code=allergy_code,\n    )\n\n    return allergy\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_condition","title":"<code>create_condition(subject, clinical_status='active', code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal active FHIR Condition. If you need to create a more complex condition, use the FHIR Condition resource directly. https://build.fhir.org/condition.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>clinical_status</code> <p>REQUIRED. Clinical status (default: active)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'active'</code> </p> <code>code</code> <p>The condition code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the condition</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Condition</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_condition(\n    subject: str,\n    clinical_status: str = \"active\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; Condition:\n    \"\"\"\n    Create a minimal active FHIR Condition.\n    If you need to create a more complex condition, use the FHIR Condition resource directly.\n    https://build.fhir.org/condition.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        clinical_status: REQUIRED. Clinical status (default: active)\n        code: The condition code\n        display: The display name for the condition\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        Condition: A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        condition_code = create_single_codeable_concept(code, display, system)\n    else:\n        condition_code = None\n\n    condition = Condition(\n        id=_generate_id(),\n        subject=Reference(reference=subject),\n        clinicalStatus=create_single_codeable_concept(\n            code=clinical_status,\n            display=clinical_status.capitalize(),\n            system=\"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n        ),\n        code=condition_code,\n    )\n\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_document_reference","title":"<code>create_document_reference(data=None, url=None, content_type=None, status='current', description='DocumentReference created by HealthChain', attachment_title='Attachment created by HealthChain')</code>","text":"<p>Create a minimal FHIR DocumentReference. If you need to create a more complex document reference, use the FHIR DocumentReference resource directly. https://build.fhir.org/documentreference.html</p> PARAMETER DESCRIPTION <code>data</code> <p>The data content of the document attachment</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>URL where the document can be accessed</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content_type</code> <p>MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>REQUIRED. Status of the document reference (default: current)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>description</code> <p>Description of the document reference</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'DocumentReference created by HealthChain'</code> </p> <code>attachment_title</code> <p>Title for the document attachment</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> RETURNS DESCRIPTION <code>DocumentReference</code> <p>A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>DocumentReference</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_document_reference(\n    data: Optional[Any] = None,\n    url: Optional[str] = None,\n    content_type: Optional[str] = None,\n    status: str = \"current\",\n    description: Optional[str] = \"DocumentReference created by HealthChain\",\n    attachment_title: Optional[str] = \"Attachment created by HealthChain\",\n) -&gt; DocumentReference:\n    \"\"\"\n    Create a minimal FHIR DocumentReference.\n    If you need to create a more complex document reference, use the FHIR DocumentReference resource directly.\n    https://build.fhir.org/documentreference.html\n\n    Args:\n        data: The data content of the document attachment\n        url: URL where the document can be accessed\n        content_type: MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")\n        status: REQUIRED. Status of the document reference (default: current)\n        description: Description of the document reference\n        attachment_title: Title for the document attachment\n\n    Returns:\n        DocumentReference: A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    document_reference = DocumentReference(\n        id=_generate_id(),\n        status=status,\n        date=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n        description=description,\n        content=[\n            {\n                \"attachment\": create_single_attachment(\n                    content_type=content_type,\n                    data=data,\n                    url=url,\n                    title=attachment_title,\n                )\n            }\n        ],\n    )\n\n    return document_reference\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_medication_statement","title":"<code>create_medication_statement(subject, status='recorded', code=None, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal recorded FHIR MedicationStatement. If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly. https://build.fhir.org/medicationstatement.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>status</code> <p>REQUIRED. Status of the medication (default: recorded)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'recorded'</code> </p> <code>code</code> <p>The medication code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the medication</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>MedicationStatement</code> <p>A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>MedicationStatement</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_medication_statement(\n    subject: str,\n    status: Optional[str] = \"recorded\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; MedicationStatement:\n    \"\"\"\n    Create a minimal recorded FHIR MedicationStatement.\n    If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly.\n    https://build.fhir.org/medicationstatement.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        status: REQUIRED. Status of the medication (default: recorded)\n        code: The medication code\n        display: The display name for the medication\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        MedicationStatement: A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    if code:\n        medication_concept = create_single_codeable_concept(code, display, system)\n    else:\n        medication_concept = None\n\n    medication = MedicationStatement(\n        id=_generate_id(),\n        subject=Reference(reference=subject),\n        status=status,\n        medication={\"concept\": medication_concept},\n    )\n\n    return medication\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_resource_from_dict","title":"<code>create_resource_from_dict(resource_dict, resource_type)</code>","text":"<p>Create a FHIR resource instance from a dictionary</p> PARAMETER DESCRIPTION <code>resource_dict</code> <p>Dictionary representation of the resource</p> <p> TYPE: <code>Dict</code> </p> <code>resource_type</code> <p>Type of FHIR resource to create</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Resource]</code> <p>Optional[Resource]: FHIR resource instance or None if creation failed</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_resource_from_dict(\n    resource_dict: Dict, resource_type: str\n) -&gt; Optional[Resource]:\n    \"\"\"Create a FHIR resource instance from a dictionary\n\n    Args:\n        resource_dict: Dictionary representation of the resource\n        resource_type: Type of FHIR resource to create\n\n    Returns:\n        Optional[Resource]: FHIR resource instance or None if creation failed\n    \"\"\"\n    try:\n        resource_module = importlib.import_module(\n            f\"fhir.resources.{resource_type.lower()}\"\n        )\n        resource_class = getattr(resource_module, resource_type)\n        return resource_class(**resource_dict)\n    except Exception as e:\n        logger.error(f\"Failed to create FHIR resource: {str(e)}\")\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_single_attachment","title":"<code>create_single_attachment(content_type=None, data=None, url=None, title='Attachment created by HealthChain')</code>","text":"<p>Create a minimal FHIR Attachment.</p> <p>Creates a FHIR Attachment resource with basic fields. Either data or url should be provided. If data is provided, it will be base64 encoded.</p> PARAMETER DESCRIPTION <code>content_type</code> <p>The MIME type of the content</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>data</code> <p>The actual data content to be base64 encoded</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>The URL where the data can be found</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>A title for the attachment (default: \"Attachment created by HealthChain\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> RETURNS DESCRIPTION <code>Attachment</code> <p>A FHIR Attachment resource with basic metadata and content</p> <p> TYPE: <code>Attachment</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_attachment(\n    content_type: Optional[str] = None,\n    data: Optional[str] = None,\n    url: Optional[str] = None,\n    title: Optional[str] = \"Attachment created by HealthChain\",\n) -&gt; Attachment:\n    \"\"\"Create a minimal FHIR Attachment.\n\n    Creates a FHIR Attachment resource with basic fields. Either data or url should be provided.\n    If data is provided, it will be base64 encoded.\n\n    Args:\n        content_type: The MIME type of the content\n        data: The actual data content to be base64 encoded\n        url: The URL where the data can be found\n        title: A title for the attachment (default: \"Attachment created by HealthChain\")\n\n    Returns:\n        Attachment: A FHIR Attachment resource with basic metadata and content\n    \"\"\"\n\n    if not data and not url:\n        logger.warning(\"No data or url provided for attachment\")\n\n    if data:\n        data = base64.b64encode(data.encode(\"utf-8\")).decode(\"utf-8\")\n\n    return Attachment(\n        contentType=content_type,\n        data=data,\n        url=url,\n        title=title,\n        creation=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n    )\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_single_codeable_concept","title":"<code>create_single_codeable_concept(code, display=None, system='http://snomed.info/sct')</code>","text":"<p>Create a minimal FHIR CodeableConcept with a single coding.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>A FHIR CodeableConcept resource with a single coding</p> <p> TYPE: <code>CodeableConcept</code> </p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_codeable_concept(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n) -&gt; CodeableConcept:\n    \"\"\"\n    Create a minimal FHIR CodeableConcept with a single coding.\n\n    Args:\n        code: REQUIRED. The code value from the code system\n        display: The display name for the code\n        system: The code system (default: SNOMED CT)\n\n    Returns:\n        CodeableConcept: A FHIR CodeableConcept resource with a single coding\n    \"\"\"\n    return CodeableConcept(coding=[Coding(system=system, code=code, display=display)])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.create_single_reaction","title":"<code>create_single_reaction(code, display=None, system='http://snomed.info/sct', severity=None)</code>","text":"<p>Create a minimal FHIR Reaction with a single coding.</p> <p>Creates a FHIR Reaction object with a single manifestation coding. The manifestation describes the clinical reaction that was observed. The severity indicates how severe the reaction was.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system representing the reaction manifestation</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the manifestation code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system for the manifestation code (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>severity</code> <p>The severity of the reaction (mild, moderate, severe)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>A list containing a single FHIR Reaction dictionary with manifestation and severity fields</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def create_single_reaction(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    severity: Optional[str] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create a minimal FHIR Reaction with a single coding.\n\n    Creates a FHIR Reaction object with a single manifestation coding. The manifestation\n    describes the clinical reaction that was observed. The severity indicates how severe\n    the reaction was.\n\n    Args:\n        code: REQUIRED. The code value from the code system representing the reaction manifestation\n        display: The display name for the manifestation code\n        system: The code system for the manifestation code (default: SNOMED CT)\n        severity: The severity of the reaction (mild, moderate, severe)\n\n    Returns:\n        A list containing a single FHIR Reaction dictionary with manifestation and severity fields\n    \"\"\"\n    return [\n        {\n            \"manifestation\": [\n                CodeableReference(\n                    concept=CodeableConcept(\n                        coding=[Coding(system=system, code=code, display=display)]\n                    )\n                )\n            ],\n            \"severity\": severity,\n        }\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.read_content_attachment","title":"<code>read_content_attachment(document_reference, include_data=True)</code>","text":"<p>Read the attachments in a human readable format from a FHIR DocumentReference content field.</p> PARAMETER DESCRIPTION <code>document_reference</code> <p>The FHIR DocumentReference resource</p> <p> TYPE: <code>DocumentReference</code> </p> <code>include_data</code> <p>Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[List[Dict[str, Any]]]</code> <p>Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata, or None if no attachments are found: [     {         \"data\": str,         \"metadata\": Dict[str, Any]     } ]</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def read_content_attachment(\n    document_reference: DocumentReference,\n    include_data: bool = True,\n) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"Read the attachments in a human readable format from a FHIR DocumentReference content field.\n\n    Args:\n        document_reference: The FHIR DocumentReference resource\n        include_data: Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)\n\n    Returns:\n        Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata,\n            or None if no attachments are found:\n            [\n                {\n                    \"data\": str,\n                    \"metadata\": Dict[str, Any]\n                }\n            ]\n    \"\"\"\n    if not document_reference.content:\n        return None\n\n    attachments = []\n    for content in document_reference.content:\n        attachment = content.attachment\n        result = {}\n\n        if include_data:\n            result[\"data\"] = (\n                attachment.url if attachment.url else attachment.data.decode(\"utf-8\")\n            )\n\n        result[\"metadata\"] = {\n            \"content_type\": attachment.contentType,\n            \"title\": attachment.title,\n            \"creation\": attachment.creation,\n        }\n\n        attachments.append(result)\n\n    return attachments\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.helpers.set_condition_category","title":"<code>set_condition_category(condition, category)</code>","text":"<p>Set the category of a FHIR Condition to either 'problem-list-item' or 'encounter-diagnosis'.</p> PARAMETER DESCRIPTION <code>condition</code> <p>The FHIR Condition resource to modify</p> <p> TYPE: <code>Condition</code> </p> <code>category</code> <p>The category to set. Must be 'problem-list-item' or 'encounter-diagnosis'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>The modified FHIR Condition resource with the specified category set</p> <p> TYPE: <code>Condition</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the category is not one of the allowed values.</p> Source code in <code>healthchain/fhir/helpers.py</code> <pre><code>def set_condition_category(condition: Condition, category: str) -&gt; Condition:\n    \"\"\"\n    Set the category of a FHIR Condition to either 'problem-list-item' or 'encounter-diagnosis'.\n\n    Args:\n        condition: The FHIR Condition resource to modify\n        category: The category to set. Must be 'problem-list-item' or 'encounter-diagnosis'.\n\n    Returns:\n        Condition: The modified FHIR Condition resource with the specified category set\n\n    Raises:\n        ValueError: If the category is not one of the allowed values.\n    \"\"\"\n    allowed_categories = {\n        \"problem-list-item\": {\n            \"code\": \"problem-list-item\",\n            \"display\": \"Problem List Item\",\n        },\n        \"encounter-diagnosis\": {\n            \"code\": \"encounter-diagnosis\",\n            \"display\": \"Encounter Diagnosis\",\n        },\n    }\n    if category not in allowed_categories:\n        raise ValueError(\n            f\"Invalid category '{category}'. Must be one of: {list(allowed_categories.keys())}\"\n        )\n\n    cat_info = allowed_categories[category]\n    condition.category = [\n        create_single_codeable_concept(\n            code=cat_info[\"code\"],\n            display=cat_info[\"display\"],\n            system=\"http://terminology.hl7.org/CodeSystem/condition-category\",\n        )\n    ]\n    return condition\n</code></pre>"},{"location":"api/interop/","title":"Interoperability Engine","text":"<p>InteropConfigManager for HealthChain Interoperability Engine</p> <p>This module provides specialized configuration management for interoperability.</p> <p>CDA Parser for HealthChain Interoperability Engine</p> <p>This module provides functionality for parsing CDA XML documents.</p> <p>CDA Generator for HealthChain Interoperability Engine</p> <p>This module provides functionality for generating CDA documents.</p> <p>FHIR Generator for HealthChain Interoperability Engine</p> <p>This module provides functionality for generating FHIR resources from templates.</p> <p>Configuration validators for HealthChain</p> <p>This module provides validation models and utilities for configuration files.</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine","title":"<code>InteropEngine</code>","text":"<p>Generic interoperability engine for converting between healthcare formats</p> <p>The InteropEngine provides capabilities for converting between different healthcare data format standards, such as HL7 FHIR, CDA, and HL7v2.</p> <p>The engine uses a template-based approach for transformations, with templates stored in the configured template directory. Transformations are handled by format-specific parsers and generators that are lazily loaded as needed.</p> <p>Configuration is handled through the <code>config</code> property, which provides direct access to the underlying ConfigManager instance. This allows for setting validation levels, changing environments, and accessing configuration values.</p> <p>The engine supports registering custom parsers, generators, and validators to extend or override the default functionality.</p> Example <p>engine = InteropEngine()</p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>class InteropEngine:\n    \"\"\"Generic interoperability engine for converting between healthcare formats\n\n    The InteropEngine provides capabilities for converting between different\n    healthcare data format standards, such as HL7 FHIR, CDA, and HL7v2.\n\n    The engine uses a template-based approach for transformations, with templates\n    stored in the configured template directory. Transformations are handled by\n    format-specific parsers and generators that are lazily loaded as needed.\n\n    Configuration is handled through the `config` property, which provides\n    direct access to the underlying ConfigManager instance. This allows\n    for setting validation levels, changing environments, and accessing\n    configuration values.\n\n    The engine supports registering custom parsers, generators, and validators\n    to extend or override the default functionality.\n\n    Example:\n        engine = InteropEngine()\n\n        # Convert CDA to FHIR\n        fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")\n\n        # Convert FHIR to CDA\n        cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")\n\n        # Access config directly:\n        engine.config.set_environment(\"production\")\n        engine.config.set_validation_level(\"warn\")\n        value = engine.config.get_config_value(\"cda.sections.problems.resource\")\n\n        # Access the template registry:\n        template = engine.template_registry.get_template(\"cda_fhir/condition\")\n        engine.template_registry.add_filter()\n\n        # Register custom components:\n        engine.register_parser(FormatType.CDA, custom_parser)\n        engine.register_generator(FormatType.FHIR, custom_generator)\n\n        # Register custom configuration validators:\n        engine.register_cda_section_config_validator(\"Procedure\", ProcedureSectionConfig)\n        engine.register_cda_document_config_validator(\"CCD\", CCDDocumentConfig)\n    \"\"\"\n\n    def __init__(\n        self,\n        config_dir: Optional[Path] = None,\n        validation_level: str = ValidationLevel.STRICT,\n        environment: Optional[str] = None,\n    ):\n        \"\"\"Initialize the InteropEngine\n\n        Args:\n            config_dir: Base directory containing configuration files. If None, will search standard locations.\n            validation_level: Level of configuration validation (strict, warn, ignore)\n            environment: Optional environment to use (development, testing, production)\n        \"\"\"\n        # Initialize configuration manager\n        self.config = InteropConfigManager(config_dir, validation_level, environment)\n\n        # Initialize template registry\n        template_dir = config_dir / \"templates\"\n        self.template_registry = TemplateRegistry(template_dir)\n\n        # Create and register default filters\n        # Get required configuration for filters\n        mappings_dir = self.config.get_config_value(\"defaults.mappings_dir\")\n        if not mappings_dir:\n            log.warning(\"No mappings directory configured, using default mappings\")\n            mappings_dir = \"cda_default\"\n        mappings = self.config.get_mappings(mappings_dir)\n        id_prefix = self.config.get_config_value(\"defaults.common.id_prefix\")\n\n        # Get default filters from the filters module\n        default_filters = create_default_filters(mappings, id_prefix)\n        self.template_registry.initialize(default_filters)\n\n        # Component registries for lazy loading\n        self._parsers = {}\n        self._generators = {}\n\n    # Lazy-loaded parsers\n    @cached_property\n    def cda_parser(self):\n        \"\"\"Lazily load the CDA parser\"\"\"\n        return self._get_parser(FormatType.CDA)\n\n    @cached_property\n    def hl7v2_parser(self):\n        \"\"\"Lazily load the HL7v2 parser\"\"\"\n        return self._get_parser(FormatType.HL7V2)\n\n    # Lazy-loaded generators\n    @cached_property\n    def cda_generator(self):\n        \"\"\"Lazily load the CDA generator\"\"\"\n        return self._get_generator(FormatType.CDA)\n\n    @cached_property\n    def fhir_generator(self):\n        \"\"\"Lazily load the FHIR generator\"\"\"\n        return self._get_generator(FormatType.FHIR)\n\n    @cached_property\n    def hl7v2_generator(self):\n        \"\"\"Lazily load the HL7v2 generator\"\"\"\n        return self._get_generator(FormatType.HL7V2)\n\n    def _get_parser(self, format_type: FormatType):\n        \"\"\"Get or create a parser for the specified format\n\n        Args:\n            format_type: The format type to get a parser for (CDA or HL7v2)\n\n        Returns:\n            The parser instance for the specified format\n\n        Raises:\n            ValueError: If an unsupported format type is provided\n        \"\"\"\n        if format_type not in self._parsers:\n            if format_type == FormatType.CDA:\n                parser = CDAParser(self.config)\n                self._parsers[format_type] = parser\n            elif format_type == FormatType.HL7V2:\n                raise NotImplementedError(\"HL7v2 parser not implemented\")\n            else:\n                raise ValueError(f\"Unsupported parser format: {format_type}\")\n\n        return self._parsers[format_type]\n\n    def _get_generator(self, format_type: FormatType):\n        \"\"\"Get or create a generator for the specified format\n\n        Args:\n            format_type: The format type to get a generator for (CDA, HL7v2, or FHIR)\n\n        Returns:\n            The generator instance for the specified format\n\n        Raises:\n            ValueError: If an unsupported format type is provided\n        \"\"\"\n        if format_type not in self._generators:\n            if format_type == FormatType.CDA:\n                generator = CDAGenerator(self.config, self.template_registry)\n                self._generators[format_type] = generator\n            elif format_type == FormatType.HL7V2:\n                raise NotImplementedError(\"HL7v2 generator not implemented\")\n            elif format_type == FormatType.FHIR:\n                generator = FHIRGenerator(self.config, self.template_registry)\n                self._generators[format_type] = generator\n            else:\n                raise ValueError(f\"Unsupported generator format: {format_type}\")\n\n        return self._generators[format_type]\n\n    def register_parser(\n        self, format_type: FormatType, parser_instance: BaseParser\n    ) -&gt; \"InteropEngine\":\n        \"\"\"Register a custom parser for a format type. This will replace the default parser for the format type.\n\n        Args:\n            format_type: The format type (CDA, HL7v2) to register the parser for\n            parser_instance: The parser instance that implements the parsing logic\n\n        Returns:\n            InteropEngine: Returns self for method chaining\n\n        Example:\n            engine.register_parser(FormatType.CDA, CustomCDAParser())\n        \"\"\"\n        self._parsers[format_type] = parser_instance\n        return self\n\n    def register_generator(\n        self, format_type: FormatType, generator_instance: BaseGenerator\n    ) -&gt; \"InteropEngine\":\n        \"\"\"Register a custom generator for a format type. This will replace the default generator for the format type.\n\n        Args:\n            format_type: The format type (CDA, HL7v2, FHIR) to register the generator for\n            generator_instance: The generator instance that implements the generation logic\n\n        Returns:\n            InteropEngine: Returns self for method chaining\n\n        Example:\n            engine.register_generator(FormatType.CDA, CustomCDAGenerator())\n        \"\"\"\n        self._generators[format_type] = generator_instance\n        return self\n\n    # TODO: make the config validator functions more generic\n    def register_cda_section_config_validator(\n        self, resource_type: str, template_model: BaseModel\n    ) -&gt; \"InteropEngine\":\n        \"\"\"Register a custom section config validator model for a resource type\n\n        Args:\n            resource_type: FHIR resource type (e.g., \"Condition\", \"MedicationStatement\") which converts to the CDA section\n            template_model: Pydantic model for CDA section config validation\n\n        Returns:\n            Self for method chaining\n\n        Example:\n            # Register a config validator for the Problem section, which is converted from the Condition resource\n            engine.register_cda_section_config_validator(\n                \"Condition\", ProblemSectionConfig\n            )\n        \"\"\"\n        self.config.register_cda_section_config(resource_type, template_model)\n        return self\n\n    def register_cda_document_config_validator(\n        self, document_type: str, document_model: BaseModel\n    ) -&gt; \"InteropEngine\":\n        \"\"\"Register a custom document validator model for a document type\n\n        Args:\n            document_type: Document type (e.g., \"ccd\", \"discharge\")\n            document_model: Pydantic model for document validation\n\n        Returns:\n            Self for method chaining\n\n        Example:\n            # Register a config validator for the CCD document type\n            engine.register_cda_document_validator(\n                \"ccd\", CCDDocumentConfig\n            )\n        \"\"\"\n        self.config.register_cda_document_config(document_type, document_model)\n        return self\n\n    def to_fhir(\n        self, src_data: str, src_format: Union[str, FormatType]\n    ) -&gt; List[Resource]:\n        \"\"\"Convert source data to FHIR resources\n\n        Args:\n            src_data: Input data as string (CDA XML or HL7v2 message)\n            src_format: Source format type, either as string (\"cda\", \"hl7v2\")\n                         or FormatType enum\n\n        Returns:\n            List[Resource]: List of FHIR resources generated from the source data\n\n        Raises:\n            ValueError: If src_format is not supported\n\n        Example:\n            # Convert CDA XML to FHIR resources\n            fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")\n        \"\"\"\n        src_format = validate_format(src_format)\n\n        if src_format == FormatType.CDA:\n            return self._cda_to_fhir(src_data)\n        elif src_format == FormatType.HL7V2:\n            return self._hl7v2_to_fhir(src_data)\n        else:\n            raise ValueError(f\"Unsupported format: {src_format}\")\n\n    def from_fhir(\n        self,\n        resources: Union[List[Resource], Bundle],\n        dest_format: Union[str, FormatType],\n        **kwargs: Any,\n    ) -&gt; str:\n        \"\"\"Convert FHIR resources to a target format\n\n        Args:\n            resources: List of FHIR resources to convert or a FHIR Bundle\n            dest_format: Destination format type, either as string (\"cda\", \"hl7v2\")\n                        or FormatType enum\n            **kwargs: Additional arguments to pass to generator.\n                     For CDA: document_type (str) - Type of CDA document (e.g. \"ccd\", \"discharge\")\n\n        Returns:\n            str: Converted data as string (CDA XML or HL7v2 message)\n\n        Raises:\n            ValueError: If dest_format is not supported\n\n        Example:\n            # Convert FHIR resources to CDA XML\n            cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")\n        \"\"\"\n        dest_format = validate_format(dest_format)\n        resources = normalize_resource_list(resources)\n\n        if dest_format == FormatType.HL7V2:\n            return self._fhir_to_hl7v2(resources, **kwargs)\n        elif dest_format == FormatType.CDA:\n            return self._fhir_to_cda(resources, **kwargs)\n        else:\n            raise ValueError(f\"Unsupported format: {dest_format}\")\n\n    def _cda_to_fhir(self, xml: str, **kwargs) -&gt; List[Resource]:\n        \"\"\"Convert CDA XML to FHIR resources\n\n        Args:\n            xml: CDA document as XML string\n            **kwargs: Additional arguments to pass to parser and generator.\n\n        Returns:\n            List[Resource]: List of FHIR resources\n\n        Raises:\n            ValueError: If required mappings are missing or if sections are unsupported\n        \"\"\"\n        # Get parser and generator (lazy loaded)\n        parser = self.cda_parser\n        generator = self.fhir_generator\n\n        # Parse sections from CDA XML using the parser\n        section_entries = parser.from_string(xml)\n\n        # Process each section and convert entries to FHIR resources\n        resources = []\n        for section_key, entries in section_entries.items():\n            section_resources = generator.transform(\n                entries, src_format=FormatType.CDA, section_key=section_key\n            )\n            resources.extend(section_resources)\n\n        return resources\n\n    def _fhir_to_cda(self, resources: List[Resource], **kwargs) -&gt; str:\n        \"\"\"Convert FHIR resources to CDA XML\n\n        Args:\n            resources: A list of FHIR resources\n            **kwargs: Additional arguments to pass to generator.\n                     Supported arguments:\n                     - document_type: Type of CDA document (e.g. \"CCD\", \"Discharge Summary\")\n\n        Returns:\n            str: CDA document as XML string\n\n        Raises:\n            ValueError: If required mappings are missing or if resource types are unsupported\n        \"\"\"\n        # Get generators (lazy loaded)\n        cda_generator = self.cda_generator\n\n        # Check for document type\n        document_type = kwargs.get(\"document_type\", \"ccd\")\n        if document_type:\n            log.info(f\"Processing CDA document of type: {document_type}\")\n\n        # Get document configuration for this specific document type\n        doc_config = self.config.get_cda_document_config(document_type)\n        if not doc_config:\n            raise ValueError(\n                f\"Invalid or missing document configuration for type: {document_type}\"\n            )\n\n        return cda_generator.transform(resources, document_type=document_type)\n\n    def _hl7v2_to_fhir(self, source_data: str) -&gt; List[Resource]:\n        \"\"\"Convert HL7v2 to FHIR resources\"\"\"\n        parser = self.hl7v2_parser\n        generator = self.fhir_generator\n\n        # Parse HL7v2 message using the parser\n        message_entries = parser.from_string(source_data)\n\n        # Process each message entry and convert to FHIR resources\n        resources = []\n        for message_key, entries in message_entries.items():\n            resource_entries = generator.transform(\n                entries, src_format=FormatType.HL7V2, message_key=message_key\n            )\n            resources.extend(resource_entries)\n\n        return resources\n\n    def _fhir_to_hl7v2(self, resources: List[Resource]) -&gt; str:\n        \"\"\"Convert FHIR resources to HL7v2\"\"\"\n        generator = self.hl7v2_generator\n\n        # Process each resource and convert to HL7v2 message\n        messages = []\n        for resource in resources:\n            message = generator.transform(resource)\n            messages.append(message)\n\n        return messages\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--convert-cda-to-fhir","title":"Convert CDA to FHIR","text":"<p>fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--convert-fhir-to-cda","title":"Convert FHIR to CDA","text":"<p>cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--access-config-directly","title":"Access config directly:","text":"<p>engine.config.set_environment(\"production\") engine.config.set_validation_level(\"warn\") value = engine.config.get_config_value(\"cda.sections.problems.resource\")</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--access-the-template-registry","title":"Access the template registry:","text":"<p>template = engine.template_registry.get_template(\"cda_fhir/condition\") engine.template_registry.add_filter()</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--register-custom-components","title":"Register custom components:","text":"<p>engine.register_parser(FormatType.CDA, custom_parser) engine.register_generator(FormatType.FHIR, custom_generator)</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--register-custom-configuration-validators","title":"Register custom configuration validators:","text":"<p>engine.register_cda_section_config_validator(\"Procedure\", ProcedureSectionConfig) engine.register_cda_document_config_validator(\"CCD\", CCDDocumentConfig)</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.cda_generator","title":"<code>cda_generator</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the CDA generator</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.cda_parser","title":"<code>cda_parser</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the CDA parser</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.fhir_generator","title":"<code>fhir_generator</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the FHIR generator</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.hl7v2_generator","title":"<code>hl7v2_generator</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the HL7v2 generator</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.hl7v2_parser","title":"<code>hl7v2_parser</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the HL7v2 parser</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.__init__","title":"<code>__init__(config_dir=None, validation_level=ValidationLevel.STRICT, environment=None)</code>","text":"<p>Initialize the InteropEngine</p> PARAMETER DESCRIPTION <code>config_dir</code> <p>Base directory containing configuration files. If None, will search standard locations.</p> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>validation_level</code> <p>Level of configuration validation (strict, warn, ignore)</p> <p> TYPE: <code>str</code> DEFAULT: <code>STRICT</code> </p> <code>environment</code> <p>Optional environment to use (development, testing, production)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>def __init__(\n    self,\n    config_dir: Optional[Path] = None,\n    validation_level: str = ValidationLevel.STRICT,\n    environment: Optional[str] = None,\n):\n    \"\"\"Initialize the InteropEngine\n\n    Args:\n        config_dir: Base directory containing configuration files. If None, will search standard locations.\n        validation_level: Level of configuration validation (strict, warn, ignore)\n        environment: Optional environment to use (development, testing, production)\n    \"\"\"\n    # Initialize configuration manager\n    self.config = InteropConfigManager(config_dir, validation_level, environment)\n\n    # Initialize template registry\n    template_dir = config_dir / \"templates\"\n    self.template_registry = TemplateRegistry(template_dir)\n\n    # Create and register default filters\n    # Get required configuration for filters\n    mappings_dir = self.config.get_config_value(\"defaults.mappings_dir\")\n    if not mappings_dir:\n        log.warning(\"No mappings directory configured, using default mappings\")\n        mappings_dir = \"cda_default\"\n    mappings = self.config.get_mappings(mappings_dir)\n    id_prefix = self.config.get_config_value(\"defaults.common.id_prefix\")\n\n    # Get default filters from the filters module\n    default_filters = create_default_filters(mappings, id_prefix)\n    self.template_registry.initialize(default_filters)\n\n    # Component registries for lazy loading\n    self._parsers = {}\n    self._generators = {}\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.from_fhir","title":"<code>from_fhir(resources, dest_format, **kwargs)</code>","text":"<p>Convert FHIR resources to a target format</p> PARAMETER DESCRIPTION <code>resources</code> <p>List of FHIR resources to convert or a FHIR Bundle</p> <p> TYPE: <code>Union[List[Resource], Bundle]</code> </p> <code>dest_format</code> <p>Destination format type, either as string (\"cda\", \"hl7v2\")         or FormatType enum</p> <p> TYPE: <code>Union[str, FormatType]</code> </p> <code>**kwargs</code> <p>Additional arguments to pass to generator.      For CDA: document_type (str) - Type of CDA document (e.g. \"ccd\", \"discharge\")</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Converted data as string (CDA XML or HL7v2 message)</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If dest_format is not supported</p> Example Source code in <code>healthchain/interop/engine.py</code> <pre><code>def from_fhir(\n    self,\n    resources: Union[List[Resource], Bundle],\n    dest_format: Union[str, FormatType],\n    **kwargs: Any,\n) -&gt; str:\n    \"\"\"Convert FHIR resources to a target format\n\n    Args:\n        resources: List of FHIR resources to convert or a FHIR Bundle\n        dest_format: Destination format type, either as string (\"cda\", \"hl7v2\")\n                    or FormatType enum\n        **kwargs: Additional arguments to pass to generator.\n                 For CDA: document_type (str) - Type of CDA document (e.g. \"ccd\", \"discharge\")\n\n    Returns:\n        str: Converted data as string (CDA XML or HL7v2 message)\n\n    Raises:\n        ValueError: If dest_format is not supported\n\n    Example:\n        # Convert FHIR resources to CDA XML\n        cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")\n    \"\"\"\n    dest_format = validate_format(dest_format)\n    resources = normalize_resource_list(resources)\n\n    if dest_format == FormatType.HL7V2:\n        return self._fhir_to_hl7v2(resources, **kwargs)\n    elif dest_format == FormatType.CDA:\n        return self._fhir_to_cda(resources, **kwargs)\n    else:\n        raise ValueError(f\"Unsupported format: {dest_format}\")\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.from_fhir--convert-fhir-resources-to-cda-xml","title":"Convert FHIR resources to CDA XML","text":"<p>cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_cda_document_config_validator","title":"<code>register_cda_document_config_validator(document_type, document_model)</code>","text":"<p>Register a custom document validator model for a document type</p> PARAMETER DESCRIPTION <code>document_type</code> <p>Document type (e.g., \"ccd\", \"discharge\")</p> <p> TYPE: <code>str</code> </p> <code>document_model</code> <p>Pydantic model for document validation</p> <p> TYPE: <code>BaseModel</code> </p> RETURNS DESCRIPTION <code>InteropEngine</code> <p>Self for method chaining</p> Example Source code in <code>healthchain/interop/engine.py</code> <pre><code>def register_cda_document_config_validator(\n    self, document_type: str, document_model: BaseModel\n) -&gt; \"InteropEngine\":\n    \"\"\"Register a custom document validator model for a document type\n\n    Args:\n        document_type: Document type (e.g., \"ccd\", \"discharge\")\n        document_model: Pydantic model for document validation\n\n    Returns:\n        Self for method chaining\n\n    Example:\n        # Register a config validator for the CCD document type\n        engine.register_cda_document_validator(\n            \"ccd\", CCDDocumentConfig\n        )\n    \"\"\"\n    self.config.register_cda_document_config(document_type, document_model)\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_cda_document_config_validator--register-a-config-validator-for-the-ccd-document-type","title":"Register a config validator for the CCD document type","text":"<p>engine.register_cda_document_validator(     \"ccd\", CCDDocumentConfig )</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_cda_section_config_validator","title":"<code>register_cda_section_config_validator(resource_type, template_model)</code>","text":"<p>Register a custom section config validator model for a resource type</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>FHIR resource type (e.g., \"Condition\", \"MedicationStatement\") which converts to the CDA section</p> <p> TYPE: <code>str</code> </p> <code>template_model</code> <p>Pydantic model for CDA section config validation</p> <p> TYPE: <code>BaseModel</code> </p> RETURNS DESCRIPTION <code>InteropEngine</code> <p>Self for method chaining</p> Example Source code in <code>healthchain/interop/engine.py</code> <pre><code>def register_cda_section_config_validator(\n    self, resource_type: str, template_model: BaseModel\n) -&gt; \"InteropEngine\":\n    \"\"\"Register a custom section config validator model for a resource type\n\n    Args:\n        resource_type: FHIR resource type (e.g., \"Condition\", \"MedicationStatement\") which converts to the CDA section\n        template_model: Pydantic model for CDA section config validation\n\n    Returns:\n        Self for method chaining\n\n    Example:\n        # Register a config validator for the Problem section, which is converted from the Condition resource\n        engine.register_cda_section_config_validator(\n            \"Condition\", ProblemSectionConfig\n        )\n    \"\"\"\n    self.config.register_cda_section_config(resource_type, template_model)\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_cda_section_config_validator--register-a-config-validator-for-the-problem-section-which-is-converted-from-the-condition-resource","title":"Register a config validator for the Problem section, which is converted from the Condition resource","text":"<p>engine.register_cda_section_config_validator(     \"Condition\", ProblemSectionConfig )</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_generator","title":"<code>register_generator(format_type, generator_instance)</code>","text":"<p>Register a custom generator for a format type. This will replace the default generator for the format type.</p> PARAMETER DESCRIPTION <code>format_type</code> <p>The format type (CDA, HL7v2, FHIR) to register the generator for</p> <p> TYPE: <code>FormatType</code> </p> <code>generator_instance</code> <p>The generator instance that implements the generation logic</p> <p> TYPE: <code>BaseGenerator</code> </p> RETURNS DESCRIPTION <code>InteropEngine</code> <p>Returns self for method chaining</p> <p> TYPE: <code>InteropEngine</code> </p> Example <p>engine.register_generator(FormatType.CDA, CustomCDAGenerator())</p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>def register_generator(\n    self, format_type: FormatType, generator_instance: BaseGenerator\n) -&gt; \"InteropEngine\":\n    \"\"\"Register a custom generator for a format type. This will replace the default generator for the format type.\n\n    Args:\n        format_type: The format type (CDA, HL7v2, FHIR) to register the generator for\n        generator_instance: The generator instance that implements the generation logic\n\n    Returns:\n        InteropEngine: Returns self for method chaining\n\n    Example:\n        engine.register_generator(FormatType.CDA, CustomCDAGenerator())\n    \"\"\"\n    self._generators[format_type] = generator_instance\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_parser","title":"<code>register_parser(format_type, parser_instance)</code>","text":"<p>Register a custom parser for a format type. This will replace the default parser for the format type.</p> PARAMETER DESCRIPTION <code>format_type</code> <p>The format type (CDA, HL7v2) to register the parser for</p> <p> TYPE: <code>FormatType</code> </p> <code>parser_instance</code> <p>The parser instance that implements the parsing logic</p> <p> TYPE: <code>BaseParser</code> </p> RETURNS DESCRIPTION <code>InteropEngine</code> <p>Returns self for method chaining</p> <p> TYPE: <code>InteropEngine</code> </p> Example <p>engine.register_parser(FormatType.CDA, CustomCDAParser())</p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>def register_parser(\n    self, format_type: FormatType, parser_instance: BaseParser\n) -&gt; \"InteropEngine\":\n    \"\"\"Register a custom parser for a format type. This will replace the default parser for the format type.\n\n    Args:\n        format_type: The format type (CDA, HL7v2) to register the parser for\n        parser_instance: The parser instance that implements the parsing logic\n\n    Returns:\n        InteropEngine: Returns self for method chaining\n\n    Example:\n        engine.register_parser(FormatType.CDA, CustomCDAParser())\n    \"\"\"\n    self._parsers[format_type] = parser_instance\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.to_fhir","title":"<code>to_fhir(src_data, src_format)</code>","text":"<p>Convert source data to FHIR resources</p> PARAMETER DESCRIPTION <code>src_data</code> <p>Input data as string (CDA XML or HL7v2 message)</p> <p> TYPE: <code>str</code> </p> <code>src_format</code> <p>Source format type, either as string (\"cda\", \"hl7v2\")          or FormatType enum</p> <p> TYPE: <code>Union[str, FormatType]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List[Resource]: List of FHIR resources generated from the source data</p> RAISES DESCRIPTION <code>ValueError</code> <p>If src_format is not supported</p> Example Source code in <code>healthchain/interop/engine.py</code> <pre><code>def to_fhir(\n    self, src_data: str, src_format: Union[str, FormatType]\n) -&gt; List[Resource]:\n    \"\"\"Convert source data to FHIR resources\n\n    Args:\n        src_data: Input data as string (CDA XML or HL7v2 message)\n        src_format: Source format type, either as string (\"cda\", \"hl7v2\")\n                     or FormatType enum\n\n    Returns:\n        List[Resource]: List of FHIR resources generated from the source data\n\n    Raises:\n        ValueError: If src_format is not supported\n\n    Example:\n        # Convert CDA XML to FHIR resources\n        fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")\n    \"\"\"\n    src_format = validate_format(src_format)\n\n    if src_format == FormatType.CDA:\n        return self._cda_to_fhir(src_data)\n    elif src_format == FormatType.HL7V2:\n        return self._hl7v2_to_fhir(src_data)\n    else:\n        raise ValueError(f\"Unsupported format: {src_format}\")\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.to_fhir--convert-cda-xml-to-fhir-resources","title":"Convert CDA XML to FHIR resources","text":"<p>fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")</p>"},{"location":"api/interop/#healthchain.interop.engine.normalize_resource_list","title":"<code>normalize_resource_list(resources)</code>","text":"<p>Convert input resources to a normalized list format</p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>def normalize_resource_list(\n    resources: Union[Resource, List[Resource], Bundle],\n) -&gt; List[Resource]:\n    \"\"\"Convert input resources to a normalized list format\"\"\"\n    if isinstance(resources, Bundle):\n        return [entry.resource for entry in resources.entry if entry.resource]\n    elif isinstance(resources, list):\n        return resources\n    else:\n        return [resources]\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager","title":"<code>InteropConfigManager</code>","text":"<p>               Bases: <code>ConfigManager</code></p> <p>Specialized configuration manager for the interoperability module</p> <p>Extends ConfigManager to handle CDA document and section template configurations. Provides functionality for:</p> <ul> <li>Loading and validating interop configurations</li> <li>Managing document and section templates</li> <li>Registering custom validation models</li> </ul> <p>Configuration structure: - Document templates (under \"document\") - Section templates (under \"sections\") - Default values and settings</p> <p>Validation levels: - STRICT: Full validation (default) - WARN: Warning-only - IGNORE: No validation</p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>class InteropConfigManager(ConfigManager):\n    \"\"\"Specialized configuration manager for the interoperability module\n\n    Extends ConfigManager to handle CDA document and section template configurations.\n    Provides functionality for:\n\n    - Loading and validating interop configurations\n    - Managing document and section templates\n    - Registering custom validation models\n\n    Configuration structure:\n    - Document templates (under \"document\")\n    - Section templates (under \"sections\")\n    - Default values and settings\n\n    Validation levels:\n    - STRICT: Full validation (default)\n    - WARN: Warning-only\n    - IGNORE: No validation\n    \"\"\"\n\n    def __init__(\n        self,\n        config_dir: Path,\n        validation_level: str = ValidationLevel.STRICT,\n        environment: Optional[str] = None,\n    ):\n        \"\"\"Initialize the InteropConfigManager.\n\n        Initializes the configuration manager with the interop module and validates\n        the configuration. The interop module configuration must exist in the\n        specified config directory.\n\n        Args:\n            config_dir: Base directory containing configuration files\n            validation_level: Level of validation to perform. Default is STRICT.\n                Can be STRICT, WARN, or IGNORE.\n            environment: Optional environment name to load environment-specific configs.\n                If provided, will load and merge environment-specific configuration.\n\n        Raises:\n            ValueError: If the interop module configuration is not found in config_dir.\n        \"\"\"\n        # Initialize with \"interop\" as the fixed module\n        super().__init__(config_dir, validation_level, module=\"interop\")\n        self.load(environment, skip_validation=True)\n\n        if \"interop\" not in self._module_configs:\n            raise ValueError(\n                f\"Interop module not found in configuration directory {config_dir}\"\n            )\n\n        self.validate()\n\n    def _find_cda_document_types(self) -&gt; List[str]:\n        \"\"\"Find available CDA document types in the configs\n\n        Returns:\n            List of CDA document type strings\n        \"\"\"\n        # Get document types from cda/document path\n        doc_section = self._find_config_section(\n            module_name=\"interop\", section_path=\"cda/document\"\n        )\n\n        # If no document section exists, return empty list\n        if not doc_section:\n            return []\n\n        # Return the keys from the document section\n        return list(doc_section.keys())\n\n    def get_cda_section_configs(self, section_key: Optional[str] = None) -&gt; Dict:\n        \"\"\"Get CDA section configuration(s).\n\n        Retrieves section configurations from the loaded configs. When section_key is provided,\n        retrieves configuration for a specific section; otherwise, returns all section configurations.\n        Section configurations define how different CDA sections should be processed and mapped to\n        FHIR resources.\n\n        Args:\n            section_key: Optional section identifier (e.g., \"problems\", \"medications\").\n                         If provided, returns only that specific section's configuration.\n\n        Returns:\n            Dict: Dictionary mapping section keys to their configurations if section_key is None.\n                  Single section configuration dict if section_key is provided.\n\n        Raises:\n            ValueError: If section_key is provided but not found in configurations\n                       or if no sections are configured\n        \"\"\"\n        # Get all sections\n        sections = self._find_config_section(\n            module_name=\"interop\", section_path=\"cda/sections\"\n        )\n\n        if not sections:\n            raise ValueError(\"No CDA section configurations found\")\n\n        # If section_key is provided, return just that section\n        if section_key is not None:\n            if section_key not in sections:\n                raise ValueError(f\"Section configuration not found: {section_key}\")\n\n            # Basic validation that required fields exist\n            section_config = sections[section_key]\n            if \"resource\" not in section_config:\n                raise ValueError(\n                    f\"Invalid section configuration for {section_key}: missing 'resource' field\"\n                )\n\n            return section_config\n\n        return sections\n\n    def get_cda_document_config(self, document_type: str) -&gt; Dict:\n        \"\"\"Get CDA document configuration for a specific document type.\n\n        Retrieves the configuration for a CDA document type from the loaded configs.\n        The configuration contains template settings and other document-specific parameters.\n\n        Args:\n            document_type: Type of document (e.g., \"ccd\", \"discharge\") to get config for\n\n        Returns:\n            Dict containing the document configuration\n\n        Raises:\n            ValueError: If document_type is not found or the configuration is invalid\n        \"\"\"\n        document_config = self._find_config_section(\n            module_name=\"interop\", section_path=f\"cda/document/{document_type}\"\n        )\n\n        if not document_config:\n            raise ValueError(\n                f\"Document configuration not found for type: {document_type}\"\n            )\n\n        # Basic validation that required sections exist\n        if \"templates\" not in document_config:\n            raise ValueError(\n                f\"Invalid document configuration for {document_type}: missing 'templates' section\"\n            )\n\n        # Return the validated config\n        return document_config\n\n    def validate(self) -&gt; bool:\n        \"\"\"Validate that all required configurations are present for the interop module.\n\n        Validates both section and document configurations according to their registered\n        validation models. Section configs are required and will cause validation to fail\n        if missing or invalid. Document configs are optional but will be validated if present.\n\n        The validation behavior depends on the validation_level setting:\n        - IGNORE: Always returns True without validating\n        - WARN: Logs warnings for validation failures but returns True\n        - ERROR: Returns False if any validation fails\n\n        Returns:\n            bool: True if validation passes or is ignored, False if validation fails\n                 when validation_level is ERROR\n        \"\"\"\n        if self._validation_level == ValidationLevel.IGNORE:\n            return True\n\n        is_valid = super().validate()\n\n        # Validate section configs\n        try:\n            section_configs = self._find_config_section(\n                module_name=\"interop\", section_path=\"cda/sections\"\n            )\n            if not section_configs:\n                is_valid = self._handle_validation_error(\"No section configs found\")\n            else:\n                # Validate each section config\n                for section_key, section_config in section_configs.items():\n                    result = validate_cda_section_config_model(\n                        section_key, section_config\n                    )\n                    if not result:\n                        is_valid = self._handle_validation_error(\n                            f\"Section config validation failed for key: {section_key}\"\n                        )\n        except Exception as e:\n            is_valid = self._handle_validation_error(\n                f\"Error validating section configs: {str(e)}\"\n            )\n\n        # Validate document configs - but don't fail if no documents are configured\n        # since some use cases might not require documents\n        document_types = self._find_cda_document_types()\n        for doc_type in document_types:\n            try:\n                doc_config = self._find_config_section(\n                    module_name=\"interop\", section_path=f\"cda/document/{doc_type}\"\n                )\n                if doc_config:\n                    result = validate_cda_document_config_model(doc_type, doc_config)\n                    if not result:\n                        is_valid = self._handle_validation_error(\n                            f\"Document config validation failed for type: {doc_type}\"\n                        )\n            except Exception as e:\n                is_valid = self._handle_validation_error(\n                    f\"Error validating document config for {doc_type}: {str(e)}\"\n                )\n\n        return is_valid\n\n    def register_cda_section_config(\n        self, resource_type: str, config_model: Type[BaseModel]\n    ) -&gt; None:\n        \"\"\"Register a validation model for a CDA section configuration.\n\n        Registers a Pydantic model that will be used to validate configuration for a CDA section\n        that maps to a specific FHIR resource type. The model defines the required and optional\n        fields that should be present in the section configuration.\n\n        Args:\n            resource_type: FHIR resource type that the section maps to (e.g. \"Condition\")\n            config_model: Pydantic model class that defines the validation schema for the section config\n        \"\"\"\n        register_cda_section_template_config_model(resource_type, config_model)\n\n    def register_cda_document_config(\n        self, document_type: str, config_model: Type[BaseModel]\n    ) -&gt; None:\n        \"\"\"Register a validation model for a CDA document configuration.\n\n        Registers a Pydantic model that will be used to validate configuration for a CDA document\n        type. The model defines the required and optional fields that should be present in the\n        document configuration.\n\n        Args:\n            document_type: Document type identifier (e.g., \"ccd\", \"discharge\")\n            config_model: Pydantic model class that defines the validation schema for the document config\n        \"\"\"\n        register_cda_document_template_config_model(document_type, config_model)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.__init__","title":"<code>__init__(config_dir, validation_level=ValidationLevel.STRICT, environment=None)</code>","text":"<p>Initialize the InteropConfigManager.</p> <p>Initializes the configuration manager with the interop module and validates the configuration. The interop module configuration must exist in the specified config directory.</p> PARAMETER DESCRIPTION <code>config_dir</code> <p>Base directory containing configuration files</p> <p> TYPE: <code>Path</code> </p> <code>validation_level</code> <p>Level of validation to perform. Default is STRICT. Can be STRICT, WARN, or IGNORE.</p> <p> TYPE: <code>str</code> DEFAULT: <code>STRICT</code> </p> <code>environment</code> <p>Optional environment name to load environment-specific configs. If provided, will load and merge environment-specific configuration.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the interop module configuration is not found in config_dir.</p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def __init__(\n    self,\n    config_dir: Path,\n    validation_level: str = ValidationLevel.STRICT,\n    environment: Optional[str] = None,\n):\n    \"\"\"Initialize the InteropConfigManager.\n\n    Initializes the configuration manager with the interop module and validates\n    the configuration. The interop module configuration must exist in the\n    specified config directory.\n\n    Args:\n        config_dir: Base directory containing configuration files\n        validation_level: Level of validation to perform. Default is STRICT.\n            Can be STRICT, WARN, or IGNORE.\n        environment: Optional environment name to load environment-specific configs.\n            If provided, will load and merge environment-specific configuration.\n\n    Raises:\n        ValueError: If the interop module configuration is not found in config_dir.\n    \"\"\"\n    # Initialize with \"interop\" as the fixed module\n    super().__init__(config_dir, validation_level, module=\"interop\")\n    self.load(environment, skip_validation=True)\n\n    if \"interop\" not in self._module_configs:\n        raise ValueError(\n            f\"Interop module not found in configuration directory {config_dir}\"\n        )\n\n    self.validate()\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.get_cda_document_config","title":"<code>get_cda_document_config(document_type)</code>","text":"<p>Get CDA document configuration for a specific document type.</p> <p>Retrieves the configuration for a CDA document type from the loaded configs. The configuration contains template settings and other document-specific parameters.</p> PARAMETER DESCRIPTION <code>document_type</code> <p>Type of document (e.g., \"ccd\", \"discharge\") to get config for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict</code> <p>Dict containing the document configuration</p> RAISES DESCRIPTION <code>ValueError</code> <p>If document_type is not found or the configuration is invalid</p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def get_cda_document_config(self, document_type: str) -&gt; Dict:\n    \"\"\"Get CDA document configuration for a specific document type.\n\n    Retrieves the configuration for a CDA document type from the loaded configs.\n    The configuration contains template settings and other document-specific parameters.\n\n    Args:\n        document_type: Type of document (e.g., \"ccd\", \"discharge\") to get config for\n\n    Returns:\n        Dict containing the document configuration\n\n    Raises:\n        ValueError: If document_type is not found or the configuration is invalid\n    \"\"\"\n    document_config = self._find_config_section(\n        module_name=\"interop\", section_path=f\"cda/document/{document_type}\"\n    )\n\n    if not document_config:\n        raise ValueError(\n            f\"Document configuration not found for type: {document_type}\"\n        )\n\n    # Basic validation that required sections exist\n    if \"templates\" not in document_config:\n        raise ValueError(\n            f\"Invalid document configuration for {document_type}: missing 'templates' section\"\n        )\n\n    # Return the validated config\n    return document_config\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.get_cda_section_configs","title":"<code>get_cda_section_configs(section_key=None)</code>","text":"<p>Get CDA section configuration(s).</p> <p>Retrieves section configurations from the loaded configs. When section_key is provided, retrieves configuration for a specific section; otherwise, returns all section configurations. Section configurations define how different CDA sections should be processed and mapped to FHIR resources.</p> PARAMETER DESCRIPTION <code>section_key</code> <p>Optional section identifier (e.g., \"problems\", \"medications\").          If provided, returns only that specific section's configuration.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dict</code> <p>Dictionary mapping section keys to their configurations if section_key is None.   Single section configuration dict if section_key is provided.</p> <p> TYPE: <code>Dict</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If section_key is provided but not found in configurations        or if no sections are configured</p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def get_cda_section_configs(self, section_key: Optional[str] = None) -&gt; Dict:\n    \"\"\"Get CDA section configuration(s).\n\n    Retrieves section configurations from the loaded configs. When section_key is provided,\n    retrieves configuration for a specific section; otherwise, returns all section configurations.\n    Section configurations define how different CDA sections should be processed and mapped to\n    FHIR resources.\n\n    Args:\n        section_key: Optional section identifier (e.g., \"problems\", \"medications\").\n                     If provided, returns only that specific section's configuration.\n\n    Returns:\n        Dict: Dictionary mapping section keys to their configurations if section_key is None.\n              Single section configuration dict if section_key is provided.\n\n    Raises:\n        ValueError: If section_key is provided but not found in configurations\n                   or if no sections are configured\n    \"\"\"\n    # Get all sections\n    sections = self._find_config_section(\n        module_name=\"interop\", section_path=\"cda/sections\"\n    )\n\n    if not sections:\n        raise ValueError(\"No CDA section configurations found\")\n\n    # If section_key is provided, return just that section\n    if section_key is not None:\n        if section_key not in sections:\n            raise ValueError(f\"Section configuration not found: {section_key}\")\n\n        # Basic validation that required fields exist\n        section_config = sections[section_key]\n        if \"resource\" not in section_config:\n            raise ValueError(\n                f\"Invalid section configuration for {section_key}: missing 'resource' field\"\n            )\n\n        return section_config\n\n    return sections\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.register_cda_document_config","title":"<code>register_cda_document_config(document_type, config_model)</code>","text":"<p>Register a validation model for a CDA document configuration.</p> <p>Registers a Pydantic model that will be used to validate configuration for a CDA document type. The model defines the required and optional fields that should be present in the document configuration.</p> PARAMETER DESCRIPTION <code>document_type</code> <p>Document type identifier (e.g., \"ccd\", \"discharge\")</p> <p> TYPE: <code>str</code> </p> <code>config_model</code> <p>Pydantic model class that defines the validation schema for the document config</p> <p> TYPE: <code>Type[BaseModel]</code> </p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def register_cda_document_config(\n    self, document_type: str, config_model: Type[BaseModel]\n) -&gt; None:\n    \"\"\"Register a validation model for a CDA document configuration.\n\n    Registers a Pydantic model that will be used to validate configuration for a CDA document\n    type. The model defines the required and optional fields that should be present in the\n    document configuration.\n\n    Args:\n        document_type: Document type identifier (e.g., \"ccd\", \"discharge\")\n        config_model: Pydantic model class that defines the validation schema for the document config\n    \"\"\"\n    register_cda_document_template_config_model(document_type, config_model)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.register_cda_section_config","title":"<code>register_cda_section_config(resource_type, config_model)</code>","text":"<p>Register a validation model for a CDA section configuration.</p> <p>Registers a Pydantic model that will be used to validate configuration for a CDA section that maps to a specific FHIR resource type. The model defines the required and optional fields that should be present in the section configuration.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>FHIR resource type that the section maps to (e.g. \"Condition\")</p> <p> TYPE: <code>str</code> </p> <code>config_model</code> <p>Pydantic model class that defines the validation schema for the section config</p> <p> TYPE: <code>Type[BaseModel]</code> </p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def register_cda_section_config(\n    self, resource_type: str, config_model: Type[BaseModel]\n) -&gt; None:\n    \"\"\"Register a validation model for a CDA section configuration.\n\n    Registers a Pydantic model that will be used to validate configuration for a CDA section\n    that maps to a specific FHIR resource type. The model defines the required and optional\n    fields that should be present in the section configuration.\n\n    Args:\n        resource_type: FHIR resource type that the section maps to (e.g. \"Condition\")\n        config_model: Pydantic model class that defines the validation schema for the section config\n    \"\"\"\n    register_cda_section_template_config_model(resource_type, config_model)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.validate","title":"<code>validate()</code>","text":"<p>Validate that all required configurations are present for the interop module.</p> <p>Validates both section and document configurations according to their registered validation models. Section configs are required and will cause validation to fail if missing or invalid. Document configs are optional but will be validated if present.</p> <p>The validation behavior depends on the validation_level setting: - IGNORE: Always returns True without validating - WARN: Logs warnings for validation failures but returns True - ERROR: Returns False if any validation fails</p> RETURNS DESCRIPTION <code>bool</code> <p>True if validation passes or is ignored, False if validation fails  when validation_level is ERROR</p> <p> TYPE: <code>bool</code> </p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"Validate that all required configurations are present for the interop module.\n\n    Validates both section and document configurations according to their registered\n    validation models. Section configs are required and will cause validation to fail\n    if missing or invalid. Document configs are optional but will be validated if present.\n\n    The validation behavior depends on the validation_level setting:\n    - IGNORE: Always returns True without validating\n    - WARN: Logs warnings for validation failures but returns True\n    - ERROR: Returns False if any validation fails\n\n    Returns:\n        bool: True if validation passes or is ignored, False if validation fails\n             when validation_level is ERROR\n    \"\"\"\n    if self._validation_level == ValidationLevel.IGNORE:\n        return True\n\n    is_valid = super().validate()\n\n    # Validate section configs\n    try:\n        section_configs = self._find_config_section(\n            module_name=\"interop\", section_path=\"cda/sections\"\n        )\n        if not section_configs:\n            is_valid = self._handle_validation_error(\"No section configs found\")\n        else:\n            # Validate each section config\n            for section_key, section_config in section_configs.items():\n                result = validate_cda_section_config_model(\n                    section_key, section_config\n                )\n                if not result:\n                    is_valid = self._handle_validation_error(\n                        f\"Section config validation failed for key: {section_key}\"\n                    )\n    except Exception as e:\n        is_valid = self._handle_validation_error(\n            f\"Error validating section configs: {str(e)}\"\n        )\n\n    # Validate document configs - but don't fail if no documents are configured\n    # since some use cases might not require documents\n    document_types = self._find_cda_document_types()\n    for doc_type in document_types:\n        try:\n            doc_config = self._find_config_section(\n                module_name=\"interop\", section_path=f\"cda/document/{doc_type}\"\n            )\n            if doc_config:\n                result = validate_cda_document_config_model(doc_type, doc_config)\n                if not result:\n                    is_valid = self._handle_validation_error(\n                        f\"Document config validation failed for type: {doc_type}\"\n                    )\n        except Exception as e:\n            is_valid = self._handle_validation_error(\n                f\"Error validating document config for {doc_type}: {str(e)}\"\n            )\n\n    return is_valid\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry","title":"<code>TemplateRegistry</code>","text":"<p>Manages loading and accessing Liquid templates for the InteropEngine.</p> <p>The TemplateRegistry handles loading Liquid template files from a directory and making them available for rendering. It supports custom filter functions that can be used within templates.</p> <p>Key features: - Loads .liquid template files recursively from a directory - Supports adding custom filter functions - Provides template lookup by name - Validates template existence</p> Example <p>registry = TemplateRegistry(Path(\"templates\")) registry.initialize({     \"uppercase\": str.upper,     \"lowercase\": str.lower }) template = registry.get_template(\"cda_fhir/condition\")</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>class TemplateRegistry:\n    \"\"\"Manages loading and accessing Liquid templates for the InteropEngine.\n\n    The TemplateRegistry handles loading Liquid template files from a directory and making them\n    available for rendering. It supports custom filter functions that can be used within templates.\n\n    Key features:\n    - Loads .liquid template files recursively from a directory\n    - Supports adding custom filter functions\n    - Provides template lookup by name\n    - Validates template existence\n\n    Example:\n        registry = TemplateRegistry(Path(\"templates\"))\n        registry.initialize({\n            \"uppercase\": str.upper,\n            \"lowercase\": str.lower\n        })\n        template = registry.get_template(\"cda_fhir/condition\")\n    \"\"\"\n\n    def __init__(self, template_dir: Path):\n        \"\"\"Initialize the TemplateRegistry\n\n        Args:\n            template_dir: Directory containing template files\n        \"\"\"\n        self.template_dir = template_dir\n        self._templates = {}\n        self._env = None\n        self._filters = {}\n\n        if not template_dir.exists():\n            raise ValueError(f\"Template directory not found: {template_dir}\")\n\n    def initialize(self, filters: Dict[str, Callable] = None) -&gt; \"TemplateRegistry\":\n        \"\"\"Initialize the Liquid environment and load templates.\n\n        This method sets up the Liquid template environment by:\n        1. Storing any provided filter functions\n        2. Creating the Liquid environment with the template directory\n        3. Loading all template files from the directory\n\n        The environment must be initialized before templates can be loaded or rendered.\n\n        Args:\n            filters: Optional dictionary mapping filter names to filter functions that can be used\n                    in templates. For example: {\"uppercase\": str.upper}\n\n        Returns:\n            TemplateRegistry: Returns self for method chaining\n\n        Raises:\n            ValueError: If template directory does not exist or environment initialization fails\n        \"\"\"\n        # Store initial filters\n        if filters:\n            self._filters.update(filters)\n\n        self._create_environment()\n        self._load_templates()\n        return self\n\n    def _create_environment(self) -&gt; None:\n        \"\"\"Create and configure the Liquid environment with registered filters\"\"\"\n        self._env = Environment(loader=FileSystemLoader(str(self.template_dir)))\n\n        # Register all filters\n        for name, func in self._filters.items():\n            self._env.filters[name] = func\n\n    def add_filter(self, name: str, filter_func: Callable) -&gt; \"TemplateRegistry\":\n        \"\"\"Add a custom filter function\n\n        Args:\n            name: Name of the filter to use in templates\n            filter_func: Filter function to register\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        # Add to internal filter registry\n        self._filters[name] = filter_func\n\n        # If environment is already initialized, register the filter\n        if self._env:\n            self._env.filters[name] = filter_func\n\n        return self\n\n    def add_filters(self, filters: Dict[str, Callable]) -&gt; \"TemplateRegistry\":\n        \"\"\"Add multiple custom filter functions\n\n        Args:\n            filters: Dictionary of filter names to filter functions\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        for name, func in filters.items():\n            self.add_filter(name, func)\n\n        return self\n\n    def _load_templates(self) -&gt; None:\n        \"\"\"Load all Liquid template files from the template directory.\n\n        This method recursively walks through the template directory and its subdirectories\n        to find all .liquid template files. Each template is loaded into the environment\n        and stored in the internal template registry using its full relative path (without extension)\n        as the key (e.g., \"cda_fhir/document\"). This is not required but recommended for clarity.\n        \"\"\"\n        if not self._env:\n            raise ValueError(\"Environment not initialized. Call initialize() first.\")\n\n        # Walk through all subdirectories to find template files\n        for template_file in self.template_dir.rglob(\"*.liquid\"):\n            rel_path = template_file.relative_to(self.template_dir)\n            # Use full path without extension as the key (e.g., \"cda_fhir/document\")\n            template_key = str(rel_path.with_suffix(\"\"))\n\n            try:\n                template = self._env.get_template(str(rel_path))\n                self._templates[template_key] = template\n                log.debug(f\"Loaded template: {template_key}\")\n            except Exception as e:\n                log.error(f\"Failed to load template {template_file}: {str(e)}\")\n                continue\n\n        if not self._templates:\n            raise ValueError(f\"No templates found in {self.template_dir}\")\n\n        log.info(f\"Loaded {len(self._templates)} templates\")\n\n    def get_template(self, template_key: str) -&gt; Template:\n        \"\"\"Get a template by key\n\n        Args:\n            template_key: Template identifier. Can be a full path (e.g., 'cda_fhir/document')\n                or just a filename (e.g., 'document').\n\n        Returns:\n            The template object\n\n        Raises:\n            KeyError: If template not found\n        \"\"\"\n        if template_key not in self._templates:\n            raise KeyError(f\"Template not found: {template_key}\")\n\n        return self._templates[template_key]\n\n    def has_template(self, template_key: str) -&gt; bool:\n        \"\"\"Check if a template exists\n\n        Args:\n            template_key: Template identifier. Can be a full path (e.g., 'cda_fhir/document')\n                or just a filename (e.g., 'document').\n\n        Returns:\n            True if template exists, False otherwise\n        \"\"\"\n        return template_key in self._templates\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.__init__","title":"<code>__init__(template_dir)</code>","text":"<p>Initialize the TemplateRegistry</p> PARAMETER DESCRIPTION <code>template_dir</code> <p>Directory containing template files</p> <p> TYPE: <code>Path</code> </p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def __init__(self, template_dir: Path):\n    \"\"\"Initialize the TemplateRegistry\n\n    Args:\n        template_dir: Directory containing template files\n    \"\"\"\n    self.template_dir = template_dir\n    self._templates = {}\n    self._env = None\n    self._filters = {}\n\n    if not template_dir.exists():\n        raise ValueError(f\"Template directory not found: {template_dir}\")\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.add_filter","title":"<code>add_filter(name, filter_func)</code>","text":"<p>Add a custom filter function</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the filter to use in templates</p> <p> TYPE: <code>str</code> </p> <code>filter_func</code> <p>Filter function to register</p> <p> TYPE: <code>Callable</code> </p> RETURNS DESCRIPTION <code>TemplateRegistry</code> <p>Self for method chaining</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def add_filter(self, name: str, filter_func: Callable) -&gt; \"TemplateRegistry\":\n    \"\"\"Add a custom filter function\n\n    Args:\n        name: Name of the filter to use in templates\n        filter_func: Filter function to register\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    # Add to internal filter registry\n    self._filters[name] = filter_func\n\n    # If environment is already initialized, register the filter\n    if self._env:\n        self._env.filters[name] = filter_func\n\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.add_filters","title":"<code>add_filters(filters)</code>","text":"<p>Add multiple custom filter functions</p> PARAMETER DESCRIPTION <code>filters</code> <p>Dictionary of filter names to filter functions</p> <p> TYPE: <code>Dict[str, Callable]</code> </p> RETURNS DESCRIPTION <code>TemplateRegistry</code> <p>Self for method chaining</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def add_filters(self, filters: Dict[str, Callable]) -&gt; \"TemplateRegistry\":\n    \"\"\"Add multiple custom filter functions\n\n    Args:\n        filters: Dictionary of filter names to filter functions\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    for name, func in filters.items():\n        self.add_filter(name, func)\n\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.get_template","title":"<code>get_template(template_key)</code>","text":"<p>Get a template by key</p> PARAMETER DESCRIPTION <code>template_key</code> <p>Template identifier. Can be a full path (e.g., 'cda_fhir/document') or just a filename (e.g., 'document').</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Template</code> <p>The template object</p> RAISES DESCRIPTION <code>KeyError</code> <p>If template not found</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def get_template(self, template_key: str) -&gt; Template:\n    \"\"\"Get a template by key\n\n    Args:\n        template_key: Template identifier. Can be a full path (e.g., 'cda_fhir/document')\n            or just a filename (e.g., 'document').\n\n    Returns:\n        The template object\n\n    Raises:\n        KeyError: If template not found\n    \"\"\"\n    if template_key not in self._templates:\n        raise KeyError(f\"Template not found: {template_key}\")\n\n    return self._templates[template_key]\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.has_template","title":"<code>has_template(template_key)</code>","text":"<p>Check if a template exists</p> PARAMETER DESCRIPTION <code>template_key</code> <p>Template identifier. Can be a full path (e.g., 'cda_fhir/document') or just a filename (e.g., 'document').</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if template exists, False otherwise</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def has_template(self, template_key: str) -&gt; bool:\n    \"\"\"Check if a template exists\n\n    Args:\n        template_key: Template identifier. Can be a full path (e.g., 'cda_fhir/document')\n            or just a filename (e.g., 'document').\n\n    Returns:\n        True if template exists, False otherwise\n    \"\"\"\n    return template_key in self._templates\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.initialize","title":"<code>initialize(filters=None)</code>","text":"<p>Initialize the Liquid environment and load templates.</p> <p>This method sets up the Liquid template environment by: 1. Storing any provided filter functions 2. Creating the Liquid environment with the template directory 3. Loading all template files from the directory</p> <p>The environment must be initialized before templates can be loaded or rendered.</p> PARAMETER DESCRIPTION <code>filters</code> <p>Optional dictionary mapping filter names to filter functions that can be used     in templates. For example: {\"uppercase\": str.upper}</p> <p> TYPE: <code>Dict[str, Callable]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>TemplateRegistry</code> <p>Returns self for method chaining</p> <p> TYPE: <code>TemplateRegistry</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If template directory does not exist or environment initialization fails</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def initialize(self, filters: Dict[str, Callable] = None) -&gt; \"TemplateRegistry\":\n    \"\"\"Initialize the Liquid environment and load templates.\n\n    This method sets up the Liquid template environment by:\n    1. Storing any provided filter functions\n    2. Creating the Liquid environment with the template directory\n    3. Loading all template files from the directory\n\n    The environment must be initialized before templates can be loaded or rendered.\n\n    Args:\n        filters: Optional dictionary mapping filter names to filter functions that can be used\n                in templates. For example: {\"uppercase\": str.upper}\n\n    Returns:\n        TemplateRegistry: Returns self for method chaining\n\n    Raises:\n        ValueError: If template directory does not exist or environment initialization fails\n    \"\"\"\n    # Store initial filters\n    if filters:\n        self._filters.update(filters)\n\n    self._create_environment()\n    self._load_templates()\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.parsers.cda.CDAParser","title":"<code>CDAParser</code>","text":"<p>               Bases: <code>BaseParser</code></p> <p>Parser for CDA XML documents.</p> <p>The CDAParser class provides functionality to parse Clinical Document Architecture (CDA) XML documents and extract structured data from their sections. It works in conjunction with the InteropConfigManager to identify and process sections based on configuration.</p> <p>Key capabilities: - Parse complete CDA XML documents - Extract entries from configured sections based on template IDs or codes - Convert and validate section entries into structured dictionaries (xmltodict)</p> <p>The parser uses configuration from InteropConfigManager to: - Identify sections by template ID or code - Map section contents to the appropriate data structures - Apply any configured transformations</p> ATTRIBUTE DESCRIPTION <code>config</code> <p>Configuration manager instance</p> <p> TYPE: <code>InteropConfigManager</code> </p> <code>clinical_document</code> <p>Currently loaded CDA document</p> <p> TYPE: <code>ClinicalDocument</code> </p> Source code in <code>healthchain/interop/parsers/cda.py</code> <pre><code>class CDAParser(BaseParser):\n    \"\"\"Parser for CDA XML documents.\n\n    The CDAParser class provides functionality to parse Clinical Document Architecture (CDA)\n    XML documents and extract structured data from their sections. It works in conjunction with\n    the InteropConfigManager to identify and process sections based on configuration.\n\n    Key capabilities:\n    - Parse complete CDA XML documents\n    - Extract entries from configured sections based on template IDs or codes\n    - Convert and validate section entries into structured dictionaries (xmltodict)\n\n    The parser uses configuration from InteropConfigManager to:\n    - Identify sections by template ID or code\n    - Map section contents to the appropriate data structures\n    - Apply any configured transformations\n\n    Attributes:\n        config (InteropConfigManager): Configuration manager instance\n        clinical_document (ClinicalDocument): Currently loaded CDA document\n    \"\"\"\n\n    def __init__(self, config: InteropConfigManager):\n        \"\"\"Initialize the CDA parser.\n\n        Args:\n            config: InteropConfigManager instance containing section configurations,\n                   templates, and mapping rules for CDA document parsing\n        \"\"\"\n        super().__init__(config)\n        self.clinical_document = None\n\n    def from_string(self, data: str) -&gt; dict:\n        \"\"\"\n        Parse input data and convert it to a structured format.\n\n        Args:\n            data: The CDA XML document string to parse\n\n        Returns:\n            A dictionary containing the parsed data structure with sections\n        \"\"\"\n        return self.parse_document(data)\n\n    def parse_document(self, xml: str) -&gt; Dict[str, List[Dict]]:\n        \"\"\"Parse a complete CDA document and extract entries from all configured sections.\n\n        This method parses a CDA XML document and extracts entries from each section that is\n        defined in the configuration. It uses xmltodict to parse the XML into a dictionary\n        and then processes each configured section to extract its entries.\n\n        Args:\n            xml: The CDA XML document string to parse\n\n        Returns:\n            Dict[str, List[Dict]]: Dictionary mapping section keys (e.g. \"problems\",\n                \"medications\") to lists of entry dictionaries containing the parsed data\n                from that section (xmltodict format).\n\n        Raises:\n            ValueError: If the XML string is empty or invalid\n            Exception: If there is an error parsing the document or any section\n\n        Example:\n            &gt;&gt;&gt; parser = CDAParser(config)\n            &gt;&gt;&gt; sections = parser.from_string(cda_xml)\n            &gt;&gt;&gt; problems = sections.get(\"problems\", [])\n        \"\"\"\n        section_entries = {}\n\n        # Parse the document once\n        try:\n            doc_dict = xmltodict.parse(xml)\n            self.clinical_document = ClinicalDocument(**doc_dict[\"ClinicalDocument\"])\n        except Exception as e:\n            log.error(f\"Error parsing CDA document: {str(e)}\")\n            return section_entries\n\n        # Get section configurations\n        sections = self.config.get_cda_section_configs()\n        if not sections:\n            log.warning(\"No sections found in configuration\")\n            return section_entries\n\n        # Process each section from the configuration\n        for section_key in sections.keys():\n            try:\n                entries = self._parse_section_entries_from_document(section_key)\n                if entries:\n                    section_entries[section_key] = entries\n            except Exception as e:\n                log.error(f\"Failed to parse section {section_key}: {str(e)}\")\n                continue\n\n        return section_entries\n\n    def _parse_section_entries_from_document(self, section_key: str) -&gt; List[Dict]:\n        \"\"\"Extract entries from a CDA section using an already parsed document.\n\n        Args:\n            section_key: Key identifying the section in the configuration (e.g. \"problems\",\n                \"medications\"). Must match a section defined in the configuration.\n\n        Returns:\n            List[Dict]: List of entry dictionaries from the matched section. Each dictionary\n                contains the parsed data from a single entry in the section. Returns an empty\n                list if no entries are found or if an error occurs.\n\n        Raises:\n            ValueError: If no template_id or code is configured for the section_key, or if\n                no matching section is found in the document.\n            Exception: If there is an error parsing the section or its entries.\n        \"\"\"\n        entries_dicts = []\n        if not self.clinical_document:\n            log.error(\"No document loaded. Call parse_document first.\")\n            return entries_dicts\n\n        try:\n            # Get all components\n            components = self.clinical_document.component.structuredBody.component\n            if not isinstance(components, list):\n                components = [components]\n\n            # Find matching section\n            section = None\n            for component in components:\n                curr_section = component.section\n\n                # Get template_id and code from config_manager\n                template_id = self.config.get_config_value(\n                    f\"cda.sections.{section_key}.identifiers.template_id\"\n                )\n                code = self.config.get_config_value(\n                    f\"cda.sections.{section_key}.identifiers.code\"\n                )\n\n                if not template_id and not code:\n                    raise ValueError(\n                        f\"No template_id or code found for section {section_key}: \\\n                            configure one of the following: \\\n                            cda.sections.{section_key}.identifiers.template_id \\\n                            or cda.sections.{section_key}.identifiers.code\"\n                    )\n\n                if template_id and self._find_section_by_template_id(\n                    curr_section, template_id\n                ):\n                    section = curr_section\n                    break\n\n                if code and self._find_section_by_code(curr_section, code):\n                    section = curr_section\n                    break\n\n            if not section:\n                log.warning(\n                    f\"Section with template_id: {template_id} or code: {code} not found in CDA document for key: {section_key}\"\n                )\n                return entries_dicts\n\n            # Check if this is a notes section (which doesn't have entries but has text) - temporary workaround\n            if section_key == \"notes\":\n                # For notes section, create a synthetic entry with the section's text content\n                section_dict = section.model_dump(exclude_none=True, by_alias=True)\n                log.debug(\n                    f\"Created synthetic entry for notes section with text: {type(section.text)}\"\n                )\n                # Return the entire section as the entry for DocumentReference\n                return [section_dict]\n\n            # Get entries from section (normal case for other sections)\n            if section.entry:\n                entries_dicts = (\n                    section.entry\n                    if isinstance(section.entry, list)\n                    else [section.entry]\n                )\n            else:\n                log.warning(f\"No entries found for section {section_key}\")\n                return entries_dicts\n\n            # Convert entries to dictionaries\n            entry_dicts = [\n                entry.model_dump(exclude_none=True, by_alias=True)\n                for entry in entries_dicts\n                if entry\n            ]\n\n            log.debug(f\"Found {len(entry_dicts)} entries in section {section_key}\")\n\n            return entry_dicts\n\n        except Exception as e:\n            log.error(f\"Error parsing section {section_key}: {str(e)}\")\n            return entries_dicts\n\n    def _find_section_by_template_id(self, section: Section, template_id: str) -&gt; bool:\n        \"\"\"Returns True if section has matching template ID\"\"\"\n        if not section.templateId:\n            return False\n\n        template_ids = (\n            section.templateId\n            if isinstance(section.templateId, list)\n            else [section.templateId]\n        )\n        return any(tid.root == template_id for tid in template_ids)\n\n    def _find_section_by_code(self, section: Section, code: str) -&gt; bool:\n        \"\"\"Returns True if section has matching code\"\"\"\n        return bool(section.code and section.code.code == code)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.parsers.cda.CDAParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the CDA parser.</p> PARAMETER DESCRIPTION <code>config</code> <p>InteropConfigManager instance containing section configurations,    templates, and mapping rules for CDA document parsing</p> <p> TYPE: <code>InteropConfigManager</code> </p> Source code in <code>healthchain/interop/parsers/cda.py</code> <pre><code>def __init__(self, config: InteropConfigManager):\n    \"\"\"Initialize the CDA parser.\n\n    Args:\n        config: InteropConfigManager instance containing section configurations,\n               templates, and mapping rules for CDA document parsing\n    \"\"\"\n    super().__init__(config)\n    self.clinical_document = None\n</code></pre>"},{"location":"api/interop/#healthchain.interop.parsers.cda.CDAParser.from_string","title":"<code>from_string(data)</code>","text":"<p>Parse input data and convert it to a structured format.</p> PARAMETER DESCRIPTION <code>data</code> <p>The CDA XML document string to parse</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the parsed data structure with sections</p> Source code in <code>healthchain/interop/parsers/cda.py</code> <pre><code>def from_string(self, data: str) -&gt; dict:\n    \"\"\"\n    Parse input data and convert it to a structured format.\n\n    Args:\n        data: The CDA XML document string to parse\n\n    Returns:\n        A dictionary containing the parsed data structure with sections\n    \"\"\"\n    return self.parse_document(data)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.parsers.cda.CDAParser.parse_document","title":"<code>parse_document(xml)</code>","text":"<p>Parse a complete CDA document and extract entries from all configured sections.</p> <p>This method parses a CDA XML document and extracts entries from each section that is defined in the configuration. It uses xmltodict to parse the XML into a dictionary and then processes each configured section to extract its entries.</p> PARAMETER DESCRIPTION <code>xml</code> <p>The CDA XML document string to parse</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, List[Dict]]</code> <p>Dict[str, List[Dict]]: Dictionary mapping section keys (e.g. \"problems\", \"medications\") to lists of entry dictionaries containing the parsed data from that section (xmltodict format).</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the XML string is empty or invalid</p> <code>Exception</code> <p>If there is an error parsing the document or any section</p> Example <p>parser = CDAParser(config) sections = parser.from_string(cda_xml) problems = sections.get(\"problems\", [])</p> Source code in <code>healthchain/interop/parsers/cda.py</code> <pre><code>def parse_document(self, xml: str) -&gt; Dict[str, List[Dict]]:\n    \"\"\"Parse a complete CDA document and extract entries from all configured sections.\n\n    This method parses a CDA XML document and extracts entries from each section that is\n    defined in the configuration. It uses xmltodict to parse the XML into a dictionary\n    and then processes each configured section to extract its entries.\n\n    Args:\n        xml: The CDA XML document string to parse\n\n    Returns:\n        Dict[str, List[Dict]]: Dictionary mapping section keys (e.g. \"problems\",\n            \"medications\") to lists of entry dictionaries containing the parsed data\n            from that section (xmltodict format).\n\n    Raises:\n        ValueError: If the XML string is empty or invalid\n        Exception: If there is an error parsing the document or any section\n\n    Example:\n        &gt;&gt;&gt; parser = CDAParser(config)\n        &gt;&gt;&gt; sections = parser.from_string(cda_xml)\n        &gt;&gt;&gt; problems = sections.get(\"problems\", [])\n    \"\"\"\n    section_entries = {}\n\n    # Parse the document once\n    try:\n        doc_dict = xmltodict.parse(xml)\n        self.clinical_document = ClinicalDocument(**doc_dict[\"ClinicalDocument\"])\n    except Exception as e:\n        log.error(f\"Error parsing CDA document: {str(e)}\")\n        return section_entries\n\n    # Get section configurations\n    sections = self.config.get_cda_section_configs()\n    if not sections:\n        log.warning(\"No sections found in configuration\")\n        return section_entries\n\n    # Process each section from the configuration\n    for section_key in sections.keys():\n        try:\n            entries = self._parse_section_entries_from_document(section_key)\n            if entries:\n                section_entries[section_key] = entries\n        except Exception as e:\n            log.error(f\"Failed to parse section {section_key}: {str(e)}\")\n            continue\n\n    return section_entries\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.cda.CDAGenerator","title":"<code>CDAGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>Handles generation of CDA documents from FHIR resources.</p> <p>This class provides functionality to convert FHIR resources into CDA (Clinical Document Architecture) documents using configurable templates. It handles the mapping of resources to appropriate CDA sections, rendering of entries and sections, and generation of the final XML document.</p> Example <p>generator = CDAGenerator(config_manager, template_registry)</p> Source code in <code>healthchain/interop/generators/cda.py</code> <pre><code>class CDAGenerator(BaseGenerator):\n    \"\"\"Handles generation of CDA documents from FHIR resources.\n\n    This class provides functionality to convert FHIR resources into CDA (Clinical Document Architecture)\n    documents using configurable templates. It handles the mapping of resources to appropriate CDA sections,\n    rendering of entries and sections, and generation of the final XML document.\n\n    Example:\n        generator = CDAGenerator(config_manager, template_registry)\n\n        # Convert FHIR resources to CDA XML document\n        cda_xml = generator.transform(\n            resources=fhir_resources,\n            document_type=\"ccd\"\n        )\n    \"\"\"\n\n    def transform(self, resources: List[Resource], **kwargs: Any) -&gt; str:\n        \"\"\"Transform FHIR resources to CDA format.\n\n        Args:\n            resources: List of FHIR resources\n            **kwargs:\n                document_type: Type of CDA document\n\n        Returns:\n            str: CDA document as XML string\n        \"\"\"\n        # TODO: add validation\n        document_type = kwargs.get(\"document_type\", \"ccd\")\n        return self.generate_document_from_fhir_resources(resources, document_type)\n\n    def generate_document_from_fhir_resources(\n        self,\n        resources: List[Resource],\n        document_type: str,\n        validate: bool = True,\n    ) -&gt; str:\n        \"\"\"Generate a complete CDA document from FHIR resources\n\n        This method handles the entire process of generating a CDA document:\n        1. Mapping FHIR resources to CDA sections (config)\n        2. Rendering sections (template)\n        3. Generating the final document (template)\n\n        Args:\n            resources: FHIR resources to include in the document\n            document_type: Type of document to generate\n            validate: Whether to validate the CDA document (default: True)\n\n        Returns:\n            CDA document as XML string\n        \"\"\"\n        mapped_entries = self._get_mapped_entries(resources, document_type)\n        sections = self._render_sections(mapped_entries, document_type)\n\n        # Generate final CDA document\n        return self._render_document(sections, document_type, validate=validate)\n\n    def _render_entry(\n        self,\n        resource: Resource,\n        config_key: str,\n    ) -&gt; Optional[Dict]:\n        \"\"\"Render a single entry for a resource\n\n        Args:\n            resource: FHIR resource\n            config_key: Key identifying the section\n\n        Returns:\n            Dictionary representation of the rendered entry (xmltodict)\n        \"\"\"\n        try:\n            # Get validated section configuration\n            section_config = self.config.get_cda_section_configs(config_key)\n\n            timestamp_format = self.config.get_config_value(\n                \"defaults.common.timestamp\", \"%Y%m%d\"\n            )\n            timestamp = datetime.now().strftime(format=timestamp_format)\n\n            id_format = self.config.get_config_value(\n                \"defaults.common.reference_name\", \"#{uuid}name\"\n            )\n            reference_name = id_format.replace(\"{uuid}\", str(uuid.uuid4())[:8])\n\n            # Create context\n            context = {\n                \"timestamp\": timestamp,\n                \"text_reference_name\": reference_name,\n                \"resource\": resource.model_dump(exclude_none=True),\n                \"config\": section_config,\n            }\n\n            # Get template and render\n            template = self.get_template_from_section_config(config_key, \"entry\")\n            if template is None:\n                log.error(f\"Required entry template for '{config_key}' not found\")\n                return None\n\n            return self.render_template(template, context)\n\n        except Exception as e:\n            log.error(f\"Failed to render {config_key} entry: {str(e)}\")\n            return None\n\n    def _get_mapped_entries(\n        self, resources: List[Resource], document_type: str = None\n    ) -&gt; Dict:\n        \"\"\"Map FHIR resources to CDA section entries by resource type.\n\n        Args:\n            resources: List of FHIR resources to map to CDA entries\n            document_type: Optional document type to determine which sections to include\n\n        Returns:\n            Dictionary mapping section keys (e.g. 'problems', 'medications') to lists of\n            their rendered CDA entries. For example:\n            {\n                'problems': [&lt;rendered condition entry&gt;, ...],\n                'medications': [&lt;rendered medication entry&gt;, ...]\n            }\n        \"\"\"\n        # Get included sections from document config if document_type is provided\n        include_sections = None\n        if document_type:\n            include_sections = self.config.get_config_value(\n                f\"cda.document.{document_type}.structure.body.include_sections\"\n            )\n            if include_sections:\n                log.debug(\n                    f\"Generating sections: {include_sections} for document type {document_type}\"\n                )\n\n        section_entries = {}\n        for resource in resources:\n            # Find matching section for resource type\n            resource_type = resource.__class__.__name__\n            all_configs = self.config.get_cda_section_configs()\n            section_key = _find_section_key_for_resource_type(\n                resource_type, all_configs\n            )\n            if not section_key:\n                log.error(f\"No section config found for resource type: {resource_type}\")\n                continue\n\n            # Skip if section is not included in the document config\n            if include_sections and section_key not in include_sections:\n                log.info(\n                    f\"Skipping section {section_key} as it's not in include_sections\"\n                )\n                continue\n\n            entry = self._render_entry(resource, section_key)\n            if entry:\n                section_entries.setdefault(section_key, []).append(entry)\n\n        return section_entries\n\n    def _render_sections(self, mapped_entries: Dict, document_type: str) -&gt; List[Dict]:\n        \"\"\"Render all sections with their entries\n\n        Args:\n            mapped_entries: Dictionary mapping section keys to their entries\n            document_type: Type of document to generate\n\n        Returns:\n            List of formatted section dictionaries\n\n        Raises:\n            ValueError: If section configurations or templates are not found\n        \"\"\"\n        sections = []\n\n        try:\n            # Get validated section configurations\n            section_configs = self.config.get_cda_section_configs()\n        except ValueError as e:\n            log.error(f\"Error getting section configs: {str(e)}\")\n            raise ValueError(f\"Failed to load section configurations: {str(e)}\")\n\n        # Get section template name from config\n        section_template_name = self.config.get_config_value(\n            f\"cda.document.{document_type}.templates.section\"\n        )\n        if not section_template_name:\n            raise ValueError(\n                f\"No section template found for document type: {document_type}\"\n            )\n\n        # Get the section template\n        section_template = self.get_template(section_template_name)\n        if not section_template:\n            raise ValueError(f\"Required template '{section_template_name}' not found\")\n\n        # Render each section that has entries\n        for section_key, section_config in section_configs.items():\n            entries = mapped_entries.get(section_key, [])\n            if entries:\n                try:\n                    # Special handling for notes section, bit of a hack for now\n                    if section_key == \"notes\":\n                        # For DocumentReference, the generated entries already contain the full\n                        # section structure, so we need to extract the section directly\n                        if (\n                            len(entries) &gt; 0\n                            and \"component\" in entries[0]\n                            and \"section\" in entries[0][\"component\"]\n                        ):\n                            # Just extract the first section (we don't support multiple notes sections yet)\n                            section_data = entries[0][\"component\"][\"section\"]\n                            sections.append({\"section\": section_data})\n                            continue\n\n                    # Regular handling for other resource types\n                    context = {\n                        \"entries\": entries,\n                        \"config\": section_config,\n                    }\n                    rendered = self.render_template(section_template, context)\n                    if rendered:\n                        sections.append(rendered)\n                except Exception as e:\n                    log.error(f\"Failed to render section {section_key}: {str(e)}\")\n\n        return sections\n\n    def _render_document(\n        self,\n        sections: List[Dict],\n        document_type: str,\n        validate: bool = True,\n    ) -&gt; str:\n        \"\"\"Generate the final CDA document\n\n        Args:\n            sections: List of formatted section dictionaries\n            document_type: Type of document to generate\n            validate: Whether to validate the CDA document\n\n        Returns:\n            CDA document as XML string\n\n        Raises:\n            ValueError: If document configuration or template is not found\n        \"\"\"\n        try:\n            # Get validated document configuration\n            config = self.config.get_cda_document_config(document_type)\n        except ValueError as e:\n            log.error(f\"Error getting document config: {str(e)}\")\n            raise ValueError(f\"Failed to load document configuration: {str(e)}\")\n\n        # Get document template name from config\n        document_template_name = self.config.get_config_value(\n            f\"cda.document.{document_type}.templates.document\"\n        )\n        if not document_template_name:\n            raise ValueError(\n                f\"No document template found for document type: {document_type}\"\n            )\n\n        # Get the document template\n        document_template = self.get_template(document_template_name)\n        if not document_template:\n            raise ValueError(f\"Required template '{document_template_name}' not found\")\n\n        # Create document context\n        # TODO: modify this as bundle metadata is not extracted\n        context = {\n            \"config\": config,\n            \"sections\": sections,\n        }\n\n        rendered = self.render_template(document_template, context)\n        if validate:\n            if \"ClinicalDocument\" not in rendered:\n                log.error(\n                    \"Unable to validate document structure: missing ClinicalDocument\"\n                )\n                out_dict = rendered\n            else:\n                validated = ClinicalDocument(**rendered[\"ClinicalDocument\"])\n                out_dict = {\n                    \"ClinicalDocument\": validated.model_dump(\n                        exclude_none=True, exclude_unset=True, by_alias=True\n                    )\n                }\n        else:\n            out_dict = rendered\n\n        # Get XML formatting options\n        pretty_print = self.config.get_config_value(\n            f\"cda.document.{document_type}.rendering.xml.pretty_print\", True\n        )\n        encoding = self.config.get_config_value(\n            f\"cda.document.{document_type}.rendering.xml.encoding\", \"UTF-8\"\n        )\n\n        # Generate XML without preprocessor\n        xml_string = xmltodict.unparse(out_dict, pretty=pretty_print, encoding=encoding)\n\n        # Replace text elements containing &lt; or &gt; with CDATA sections\n        # This regex matches &lt;text&gt;...&lt;/text&gt; tags where content has HTML entities\n        def replace_with_cdata(match):\n            content = match.group(1)\n            # Only process if it contains HTML entities\n            if \"&amp;lt;\" in content or \"&amp;gt;\" in content:\n                # Convert HTML entities back to characters\n                import html\n\n                decoded = html.unescape(content)\n                return f\"&lt;text&gt;&lt;![CDATA[{decoded}]]&gt;&lt;/text&gt;\"\n            return f\"&lt;text&gt;{content}&lt;/text&gt;\"\n\n        xml_string = re.sub(\n            r\"&lt;text&gt;(.*?)&lt;/text&gt;\", replace_with_cdata, xml_string, flags=re.DOTALL\n        )\n\n        # Fix self-closing tags\n        return re.sub(r\"(&lt;(\\w+)(\\s+[^&gt;]*?)?)&gt;&lt;/\\2&gt;\", r\"\\1/&gt;\", xml_string)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.cda.CDAGenerator--convert-fhir-resources-to-cda-xml-document","title":"Convert FHIR resources to CDA XML document","text":"<p>cda_xml = generator.transform(     resources=fhir_resources,     document_type=\"ccd\" )</p>"},{"location":"api/interop/#healthchain.interop.generators.cda.CDAGenerator.generate_document_from_fhir_resources","title":"<code>generate_document_from_fhir_resources(resources, document_type, validate=True)</code>","text":"<p>Generate a complete CDA document from FHIR resources</p> <p>This method handles the entire process of generating a CDA document: 1. Mapping FHIR resources to CDA sections (config) 2. Rendering sections (template) 3. Generating the final document (template)</p> PARAMETER DESCRIPTION <code>resources</code> <p>FHIR resources to include in the document</p> <p> TYPE: <code>List[Resource]</code> </p> <code>document_type</code> <p>Type of document to generate</p> <p> TYPE: <code>str</code> </p> <code>validate</code> <p>Whether to validate the CDA document (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>CDA document as XML string</p> Source code in <code>healthchain/interop/generators/cda.py</code> <pre><code>def generate_document_from_fhir_resources(\n    self,\n    resources: List[Resource],\n    document_type: str,\n    validate: bool = True,\n) -&gt; str:\n    \"\"\"Generate a complete CDA document from FHIR resources\n\n    This method handles the entire process of generating a CDA document:\n    1. Mapping FHIR resources to CDA sections (config)\n    2. Rendering sections (template)\n    3. Generating the final document (template)\n\n    Args:\n        resources: FHIR resources to include in the document\n        document_type: Type of document to generate\n        validate: Whether to validate the CDA document (default: True)\n\n    Returns:\n        CDA document as XML string\n    \"\"\"\n    mapped_entries = self._get_mapped_entries(resources, document_type)\n    sections = self._render_sections(mapped_entries, document_type)\n\n    # Generate final CDA document\n    return self._render_document(sections, document_type, validate=validate)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.cda.CDAGenerator.transform","title":"<code>transform(resources, **kwargs)</code>","text":"<p>Transform FHIR resources to CDA format.</p> PARAMETER DESCRIPTION <code>resources</code> <p>List of FHIR resources</p> <p> TYPE: <code>List[Resource]</code> </p> <code>**kwargs</code> <p>document_type: Type of CDA document</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>str</code> <p>CDA document as XML string</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/interop/generators/cda.py</code> <pre><code>def transform(self, resources: List[Resource], **kwargs: Any) -&gt; str:\n    \"\"\"Transform FHIR resources to CDA format.\n\n    Args:\n        resources: List of FHIR resources\n        **kwargs:\n            document_type: Type of CDA document\n\n    Returns:\n        str: CDA document as XML string\n    \"\"\"\n    # TODO: add validation\n    document_type = kwargs.get(\"document_type\", \"ccd\")\n    return self.generate_document_from_fhir_resources(resources, document_type)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator","title":"<code>FHIRGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>Handles generation of FHIR resources from templates.</p> <p>This class provides functionality to convert CDA section entries into FHIR resources using configurable templates. It handles validation, required field population, and error handling during the conversion process.</p> <p>Key features: - Template-based conversion of CDA entries (xmltodict format) to FHIR resources - Automatic population of required FHIR fields based on configuration for     common resource types like Condition, MedicationStatement, AllergyIntolerance - Validation of generated FHIR resources</p> Example <p>generator = FHIRGenerator(config_manager, template_registry)</p> Source code in <code>healthchain/interop/generators/fhir.py</code> <pre><code>class FHIRGenerator(BaseGenerator):\n    \"\"\"Handles generation of FHIR resources from templates.\n\n    This class provides functionality to convert CDA section entries into FHIR resources\n    using configurable templates. It handles validation, required field population, and\n    error handling during the conversion process.\n\n    Key features:\n    - Template-based conversion of CDA entries (xmltodict format) to FHIR resources\n    - Automatic population of required FHIR fields based on configuration for\n        common resource types like Condition, MedicationStatement, AllergyIntolerance\n    - Validation of generated FHIR resources\n\n    Example:\n        generator = FHIRGenerator(config_manager, template_registry)\n\n        # Convert CDA problem entries to FHIR Condition resources\n        problems = generator.generate_resources_from_cda_section_entries(\n            entries=problem_entries,\n            section_key=\"problems\"  # from configs\n        )\n    \"\"\"\n\n    def transform(self, data: List[Dict], **kwargs: Any) -&gt; List[Resource]:\n        \"\"\"Transform input data to FHIR resources.\n\n        Args:\n            data: List of entries from source format\n            **kwargs:\n                src_format: The source format type (FormatType.CDA or FormatType.HL7V2)\n                section_key: For CDA, the section key\n                message_key: For HL7v2, the message key\n\n        Returns:\n            List[Resource]: FHIR resources\n        \"\"\"\n        src_format = kwargs.get(\"src_format\")\n        if src_format == FormatType.CDA:\n            return self.generate_resources_from_cda_section_entries(\n                data, kwargs.get(\"section_key\")\n            )\n        elif src_format == FormatType.HL7V2:\n            return self.generate_resources_from_hl7v2_entries(\n                data, kwargs.get(\"message_key\")\n            )\n        else:\n            raise ValueError(f\"Unsupported source format: {src_format}\")\n\n    def generate_resources_from_cda_section_entries(\n        self, entries: List[Dict], section_key: str\n    ) -&gt; List[Dict]:\n        \"\"\"\n        Convert CDA section entries into FHIR resources using configured templates.\n\n        This method processes entries from a CDA section and generates corresponding FHIR\n        resources based on templates and configuration. It handles validation and error\n        checking during the conversion process.\n\n        Args:\n            entries: List of CDA section entries in xmltodict format to convert\n            section_key: Configuration key identifying the section (e.g. \"problems\", \"medications\")\n                Used to look up templates and resource type mappings\n\n        Returns:\n            List of validated FHIR resource dictionaries. Empty list if conversion fails.\n\n        Example:\n            # Convert problem list entries to FHIR Condition resources\n            conditions = generator.generate_resources_from_cda_section_entries(\n                problem_entries, \"problems\"\n            )\n        \"\"\"\n        if not section_key:\n            log.error(\n                \"No section key provided for CDA section entries: data needs to be in the format \\\n                      '{&lt;section_key&gt;}: {&lt;section_entries&gt;}'\"\n            )\n            return []\n\n        resources = []\n        template = self.get_template_from_section_config(section_key, \"resource\")\n\n        if not template:\n            log.error(f\"No resource template found for section {section_key}\")\n            return resources\n\n        resource_type = self.config.get_config_value(\n            f\"cda.sections.{section_key}.resource\"\n        )\n        if not resource_type:\n            log.error(f\"No resource type specified for section {section_key}\")\n            return resources\n\n        for entry in entries:\n            try:\n                # Convert entry to FHIR resource dictionary\n                resource_dict = self._render_resource_from_entry(\n                    entry, section_key, template\n                )\n                if not resource_dict:\n                    continue\n\n                log.debug(f\"Rendered FHIR resource: {resource_dict}\")\n\n                resource = self._validate_fhir_resource(resource_dict, resource_type)\n\n                if resource:\n                    resources.append(resource)\n\n            except Exception as e:\n                log.error(f\"Failed to convert entry in section {section_key}: {str(e)}\")\n                continue\n\n        return resources\n\n    def _render_resource_from_entry(\n        self, entry: Dict, section_key: str, template: Type[Template]\n    ) -&gt; Optional[Dict]:\n        \"\"\"Renders a FHIR resource dictionary from a CDA entry using templates.\n\n        Args:\n            entry: CDA entry dictionary\n            section_key: Section identifier (e.g. \"problems\")\n            template: Template to use for rendering\n\n        Returns:\n            FHIR resource dictionary or None if rendering fails\n        \"\"\"\n        try:\n            # Get validated section configuration\n            try:\n                section_config = self.config.get_cda_section_configs(section_key)\n            except ValueError as e:\n                log.error(\n                    f\"Failed to get CDA section config for {section_key}: {str(e)}\"\n                )\n                return None\n\n            # Create context with entry data and config\n            context = {\"entry\": entry, \"config\": section_config}\n\n            # Render template with context\n            return self.render_template(template, context)\n\n        except Exception as e:\n            log.error(f\"Failed to render resource for section {section_key}: {str(e)}\")\n            return None\n\n    def _validate_fhir_resource(\n        self, resource_dict: Dict, resource_type: str\n    ) -&gt; Optional[Resource]:\n        \"\"\"Validates and creates a FHIR resource from a dictionary.\n        Adds required fields.\n\n        Args:\n            resource_dict: FHIR resource dictionary\n            resource_type: FHIR resource type\n\n        Returns:\n            FHIR resource or None if validation fails\n        \"\"\"\n\n        try:\n            resource_dict = self._add_required_fields(resource_dict, resource_type)\n            resource = create_resource_from_dict(resource_dict, resource_type)\n            if resource:\n                return resource\n        except Exception as e:\n            log.error(f\"Failed to validate FHIR resource: {str(e)}\")\n            return None\n\n    def _add_required_fields(self, resource_dict: Dict, resource_type: str) -&gt; Dict:\n        \"\"\"Add required fields to FHIR resource dictionary based on resource type.\n        Currently only supports Condition, MedicationStatement, and AllergyIntolerance.\n\n        Args:\n            resource_dict: Dictionary representation of the resource\n            resource_type: Type of FHIR resource\n\n        Returns:\n            Dict: Resource dictionary with required fields added\n        \"\"\"\n        # Add common fields\n        id_prefix = self.config.get_config_value(\"defaults.common.id_prefix\", \"hc-\")\n        if \"id\" not in resource_dict:\n            resource_dict[\"id\"] = f\"{id_prefix}{str(uuid.uuid4())}\"\n\n        # Get default values from configuration if available\n        default_subject = self.config.get_config_value(\"defaults.common.subject\")\n\n        # Add resource-specific required fields\n        if resource_type == \"Condition\":\n            if \"subject\" not in resource_dict:\n                resource_dict[\"subject\"] = default_subject\n\n            if \"clinicalStatus\" not in resource_dict:\n                default_status = self.config.get_config_value(\n                    \"defaults.resources.Condition.clinicalStatus\"\n                )\n                resource_dict[\"clinicalStatus\"] = default_status\n        elif resource_type == \"MedicationStatement\":\n            if \"subject\" not in resource_dict:\n                resource_dict[\"subject\"] = default_subject\n            if \"status\" not in resource_dict:\n                default_status = self.config.get_config_value(\n                    \"defaults.resources.MedicationStatement.status\"\n                )\n                resource_dict[\"status\"] = default_status\n        elif resource_type == \"AllergyIntolerance\":\n            if \"patient\" not in resource_dict:\n                resource_dict[\"patient\"] = default_subject\n            if \"clinicalStatus\" not in resource_dict:\n                default_status = self.config.get_config_value(\n                    \"defaults.resources.AllergyIntolerance.clinicalStatus\"\n                )\n                resource_dict[\"clinicalStatus\"] = default_status\n\n        return resource_dict\n\n    def generate_resources_from_hl7v2_entries(\n        self, entries: List[Dict], message_key: str\n    ) -&gt; List[Dict]:\n        \"\"\"\n        Convert HL7v2 message entries into FHIR resources.\n        This is a placeholder implementation.\n\n        Args:\n            entries: List of HL7v2 message entries to convert\n            message_key: Key identifying the message type\n\n        Returns:\n            List of FHIR resources\n        \"\"\"\n        log.warning(\n            \"FHIR resource generation from HL7v2 is a placeholder implementation\"\n        )\n        return []\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator--convert-cda-problem-entries-to-fhir-condition-resources","title":"Convert CDA problem entries to FHIR Condition resources","text":"<p>problems = generator.generate_resources_from_cda_section_entries(     entries=problem_entries,     section_key=\"problems\"  # from configs )</p>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator.generate_resources_from_cda_section_entries","title":"<code>generate_resources_from_cda_section_entries(entries, section_key)</code>","text":"<p>Convert CDA section entries into FHIR resources using configured templates.</p> <p>This method processes entries from a CDA section and generates corresponding FHIR resources based on templates and configuration. It handles validation and error checking during the conversion process.</p> PARAMETER DESCRIPTION <code>entries</code> <p>List of CDA section entries in xmltodict format to convert</p> <p> TYPE: <code>List[Dict]</code> </p> <code>section_key</code> <p>Configuration key identifying the section (e.g. \"problems\", \"medications\") Used to look up templates and resource type mappings</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[Dict]</code> <p>List of validated FHIR resource dictionaries. Empty list if conversion fails.</p> Example Source code in <code>healthchain/interop/generators/fhir.py</code> <pre><code>def generate_resources_from_cda_section_entries(\n    self, entries: List[Dict], section_key: str\n) -&gt; List[Dict]:\n    \"\"\"\n    Convert CDA section entries into FHIR resources using configured templates.\n\n    This method processes entries from a CDA section and generates corresponding FHIR\n    resources based on templates and configuration. It handles validation and error\n    checking during the conversion process.\n\n    Args:\n        entries: List of CDA section entries in xmltodict format to convert\n        section_key: Configuration key identifying the section (e.g. \"problems\", \"medications\")\n            Used to look up templates and resource type mappings\n\n    Returns:\n        List of validated FHIR resource dictionaries. Empty list if conversion fails.\n\n    Example:\n        # Convert problem list entries to FHIR Condition resources\n        conditions = generator.generate_resources_from_cda_section_entries(\n            problem_entries, \"problems\"\n        )\n    \"\"\"\n    if not section_key:\n        log.error(\n            \"No section key provided for CDA section entries: data needs to be in the format \\\n                  '{&lt;section_key&gt;}: {&lt;section_entries&gt;}'\"\n        )\n        return []\n\n    resources = []\n    template = self.get_template_from_section_config(section_key, \"resource\")\n\n    if not template:\n        log.error(f\"No resource template found for section {section_key}\")\n        return resources\n\n    resource_type = self.config.get_config_value(\n        f\"cda.sections.{section_key}.resource\"\n    )\n    if not resource_type:\n        log.error(f\"No resource type specified for section {section_key}\")\n        return resources\n\n    for entry in entries:\n        try:\n            # Convert entry to FHIR resource dictionary\n            resource_dict = self._render_resource_from_entry(\n                entry, section_key, template\n            )\n            if not resource_dict:\n                continue\n\n            log.debug(f\"Rendered FHIR resource: {resource_dict}\")\n\n            resource = self._validate_fhir_resource(resource_dict, resource_type)\n\n            if resource:\n                resources.append(resource)\n\n        except Exception as e:\n            log.error(f\"Failed to convert entry in section {section_key}: {str(e)}\")\n            continue\n\n    return resources\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator.generate_resources_from_cda_section_entries--convert-problem-list-entries-to-fhir-condition-resources","title":"Convert problem list entries to FHIR Condition resources","text":"<p>conditions = generator.generate_resources_from_cda_section_entries(     problem_entries, \"problems\" )</p>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator.generate_resources_from_hl7v2_entries","title":"<code>generate_resources_from_hl7v2_entries(entries, message_key)</code>","text":"<p>Convert HL7v2 message entries into FHIR resources. This is a placeholder implementation.</p> PARAMETER DESCRIPTION <code>entries</code> <p>List of HL7v2 message entries to convert</p> <p> TYPE: <code>List[Dict]</code> </p> <code>message_key</code> <p>Key identifying the message type</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[Dict]</code> <p>List of FHIR resources</p> Source code in <code>healthchain/interop/generators/fhir.py</code> <pre><code>def generate_resources_from_hl7v2_entries(\n    self, entries: List[Dict], message_key: str\n) -&gt; List[Dict]:\n    \"\"\"\n    Convert HL7v2 message entries into FHIR resources.\n    This is a placeholder implementation.\n\n    Args:\n        entries: List of HL7v2 message entries to convert\n        message_key: Key identifying the message type\n\n    Returns:\n        List of FHIR resources\n    \"\"\"\n    log.warning(\n        \"FHIR resource generation from HL7v2 is a placeholder implementation\"\n    )\n    return []\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator.transform","title":"<code>transform(data, **kwargs)</code>","text":"<p>Transform input data to FHIR resources.</p> PARAMETER DESCRIPTION <code>data</code> <p>List of entries from source format</p> <p> TYPE: <code>List[Dict]</code> </p> <code>**kwargs</code> <p>src_format: The source format type (FormatType.CDA or FormatType.HL7V2) section_key: For CDA, the section key message_key: For HL7v2, the message key</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List[Resource]: FHIR resources</p> Source code in <code>healthchain/interop/generators/fhir.py</code> <pre><code>def transform(self, data: List[Dict], **kwargs: Any) -&gt; List[Resource]:\n    \"\"\"Transform input data to FHIR resources.\n\n    Args:\n        data: List of entries from source format\n        **kwargs:\n            src_format: The source format type (FormatType.CDA or FormatType.HL7V2)\n            section_key: For CDA, the section key\n            message_key: For HL7v2, the message key\n\n    Returns:\n        List[Resource]: FHIR resources\n    \"\"\"\n    src_format = kwargs.get(\"src_format\")\n    if src_format == FormatType.CDA:\n        return self.generate_resources_from_cda_section_entries(\n            data, kwargs.get(\"section_key\")\n        )\n    elif src_format == FormatType.HL7V2:\n        return self.generate_resources_from_hl7v2_entries(\n            data, kwargs.get(\"message_key\")\n        )\n    else:\n        raise ValueError(f\"Unsupported source format: {src_format}\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.AllergySectionTemplateConfig","title":"<code>AllergySectionTemplateConfig</code>","text":"<p>               Bases: <code>SectionTemplateConfigBase</code></p> <p>Template configuration for Allergy Section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class AllergySectionTemplateConfig(SectionTemplateConfigBase):\n    \"\"\"Template configuration for Allergy Section\"\"\"\n\n    act: ComponentTemplateConfig\n    allergy_obs: ComponentTemplateConfig\n    reaction_obs: Optional[ComponentTemplateConfig] = None\n    severity_obs: Optional[ComponentTemplateConfig] = None\n    clinical_status_obs: ComponentTemplateConfig\n\n    @field_validator(\"allergy_obs\")\n    @classmethod\n    def validate_allergy_obs(cls, v):\n        required_fields = {\"code\", \"code_system\", \"status_code\"}\n        missing = required_fields - set(v.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(f\"allergy_obs missing required fields: {missing}\")\n        return v\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.CcdDocumentConfig","title":"<code>CcdDocumentConfig</code>","text":"<p>               Bases: <code>DocumentConfigBase</code></p> <p>Configuration model specific to CCD documents</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class CcdDocumentConfig(DocumentConfigBase):\n    \"\"\"Configuration model specific to CCD documents\"\"\"\n\n    allowed_sections: List[str] = [\"problems\", \"medications\", \"notes\"]\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.ComponentTemplateConfig","title":"<code>ComponentTemplateConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic template for CDA/FHIR component configuration</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class ComponentTemplateConfig(BaseModel):\n    \"\"\"Generic template for CDA/FHIR component configuration\"\"\"\n\n    template_id: Union[List[str], str]\n    code: Optional[str] = None\n    code_system: Optional[str] = \"2.16.840.1.113883.6.1\"\n    code_system_name: Optional[str] = \"LOINC\"\n    display_name: Optional[str] = None\n    status_code: Optional[str] = \"active\"\n    class_code: Optional[str] = None\n    mood_code: Optional[str] = None\n    type_code: Optional[str] = None\n    inversion_ind: Optional[bool] = None\n    value: Optional[Dict[str, Any]] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.DocumentConfigBase","title":"<code>DocumentConfigBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic document configuration model</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class DocumentConfigBase(BaseModel):\n    \"\"\"Generic document configuration model\"\"\"\n\n    type_id: Dict[str, Any]\n    code: Dict[str, Any]\n    confidentiality_code: Dict[str, Any]\n    language_code: Optional[str] = \"en-US\"\n    templates: Optional[Dict[str, Any]] = None\n    structure: Optional[Dict[str, Any]] = None\n    defaults: Optional[Dict[str, Any]] = None\n    rendering: Optional[Dict[str, Any]] = None\n\n    @field_validator(\"type_id\")\n    @classmethod\n    def validate_type_id(cls, v):\n        if not isinstance(v, dict) or \"root\" not in v:\n            raise ValueError(\"type_id must contain 'root' field\")\n        return v\n\n    @field_validator(\"code\")\n    @classmethod\n    def validate_code(cls, v):\n        if not isinstance(v, dict) or \"code\" not in v or \"code_system\" not in v:\n            raise ValueError(\"code must contain 'code' and 'code_system' fields\")\n        return v\n\n    @field_validator(\"confidentiality_code\")\n    @classmethod\n    def validate_confidentiality_code(cls, v):\n        if not isinstance(v, dict) or \"code\" not in v:\n            raise ValueError(\"confidentiality_code must contain 'code' field\")\n        return v\n\n    @field_validator(\"templates\")\n    @classmethod\n    def validate_templates(cls, v):\n        if not isinstance(v, dict) or \"section\" not in v or \"document\" not in v:\n            raise ValueError(\"templates must contain 'section' and 'document' fields\")\n        return v\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.MedicationSectionTemplateConfig","title":"<code>MedicationSectionTemplateConfig</code>","text":"<p>               Bases: <code>SectionTemplateConfigBase</code></p> <p>Template configuration for SubstanceAdministration Section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class MedicationSectionTemplateConfig(SectionTemplateConfigBase):\n    \"\"\"Template configuration for SubstanceAdministration Section\"\"\"\n\n    substance_admin: ComponentTemplateConfig\n    manufactured_product: ComponentTemplateConfig\n    clinical_status_obs: ComponentTemplateConfig\n\n    @field_validator(\"substance_admin\")\n    @classmethod\n    def validate_substance_admin(cls, v):\n        if not v.status_code:\n            raise ValueError(\"substance_admin requires status_code\")\n        return v\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.NoteSectionTemplateConfig","title":"<code>NoteSectionTemplateConfig</code>","text":"<p>               Bases: <code>SectionTemplateConfigBase</code></p> <p>Template configuration for Notes Section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class NoteSectionTemplateConfig(SectionTemplateConfigBase):\n    \"\"\"Template configuration for Notes Section\"\"\"\n\n    note_section: ComponentTemplateConfig\n\n    @field_validator(\"note_section\")\n    @classmethod\n    def validate_note_section(cls, v):\n        required_fields = {\"template_id\", \"code\", \"code_system\", \"status_code\"}\n        missing = required_fields - set(v.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(f\"note_section missing required fields: {missing}\")\n        return v\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.ProblemSectionTemplateConfig","title":"<code>ProblemSectionTemplateConfig</code>","text":"<p>               Bases: <code>SectionTemplateConfigBase</code></p> <p>Template configuration for Problem Section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class ProblemSectionTemplateConfig(SectionTemplateConfigBase):\n    \"\"\"Template configuration for Problem Section\"\"\"\n\n    act: ComponentTemplateConfig\n    problem_obs: ComponentTemplateConfig\n    clinical_status_obs: ComponentTemplateConfig\n\n    @field_validator(\"problem_obs\")\n    @classmethod\n    def validate_problem_obs(cls, v):\n        required_fields = {\"code\", \"code_system\", \"status_code\"}\n        missing = required_fields - set(v.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(f\"problem_obs missing required fields: {missing}\")\n        return v\n\n    @field_validator(\"clinical_status_obs\")\n    @classmethod\n    def validate_clinical_status(cls, v):\n        required_fields = {\"code\", \"code_system\", \"status_code\"}\n        missing = required_fields - set(v.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(f\"clinical_status_obs missing required fields: {missing}\")\n        return v\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.RenderingConfig","title":"<code>RenderingConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for section rendering</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class RenderingConfig(BaseModel):\n    \"\"\"Configuration for section rendering\"\"\"\n\n    narrative: Optional[Dict[str, Any]] = None\n    entry: Optional[Dict[str, Any]] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.SectionBaseConfig","title":"<code>SectionBaseConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for all section configurations</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class SectionBaseConfig(BaseModel):\n    \"\"\"Base model for all section configurations\"\"\"\n\n    resource: str\n    resource_template: str\n    entry_template: str\n    identifiers: SectionIdentifiersConfig\n    rendering: Optional[RenderingConfig] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.SectionIdentifiersConfig","title":"<code>SectionIdentifiersConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Section identifiers validation</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class SectionIdentifiersConfig(BaseModel):\n    \"\"\"Section identifiers validation\"\"\"\n\n    template_id: str\n    code: str\n    code_system: Optional[str] = \"2.16.840.1.113883.6.1\"\n    code_system_name: Optional[str] = \"LOINC\"\n    display: str\n    clinical_status: Optional[Dict[str, str]] = None\n    reaction: Optional[Dict[str, str]] = None\n    severity: Optional[Dict[str, str]] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.SectionTemplateConfigBase","title":"<code>SectionTemplateConfigBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for section template configurations</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class SectionTemplateConfigBase(BaseModel):\n    \"\"\"Base class for section template configurations\"\"\"\n\n    def validate_component_fields(self, component, required_fields):\n        \"\"\"Helper method to validate required fields in a component\"\"\"\n        missing = required_fields - set(component.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(\n                f\"{component.__class__.__name__} missing required fields: {missing}\"\n            )\n        return component\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.SectionTemplateConfigBase.validate_component_fields","title":"<code>validate_component_fields(component, required_fields)</code>","text":"<p>Helper method to validate required fields in a component</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def validate_component_fields(self, component, required_fields):\n    \"\"\"Helper method to validate required fields in a component\"\"\"\n    missing = required_fields - set(component.model_dump(exclude_unset=True).keys())\n    if missing:\n        raise ValueError(\n            f\"{component.__class__.__name__} missing required fields: {missing}\"\n        )\n    return component\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.create_cda_section_validator","title":"<code>create_cda_section_validator(resource_type, template_model)</code>","text":"<p>Create a section validator for a specific resource type</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def create_cda_section_validator(\n    resource_type: str, template_model: Type[BaseModel]\n) -&gt; Type[BaseModel]:\n    \"\"\"Create a section validator for a specific resource type\"\"\"\n\n    class DynamicSectionConfig(SectionBaseConfig):\n        template: Dict[str, Any]\n\n        @field_validator(\"template\")\n        @classmethod\n        def validate_template(cls, v):\n            try:\n                template_model(**v)\n            except ValidationError as e:\n                raise ValueError(f\"Template validation failed: {str(e)}\")\n            return v\n\n    DynamicSectionConfig.__name__ = f\"{resource_type}SectionConfig\"\n    return DynamicSectionConfig\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.register_cda_document_template_config_model","title":"<code>register_cda_document_template_config_model(document_type, document_model)</code>","text":"<p>Register a custom document model</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def register_cda_document_template_config_model(\n    document_type: str, document_model: Type[BaseModel]\n) -&gt; None:\n    \"\"\"Register a custom document model\"\"\"\n    CDA_DOCUMENT_CONFIG_REGISTRY[document_type.lower()] = document_model\n    logger.info(f\"Registered custom document model for {document_type}\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.register_cda_section_template_config_model","title":"<code>register_cda_section_template_config_model(resource_type, template_model)</code>","text":"<p>Register a custom template model for a section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def register_cda_section_template_config_model(\n    resource_type: str, template_model: Type[BaseModel]\n) -&gt; None:\n    \"\"\"Register a custom template model for a section\"\"\"\n    CDA_SECTION_CONFIG_REGISTRY[resource_type] = template_model\n    SECTION_VALIDATORS[resource_type] = create_cda_section_validator(\n        resource_type, template_model\n    )\n    logger.info(f\"Registered custom template model for {resource_type}\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.validate_cda_document_config_model","title":"<code>validate_cda_document_config_model(document_type, document_config)</code>","text":"<p>Validate a document configuration</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def validate_cda_document_config_model(\n    document_type: str, document_config: Dict[str, Any]\n) -&gt; bool:\n    \"\"\"Validate a document configuration\"\"\"\n    validator = CDA_DOCUMENT_CONFIG_REGISTRY.get(document_type.lower())\n    if not validator:\n        logger.warning(f\"No specific validator for document type: {document_type}\")\n        return True\n\n    try:\n        validator(**document_config)\n        return True\n    except ValidationError as e:\n        logger.error(f\"Document validation failed for {document_type}: {str(e)}\")\n        return False\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.validate_cda_section_config_model","title":"<code>validate_cda_section_config_model(section_key, section_config)</code>","text":"<p>Validate a section configuration</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def validate_cda_section_config_model(\n    section_key: str, section_config: Dict[str, Any]\n) -&gt; bool:\n    \"\"\"Validate a section configuration\"\"\"\n    resource_type = section_config.get(\"resource\")\n    if not resource_type:\n        logger.error(f\"Section '{section_key}' is missing 'resource' field\")\n        return False\n\n    validator = SECTION_VALIDATORS.get(resource_type)\n    if not validator:\n        # TODO: Pass validation level to this\n        logger.warning(f\"No specific validator for resource type: {resource_type}\")\n        return True\n\n    try:\n        validator(**section_config)\n        return True\n    except ValidationError as e:\n        logger.error(f\"Section validation failed for {resource_type}: {str(e)}\")\n        return False\n</code></pre>"},{"location":"api/pipeline/","title":"Pipeline","text":""},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline","title":"<code>BasePipeline</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for creating and managing data processing pipelines.</p> <p>The BasePipeline class provides a framework for building modular data processing pipelines by allowing users to add, remove, and configure components with defined dependencies and execution order. Components can be added at specific positions and grouped into stages.</p> <p>This is an abstract base class that should be subclassed to create specific pipeline implementations.</p> ATTRIBUTE DESCRIPTION <code>_components</code> <p>Ordered list of pipeline components</p> <p> TYPE: <code>List[PipelineNode[T]]</code> </p> <code>_stages</code> <p>Components grouped by processing stage</p> <p> TYPE: <code>Dict[str, List[Callable]]</code> </p> <code>_built_pipeline</code> <p>Compiled pipeline function</p> <p> TYPE: <code>Optional[Callable]</code> </p> <code>_output_template</code> <p>Template string for formatting pipeline outputs</p> <p> TYPE: <code>Optional[str]</code> </p> <code>_output_template_path</code> <p>Path to template file for formatting pipeline outputs</p> <p> TYPE: <code>Optional[Path]</code> </p> Example <p>class MyPipeline(BasePipeline[Document]): ...     def configure_pipeline(self, config: ModelConfig) -&gt; None: ...         self.add_node(preprocess, stage=\"preprocessing\") ...         self.add_node(process, stage=\"processing\") ...         self.add_node(postprocess, stage=\"postprocessing\") ... pipeline = MyPipeline() result = pipeline(document)  # Document \u2192 Document</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class BasePipeline(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for creating and managing data processing pipelines.\n\n    The BasePipeline class provides a framework for building modular data processing pipelines\n    by allowing users to add, remove, and configure components with defined dependencies and\n    execution order. Components can be added at specific positions and grouped into stages.\n\n    This is an abstract base class that should be subclassed to create specific pipeline\n    implementations.\n\n    Attributes:\n        _components (List[PipelineNode[T]]): Ordered list of pipeline components\n        _stages (Dict[str, List[Callable]]): Components grouped by processing stage\n        _built_pipeline (Optional[Callable]): Compiled pipeline function\n        _output_template (Optional[str]): Template string for formatting pipeline outputs\n        _output_template_path (Optional[Path]): Path to template file for formatting pipeline outputs\n\n    Example:\n        &gt;&gt;&gt; class MyPipeline(BasePipeline[Document]):\n        ...     def configure_pipeline(self, config: ModelConfig) -&gt; None:\n        ...         self.add_node(preprocess, stage=\"preprocessing\")\n        ...         self.add_node(process, stage=\"processing\")\n        ...         self.add_node(postprocess, stage=\"postprocessing\")\n        ...\n        &gt;&gt;&gt; pipeline = MyPipeline()\n        &gt;&gt;&gt; result = pipeline(document)  # Document \u2192 Document\n    \"\"\"\n\n    def __init__(self):\n        self._components: List[PipelineNode[T]] = []\n        self._stages: Dict[str, List[Callable]] = {}\n        self._built_pipeline: Optional[Callable] = None\n        self._output_template: Optional[str] = None\n        self._output_template_path: Optional[Path] = None\n\n    def __repr__(self) -&gt; str:\n        components_repr = \", \".join(\n            [f'\"{component.name}\"' for component in self._components]\n        )\n        return f\"[{components_repr}]\"\n\n    def _configure_output_templates(\n        self,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Configure template settings for the pipeline.\n\n        Args:\n            template (Optional[str]): Template string for formatting outputs.\n                Defaults to None.\n            template_path (Optional[Union[str, Path]]): Path to template file.\n                Defaults to None.\n        \"\"\"\n        self._output_template = template\n        self._output_template_path = Path(template_path) if template_path else None\n\n    @classmethod\n    def load(\n        cls,\n        pipeline: Callable,\n        source: str,\n        task: Optional[str] = \"text-generation\",\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"\n        Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).\n\n        Args:\n            pipeline (Callable): A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)\n            source (str): Source of the pipeline. Can be \"langchain\" or \"huggingface\".\n            task (Optional[str]): Task identifier used to retrieve model outputs.\n                Defaults to \"text-generation\".\n            template (Optional[str]): Template string for formatting outputs.\n                Defaults to None.\n            template_path (Optional[Union[str, Path]]): Path to template file.\n                Defaults to None.\n            **kwargs: Additional configuration options passed to the pipeline.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If pipeline is not callable or source is invalid.\n\n        Examples:\n            &gt;&gt;&gt; # Load LangChain pipeline\n            &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n            &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n            &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n            &gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load HuggingFace pipeline\n            &gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n            &gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n            &gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n            &gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n            &gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n        \"\"\"\n        if not (hasattr(pipeline, \"__call__\") or hasattr(pipeline, \"invoke\")):\n            raise ValueError(\"Pipeline must be a callable object\")\n\n        # Validate source\n        source = source.lower()\n        if source not in [\"langchain\", \"huggingface\"]:\n            raise ValueError(\n                \"Source must be either 'langchain' or 'huggingface' for direct pipeline loading\"\n            )\n\n        # For HuggingFace pipelines, try to infer task if not provided\n        if source == \"huggingface\" and hasattr(pipeline, \"task\") and not task:\n            task = pipeline.task\n\n        instance = cls()\n        instance._configure_output_templates(template, template_path)\n\n        config = ModelConfig(\n            source=ModelSource(source),\n            pipeline_object=pipeline,\n            task=task,\n            kwargs=kwargs,\n        )\n\n        instance._model_config = config\n        instance.configure_pipeline(config)\n\n        return instance\n\n    @classmethod\n    def from_model_id(\n        cls,\n        model_id: str,\n        source: Union[str, ModelSource] = \"huggingface\",\n        task: Optional[str] = \"text-generation\",\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"\n        Load pipeline from a model identifier.\n\n        Args:\n            model_id (str): Model identifier (e.g. HuggingFace model ID, SpaCy model name)\n            source (Union[str, ModelSource]): Model source. Defaults to \"huggingface\".\n                Can be \"huggingface\", \"spacy\".\n            task (Optional[str]): Task identifier for the model. Defaults to \"text-generation\".\n            template (Optional[str]): Optional template string for formatting model output.\n            template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n            **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If source is not a valid ModelSource.\n\n        Examples:\n            &gt;&gt;&gt; # Load HuggingFace model\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"facebook/bart-large-cnn\",\n            ...     task=\"summarization\",\n            ...     temperature=0.7\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load SpaCy model\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"en_core_sci_md\",\n            ...     source=\"spacy\",\n            ...     disable=[\"parser\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load with output template\n            &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"gpt-3.5-turbo\",\n            ...     source=\"huggingface\",\n            ...     template=template\n            ... )\n        \"\"\"\n        pipeline = cls()\n        pipeline._configure_output_templates(template, template_path)\n\n        config = ModelConfig(\n            source=ModelSource(source.lower()),\n            model_id=model_id,\n            task=task,\n            kwargs=kwargs,\n        )\n        pipeline._model_config = config\n        pipeline.configure_pipeline(config)\n\n        return pipeline\n\n    @classmethod\n    def from_local_model(\n        cls,\n        path: Union[str, Path],\n        source: Union[str, ModelSource],\n        task: Optional[str] = None,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"Load pipeline from a local model path.\n\n        Args:\n            path (Union[str, Path]): Path to local model files/directory\n            source (Union[str, ModelSource]): Model source (e.g. \"huggingface\", \"spacy\")\n            task (Optional[str]): Task identifier for the model. Defaults to None.\n            template (Optional[str]): Optional template string for formatting model output.\n            template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n            **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If source is not a valid ModelSource.\n\n        Examples:\n            &gt;&gt;&gt; # Load local HuggingFace model\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/my_summarizer\",\n            ...     source=\"huggingface\",\n            ...     task=\"summarization\",\n            ...     temperature=0.7\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load local SpaCy model\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/en_core_sci_md\",\n            ...     source=\"spacy\",\n            ...     disable=[\"parser\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load with output template\n            &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/gpt_model\",\n            ...     source=\"huggingface\",\n            ...     template=template\n            ... )\n        \"\"\"\n        pipeline = cls()\n        pipeline._configure_output_templates(template, template_path)\n\n        path = Path(path)\n        config = ModelConfig(\n            source=ModelSource(source.lower()),\n            model_id=path.name,\n            path=path,\n            task=task,\n            kwargs=kwargs,\n        )\n        pipeline._model_config = config\n        pipeline.configure_pipeline(config)\n\n        return pipeline\n\n    @abstractmethod\n    def configure_pipeline(self, model_config: ModelConfig) -&gt; None:\n        \"\"\"\n        Configure the pipeline based on the provided model configuration.\n\n        This method should be implemented by subclasses to add specific components\n        and configure the pipeline according to the given model configuration.\n        The configuration typically involves:\n        1. Adding model components based on the model source\n        2. Adding any additional processing nodes\n        3. Configuring the pipeline stages and execution order\n\n        Args:\n            model_config (ModelConfig): Configuration object containing:\n                - source: Model source (e.g. huggingface, spacy, langchain)\n                - model: Model identifier or path\n                - task: Optional task name (e.g. summarization, ner)\n                - path: Optional local path to model files\n                - kwargs: Additional model configuration parameters\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented by a subclass.\n\n        Example:\n            &gt;&gt;&gt; def configure_pipeline(self, config: ModelConfig):\n            ...     # Add model component\n            ...     model = self.get_model_component(config)\n            ...     self.add_node(model, stage=\"processing\")\n            ...\n            ...     # Add output formatting\n            ...     self.add_node(OutputFormatter(), stage=\"formatting\")\n        \"\"\"\n        raise NotImplementedError(\"This method must be implemented by subclasses.\")\n\n    @property\n    def stages(self):\n        \"\"\"\n        Returns a human-readable representation of the pipeline stages.\n        \"\"\"\n        output = [\"Pipeline Stages:\"]\n        for stage, components in self._stages.items():\n            output.append(f\"  {stage}:\")\n            for component in components:\n                component_name = (\n                    component.__name__\n                    if hasattr(component, \"__name__\")\n                    else (\n                        component.__class__.__name__\n                        if hasattr(component, \"__class__\")\n                        else str(component)\n                    )\n                )\n                output.append(f\"    - {component_name}\")\n        if not self._stages:\n            output.append(\"  No stages defined.\")\n        return \"\\n\".join(output)\n\n    @stages.setter\n    def stages(self, new_stages: Dict[str, List[Callable]]):\n        \"\"\"\n        Sets the stages of the pipeline.\n\n        Args:\n            new_stages (Dict[str, List[Callable]]): A dictionary where keys are stage names\n                                                    and values are lists of callable components.\n        \"\"\"\n        self._stages = new_stages\n\n    def add_node(\n        self,\n        component: Union[\n            BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n        ] = None,\n        *,\n        position: PositionType = \"default\",\n        reference: str = None,\n        stage: str = None,\n        name: str = None,\n        input_model: Type[BaseModel] = None,\n        output_model: Type[BaseModel] = None,\n        dependencies: List[str] = [],\n    ) -&gt; None:\n        \"\"\"\n        Adds a component node to the pipeline.\n\n        Args:\n            component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]], optional):\n                The component to be added. It can be either a BaseComponent object or a callable function.\n                Defaults to None.\n            position (PositionType, optional):\n                The position at which the component should be added in the pipeline.\n                Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\".\n                Defaults to \"default\".\n            reference (str, optional):\n                The name of the component after or before which the new component should be added.\n                Only applicable when position is \"after\" or \"before\".\n                Defaults to None.\n            stage (str, optional):\n                The stage to which the component belongs.\n                Defaults to None.\n            name (str, optional):\n                The name of the component.\n                Defaults to None, in which case the name of the function will be used.\n            input_model (Type[BaseModel], optional):\n                The input Pydantic model class for validating the input data.\n                Defaults to None.\n            output_model (Type[BaseModel], optional):\n                The output Pydantic model class for validating the output data.\n                Defaults to None.\n            dependencies (List[str], optional):\n                The list of component names that this component depends on.\n                Defaults to an empty list.\n\n        Returns:\n            The original component if component is None, otherwise the wrapper function.\n\n        \"\"\"\n\n        def wrapper(func):\n            def validated_component(data: DataContainer[T]) -&gt; DataContainer[T]:\n                # Validate input if input_model is provided\n                if input_model:\n                    input_model(**data.__dict__)\n\n                # Run the component\n                result = func(data)\n\n                # Validate output if output_model is provided\n                if output_model:\n                    output_model(**result.__dict__)\n\n                return result\n\n            component_func = (\n                validated_component if input_model or output_model else func\n            )\n            new_component = PipelineNode(\n                func=component_func,\n                position=position,\n                reference=reference,\n                stage=stage,\n                name=name\n                if name is not None\n                else (\n                    component_func.__name__\n                    if hasattr(component_func, \"__name__\")\n                    else (\n                        component_func.__class__.__name__\n                        if hasattr(component_func, \"__class__\")\n                        else str(component_func)\n                    )\n                ),\n                dependencies=dependencies,\n            )\n            try:\n                self._add_component_at_position(new_component, position, reference)\n            except Exception as e:\n                raise ValueError(f\"Error adding component: {str(e)}\")\n\n            if stage:\n                if stage not in self._stages:\n                    self._stages[stage] = []\n                self._stages[stage].append(func)\n                logger.debug(\n                    f\"Successfully added component '{new_component.name}' to stage '{stage}'.\"\n                )\n\n            return func\n\n        if component is None:\n            return wrapper\n        if callable(component):\n            return wrapper(component)\n        else:\n            raise ValueError(\"Component must be callable\")\n\n    def _add_component_at_position(self, new_component, position, reference):\n        \"\"\"\n        Add a new component to the pipeline at a specified position.\n\n        Args:\n            new_component (PipelineNode): The new component to be added to the pipeline.\n            position (str): The position where the component should be added.\n                            Valid values are 'first', 'last', 'after', 'before', or 'default'.\n            reference (str, optional): The name of the reference component when using 'after' or 'before' positions.\n\n        Raises:\n            ValueError: If an invalid position is provided or if a reference is required but not provided.\n\n        This method handles the insertion of a new component into the pipeline based on the specified position:\n        - 'first': Inserts the component at the beginning of the pipeline.\n        - 'last' or 'default': Appends the component to the end of the pipeline.\n        - 'after' or 'before': Inserts the component relative to a reference component.\n\n        For 'after' and 'before' positions, a reference component name must be provided.\n        \"\"\"\n        if position == \"first\":\n            self._components.insert(0, new_component)\n        elif position in [\"last\", \"default\"]:\n            self._components.append(new_component)\n        elif position in [\"after\", \"before\"]:\n            if not reference:\n                raise ValueError(\n                    f\"Reference must be provided for position '{position}'.\"\n                )\n            offset = 1 if position == \"after\" else 0\n            self._insert_relative_position(new_component, reference, offset)\n        else:\n            raise ValueError(\n                f\"Invalid position '{position}'. Must be 'first', 'last', 'after', 'before', or 'default'.\"\n            )\n\n    def _insert_relative_position(self, component, reference, offset):\n        \"\"\"\n        Insert a component relative to a reference component in the pipeline.\n\n        Args:\n            component (PipelineNode): The component to be inserted.\n            reference (str): The name of the reference component.\n            offset (int): The offset from the reference component (0 for before, 1 for after).\n\n        Raises:\n            ValueError: If the reference component is not found in the pipeline.\n        \"\"\"\n        ref_index = next(\n            (i for i, c in enumerate(self._components) if c.name == reference), None\n        )\n        if ref_index is None:\n            raise ValueError(f\"Reference component '{reference}' not found.\")\n\n        self._components.insert(ref_index + offset, component)\n\n    def remove(self, component_name: str) -&gt; None:\n        \"\"\"\n        Removes a component from the pipeline.\n\n        Args:\n            component_name (str): The name of the component to be removed.\n\n        Raises:\n            ValueError: If the component is not found in the pipeline.\n\n        Returns:\n            None\n\n        Logs:\n            DEBUG: When the component is successfully removed.\n            WARNING: If the component fails to be removed after attempting to do so.\n        \"\"\"\n        # Check if the component exists in the pipeline\n        if not any(c.name == component_name for c in self._components):\n            raise ValueError(f\"Component '{component_name}' not found in the pipeline.\")\n\n        # Remove the component from self.components\n        original_count = len(self._components)\n        self._components = [c for c in self._components if c.name != component_name]\n\n        # Remove the component from stages\n        for stage in self._stages.values():\n            stage[:] = [c for c in stage if c.__name__ != component_name]\n\n        # Validate that the component was removed\n        if len(self._components) == original_count or any(\n            c.__name__ == component_name\n            for stage in self._stages.values()\n            for c in stage\n        ):\n            logger.warning(\n                f\"Failed to remove component '{component_name}' from the pipeline.\"\n            )\n        logger.debug(\n            f\"Successfully removed component '{component_name}' from the pipeline.\"\n        )\n\n    def replace(\n        self,\n        old_component_name: str,\n        new_component: Union[\n            BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n        ],\n    ) -&gt; None:\n        \"\"\"\n        Replaces a component in the pipeline with a new component.\n\n        Args:\n            old_component_name (str): The name of the component to be replaced.\n            new_component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]):\n                The new component to replace the old component with.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the old component is not found in the pipeline.\n            ValueError: If the new component is not a BaseComponent or a callable.\n            ValueError: If the new component callable doesn't have the correct signature.\n\n        Logs:\n            DEBUG: When the component is successfully replaced.\n        \"\"\"\n\n        if isinstance(new_component, BaseComponent):\n            # It's a valid BaseComponent, no further checks needed\n            pass\n        elif callable(new_component):\n            sig = signature(new_component)\n            param = list(sig.parameters.values())[0]\n            if len(sig.parameters) != 1 or not issubclass(\n                param.annotation, DataContainer\n            ):\n                raise ValueError(\n                    \"New component callable must accept a single argument that is a subclass of DataContainer.\"\n                )\n        else:\n            raise ValueError(\"New component must be a BaseComponent or a callable.\")\n\n        old_component_found = False\n\n        # Replace in self.components\n        for i, c in enumerate(self._components):\n            if c.name == old_component_name:\n                self._components[i] = PipelineNode(\n                    func=new_component,\n                    name=old_component_name,\n                    position=c.position,\n                    reference=c.reference,\n                    stage=c.stage,\n                    dependencies=c.dependencies,\n                )\n                old_component_found = True\n\n        # Replace in self.stages\n        for stage in self._stages.values():\n            for i, c in enumerate(stage):\n                if getattr(c, \"name\", c.__name__) == old_component_name:\n                    stage[i] = new_component\n                    old_component_found = True\n\n        if not old_component_found:\n            raise ValueError(\n                f\"Component '{old_component_name}' not found in the pipeline.\"\n            )\n        else:\n            logger.debug(\n                f\"Successfully replaced component '{old_component_name}' in the pipeline.\"\n            )\n\n    def __call__(self, data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n        if self._built_pipeline is None:\n            self._built_pipeline = self.build()\n        return self._built_pipeline(data)\n\n    def build(self) -&gt; Callable:\n        \"\"\"\n        Builds and returns a pipeline function that applies a series of components to the input data.\n        Returns:\n            pipeline: A function that takes input data and applies the ordered components to it.\n        Raises:\n            ValueError: If a circular dependency is detected among the components.\n        \"\"\"\n\n        def resolve_dependencies():\n            resolved = []\n            unresolved = self._components.copy()\n\n            while unresolved:\n                for component in unresolved:\n                    if all(\n                        dep in [c.name for c in resolved]\n                        for dep in component.dependencies\n                    ):\n                        resolved.append(component)\n                        unresolved.remove(component)\n                        break\n                else:\n                    raise ValueError(\"Circular dependency detected\")\n\n            return [c.func for c in resolved]\n\n        ordered_components = resolve_dependencies()\n\n        def pipeline(data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n            if not isinstance(data, DataContainer):\n                data = DataContainer(data)\n\n            data = reduce(lambda d, comp: comp(d), ordered_components, data)\n\n            return data\n\n        if self._built_pipeline is not pipeline:\n            self._built_pipeline = pipeline\n\n        return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.stages","title":"<code>stages</code>  <code>property</code> <code>writable</code>","text":"<p>Returns a human-readable representation of the pipeline stages.</p>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.add_node","title":"<code>add_node(component=None, *, position='default', reference=None, stage=None, name=None, input_model=None, output_model=None, dependencies=[])</code>","text":"<p>Adds a component node to the pipeline.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to be added. It can be either a BaseComponent object or a callable function. Defaults to None.</p> <p> TYPE: <code>Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]</code> DEFAULT: <code>None</code> </p> <code>position</code> <p>The position at which the component should be added in the pipeline. Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\". Defaults to \"default\".</p> <p> TYPE: <code>PositionType</code> DEFAULT: <code>'default'</code> </p> <code>reference</code> <p>The name of the component after or before which the new component should be added. Only applicable when position is \"after\" or \"before\". Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>stage</code> <p>The stage to which the component belongs. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>The name of the component. Defaults to None, in which case the name of the function will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>input_model</code> <p>The input Pydantic model class for validating the input data. Defaults to None.</p> <p> TYPE: <code>Type[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>output_model</code> <p>The output Pydantic model class for validating the output data. Defaults to None.</p> <p> TYPE: <code>Type[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>The list of component names that this component depends on. Defaults to an empty list.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>[]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>The original component if component is None, otherwise the wrapper function.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def add_node(\n    self,\n    component: Union[\n        BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n    ] = None,\n    *,\n    position: PositionType = \"default\",\n    reference: str = None,\n    stage: str = None,\n    name: str = None,\n    input_model: Type[BaseModel] = None,\n    output_model: Type[BaseModel] = None,\n    dependencies: List[str] = [],\n) -&gt; None:\n    \"\"\"\n    Adds a component node to the pipeline.\n\n    Args:\n        component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]], optional):\n            The component to be added. It can be either a BaseComponent object or a callable function.\n            Defaults to None.\n        position (PositionType, optional):\n            The position at which the component should be added in the pipeline.\n            Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\".\n            Defaults to \"default\".\n        reference (str, optional):\n            The name of the component after or before which the new component should be added.\n            Only applicable when position is \"after\" or \"before\".\n            Defaults to None.\n        stage (str, optional):\n            The stage to which the component belongs.\n            Defaults to None.\n        name (str, optional):\n            The name of the component.\n            Defaults to None, in which case the name of the function will be used.\n        input_model (Type[BaseModel], optional):\n            The input Pydantic model class for validating the input data.\n            Defaults to None.\n        output_model (Type[BaseModel], optional):\n            The output Pydantic model class for validating the output data.\n            Defaults to None.\n        dependencies (List[str], optional):\n            The list of component names that this component depends on.\n            Defaults to an empty list.\n\n    Returns:\n        The original component if component is None, otherwise the wrapper function.\n\n    \"\"\"\n\n    def wrapper(func):\n        def validated_component(data: DataContainer[T]) -&gt; DataContainer[T]:\n            # Validate input if input_model is provided\n            if input_model:\n                input_model(**data.__dict__)\n\n            # Run the component\n            result = func(data)\n\n            # Validate output if output_model is provided\n            if output_model:\n                output_model(**result.__dict__)\n\n            return result\n\n        component_func = (\n            validated_component if input_model or output_model else func\n        )\n        new_component = PipelineNode(\n            func=component_func,\n            position=position,\n            reference=reference,\n            stage=stage,\n            name=name\n            if name is not None\n            else (\n                component_func.__name__\n                if hasattr(component_func, \"__name__\")\n                else (\n                    component_func.__class__.__name__\n                    if hasattr(component_func, \"__class__\")\n                    else str(component_func)\n                )\n            ),\n            dependencies=dependencies,\n        )\n        try:\n            self._add_component_at_position(new_component, position, reference)\n        except Exception as e:\n            raise ValueError(f\"Error adding component: {str(e)}\")\n\n        if stage:\n            if stage not in self._stages:\n                self._stages[stage] = []\n            self._stages[stage].append(func)\n            logger.debug(\n                f\"Successfully added component '{new_component.name}' to stage '{stage}'.\"\n            )\n\n        return func\n\n    if component is None:\n        return wrapper\n    if callable(component):\n        return wrapper(component)\n    else:\n        raise ValueError(\"Component must be callable\")\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.build","title":"<code>build()</code>","text":"<p>Builds and returns a pipeline function that applies a series of components to the input data. Returns:     pipeline: A function that takes input data and applies the ordered components to it. Raises:     ValueError: If a circular dependency is detected among the components.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def build(self) -&gt; Callable:\n    \"\"\"\n    Builds and returns a pipeline function that applies a series of components to the input data.\n    Returns:\n        pipeline: A function that takes input data and applies the ordered components to it.\n    Raises:\n        ValueError: If a circular dependency is detected among the components.\n    \"\"\"\n\n    def resolve_dependencies():\n        resolved = []\n        unresolved = self._components.copy()\n\n        while unresolved:\n            for component in unresolved:\n                if all(\n                    dep in [c.name for c in resolved]\n                    for dep in component.dependencies\n                ):\n                    resolved.append(component)\n                    unresolved.remove(component)\n                    break\n            else:\n                raise ValueError(\"Circular dependency detected\")\n\n        return [c.func for c in resolved]\n\n    ordered_components = resolve_dependencies()\n\n    def pipeline(data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n        if not isinstance(data, DataContainer):\n            data = DataContainer(data)\n\n        data = reduce(lambda d, comp: comp(d), ordered_components, data)\n\n        return data\n\n    if self._built_pipeline is not pipeline:\n        self._built_pipeline = pipeline\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.configure_pipeline","title":"<code>configure_pipeline(model_config)</code>  <code>abstractmethod</code>","text":"<p>Configure the pipeline based on the provided model configuration.</p> <p>This method should be implemented by subclasses to add specific components and configure the pipeline according to the given model configuration. The configuration typically involves: 1. Adding model components based on the model source 2. Adding any additional processing nodes 3. Configuring the pipeline stages and execution order</p> PARAMETER DESCRIPTION <code>model_config</code> <p>Configuration object containing: - source: Model source (e.g. huggingface, spacy, langchain) - model: Model identifier or path - task: Optional task name (e.g. summarization, ner) - path: Optional local path to model files - kwargs: Additional model configuration parameters</p> <p> TYPE: <code>ModelConfig</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented by a subclass.</p> Example <p>def configure_pipeline(self, config: ModelConfig): ...     # Add model component ...     model = self.get_model_component(config) ...     self.add_node(model, stage=\"processing\") ... ...     # Add output formatting ...     self.add_node(OutputFormatter(), stage=\"formatting\")</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@abstractmethod\ndef configure_pipeline(self, model_config: ModelConfig) -&gt; None:\n    \"\"\"\n    Configure the pipeline based on the provided model configuration.\n\n    This method should be implemented by subclasses to add specific components\n    and configure the pipeline according to the given model configuration.\n    The configuration typically involves:\n    1. Adding model components based on the model source\n    2. Adding any additional processing nodes\n    3. Configuring the pipeline stages and execution order\n\n    Args:\n        model_config (ModelConfig): Configuration object containing:\n            - source: Model source (e.g. huggingface, spacy, langchain)\n            - model: Model identifier or path\n            - task: Optional task name (e.g. summarization, ner)\n            - path: Optional local path to model files\n            - kwargs: Additional model configuration parameters\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented by a subclass.\n\n    Example:\n        &gt;&gt;&gt; def configure_pipeline(self, config: ModelConfig):\n        ...     # Add model component\n        ...     model = self.get_model_component(config)\n        ...     self.add_node(model, stage=\"processing\")\n        ...\n        ...     # Add output formatting\n        ...     self.add_node(OutputFormatter(), stage=\"formatting\")\n    \"\"\"\n    raise NotImplementedError(\"This method must be implemented by subclasses.\")\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.from_local_model","title":"<code>from_local_model(path, source, task=None, template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load pipeline from a local model path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to local model files/directory</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>source</code> <p>Model source (e.g. \"huggingface\", \"spacy\")</p> <p> TYPE: <code>Union[str, ModelSource]</code> </p> <code>task</code> <p>Task identifier for the model. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template</code> <p>Optional template string for formatting model output.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Optional path to template file for formatting model output.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the model. e.g. temperature, max_length, etc.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If source is not a valid ModelSource.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load local HuggingFace model\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/my_summarizer\",\n...     source=\"huggingface\",\n...     task=\"summarization\",\n...     temperature=0.7\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load local SpaCy model\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/en_core_sci_md\",\n...     source=\"spacy\",\n...     disable=[\"parser\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load with output template\n&gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/gpt_model\",\n...     source=\"huggingface\",\n...     template=template\n... )\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef from_local_model(\n    cls,\n    path: Union[str, Path],\n    source: Union[str, ModelSource],\n    task: Optional[str] = None,\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"Load pipeline from a local model path.\n\n    Args:\n        path (Union[str, Path]): Path to local model files/directory\n        source (Union[str, ModelSource]): Model source (e.g. \"huggingface\", \"spacy\")\n        task (Optional[str]): Task identifier for the model. Defaults to None.\n        template (Optional[str]): Optional template string for formatting model output.\n        template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n        **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If source is not a valid ModelSource.\n\n    Examples:\n        &gt;&gt;&gt; # Load local HuggingFace model\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/my_summarizer\",\n        ...     source=\"huggingface\",\n        ...     task=\"summarization\",\n        ...     temperature=0.7\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load local SpaCy model\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/en_core_sci_md\",\n        ...     source=\"spacy\",\n        ...     disable=[\"parser\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load with output template\n        &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/gpt_model\",\n        ...     source=\"huggingface\",\n        ...     template=template\n        ... )\n    \"\"\"\n    pipeline = cls()\n    pipeline._configure_output_templates(template, template_path)\n\n    path = Path(path)\n    config = ModelConfig(\n        source=ModelSource(source.lower()),\n        model_id=path.name,\n        path=path,\n        task=task,\n        kwargs=kwargs,\n    )\n    pipeline._model_config = config\n    pipeline.configure_pipeline(config)\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.from_model_id","title":"<code>from_model_id(model_id, source='huggingface', task='text-generation', template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load pipeline from a model identifier.</p> PARAMETER DESCRIPTION <code>model_id</code> <p>Model identifier (e.g. HuggingFace model ID, SpaCy model name)</p> <p> TYPE: <code>str</code> </p> <code>source</code> <p>Model source. Defaults to \"huggingface\". Can be \"huggingface\", \"spacy\".</p> <p> TYPE: <code>Union[str, ModelSource]</code> DEFAULT: <code>'huggingface'</code> </p> <code>task</code> <p>Task identifier for the model. Defaults to \"text-generation\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'text-generation'</code> </p> <code>template</code> <p>Optional template string for formatting model output.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Optional path to template file for formatting model output.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the model. e.g. temperature, max_length, etc.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If source is not a valid ModelSource.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load HuggingFace model\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"facebook/bart-large-cnn\",\n...     task=\"summarization\",\n...     temperature=0.7\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load SpaCy model\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"en_core_sci_md\",\n...     source=\"spacy\",\n...     disable=[\"parser\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load with output template\n&gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"gpt-3.5-turbo\",\n...     source=\"huggingface\",\n...     template=template\n... )\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef from_model_id(\n    cls,\n    model_id: str,\n    source: Union[str, ModelSource] = \"huggingface\",\n    task: Optional[str] = \"text-generation\",\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"\n    Load pipeline from a model identifier.\n\n    Args:\n        model_id (str): Model identifier (e.g. HuggingFace model ID, SpaCy model name)\n        source (Union[str, ModelSource]): Model source. Defaults to \"huggingface\".\n            Can be \"huggingface\", \"spacy\".\n        task (Optional[str]): Task identifier for the model. Defaults to \"text-generation\".\n        template (Optional[str]): Optional template string for formatting model output.\n        template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n        **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If source is not a valid ModelSource.\n\n    Examples:\n        &gt;&gt;&gt; # Load HuggingFace model\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"facebook/bart-large-cnn\",\n        ...     task=\"summarization\",\n        ...     temperature=0.7\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load SpaCy model\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"en_core_sci_md\",\n        ...     source=\"spacy\",\n        ...     disable=[\"parser\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load with output template\n        &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"gpt-3.5-turbo\",\n        ...     source=\"huggingface\",\n        ...     template=template\n        ... )\n    \"\"\"\n    pipeline = cls()\n    pipeline._configure_output_templates(template, template_path)\n\n    config = ModelConfig(\n        source=ModelSource(source.lower()),\n        model_id=model_id,\n        task=task,\n        kwargs=kwargs,\n    )\n    pipeline._model_config = config\n    pipeline.configure_pipeline(config)\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.load","title":"<code>load(pipeline, source, task='text-generation', template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)</p> <p> TYPE: <code>Callable</code> </p> <code>source</code> <p>Source of the pipeline. Can be \"langchain\" or \"huggingface\".</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>Task identifier used to retrieve model outputs. Defaults to \"text-generation\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'text-generation'</code> </p> <code>template</code> <p>Template string for formatting outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Path to template file. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the pipeline.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If pipeline is not callable or source is invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load LangChain pipeline\n&gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n&gt;&gt;&gt; from langchain_openai import ChatOpenAI\n&gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n&gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load HuggingFace pipeline\n&gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n&gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n&gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n&gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n&gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    pipeline: Callable,\n    source: str,\n    task: Optional[str] = \"text-generation\",\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"\n    Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).\n\n    Args:\n        pipeline (Callable): A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)\n        source (str): Source of the pipeline. Can be \"langchain\" or \"huggingface\".\n        task (Optional[str]): Task identifier used to retrieve model outputs.\n            Defaults to \"text-generation\".\n        template (Optional[str]): Template string for formatting outputs.\n            Defaults to None.\n        template_path (Optional[Union[str, Path]]): Path to template file.\n            Defaults to None.\n        **kwargs: Additional configuration options passed to the pipeline.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If pipeline is not callable or source is invalid.\n\n    Examples:\n        &gt;&gt;&gt; # Load LangChain pipeline\n        &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n        &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n        &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n        &gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load HuggingFace pipeline\n        &gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n        &gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n        &gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n        &gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n        &gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n    \"\"\"\n    if not (hasattr(pipeline, \"__call__\") or hasattr(pipeline, \"invoke\")):\n        raise ValueError(\"Pipeline must be a callable object\")\n\n    # Validate source\n    source = source.lower()\n    if source not in [\"langchain\", \"huggingface\"]:\n        raise ValueError(\n            \"Source must be either 'langchain' or 'huggingface' for direct pipeline loading\"\n        )\n\n    # For HuggingFace pipelines, try to infer task if not provided\n    if source == \"huggingface\" and hasattr(pipeline, \"task\") and not task:\n        task = pipeline.task\n\n    instance = cls()\n    instance._configure_output_templates(template, template_path)\n\n    config = ModelConfig(\n        source=ModelSource(source),\n        pipeline_object=pipeline,\n        task=task,\n        kwargs=kwargs,\n    )\n\n    instance._model_config = config\n    instance.configure_pipeline(config)\n\n    return instance\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.remove","title":"<code>remove(component_name)</code>","text":"<p>Removes a component from the pipeline.</p> PARAMETER DESCRIPTION <code>component_name</code> <p>The name of the component to be removed.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the component is not found in the pipeline.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Logs <p>DEBUG: When the component is successfully removed. WARNING: If the component fails to be removed after attempting to do so.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def remove(self, component_name: str) -&gt; None:\n    \"\"\"\n    Removes a component from the pipeline.\n\n    Args:\n        component_name (str): The name of the component to be removed.\n\n    Raises:\n        ValueError: If the component is not found in the pipeline.\n\n    Returns:\n        None\n\n    Logs:\n        DEBUG: When the component is successfully removed.\n        WARNING: If the component fails to be removed after attempting to do so.\n    \"\"\"\n    # Check if the component exists in the pipeline\n    if not any(c.name == component_name for c in self._components):\n        raise ValueError(f\"Component '{component_name}' not found in the pipeline.\")\n\n    # Remove the component from self.components\n    original_count = len(self._components)\n    self._components = [c for c in self._components if c.name != component_name]\n\n    # Remove the component from stages\n    for stage in self._stages.values():\n        stage[:] = [c for c in stage if c.__name__ != component_name]\n\n    # Validate that the component was removed\n    if len(self._components) == original_count or any(\n        c.__name__ == component_name\n        for stage in self._stages.values()\n        for c in stage\n    ):\n        logger.warning(\n            f\"Failed to remove component '{component_name}' from the pipeline.\"\n        )\n    logger.debug(\n        f\"Successfully removed component '{component_name}' from the pipeline.\"\n    )\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.replace","title":"<code>replace(old_component_name, new_component)</code>","text":"<p>Replaces a component in the pipeline with a new component.</p> PARAMETER DESCRIPTION <code>old_component_name</code> <p>The name of the component to be replaced.</p> <p> TYPE: <code>str</code> </p> <code>new_component</code> <p>The new component to replace the old component with.</p> <p> TYPE: <code>Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the old component is not found in the pipeline.</p> <code>ValueError</code> <p>If the new component is not a BaseComponent or a callable.</p> <code>ValueError</code> <p>If the new component callable doesn't have the correct signature.</p> Logs <p>DEBUG: When the component is successfully replaced.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def replace(\n    self,\n    old_component_name: str,\n    new_component: Union[\n        BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n    ],\n) -&gt; None:\n    \"\"\"\n    Replaces a component in the pipeline with a new component.\n\n    Args:\n        old_component_name (str): The name of the component to be replaced.\n        new_component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]):\n            The new component to replace the old component with.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the old component is not found in the pipeline.\n        ValueError: If the new component is not a BaseComponent or a callable.\n        ValueError: If the new component callable doesn't have the correct signature.\n\n    Logs:\n        DEBUG: When the component is successfully replaced.\n    \"\"\"\n\n    if isinstance(new_component, BaseComponent):\n        # It's a valid BaseComponent, no further checks needed\n        pass\n    elif callable(new_component):\n        sig = signature(new_component)\n        param = list(sig.parameters.values())[0]\n        if len(sig.parameters) != 1 or not issubclass(\n            param.annotation, DataContainer\n        ):\n            raise ValueError(\n                \"New component callable must accept a single argument that is a subclass of DataContainer.\"\n            )\n    else:\n        raise ValueError(\"New component must be a BaseComponent or a callable.\")\n\n    old_component_found = False\n\n    # Replace in self.components\n    for i, c in enumerate(self._components):\n        if c.name == old_component_name:\n            self._components[i] = PipelineNode(\n                func=new_component,\n                name=old_component_name,\n                position=c.position,\n                reference=c.reference,\n                stage=c.stage,\n                dependencies=c.dependencies,\n            )\n            old_component_found = True\n\n    # Replace in self.stages\n    for stage in self._stages.values():\n        for i, c in enumerate(stage):\n            if getattr(c, \"name\", c.__name__) == old_component_name:\n                stage[i] = new_component\n                old_component_found = True\n\n    if not old_component_found:\n        raise ValueError(\n            f\"Component '{old_component_name}' not found in the pipeline.\"\n        )\n    else:\n        logger.debug(\n            f\"Successfully replaced component '{old_component_name}' in the pipeline.\"\n        )\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.ModelConfig","title":"<code>ModelConfig</code>  <code>dataclass</code>","text":"<p>Configuration for model initialization</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@dataclass\nclass ModelConfig:\n    \"\"\"Configuration for model initialization\"\"\"\n\n    source: ModelSource\n    model_id: Optional[str] = None\n    pipeline_object: Optional[Any] = None\n    task: Optional[str] = None\n    path: Optional[Path] = None\n    kwargs: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.ModelSource","title":"<code>ModelSource</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported model sources</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class ModelSource(Enum):\n    \"\"\"Enumeration of supported model sources\"\"\"\n\n    SPACY = \"spacy\"\n    HUGGINGFACE = \"huggingface\"\n    LANGCHAIN = \"langchain\"\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.Pipeline","title":"<code>Pipeline</code>","text":"<p>               Bases: <code>BasePipeline</code>, <code>Generic[T]</code></p> <p>Default Pipeline class for creating a basic data processing pipeline. This class inherits from BasePipeline and provides a default implementation of the configure_pipeline method, which does not add any specific components.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class Pipeline(BasePipeline, Generic[T]):\n    \"\"\"\n    Default Pipeline class for creating a basic data processing pipeline.\n    This class inherits from BasePipeline and provides a default implementation\n    of the configure_pipeline method, which does not add any specific components.\n    \"\"\"\n\n    def configure_pipeline(self, model_path: str) -&gt; None:\n        \"\"\"\n        Configures the pipeline by adding components based on the provided model path.\n        This default implementation does not add any specific components.\n\n        Args:\n            model_path (str): The path to the model used for configuring the pipeline.\n        \"\"\"\n        # Default implementation: No specific components added\n        pass\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.Pipeline.configure_pipeline","title":"<code>configure_pipeline(model_path)</code>","text":"<p>Configures the pipeline by adding components based on the provided model path. This default implementation does not add any specific components.</p> PARAMETER DESCRIPTION <code>model_path</code> <p>The path to the model used for configuring the pipeline.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def configure_pipeline(self, model_path: str) -&gt; None:\n    \"\"\"\n    Configures the pipeline by adding components based on the provided model path.\n    This default implementation does not add any specific components.\n\n    Args:\n        model_path (str): The path to the model used for configuring the pipeline.\n    \"\"\"\n    # Default implementation: No specific components added\n    pass\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.PipelineNode","title":"<code>PipelineNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Represents a node in a pipeline.</p> ATTRIBUTE DESCRIPTION <code>func</code> <p>The function to be applied to the data.</p> <p> TYPE: <code>Callable[[DataContainer[T]], DataContainer[T]]</code> </p> <code>position</code> <p>The position of the node in the pipeline. Defaults to \"default\".</p> <p> TYPE: <code>PositionType</code> </p> <code>reference</code> <p>The reference for the relative position of the node. Name should be the \"name\" attribute of another node. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>stage</code> <p>The stage of the node in the pipeline. Group nodes by stage e.g. \"preprocessing\". Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of the node. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>dependencies</code> <p>The list of dependencies for the node. Defaults to an empty list.</p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@dataclass\nclass PipelineNode(Generic[T]):\n    \"\"\"\n    Represents a node in a pipeline.\n\n    Attributes:\n        func (Callable[[DataContainer[T]], DataContainer[T]]): The function to be applied to the data.\n        position (PositionType, optional): The position of the node in the pipeline. Defaults to \"default\".\n        reference (str, optional): The reference for the relative position of the node. Name should be the \"name\" attribute of another node. Defaults to None.\n        stage (str, optional): The stage of the node in the pipeline. Group nodes by stage e.g. \"preprocessing\". Defaults to None.\n        name (str, optional): The name of the node. Defaults to None.\n        dependencies (List[str], optional): The list of dependencies for the node. Defaults to an empty list.\n    \"\"\"\n\n    func: Callable[[DataContainer[T]], DataContainer[T]]\n    position: PositionType = \"default\"\n    reference: str = None\n    stage: str = None\n    name: str = None\n    dependencies: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/sandbox/","title":"Sandbox Client","text":"<p>Simplified client for testing healthcare services with various data sources.</p> <p>This class provides an intuitive interface for: - Loading test datasets (MIMIC-on-FHIR, Synthea, CSV) - Generating synthetic FHIR data - Sending requests to healthcare services - Managing request/response lifecycle</p> <p>Examples:</p> <p>Load from dataset registry:</p> <pre><code>&gt;&gt;&gt; client = SandboxClient(\n...     api_url=\"http://localhost:8000\",\n...     endpoint=\"/cds/cds-services/my-service\"\n... )\n&gt;&gt;&gt; client.load_from_registry(\"mimic-on-fhir\", sample_size=10)\n&gt;&gt;&gt; responses = client.send_requests()\n</code></pre> <p>Load CDA file from path:</p> <pre><code>&gt;&gt;&gt; client = SandboxClient(\n...     api_url=\"http://localhost:8000\",\n...     endpoint=\"/notereader/fhir/\",\n...     protocol=\"soap\"\n... )\n&gt;&gt;&gt; client.load_from_path(\"./data/clinical_note.xml\")\n&gt;&gt;&gt; responses = client.send_requests()\n</code></pre> <p>Generate data from free text:</p> <pre><code>&gt;&gt;&gt; client = SandboxClient(\n...     api_url=\"http://localhost:8000\",\n...     endpoint=\"/cds/cds-services/discharge-summarizer\"\n... )\n&gt;&gt;&gt; client.load_free_text(\n...     csv_path=\"./data/notes.csv\",\n...     column_name=\"text\",\n...     workflow=\"encounter-discharge\"\n... )\n&gt;&gt;&gt; responses = client.send_requests()\n</code></pre> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>class SandboxClient:\n    \"\"\"\n    Simplified client for testing healthcare services with various data sources.\n\n    This class provides an intuitive interface for:\n    - Loading test datasets (MIMIC-on-FHIR, Synthea, CSV)\n    - Generating synthetic FHIR data\n    - Sending requests to healthcare services\n    - Managing request/response lifecycle\n\n    Examples:\n        Load from dataset registry:\n        &gt;&gt;&gt; client = SandboxClient(\n        ...     api_url=\"http://localhost:8000\",\n        ...     endpoint=\"/cds/cds-services/my-service\"\n        ... )\n        &gt;&gt;&gt; client.load_from_registry(\"mimic-on-fhir\", sample_size=10)\n        &gt;&gt;&gt; responses = client.send_requests()\n\n        Load CDA file from path:\n        &gt;&gt;&gt; client = SandboxClient(\n        ...     api_url=\"http://localhost:8000\",\n        ...     endpoint=\"/notereader/fhir/\",\n        ...     protocol=\"soap\"\n        ... )\n        &gt;&gt;&gt; client.load_from_path(\"./data/clinical_note.xml\")\n        &gt;&gt;&gt; responses = client.send_requests()\n\n        Generate data from free text:\n        &gt;&gt;&gt; client = SandboxClient(\n        ...     api_url=\"http://localhost:8000\",\n        ...     endpoint=\"/cds/cds-services/discharge-summarizer\"\n        ... )\n        &gt;&gt;&gt; client.load_free_text(\n        ...     csv_path=\"./data/notes.csv\",\n        ...     column_name=\"text\",\n        ...     workflow=\"encounter-discharge\"\n        ... )\n        &gt;&gt;&gt; responses = client.send_requests()\n    \"\"\"\n\n    def __init__(\n        self,\n        api_url: str,\n        endpoint: str,\n        workflow: Optional[Union[Workflow, str]] = None,\n        protocol: Literal[\"rest\", \"soap\"] = \"rest\",\n        timeout: float = 10.0,\n    ):\n        \"\"\"\n        Initialize SandboxClient.\n\n        Args:\n            api_url: Base URL of the service (e.g., \"http://localhost:8000\")\n            endpoint: Service endpoint path (e.g., \"/cds/cds-services/my-service\")\n            workflow: Optional workflow specification (auto-detected if not provided)\n            protocol: Communication protocol - \"rest\" for CDS Hooks, \"soap\" for CDA\n            timeout: Request timeout in seconds\n\n        Raises:\n            ValueError: If api_url or endpoint is invalid\n        \"\"\"\n        try:\n            self.api = httpx.URL(api_url)\n        except Exception as e:\n            raise ValueError(f\"Invalid API URL: {str(e)}\")\n\n        self.endpoint = endpoint\n        self.workflow = Workflow(workflow) if isinstance(workflow, str) else workflow\n        self.protocol = ApiProtocol.soap if protocol == \"soap\" else ApiProtocol.rest\n        self.timeout = timeout\n\n        # Request/response management\n        self.request_data: List[Union[CDSRequest, Any]] = []\n        self.responses: List[Dict] = []\n        self.sandbox_id = uuid.uuid4()\n\n        log.info(\n            f\"Initialized SandboxClient {self.sandbox_id} for {self.api}{self.endpoint}\"\n        )\n\n    def load_from_registry(\n        self,\n        source: str,\n        **kwargs: Any,\n    ) -&gt; \"SandboxClient\":\n        \"\"\"\n        Load data from the dataset registry.\n\n        Loads pre-configured datasets like MIMIC-on-FHIR, Synthea, or custom\n        registered datasets.\n\n        Args:\n            source: Dataset name (e.g., \"mimic-on-fhir\", \"synthea\")\n            **kwargs: Dataset-specific parameters (e.g., sample_size, num_patients)\n\n        Returns:\n            Self for method chaining\n\n        Raises:\n            ValueError: If dataset not found in registry\n\n        Examples:\n            Discover available datasets:\n            &gt;&gt;&gt; from healthchain.sandbox import list_available_datasets\n            &gt;&gt;&gt; print(list_available_datasets())\n\n            Load MIMIC dataset:\n            &gt;&gt;&gt; client.load_from_registry(\"mimic-on-fhir\", sample_size=10)\n        \"\"\"\n        from healthchain.sandbox.datasets import DatasetRegistry\n\n        log.info(f\"Loading dataset from registry: {source}\")\n        try:\n            loaded_data = DatasetRegistry.load(source, **kwargs)\n            self._construct_request(loaded_data)\n            log.info(f\"Loaded {source} dataset with {len(self.request_data)} requests\")\n        except KeyError:\n            raise ValueError(\n                f\"Unknown dataset: {source}. \"\n                f\"Available datasets: {DatasetRegistry.list_datasets()}\"\n            )\n        return self\n\n    def load_from_path(\n        self,\n        path: Union[str, Path],\n        pattern: Optional[str] = None,\n        workflow: Optional[Union[Workflow, str]] = None,\n    ) -&gt; \"SandboxClient\":\n        \"\"\"\n        Load data from file system path.\n\n        Supports loading single files or directories. File type is auto-detected\n        from extension and protocol:\n        - .xml files with SOAP protocol \u2192 CDA documents\n        - .json files with REST protocol \u2192 Pre-formatted Prefetch data\n\n        Args:\n            path: File path or directory path\n            pattern: Glob pattern for filtering files in directory (e.g., \"*.xml\")\n            workflow: Optional workflow override (auto-detected from protocol if not provided)\n\n        Returns:\n            Self for method chaining\n\n        Raises:\n            FileNotFoundError: If path doesn't exist\n            ValueError: If no matching files found or unsupported file type\n\n        Examples:\n            Load single CDA file:\n            &gt;&gt;&gt; client.load_from_path(\"./data/clinical_note.xml\")\n\n            Load directory of CDA files:\n            &gt;&gt;&gt; client.load_from_path(\"./data/cda_files/\", pattern=\"*.xml\")\n\n            Load with explicit workflow:\n            &gt;&gt;&gt; client.load_from_path(\"./data/note.xml\", workflow=\"sign-note-inpatient\")\n        \"\"\"\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"Path not found: {path}\")\n\n        # Collect files to process\n        files_to_load = []\n        if path.is_file():\n            files_to_load = [path]\n        elif path.is_dir():\n            pattern = pattern or \"*\"\n            files_to_load = list(path.glob(pattern))\n            if not files_to_load:\n                raise ValueError(\n                    f\"No files found matching pattern '{pattern}' in {path}\"\n                )\n        else:\n            raise ValueError(f\"Path must be a file or directory: {path}\")\n\n        log.info(f\"Loading {len(files_to_load)} file(s) from {path}\")\n\n        # Process each file\n        for file_path in files_to_load:\n            # Determine file type from extension\n            extension = file_path.suffix.lower()\n\n            if extension == \".xml\":\n                with open(file_path, \"r\") as f:\n                    xml_content = f.read()\n                workflow_enum = (\n                    Workflow(workflow)\n                    if isinstance(workflow, str)\n                    else workflow or self.workflow or Workflow.sign_note_inpatient\n                )\n                self._construct_request(xml_content, workflow_enum)\n                log.info(f\"Loaded CDA document from {file_path.name}\")\n\n            elif extension == \".json\":\n                with open(file_path, \"r\") as f:\n                    json_data = json.load(f)\n\n                try:\n                    # Validate and load as Prefetch object\n                    prefetch_data = Prefetch(**json_data)\n\n                    workflow_enum = (\n                        Workflow(workflow)\n                        if isinstance(workflow, str)\n                        else workflow or self.workflow\n                    )\n                    if not workflow_enum:\n                        raise ValueError(\n                            \"Workflow must be specified when loading JSON Prefetch data. \"\n                            \"Provide via 'workflow' parameter or set on client initialization.\"\n                        )\n                    self._construct_request(prefetch_data, workflow_enum)\n                    log.info(f\"Loaded Prefetch data from {file_path.name}\")\n\n                except Exception as e:\n                    log.error(f\"Failed to parse {file_path} as Prefetch: {e}\")\n                    raise ValueError(\n                        f\"File {file_path} is not valid Prefetch format. \"\n                        f\"Expected JSON with 'prefetch' key containing FHIR resources. \"\n                        f\"Error: {e}\"\n                    )\n            else:\n                log.warning(f\"Skipping unsupported file type: {file_path}\")\n\n        log.info(\n            f\"Loaded {len(self.request_data)} requests from {len(files_to_load)} file(s)\"\n        )\n        return self\n\n    def load_free_text(\n        self,\n        csv_path: str,\n        column_name: str,\n        workflow: Union[Workflow, str],\n        random_seed: Optional[int] = None,\n        **kwargs: Any,\n    ) -&gt; \"SandboxClient\":\n        \"\"\"\n        Generates a CDS prefetch from free text notes.\n\n        Reads clinical notes from a CSV file and wraps it in FHIR DocumentReferences\n        in a CDS prefetch field for CDS Hooks workflows. Generates additional synthetic\n        FHIR resources as needed based on the specified workflow.\n\n        Args:\n            csv_path: Path to CSV file containing clinical notes\n            column_name: Name of the column containing the text\n            workflow: CDS workflow type (e.g., \"encounter-discharge\", \"patient-view\")\n            random_seed: Seed for reproducible data generation\n            **kwargs: Additional parameters for data generation\n\n        Returns:\n            Self for method chaining\n\n        Raises:\n            FileNotFoundError: If CSV file doesn't exist\n            ValueError: If workflow is invalid or column not found\n\n        Examples:\n            Generate discharge summaries:\n            &gt;&gt;&gt; client.load_free_text(\n            ...     csv_path=\"./data/discharge_notes.csv\",\n            ...     column_name=\"text\",\n            ...     workflow=\"encounter-discharge\",\n            ...     random_seed=42\n            ... )\n        \"\"\"\n        from .generators import CdsDataGenerator\n\n        workflow_enum = Workflow(workflow) if isinstance(workflow, str) else workflow\n\n        generator = CdsDataGenerator()\n        generator.set_workflow(workflow_enum)\n\n        prefetch_data = generator.generate_prefetch(\n            random_seed=random_seed,\n            free_text_path=csv_path,\n            column_name=column_name,\n            **kwargs,\n        )\n\n        self._construct_request(prefetch_data, workflow_enum)\n        log.info(\n            f\"Generated {len(self.request_data)} requests from free text for workflow {workflow_enum.value}\"\n        )\n\n        return self\n\n    def _construct_request(\n        self, data: Union[Prefetch, Any], workflow: Optional[Workflow] = None\n    ) -&gt; None:\n        \"\"\"\n        Convert data to request format and add to queue.\n\n        Args:\n            data: Data to convert (Prefetch for CDS, DocumentReference for CDA)\n            workflow: Workflow to use for request construction\n        \"\"\"\n        workflow = workflow or self.workflow\n\n        if self.protocol == ApiProtocol.rest:\n            if not workflow:\n                raise ValueError(\n                    \"Workflow must be specified for REST/CDS Hooks requests\"\n                )\n            constructor = CdsRequestConstructor()\n            request = constructor.construct_request(data, workflow)\n        elif self.protocol == ApiProtocol.soap:\n            constructor = ClinDocRequestConstructor()\n            request = constructor.construct_request(\n                data, workflow or Workflow.sign_note_inpatient\n            )\n        else:\n            raise ValueError(f\"Unsupported protocol: {self.protocol}\")\n\n        self.request_data.append(request)\n\n    def send_requests(self) -&gt; List[Dict]:\n        \"\"\"\n        Send all queued requests to the service.\n\n        Returns:\n            List of response dictionaries\n\n        Raises:\n            RuntimeError: If no requests are queued\n        \"\"\"\n        if not self.request_data:\n            raise RuntimeError(\n                \"No requests to send. Load data first using load_from_registry(), load_from_path(), or load_free_text()\"\n            )\n\n        url = self.api.join(self.endpoint)\n        log.info(f\"Sending {len(self.request_data)} requests to {url}\")\n\n        with httpx.Client(follow_redirects=True) as client:\n            responses: List[Dict] = []\n            timeout = httpx.Timeout(self.timeout, read=None)\n\n            for request in self.request_data:\n                try:\n                    if self.protocol == ApiProtocol.soap:\n                        headers = {\"Content-Type\": \"text/xml; charset=utf-8\"}\n                        response = client.post(\n                            url=str(url),\n                            data=request.document,\n                            headers=headers,\n                            timeout=timeout,\n                        )\n                        response.raise_for_status()\n                        response_model = CdaResponse(document=response.text)\n                        responses.append(response_model.model_dump_xml())\n                    else:\n                        # REST/CDS Hooks\n                        log.debug(f\"Making POST request to: {url}\")\n                        response = client.post(\n                            url=str(url),\n                            json=request.model_dump(exclude_none=True),\n                            timeout=timeout,\n                        )\n                        response.raise_for_status()\n                        response_data = response.json()\n                        try:\n                            cds_response = CDSResponse(**response_data)\n                            responses.append(cds_response.model_dump(exclude_none=True))\n                        except Exception:\n                            # Fallback to raw response if parsing fails\n                            responses.append(response_data)\n\n                except httpx.HTTPStatusError as exc:\n                    try:\n                        error_content = exc.response.json()\n                    except Exception:\n                        error_content = exc.response.text\n                    log.error(\n                        f\"Error response {exc.response.status_code} while requesting \"\n                        f\"{exc.request.url!r}: {error_content}\"\n                    )\n                    responses.append({})\n                except httpx.TimeoutException as exc:\n                    log.error(f\"Request to {exc.request.url!r} timed out!\")\n                    responses.append({})\n                except httpx.RequestError as exc:\n                    log.error(\n                        f\"An error occurred while requesting {exc.request.url!r}.\"\n                    )\n                    responses.append({})\n\n        self.responses = responses\n        log.info(f\"Received {len(responses)} responses\")\n\n        return responses\n\n    def save_results(self, directory: Union[str, Path] = \"./output/\") -&gt; None:\n        \"\"\"\n        Save request and response data to disk.\n\n        Args:\n            directory: Directory to save data to (default: \"./output/\")\n\n        Raises:\n            RuntimeError: If no responses are available to save\n        \"\"\"\n        if not self.responses:\n            raise RuntimeError(\n                \"No responses to save. Send requests first using send_requests()\"\n            )\n\n        save_dir = Path(directory)\n        request_path = ensure_directory_exists(save_dir / \"requests\")\n\n        # Determine file extension based on protocol\n        extension = \"xml\" if self.protocol == ApiProtocol.soap else \"json\"\n\n        # Save requests\n        if self.protocol == ApiProtocol.soap:\n            request_data = [request.model_dump_xml() for request in self.request_data]\n        else:\n            request_data = [\n                request.model_dump(exclude_none=True) for request in self.request_data\n            ]\n\n        save_data_to_directory(\n            request_data,\n            \"request\",\n            self.sandbox_id,\n            request_path,\n            extension,\n        )\n        log.info(f\"Saved request data at {request_path}/\")\n\n        # Save responses\n        response_path = ensure_directory_exists(save_dir / \"responses\")\n        save_data_to_directory(\n            self.responses,\n            \"response\",\n            self.sandbox_id,\n            response_path,\n            extension,\n        )\n        log.info(f\"Saved response data at {response_path}/\")\n\n    def get_status(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get current client status and statistics.\n\n        Returns:\n            Dictionary containing client status information\n        \"\"\"\n        return {\n            \"sandbox_id\": str(self.sandbox_id),\n            \"api_url\": str(self.api),\n            \"endpoint\": self.endpoint,\n            \"protocol\": self.protocol.value\n            if hasattr(self.protocol, \"value\")\n            else str(self.protocol),\n            \"workflow\": self.workflow.value if self.workflow else None,\n            \"requests_queued\": len(self.request_data),\n            \"responses_received\": len(self.responses),\n        }\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of SandboxClient.\"\"\"\n        return (\n            f\"SandboxClient(api_url='{self.api}', endpoint='{self.endpoint}', \"\n            f\"protocol='{self.protocol.value if hasattr(self.protocol, 'value') else self.protocol}', \"\n            f\"requests={len(self.request_data)})\"\n        )\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.__init__","title":"<code>__init__(api_url, endpoint, workflow=None, protocol='rest', timeout=10.0)</code>","text":"<p>Initialize SandboxClient.</p> PARAMETER DESCRIPTION <code>api_url</code> <p>Base URL of the service (e.g., \"http://localhost:8000\")</p> <p> TYPE: <code>str</code> </p> <code>endpoint</code> <p>Service endpoint path (e.g., \"/cds/cds-services/my-service\")</p> <p> TYPE: <code>str</code> </p> <code>workflow</code> <p>Optional workflow specification (auto-detected if not provided)</p> <p> TYPE: <code>Optional[Union[Workflow, str]]</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>Communication protocol - \"rest\" for CDS Hooks, \"soap\" for CDA</p> <p> TYPE: <code>Literal['rest', 'soap']</code> DEFAULT: <code>'rest'</code> </p> <code>timeout</code> <p>Request timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>10.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If api_url or endpoint is invalid</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def __init__(\n    self,\n    api_url: str,\n    endpoint: str,\n    workflow: Optional[Union[Workflow, str]] = None,\n    protocol: Literal[\"rest\", \"soap\"] = \"rest\",\n    timeout: float = 10.0,\n):\n    \"\"\"\n    Initialize SandboxClient.\n\n    Args:\n        api_url: Base URL of the service (e.g., \"http://localhost:8000\")\n        endpoint: Service endpoint path (e.g., \"/cds/cds-services/my-service\")\n        workflow: Optional workflow specification (auto-detected if not provided)\n        protocol: Communication protocol - \"rest\" for CDS Hooks, \"soap\" for CDA\n        timeout: Request timeout in seconds\n\n    Raises:\n        ValueError: If api_url or endpoint is invalid\n    \"\"\"\n    try:\n        self.api = httpx.URL(api_url)\n    except Exception as e:\n        raise ValueError(f\"Invalid API URL: {str(e)}\")\n\n    self.endpoint = endpoint\n    self.workflow = Workflow(workflow) if isinstance(workflow, str) else workflow\n    self.protocol = ApiProtocol.soap if protocol == \"soap\" else ApiProtocol.rest\n    self.timeout = timeout\n\n    # Request/response management\n    self.request_data: List[Union[CDSRequest, Any]] = []\n    self.responses: List[Dict] = []\n    self.sandbox_id = uuid.uuid4()\n\n    log.info(\n        f\"Initialized SandboxClient {self.sandbox_id} for {self.api}{self.endpoint}\"\n    )\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of SandboxClient.</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of SandboxClient.\"\"\"\n    return (\n        f\"SandboxClient(api_url='{self.api}', endpoint='{self.endpoint}', \"\n        f\"protocol='{self.protocol.value if hasattr(self.protocol, 'value') else self.protocol}', \"\n        f\"requests={len(self.request_data)})\"\n    )\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.get_status","title":"<code>get_status()</code>","text":"<p>Get current client status and statistics.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary containing client status information</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def get_status(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get current client status and statistics.\n\n    Returns:\n        Dictionary containing client status information\n    \"\"\"\n    return {\n        \"sandbox_id\": str(self.sandbox_id),\n        \"api_url\": str(self.api),\n        \"endpoint\": self.endpoint,\n        \"protocol\": self.protocol.value\n        if hasattr(self.protocol, \"value\")\n        else str(self.protocol),\n        \"workflow\": self.workflow.value if self.workflow else None,\n        \"requests_queued\": len(self.request_data),\n        \"responses_received\": len(self.responses),\n    }\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.load_free_text","title":"<code>load_free_text(csv_path, column_name, workflow, random_seed=None, **kwargs)</code>","text":"<p>Generates a CDS prefetch from free text notes.</p> <p>Reads clinical notes from a CSV file and wraps it in FHIR DocumentReferences in a CDS prefetch field for CDS Hooks workflows. Generates additional synthetic FHIR resources as needed based on the specified workflow.</p> PARAMETER DESCRIPTION <code>csv_path</code> <p>Path to CSV file containing clinical notes</p> <p> TYPE: <code>str</code> </p> <code>column_name</code> <p>Name of the column containing the text</p> <p> TYPE: <code>str</code> </p> <code>workflow</code> <p>CDS workflow type (e.g., \"encounter-discharge\", \"patient-view\")</p> <p> TYPE: <code>Union[Workflow, str]</code> </p> <code>random_seed</code> <p>Seed for reproducible data generation</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters for data generation</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>SandboxClient</code> <p>Self for method chaining</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If CSV file doesn't exist</p> <code>ValueError</code> <p>If workflow is invalid or column not found</p> <p>Examples:</p> <p>Generate discharge summaries:</p> <pre><code>&gt;&gt;&gt; client.load_free_text(\n...     csv_path=\"./data/discharge_notes.csv\",\n...     column_name=\"text\",\n...     workflow=\"encounter-discharge\",\n...     random_seed=42\n... )\n</code></pre> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def load_free_text(\n    self,\n    csv_path: str,\n    column_name: str,\n    workflow: Union[Workflow, str],\n    random_seed: Optional[int] = None,\n    **kwargs: Any,\n) -&gt; \"SandboxClient\":\n    \"\"\"\n    Generates a CDS prefetch from free text notes.\n\n    Reads clinical notes from a CSV file and wraps it in FHIR DocumentReferences\n    in a CDS prefetch field for CDS Hooks workflows. Generates additional synthetic\n    FHIR resources as needed based on the specified workflow.\n\n    Args:\n        csv_path: Path to CSV file containing clinical notes\n        column_name: Name of the column containing the text\n        workflow: CDS workflow type (e.g., \"encounter-discharge\", \"patient-view\")\n        random_seed: Seed for reproducible data generation\n        **kwargs: Additional parameters for data generation\n\n    Returns:\n        Self for method chaining\n\n    Raises:\n        FileNotFoundError: If CSV file doesn't exist\n        ValueError: If workflow is invalid or column not found\n\n    Examples:\n        Generate discharge summaries:\n        &gt;&gt;&gt; client.load_free_text(\n        ...     csv_path=\"./data/discharge_notes.csv\",\n        ...     column_name=\"text\",\n        ...     workflow=\"encounter-discharge\",\n        ...     random_seed=42\n        ... )\n    \"\"\"\n    from .generators import CdsDataGenerator\n\n    workflow_enum = Workflow(workflow) if isinstance(workflow, str) else workflow\n\n    generator = CdsDataGenerator()\n    generator.set_workflow(workflow_enum)\n\n    prefetch_data = generator.generate_prefetch(\n        random_seed=random_seed,\n        free_text_path=csv_path,\n        column_name=column_name,\n        **kwargs,\n    )\n\n    self._construct_request(prefetch_data, workflow_enum)\n    log.info(\n        f\"Generated {len(self.request_data)} requests from free text for workflow {workflow_enum.value}\"\n    )\n\n    return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.load_from_path","title":"<code>load_from_path(path, pattern=None, workflow=None)</code>","text":"<p>Load data from file system path.</p> <p>Supports loading single files or directories. File type is auto-detected from extension and protocol: - .xml files with SOAP protocol \u2192 CDA documents - .json files with REST protocol \u2192 Pre-formatted Prefetch data</p> PARAMETER DESCRIPTION <code>path</code> <p>File path or directory path</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>pattern</code> <p>Glob pattern for filtering files in directory (e.g., \"*.xml\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>workflow</code> <p>Optional workflow override (auto-detected from protocol if not provided)</p> <p> TYPE: <code>Optional[Union[Workflow, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>SandboxClient</code> <p>Self for method chaining</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If path doesn't exist</p> <code>ValueError</code> <p>If no matching files found or unsupported file type</p> <p>Examples:</p> <p>Load single CDA file:</p> <pre><code>&gt;&gt;&gt; client.load_from_path(\"./data/clinical_note.xml\")\n</code></pre> <p>Load directory of CDA files:</p> <pre><code>&gt;&gt;&gt; client.load_from_path(\"./data/cda_files/\", pattern=\"*.xml\")\n</code></pre> <p>Load with explicit workflow:</p> <pre><code>&gt;&gt;&gt; client.load_from_path(\"./data/note.xml\", workflow=\"sign-note-inpatient\")\n</code></pre> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def load_from_path(\n    self,\n    path: Union[str, Path],\n    pattern: Optional[str] = None,\n    workflow: Optional[Union[Workflow, str]] = None,\n) -&gt; \"SandboxClient\":\n    \"\"\"\n    Load data from file system path.\n\n    Supports loading single files or directories. File type is auto-detected\n    from extension and protocol:\n    - .xml files with SOAP protocol \u2192 CDA documents\n    - .json files with REST protocol \u2192 Pre-formatted Prefetch data\n\n    Args:\n        path: File path or directory path\n        pattern: Glob pattern for filtering files in directory (e.g., \"*.xml\")\n        workflow: Optional workflow override (auto-detected from protocol if not provided)\n\n    Returns:\n        Self for method chaining\n\n    Raises:\n        FileNotFoundError: If path doesn't exist\n        ValueError: If no matching files found or unsupported file type\n\n    Examples:\n        Load single CDA file:\n        &gt;&gt;&gt; client.load_from_path(\"./data/clinical_note.xml\")\n\n        Load directory of CDA files:\n        &gt;&gt;&gt; client.load_from_path(\"./data/cda_files/\", pattern=\"*.xml\")\n\n        Load with explicit workflow:\n        &gt;&gt;&gt; client.load_from_path(\"./data/note.xml\", workflow=\"sign-note-inpatient\")\n    \"\"\"\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"Path not found: {path}\")\n\n    # Collect files to process\n    files_to_load = []\n    if path.is_file():\n        files_to_load = [path]\n    elif path.is_dir():\n        pattern = pattern or \"*\"\n        files_to_load = list(path.glob(pattern))\n        if not files_to_load:\n            raise ValueError(\n                f\"No files found matching pattern '{pattern}' in {path}\"\n            )\n    else:\n        raise ValueError(f\"Path must be a file or directory: {path}\")\n\n    log.info(f\"Loading {len(files_to_load)} file(s) from {path}\")\n\n    # Process each file\n    for file_path in files_to_load:\n        # Determine file type from extension\n        extension = file_path.suffix.lower()\n\n        if extension == \".xml\":\n            with open(file_path, \"r\") as f:\n                xml_content = f.read()\n            workflow_enum = (\n                Workflow(workflow)\n                if isinstance(workflow, str)\n                else workflow or self.workflow or Workflow.sign_note_inpatient\n            )\n            self._construct_request(xml_content, workflow_enum)\n            log.info(f\"Loaded CDA document from {file_path.name}\")\n\n        elif extension == \".json\":\n            with open(file_path, \"r\") as f:\n                json_data = json.load(f)\n\n            try:\n                # Validate and load as Prefetch object\n                prefetch_data = Prefetch(**json_data)\n\n                workflow_enum = (\n                    Workflow(workflow)\n                    if isinstance(workflow, str)\n                    else workflow or self.workflow\n                )\n                if not workflow_enum:\n                    raise ValueError(\n                        \"Workflow must be specified when loading JSON Prefetch data. \"\n                        \"Provide via 'workflow' parameter or set on client initialization.\"\n                    )\n                self._construct_request(prefetch_data, workflow_enum)\n                log.info(f\"Loaded Prefetch data from {file_path.name}\")\n\n            except Exception as e:\n                log.error(f\"Failed to parse {file_path} as Prefetch: {e}\")\n                raise ValueError(\n                    f\"File {file_path} is not valid Prefetch format. \"\n                    f\"Expected JSON with 'prefetch' key containing FHIR resources. \"\n                    f\"Error: {e}\"\n                )\n        else:\n            log.warning(f\"Skipping unsupported file type: {file_path}\")\n\n    log.info(\n        f\"Loaded {len(self.request_data)} requests from {len(files_to_load)} file(s)\"\n    )\n    return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.load_from_registry","title":"<code>load_from_registry(source, **kwargs)</code>","text":"<p>Load data from the dataset registry.</p> <p>Loads pre-configured datasets like MIMIC-on-FHIR, Synthea, or custom registered datasets.</p> PARAMETER DESCRIPTION <code>source</code> <p>Dataset name (e.g., \"mimic-on-fhir\", \"synthea\")</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Dataset-specific parameters (e.g., sample_size, num_patients)</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>SandboxClient</code> <p>Self for method chaining</p> RAISES DESCRIPTION <code>ValueError</code> <p>If dataset not found in registry</p> <p>Examples:</p> <p>Discover available datasets:</p> <pre><code>&gt;&gt;&gt; from healthchain.sandbox import list_available_datasets\n&gt;&gt;&gt; print(list_available_datasets())\n</code></pre> <p>Load MIMIC dataset:</p> <pre><code>&gt;&gt;&gt; client.load_from_registry(\"mimic-on-fhir\", sample_size=10)\n</code></pre> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def load_from_registry(\n    self,\n    source: str,\n    **kwargs: Any,\n) -&gt; \"SandboxClient\":\n    \"\"\"\n    Load data from the dataset registry.\n\n    Loads pre-configured datasets like MIMIC-on-FHIR, Synthea, or custom\n    registered datasets.\n\n    Args:\n        source: Dataset name (e.g., \"mimic-on-fhir\", \"synthea\")\n        **kwargs: Dataset-specific parameters (e.g., sample_size, num_patients)\n\n    Returns:\n        Self for method chaining\n\n    Raises:\n        ValueError: If dataset not found in registry\n\n    Examples:\n        Discover available datasets:\n        &gt;&gt;&gt; from healthchain.sandbox import list_available_datasets\n        &gt;&gt;&gt; print(list_available_datasets())\n\n        Load MIMIC dataset:\n        &gt;&gt;&gt; client.load_from_registry(\"mimic-on-fhir\", sample_size=10)\n    \"\"\"\n    from healthchain.sandbox.datasets import DatasetRegistry\n\n    log.info(f\"Loading dataset from registry: {source}\")\n    try:\n        loaded_data = DatasetRegistry.load(source, **kwargs)\n        self._construct_request(loaded_data)\n        log.info(f\"Loaded {source} dataset with {len(self.request_data)} requests\")\n    except KeyError:\n        raise ValueError(\n            f\"Unknown dataset: {source}. \"\n            f\"Available datasets: {DatasetRegistry.list_datasets()}\"\n        )\n    return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.save_results","title":"<code>save_results(directory='./output/')</code>","text":"<p>Save request and response data to disk.</p> PARAMETER DESCRIPTION <code>directory</code> <p>Directory to save data to (default: \"./output/\")</p> <p> TYPE: <code>Union[str, Path]</code> DEFAULT: <code>'./output/'</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If no responses are available to save</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def save_results(self, directory: Union[str, Path] = \"./output/\") -&gt; None:\n    \"\"\"\n    Save request and response data to disk.\n\n    Args:\n        directory: Directory to save data to (default: \"./output/\")\n\n    Raises:\n        RuntimeError: If no responses are available to save\n    \"\"\"\n    if not self.responses:\n        raise RuntimeError(\n            \"No responses to save. Send requests first using send_requests()\"\n        )\n\n    save_dir = Path(directory)\n    request_path = ensure_directory_exists(save_dir / \"requests\")\n\n    # Determine file extension based on protocol\n    extension = \"xml\" if self.protocol == ApiProtocol.soap else \"json\"\n\n    # Save requests\n    if self.protocol == ApiProtocol.soap:\n        request_data = [request.model_dump_xml() for request in self.request_data]\n    else:\n        request_data = [\n            request.model_dump(exclude_none=True) for request in self.request_data\n        ]\n\n    save_data_to_directory(\n        request_data,\n        \"request\",\n        self.sandbox_id,\n        request_path,\n        extension,\n    )\n    log.info(f\"Saved request data at {request_path}/\")\n\n    # Save responses\n    response_path = ensure_directory_exists(save_dir / \"responses\")\n    save_data_to_directory(\n        self.responses,\n        \"response\",\n        self.sandbox_id,\n        response_path,\n        extension,\n    )\n    log.info(f\"Saved response data at {response_path}/\")\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.send_requests","title":"<code>send_requests()</code>","text":"<p>Send all queued requests to the service.</p> RETURNS DESCRIPTION <code>List[Dict]</code> <p>List of response dictionaries</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If no requests are queued</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def send_requests(self) -&gt; List[Dict]:\n    \"\"\"\n    Send all queued requests to the service.\n\n    Returns:\n        List of response dictionaries\n\n    Raises:\n        RuntimeError: If no requests are queued\n    \"\"\"\n    if not self.request_data:\n        raise RuntimeError(\n            \"No requests to send. Load data first using load_from_registry(), load_from_path(), or load_free_text()\"\n        )\n\n    url = self.api.join(self.endpoint)\n    log.info(f\"Sending {len(self.request_data)} requests to {url}\")\n\n    with httpx.Client(follow_redirects=True) as client:\n        responses: List[Dict] = []\n        timeout = httpx.Timeout(self.timeout, read=None)\n\n        for request in self.request_data:\n            try:\n                if self.protocol == ApiProtocol.soap:\n                    headers = {\"Content-Type\": \"text/xml; charset=utf-8\"}\n                    response = client.post(\n                        url=str(url),\n                        data=request.document,\n                        headers=headers,\n                        timeout=timeout,\n                    )\n                    response.raise_for_status()\n                    response_model = CdaResponse(document=response.text)\n                    responses.append(response_model.model_dump_xml())\n                else:\n                    # REST/CDS Hooks\n                    log.debug(f\"Making POST request to: {url}\")\n                    response = client.post(\n                        url=str(url),\n                        json=request.model_dump(exclude_none=True),\n                        timeout=timeout,\n                    )\n                    response.raise_for_status()\n                    response_data = response.json()\n                    try:\n                        cds_response = CDSResponse(**response_data)\n                        responses.append(cds_response.model_dump(exclude_none=True))\n                    except Exception:\n                        # Fallback to raw response if parsing fails\n                        responses.append(response_data)\n\n            except httpx.HTTPStatusError as exc:\n                try:\n                    error_content = exc.response.json()\n                except Exception:\n                    error_content = exc.response.text\n                log.error(\n                    f\"Error response {exc.response.status_code} while requesting \"\n                    f\"{exc.request.url!r}: {error_content}\"\n                )\n                responses.append({})\n            except httpx.TimeoutException as exc:\n                log.error(f\"Request to {exc.request.url!r} timed out!\")\n                responses.append({})\n            except httpx.RequestError as exc:\n                log.error(\n                    f\"An error occurred while requesting {exc.request.url!r}.\"\n                )\n                responses.append({})\n\n    self.responses = responses\n    log.info(f\"Received {len(responses)} responses\")\n\n    return responses\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator","title":"<code>CdsDataGenerator</code>","text":"<p>A class to generate CDS (Clinical Decision Support) data based on specified workflows and constraints.</p> <p>This class provides functionality to generate synthetic FHIR resources for testing CDS systems. It uses registered data generators to create resources like Patients, Encounters, Conditions etc. based on configured workflows. It can also incorporate free text data from CSV files.</p> ATTRIBUTE DESCRIPTION <code>registry</code> <p>A registry mapping generator names to generator classes.</p> <p> TYPE: <code>dict</code> </p> <code>mappings</code> <p>A mapping of workflow names to lists of required generators.</p> <p> TYPE: <code>dict</code> </p> <code>generated_data</code> <p>The most recently generated FHIR resources.</p> <p> TYPE: <code>Dict[str, Resource]</code> </p> <code>workflow</code> <p>The currently active workflow.</p> <p> TYPE: <code>str</code> </p> Example <p>generator = CdsDataGenerator() generator.set_workflow(\"encounter_discharge\") data = generator.generate_prefetch( ...     random_seed=42 ... )</p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>class CdsDataGenerator:\n    \"\"\"\n    A class to generate CDS (Clinical Decision Support) data based on specified workflows and constraints.\n\n    This class provides functionality to generate synthetic FHIR resources for testing CDS systems.\n    It uses registered data generators to create resources like Patients, Encounters, Conditions etc.\n    based on configured workflows. It can also incorporate free text data from CSV files.\n\n    Attributes:\n        registry (dict): A registry mapping generator names to generator classes.\n        mappings (dict): A mapping of workflow names to lists of required generators.\n        generated_data (Dict[str, Resource]): The most recently generated FHIR resources.\n        workflow (str): The currently active workflow.\n\n    Example:\n        &gt;&gt;&gt; generator = CdsDataGenerator()\n        &gt;&gt;&gt; generator.set_workflow(\"encounter_discharge\")\n        &gt;&gt;&gt; data = generator.generate_prefetch(\n        ...     random_seed=42\n        ... )\n    \"\"\"\n\n    # TODO: Add ordering and logic so that patient/encounter IDs are passed to subsequent generators\n    # TODO: Some of the resources should be allowed to be multiplied\n\n    default_workflow_mappings = {\n        Workflow.encounter_discharge: [\n            {\"generator\": \"EncounterGenerator\"},\n            {\"generator\": \"ConditionGenerator\"},\n            {\"generator\": \"ProcedureGenerator\"},\n            {\"generator\": \"MedicationRequestGenerator\"},\n        ],\n        Workflow.patient_view: [\n            {\"generator\": \"PatientGenerator\"},\n            {\"generator\": \"EncounterGenerator\"},\n            {\"generator\": \"ConditionGenerator\"},\n        ],\n    }\n\n    def __init__(self):\n        self.registry = generator_registry\n        self.mappings = self.default_workflow_mappings\n        self.generated_data: Dict[str, Resource] = {}\n\n    def fetch_generator(self, generator_name: str) -&gt; Callable:\n        \"\"\"\n        Fetches a data generator class by its name from the registry.\n\n        Args:\n            generator_name (str): The name of the data generator to fetch (e.g. \"PatientGenerator\", \"EncounterGenerator\")\n\n        Returns:\n            Callable: The data generator class that can be used to generate FHIR resources. Returns None if generator not found.\n\n        Example:\n            &gt;&gt;&gt; generator = CdsDataGenerator()\n            &gt;&gt;&gt; patient_gen = generator.fetch_generator(\"PatientGenerator\")\n            &gt;&gt;&gt; patient = patient_gen.generate()\n        \"\"\"\n        return self.registry.get(generator_name)\n\n    def set_workflow(self, workflow: str) -&gt; None:\n        \"\"\"\n        Sets the current workflow to be used for data generation.\n\n        Parameters:\n            workflow (str): The name of the workflow to set.\n        \"\"\"\n        self.workflow = workflow\n\n    def generate_prefetch(\n        self,\n        constraints: Optional[list] = None,\n        free_text_path: Optional[str] = None,\n        column_name: Optional[str] = None,\n        random_seed: Optional[int] = None,\n    ) -&gt; Prefetch:\n        \"\"\"\n        Generates CDS data based on the current workflow, constraints, and optional free text data.\n\n        This method generates FHIR resources according to the configured workflow mapping. For each\n        resource type in the workflow, it uses the corresponding generator to create a FHIR resource.\n        If free text data is provided via CSV, it will also generate a DocumentReference containing\n        randomly selected text from the CSV.\n\n        Args:\n            constraints (Optional[list]): A list of constraints to apply to the data generation.\n                Each constraint should match the format expected by the individual generators.\n            free_text_path (Optional[str]): Path to a CSV file containing free text data to be\n                included as DocumentReferences. If provided, column_name must also be specified.\n            column_name (Optional[str]): The name of the column in the CSV file containing the\n                free text data to use. Required if free_text_path is provided.\n            random_seed (Optional[int]): Seed value for random number generation to ensure\n                reproducible results. If not provided, generation will be truly random.\n\n        Returns:\n            Prefetch: A dictionary mapping resource types to generated FHIR resources.\n                The keys are lowercase resource type names (e.g. \"patient\", \"encounter\").\n                If free text is provided, includes a \"document\" key with a DocumentReference.\n\n        Raises:\n            ValueError: If the configured workflow is not found in the mappings\n            FileNotFoundError: If the free_text_path is provided but file not found\n            ValueError: If free_text_path provided without column_name\n        \"\"\"\n        prefetch = Prefetch(prefetch={})\n\n        if self.workflow not in self.mappings.keys():\n            raise ValueError(f\"Workflow {self.workflow} not found in mappings\")\n\n        for resource in self.mappings[self.workflow]:\n            generator_name = resource[\"generator\"]\n            generator = self.fetch_generator(generator_name)\n            resource = generator.generate(\n                constraints=constraints, random_seed=random_seed\n            )\n\n            prefetch.prefetch[resource.__resource_type__.lower()] = resource\n\n        parsed_free_text = (\n            self.free_text_parser(free_text_path, column_name)\n            if free_text_path\n            else None\n        )\n        if parsed_free_text:\n            prefetch.prefetch[\"document\"] = create_document_reference(\n                data=random.choice(parsed_free_text),\n                content_type=\"text/plain\",\n                status=\"current\",\n                description=\"Free text created by HealthChain CdsDataGenerator\",\n                attachment_title=\"Free text created by HealthChain CdsDataGenerator\",\n            )\n\n        self.generated_data = prefetch\n\n        return self.generated_data\n\n    def free_text_parser(self, path_to_csv: str, column_name: str) -&gt; List[str]:\n        \"\"\"\n        Parse free text data from a CSV file.\n\n        This method reads a CSV file and extracts text data from a specified column. The text data\n        can later be used to create DocumentReference resources.\n\n        Args:\n            path_to_csv (str): Path to the CSV file containing the free text data.\n            column_name (str): Name of the column in the CSV file to extract text from.\n\n        Returns:\n            List[str]: List of text strings extracted from the specified column.\n\n        Raises:\n            FileNotFoundError: If the specified CSV file does not exist or is not a file.\n            ValueError: If column_name is not provided.\n            Exception: If any other error occurs while reading/parsing the CSV file.\n        \"\"\"\n        text_data = []\n\n        # Check that path_to_csv is a valid path with pathlib\n        path = Path(path_to_csv)\n        if not path.is_file():\n            raise FileNotFoundError(\n                f\"The file {path_to_csv} does not exist or is not a file.\"\n            )\n\n        try:\n            with path.open(mode=\"r\", newline=\"\") as file:\n                reader = csv.DictReader(file)\n                if column_name is not None:\n                    for row in reader:\n                        text_data.append(row[column_name])\n                else:\n                    raise ValueError(\n                        \"Column name must be provided when header is True.\"\n                    )\n        except Exception as ex:\n            logger.error(f\"An error occurred: {ex}\")\n\n        return text_data\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator.fetch_generator","title":"<code>fetch_generator(generator_name)</code>","text":"<p>Fetches a data generator class by its name from the registry.</p> PARAMETER DESCRIPTION <code>generator_name</code> <p>The name of the data generator to fetch (e.g. \"PatientGenerator\", \"EncounterGenerator\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>The data generator class that can be used to generate FHIR resources. Returns None if generator not found.</p> <p> TYPE: <code>Callable</code> </p> Example <p>generator = CdsDataGenerator() patient_gen = generator.fetch_generator(\"PatientGenerator\") patient = patient_gen.generate()</p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>def fetch_generator(self, generator_name: str) -&gt; Callable:\n    \"\"\"\n    Fetches a data generator class by its name from the registry.\n\n    Args:\n        generator_name (str): The name of the data generator to fetch (e.g. \"PatientGenerator\", \"EncounterGenerator\")\n\n    Returns:\n        Callable: The data generator class that can be used to generate FHIR resources. Returns None if generator not found.\n\n    Example:\n        &gt;&gt;&gt; generator = CdsDataGenerator()\n        &gt;&gt;&gt; patient_gen = generator.fetch_generator(\"PatientGenerator\")\n        &gt;&gt;&gt; patient = patient_gen.generate()\n    \"\"\"\n    return self.registry.get(generator_name)\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator.free_text_parser","title":"<code>free_text_parser(path_to_csv, column_name)</code>","text":"<p>Parse free text data from a CSV file.</p> <p>This method reads a CSV file and extracts text data from a specified column. The text data can later be used to create DocumentReference resources.</p> PARAMETER DESCRIPTION <code>path_to_csv</code> <p>Path to the CSV file containing the free text data.</p> <p> TYPE: <code>str</code> </p> <code>column_name</code> <p>Name of the column in the CSV file to extract text from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: List of text strings extracted from the specified column.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the specified CSV file does not exist or is not a file.</p> <code>ValueError</code> <p>If column_name is not provided.</p> <code>Exception</code> <p>If any other error occurs while reading/parsing the CSV file.</p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>def free_text_parser(self, path_to_csv: str, column_name: str) -&gt; List[str]:\n    \"\"\"\n    Parse free text data from a CSV file.\n\n    This method reads a CSV file and extracts text data from a specified column. The text data\n    can later be used to create DocumentReference resources.\n\n    Args:\n        path_to_csv (str): Path to the CSV file containing the free text data.\n        column_name (str): Name of the column in the CSV file to extract text from.\n\n    Returns:\n        List[str]: List of text strings extracted from the specified column.\n\n    Raises:\n        FileNotFoundError: If the specified CSV file does not exist or is not a file.\n        ValueError: If column_name is not provided.\n        Exception: If any other error occurs while reading/parsing the CSV file.\n    \"\"\"\n    text_data = []\n\n    # Check that path_to_csv is a valid path with pathlib\n    path = Path(path_to_csv)\n    if not path.is_file():\n        raise FileNotFoundError(\n            f\"The file {path_to_csv} does not exist or is not a file.\"\n        )\n\n    try:\n        with path.open(mode=\"r\", newline=\"\") as file:\n            reader = csv.DictReader(file)\n            if column_name is not None:\n                for row in reader:\n                    text_data.append(row[column_name])\n            else:\n                raise ValueError(\n                    \"Column name must be provided when header is True.\"\n                )\n    except Exception as ex:\n        logger.error(f\"An error occurred: {ex}\")\n\n    return text_data\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator.generate_prefetch","title":"<code>generate_prefetch(constraints=None, free_text_path=None, column_name=None, random_seed=None)</code>","text":"<p>Generates CDS data based on the current workflow, constraints, and optional free text data.</p> <p>This method generates FHIR resources according to the configured workflow mapping. For each resource type in the workflow, it uses the corresponding generator to create a FHIR resource. If free text data is provided via CSV, it will also generate a DocumentReference containing randomly selected text from the CSV.</p> PARAMETER DESCRIPTION <code>constraints</code> <p>A list of constraints to apply to the data generation. Each constraint should match the format expected by the individual generators.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>free_text_path</code> <p>Path to a CSV file containing free text data to be included as DocumentReferences. If provided, column_name must also be specified.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>column_name</code> <p>The name of the column in the CSV file containing the free text data to use. Required if free_text_path is provided.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>random_seed</code> <p>Seed value for random number generation to ensure reproducible results. If not provided, generation will be truly random.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Prefetch</code> <p>A dictionary mapping resource types to generated FHIR resources. The keys are lowercase resource type names (e.g. \"patient\", \"encounter\"). If free text is provided, includes a \"document\" key with a DocumentReference.</p> <p> TYPE: <code>Prefetch</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the configured workflow is not found in the mappings</p> <code>FileNotFoundError</code> <p>If the free_text_path is provided but file not found</p> <code>ValueError</code> <p>If free_text_path provided without column_name</p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>def generate_prefetch(\n    self,\n    constraints: Optional[list] = None,\n    free_text_path: Optional[str] = None,\n    column_name: Optional[str] = None,\n    random_seed: Optional[int] = None,\n) -&gt; Prefetch:\n    \"\"\"\n    Generates CDS data based on the current workflow, constraints, and optional free text data.\n\n    This method generates FHIR resources according to the configured workflow mapping. For each\n    resource type in the workflow, it uses the corresponding generator to create a FHIR resource.\n    If free text data is provided via CSV, it will also generate a DocumentReference containing\n    randomly selected text from the CSV.\n\n    Args:\n        constraints (Optional[list]): A list of constraints to apply to the data generation.\n            Each constraint should match the format expected by the individual generators.\n        free_text_path (Optional[str]): Path to a CSV file containing free text data to be\n            included as DocumentReferences. If provided, column_name must also be specified.\n        column_name (Optional[str]): The name of the column in the CSV file containing the\n            free text data to use. Required if free_text_path is provided.\n        random_seed (Optional[int]): Seed value for random number generation to ensure\n            reproducible results. If not provided, generation will be truly random.\n\n    Returns:\n        Prefetch: A dictionary mapping resource types to generated FHIR resources.\n            The keys are lowercase resource type names (e.g. \"patient\", \"encounter\").\n            If free text is provided, includes a \"document\" key with a DocumentReference.\n\n    Raises:\n        ValueError: If the configured workflow is not found in the mappings\n        FileNotFoundError: If the free_text_path is provided but file not found\n        ValueError: If free_text_path provided without column_name\n    \"\"\"\n    prefetch = Prefetch(prefetch={})\n\n    if self.workflow not in self.mappings.keys():\n        raise ValueError(f\"Workflow {self.workflow} not found in mappings\")\n\n    for resource in self.mappings[self.workflow]:\n        generator_name = resource[\"generator\"]\n        generator = self.fetch_generator(generator_name)\n        resource = generator.generate(\n            constraints=constraints, random_seed=random_seed\n        )\n\n        prefetch.prefetch[resource.__resource_type__.lower()] = resource\n\n    parsed_free_text = (\n        self.free_text_parser(free_text_path, column_name)\n        if free_text_path\n        else None\n    )\n    if parsed_free_text:\n        prefetch.prefetch[\"document\"] = create_document_reference(\n            data=random.choice(parsed_free_text),\n            content_type=\"text/plain\",\n            status=\"current\",\n            description=\"Free text created by HealthChain CdsDataGenerator\",\n            attachment_title=\"Free text created by HealthChain CdsDataGenerator\",\n        )\n\n    self.generated_data = prefetch\n\n    return self.generated_data\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator.set_workflow","title":"<code>set_workflow(workflow)</code>","text":"<p>Sets the current workflow to be used for data generation.</p> PARAMETER DESCRIPTION <code>workflow</code> <p>The name of the workflow to set.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>def set_workflow(self, workflow: str) -&gt; None:\n    \"\"\"\n    Sets the current workflow to be used for data generation.\n\n    Parameters:\n        workflow (str): The name of the workflow to set.\n    \"\"\"\n    self.workflow = workflow\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdsrequest.CDSRequest","title":"<code>CDSRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing the data structure for a CDS service call, triggered by specific hooks within a healthcare application.</p> ATTRIBUTE DESCRIPTION <code>hook</code> <p>The hook that triggered this CDS Service call. For example, 'patient-view'.</p> <p> TYPE: <code>str</code> </p> <code>hookInstance</code> <p>A universally unique identifier for this particular hook call.</p> <p> TYPE: <code>UUID</code> </p> <code>fhirServer</code> <p>The base URL of the CDS Client's FHIR server. This field is required if <code>fhirAuthorization</code> is provided.</p> <p> TYPE: <code>HttpUrl</code> </p> <code>fhirAuthorization</code> <p>Optional authorization details providing a bearer access token for FHIR resources.</p> <p> TYPE: <code>Optional[FhirAuthorization]</code> </p> <code>context</code> <p>Hook-specific contextual data required by the CDS service.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>prefetch</code> <p>Optional FHIR data that was prefetched by the CDS Client.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#http-request_1</p> Source code in <code>healthchain/models/requests/cdsrequest.py</code> <pre><code>class CDSRequest(BaseModel):\n    \"\"\"\n    A model representing the data structure for a CDS service call, triggered by specific hooks\n    within a healthcare application.\n\n    Attributes:\n        hook (str): The hook that triggered this CDS Service call. For example, 'patient-view'.\n        hookInstance (UUID): A universally unique identifier for this particular hook call.\n        fhirServer (HttpUrl): The base URL of the CDS Client's FHIR server. This field is required if `fhirAuthorization` is provided.\n        fhirAuthorization (Optional[FhirAuthorization]): Optional authorization details providing a bearer access token for FHIR resources.\n        context (Dict[str, Any]): Hook-specific contextual data required by the CDS service.\n        prefetch (Optional[Dict[str, Any]]): Optional FHIR data that was prefetched by the CDS Client.\n\n    Documentation: https://cds-hooks.org/specification/current/#http-request_1\n    \"\"\"\n\n    hook: str\n    hookInstance: str = Field(default_factory=id_generator.generate_random_uuid)\n    context: BaseHookContext\n    fhirServer: Optional[HttpUrl] = None\n    fhirAuthorization: Optional[FHIRAuthorization] = (\n        None  # TODO: note this is required if fhirserver is given\n    )\n    prefetch: Optional[Dict[str, Any]] = (\n        None  # fhir resource is passed either thru prefetched template of fhir server\n    )\n    extension: Optional[List[Dict[str, Any]]] = None\n\n    def model_dump(self, **kwargs):\n        \"\"\"\n        Model dump method to convert any nested datetime and byte objects to strings for readability.\n        This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571\n        For proper JSON serialization, should use model_dump_json() instead when issue is resolved.\n        \"\"\"\n\n        def convert_objects(obj):\n            if isinstance(obj, dict):\n                return {k: convert_objects(v) for k, v in obj.items()}\n            elif isinstance(obj, list):\n                return [convert_objects(i) for i in obj]\n            elif isinstance(obj, datetime):\n                return obj.astimezone().isoformat()\n            elif isinstance(obj, bytes):\n                return obj.decode(\"utf-8\")\n            return obj\n\n        dump = super().model_dump(**kwargs)\n        return convert_objects(dump)\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdsrequest.CDSRequest.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Model dump method to convert any nested datetime and byte objects to strings for readability. This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571 For proper JSON serialization, should use model_dump_json() instead when issue is resolved.</p> Source code in <code>healthchain/models/requests/cdsrequest.py</code> <pre><code>def model_dump(self, **kwargs):\n    \"\"\"\n    Model dump method to convert any nested datetime and byte objects to strings for readability.\n    This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571\n    For proper JSON serialization, should use model_dump_json() instead when issue is resolved.\n    \"\"\"\n\n    def convert_objects(obj):\n        if isinstance(obj, dict):\n            return {k: convert_objects(v) for k, v in obj.items()}\n        elif isinstance(obj, list):\n            return [convert_objects(i) for i in obj]\n        elif isinstance(obj, datetime):\n            return obj.astimezone().isoformat()\n        elif isinstance(obj, bytes):\n            return obj.decode(\"utf-8\")\n        return obj\n\n    dump = super().model_dump(**kwargs)\n    return convert_objects(dump)\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Within a suggestion, all actions are logically AND'd together, such that a user selecting a suggestion selects all of the actions within it. When a suggestion contains multiple actions, the actions SHOULD be processed as per FHIR's rules for processing transactions with the CDS Client's fhirServer as the base url for the inferred full URL of the transaction bundle entries.</p> <p>https://cds-hooks.org/specification/current/#action</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Action(BaseModel):\n    \"\"\"\n    Within a suggestion, all actions are logically AND'd together, such that a user selecting a\n    suggestion selects all of the actions within it. When a suggestion contains multiple actions,\n    the actions SHOULD be processed as per FHIR's rules for processing transactions with the CDS\n    Client's fhirServer as the base url for the inferred full URL of the transaction bundle entries.\n\n    https://cds-hooks.org/specification/current/#action\n    \"\"\"\n\n    type: ActionTypeEnum\n    description: str\n    resource: Optional[Dict] = None\n    resourceId: Optional[str] = None\n\n    @model_validator(mode=\"after\")\n    def validate_action_type(self) -&gt; Self:\n        if self.type in [ActionTypeEnum.create, ActionTypeEnum.update]:\n            assert (\n                self.resource\n            ), f\"'resource' must be provided when type is '{self.type.value}'\"\n        else:\n            assert (\n                self.resourceId\n            ), f\"'resourceId' must be provided when type is '{self.type.value}'\"\n\n        return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.ActionTypeEnum","title":"<code>ActionTypeEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of action being performed</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class ActionTypeEnum(str, Enum):\n    \"\"\"\n    The type of action being performed\n    \"\"\"\n\n    create = \"create\"\n    update = \"update\"\n    delete = \"delete\"\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.CDSResponse","title":"<code>CDSResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the response from a CDS service.</p> <p>This class models the structure of a CDS Hooks response, which includes cards for displaying information or suggestions to the user, and optional system actions that can be executed automatically.</p> ATTRIBUTE DESCRIPTION <code>cards</code> <p>A list of Card objects to be displayed to the end user. Default is an empty list.</p> <p> TYPE: <code>List[Card]</code> </p> <code>systemActions</code> <p>A list of Action objects representing actions that the CDS Client should execute as part of performing the decision support requested. This field is optional.</p> <p> TYPE: <code>Optional[List[Action]]</code> </p> <p>For more information, see: https://cds-hooks.org/specification/current/#cds-service-response</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class CDSResponse(BaseModel):\n    \"\"\"\n    Represents the response from a CDS service.\n\n    This class models the structure of a CDS Hooks response, which includes\n    cards for displaying information or suggestions to the user, and optional\n    system actions that can be executed automatically.\n\n    Attributes:\n        cards (List[Card]): A list of Card objects to be displayed to the end user.\n            Default is an empty list.\n        systemActions (Optional[List[Action]]): A list of Action objects representing\n            actions that the CDS Client should execute as part of performing\n            the decision support requested. This field is optional.\n\n    For more information, see:\n    https://cds-hooks.org/specification/current/#cds-service-response\n    \"\"\"\n\n    cards: List[Card] = []\n    systemActions: Optional[List[Action]] = None\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Card","title":"<code>Card</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Cards can provide a combination of information (for reading), suggested actions (to be applied if a user selects them), and links (to launch an app if the user selects them). The CDS Client decides how to display cards, but this specification recommends displaying suggestions using buttons, and links using underlined text.</p> <p>https://cds-hooks.org/specification/current/#card-attributes</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Card(BaseModel):\n    \"\"\"\n    Cards can provide a combination of information (for reading), suggested actions\n    (to be applied if a user selects them), and links (to launch an app if the user selects them).\n    The CDS Client decides how to display cards, but this specification recommends displaying suggestions\n    using buttons, and links using underlined text.\n\n    https://cds-hooks.org/specification/current/#card-attributes\n    \"\"\"\n\n    summary: str = Field(..., max_length=140)\n    indicator: IndicatorEnum\n    source: Source\n    uuid: Optional[str] = None\n    detail: Optional[str] = None\n    suggestions: Optional[List[Suggestion]] = None\n    selectionBehavior: Optional[SelectionBehaviorEnum] = None\n    overrideReasons: Optional[List[SimpleCoding]] = None\n    links: Optional[List[Link]] = None\n\n    @model_validator(mode=\"after\")\n    def validate_suggestions(self) -&gt; Self:\n        if self.suggestions is not None:\n            assert self.selectionBehavior, f\"'selectionBehavior' must be given if 'suggestions' is present! Choose from {[v for v in SelectionBehaviorEnum.value]}\"\n        return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.IndicatorEnum","title":"<code>IndicatorEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Urgency/importance of what Card conveys. Allowed values, in order of increasing urgency, are: info, warning, critical. The CDS Client MAY use this field to help make UI display decisions such as sort order or coloring.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class IndicatorEnum(str, Enum):\n    \"\"\"\n    Urgency/importance of what Card conveys.\n    Allowed values, in order of increasing urgency, are: info, warning, critical.\n    The CDS Client MAY use this field to help make UI display decisions such as sort order or coloring.\n    \"\"\"\n\n    info = \"info\"\n    warning = \"warning\"\n    critical = \"critical\"\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Link","title":"<code>Link</code>","text":"<p>               Bases: <code>BaseModel</code></p> <ul> <li> <p>CDS Client support for appContext requires additional coordination with the authorization server that is not described or specified in CDS Hooks nor SMART.</p> </li> <li> <p>Autolaunchable is experimental</p> </li> </ul> <p>https://cds-hooks.org/specification/current/#link</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Link(BaseModel):\n    \"\"\"\n    * CDS Client support for appContext requires additional coordination with the authorization\n    server that is not described or specified in CDS Hooks nor SMART.\n\n    * Autolaunchable is experimental\n\n    https://cds-hooks.org/specification/current/#link\n    \"\"\"\n\n    label: str\n    url: HttpUrl\n    type: LinkTypeEnum\n    appContext: Optional[str] = None\n    autoLaunchable: Optional[bool]\n\n    @model_validator(mode=\"after\")\n    def validate_link(self) -&gt; Self:\n        if self.appContext:\n            assert (\n                self.type == LinkTypeEnum.smart\n            ), \"'type' must be 'smart' for appContext to be valued.\"\n\n        return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.LinkTypeEnum","title":"<code>LinkTypeEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of the given URL. There are two possible values for this field. A type of absolute indicates that the URL is absolute and should be treated as-is. A type of smart indicates that the URL is a SMART app launch URL and the CDS Client should ensure the SMART app launch URL is populated with the appropriate SMART launch parameters.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class LinkTypeEnum(str, Enum):\n    \"\"\"\n    The type of the given URL. There are two possible values for this field.\n    A type of absolute indicates that the URL is absolute and should be treated as-is.\n    A type of smart indicates that the URL is a SMART app launch URL and the CDS Client\n    should ensure the SMART app launch URL is populated with the appropriate SMART\n    launch parameters.\n    \"\"\"\n\n    absolute = \"absolute\"\n    smart = \"smart\"\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.SelectionBehaviorEnum","title":"<code>SelectionBehaviorEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Describes the intended selection behavior of the suggestions in the card. Allowed values are: at-most-one, indicating that the user may choose none or at most one of the suggestions; any, indicating that the end user may choose any number of suggestions including none of them and all of them. CDS Clients that do not understand the value MUST treat the card as an error.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class SelectionBehaviorEnum(str, Enum):\n    \"\"\"\n    Describes the intended selection behavior of the suggestions in the card.\n    Allowed values are: at-most-one, indicating that the user may choose none or\n    at most one of the suggestions; any, indicating that the end user may choose\n    any number of suggestions including none of them and all of them.\n    CDS Clients that do not understand the value MUST treat the card as an error.\n    \"\"\"\n\n    at_most_one = \"at-most-one\"\n    any = \"any\"\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.SimpleCoding","title":"<code>SimpleCoding</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The Coding data type captures the concept of a code. This coding type is a standalone data type in CDS Hooks modeled after a trimmed down version of the FHIR Coding data type.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class SimpleCoding(BaseModel):\n    \"\"\"\n    The Coding data type captures the concept of a code. This coding type is a standalone data type\n    in CDS Hooks modeled after a trimmed down version of the FHIR Coding data type.\n    \"\"\"\n\n    code: str\n    system: str\n    display: Optional[str] = None\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Source","title":"<code>Source</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Grouping structure for the Source of the information displayed on this card. The source should be the primary source of guidance for the decision support Card represents.</p> <p>https://cds-hooks.org/specification/current/#source</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Source(BaseModel):\n    \"\"\"\n    Grouping structure for the Source of the information displayed on this card.\n    The source should be the primary source of guidance for the decision support Card represents.\n\n    https://cds-hooks.org/specification/current/#source\n    \"\"\"\n\n    label: str\n    url: Optional[HttpUrl] = None\n    icon: Optional[HttpUrl] = None\n    topic: Optional[SimpleCoding] = None\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Suggestion","title":"<code>Suggestion</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Allows a service to suggest a set of changes in the context of the current activity (e.g. changing the dose of a medication currently being prescribed, for the order-sign activity). If suggestions are present, selectionBehavior MUST also be provided.</p> <p>https://cds-hooks.org/specification/current/#suggestion</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Suggestion(BaseModel):\n    \"\"\"\n    Allows a service to suggest a set of changes in the context of the current activity\n    (e.g. changing the dose of a medication currently being prescribed, for the order-sign activity).\n    If suggestions are present, selectionBehavior MUST also be provided.\n\n    https://cds-hooks.org/specification/current/#suggestion\n    \"\"\"\n\n    label: str\n    uuid: Optional[str] = None\n    isRecommended: Optional[bool]\n    actions: Optional[List[Action]] = []\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdarequest.CdaRequest","title":"<code>CdaRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>class CdaRequest(BaseModel):\n    document: str\n    session_id: Optional[str] = None\n    work_type: Optional[str] = None\n    organization_id: Optional[str] = None\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Loads data from dict (xmltodict format)\n        \"\"\"\n        return cls(document=xmltodict.unparse(data))\n\n    def model_dump(self, *args, **kwargs) -&gt; Dict:\n        \"\"\"\n        Dumps document as dict with xmltodict\n        \"\"\"\n        return xmltodict.parse(self.document)\n\n    def model_dump_xml(self, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Decodes and dumps document as an xml string\n        \"\"\"\n        xml_dict = xmltodict.parse(self.document)\n        document = search_key(xml_dict, \"urn:Document\")\n        if document is None:\n            log.warning(\"Couldn't find document under namespace 'urn:Document\")\n            return \"\"\n\n        cda = base64.b64decode(document).decode(\"UTF-8\")\n\n        return cda\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdarequest.CdaRequest.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Loads data from dict (xmltodict format)</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Loads data from dict (xmltodict format)\n    \"\"\"\n    return cls(document=xmltodict.unparse(data))\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdarequest.CdaRequest.model_dump","title":"<code>model_dump(*args, **kwargs)</code>","text":"<p>Dumps document as dict with xmltodict</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; Dict:\n    \"\"\"\n    Dumps document as dict with xmltodict\n    \"\"\"\n    return xmltodict.parse(self.document)\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdarequest.CdaRequest.model_dump_xml","title":"<code>model_dump_xml(*args, **kwargs)</code>","text":"<p>Decodes and dumps document as an xml string</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>def model_dump_xml(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Decodes and dumps document as an xml string\n    \"\"\"\n    xml_dict = xmltodict.parse(self.document)\n    document = search_key(xml_dict, \"urn:Document\")\n    if document is None:\n        log.warning(\"Couldn't find document under namespace 'urn:Document\")\n        return \"\"\n\n    cda = base64.b64decode(document).decode(\"UTF-8\")\n\n    return cda\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdaresponse.CdaResponse","title":"<code>CdaResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>class CdaResponse(BaseModel):\n    document: str\n    error: Optional[str] = None\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Loads data from dict (xmltodict format)\n        \"\"\"\n        return cls(document=xmltodict.unparse(data))\n\n    def model_dump(self, *args, **kwargs) -&gt; Dict:\n        \"\"\"\n        Dumps document as dict with xmltodict\n        \"\"\"\n        return xmltodict.parse(self.document)\n\n    def model_dump_xml(self, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Decodes and dumps document as an xml string\n        \"\"\"\n        xml_dict = xmltodict.parse(self.document)\n        document = search_key(xml_dict, \"tns:Document\")\n        if document is None:\n            log.warning(\"Couldn't find document under namespace 'tns:Document\")\n            return \"\"\n\n        cda = base64.b64decode(document).decode(\"UTF-8\")\n\n        return cda\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdaresponse.CdaResponse.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Loads data from dict (xmltodict format)</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Loads data from dict (xmltodict format)\n    \"\"\"\n    return cls(document=xmltodict.unparse(data))\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdaresponse.CdaResponse.model_dump","title":"<code>model_dump(*args, **kwargs)</code>","text":"<p>Dumps document as dict with xmltodict</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; Dict:\n    \"\"\"\n    Dumps document as dict with xmltodict\n    \"\"\"\n    return xmltodict.parse(self.document)\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdaresponse.CdaResponse.model_dump_xml","title":"<code>model_dump_xml(*args, **kwargs)</code>","text":"<p>Decodes and dumps document as an xml string</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>def model_dump_xml(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Decodes and dumps document as an xml string\n    \"\"\"\n    xml_dict = xmltodict.parse(self.document)\n    document = search_key(xml_dict, \"tns:Document\")\n    if document is None:\n        log.warning(\"Couldn't find document under namespace 'tns:Document\")\n        return \"\"\n\n    cda = base64.b64decode(document).decode(\"UTF-8\")\n\n    return cda\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"community/","title":"Community","text":""},{"location":"community/#contribute","title":"Contribute","text":"<p>Contributing Guidelines</p>"},{"location":"community/contribution_guide/","title":"Contribution Guide","text":""},{"location":"community/resources/","title":"Resources","text":""},{"location":"cookbook/","title":"\ud83c\udf73 Cookbook: Hands-On Examples","text":"<p>Dive into real-world, production-ready examples to learn how to build interoperable healthcare AI apps with HealthChain.</p>"},{"location":"cookbook/#getting-started","title":"\ud83d\udea6 Getting Started","text":"<ul> <li>Working with FHIR Sandboxes Spin up and access free Epic, Medplum, and other FHIR sandboxes for safe experimentation. This is the recommended first step before doing the detailed tutorials below.</li> </ul>"},{"location":"cookbook/#how-to-guides","title":"\ud83d\udcda How-To Guides","text":"<ul> <li> <p>\ud83d\udea6 Multi-Source Patient Data Aggregation Merge patient data from multiple FHIR sources (Epic, Cerner, etc.), deduplicate conditions, prove provenance, and robustly handle cross-vendor errors. Foundation for retrieval-augmented generation (RAG) and analytics workflows.</p> </li> <li> <p>\ud83e\uddfe Automate Clinical Coding &amp; FHIR Integration Extract medical conditions from clinical documentation using AI, map to SNOMED CT codes, and sync as FHIR Condition resources to systems like Medplum\u2014enabling downstream billing, analytics, and interoperability.</p> </li> <li> <p>\ud83d\udcdd Summarize Discharge Notes with CDS Hooks Deploy a CDS Hooks-compliant service that listens for discharge events, auto-generates concise plain-language summaries, and delivers actionable clinical cards directly into the EHR workflow.</p> </li> </ul> <p>What next?</p> <p>See the source code for each recipe, experiment with the sandboxes, and adapt the patterns for your projects!</p>"},{"location":"cookbook/clinical_coding/","title":"Build a NoteReader Service with FHIR Integration","text":"<p>Modernize Epic NoteReader's legacy SOAP interface by connecting it to a modern FHIR server, without disrupting existing CDI workflows. You'll extract SNOMED CT codes from clinical notes using NLP, write structured data to Medplum for analytics, and return CDA responses to Epic.</p> <p>Epic NoteReader CDI is a legacy CDA interface for clinical documentation improvement workflows. It's great because it's already embedded in existing EHR workflows and designed for third-party NLP integrations. The downside? Its legacy SOAP design limits modern analytics in FHIR. This tutorial shows you how to bridge that gap. Get the best of both worlds! Legacy workflows keep running while you unlock advanced analytics.</p> <p>Check out the full working example here.</p>"},{"location":"cookbook/clinical_coding/#how-it-works","title":"How It Works","text":"<p>A clinical note arrives from NoteReader as CDA XML \u2192 gets parsed and processed through scispacy \u2192 entities are linked to SNOMED CT codes \u2192 converted to FHIR Condition resources \u2192 written to both Medplum (modern FHIR) and back to Epic (legacy CDA).</p>"},{"location":"cookbook/clinical_coding/#setup","title":"Setup","text":""},{"location":"cookbook/clinical_coding/#install-dependencies","title":"Install Dependencies","text":"<p>We'll use scispacy for medical entity extraction. Install the required dependencies:</p> <pre><code>pip install healthchain scispacy python-dotenv\npip install https://s3-us-west-2.amazonaws.com/ai2-s2-scispacy/releases/v0.5.4/en_core_sci_sm-0.5.4.tar.gz\n</code></pre>"},{"location":"cookbook/clinical_coding/#download-sample-data","title":"Download Sample Data","text":"<p>Download the sample CDA file <code>notereader_cda.xml</code> into a <code>data/</code> folder in your project root using <code>wget</code>:</p> <pre><code>mkdir -p data\ncd data\nwget https://github.com/dotimplement/HealthChain/raw/main/cookbook/data/notereader_cda.xml\n</code></pre>"},{"location":"cookbook/clinical_coding/#configure-medplum-credentials","title":"Configure Medplum Credentials","text":"<p>Set up a Medplum account and obtain client credentials. See the FHIR Sandbox Setup Guide for detailed instructions.</p> <p>Once you have your Medplum credentials, configure them in a <code>.env</code> file:</p> <pre><code># .env file\nMEDPLUM_BASE_URL=https://api.medplum.com/fhir/R4\nMEDPLUM_CLIENT_ID=your_client_id\nMEDPLUM_CLIENT_SECRET=your_client_secret\nMEDPLUM_TOKEN_URL=https://api.medplum.com/oauth2/token\nMEDPLUM_SCOPE=openid\n</code></pre>"},{"location":"cookbook/clinical_coding/#add-the-cda-adapter","title":"Add the CDA Adapter","text":"<p>First we'll need to convert the incoming CDA XML to FHIR. The CdaAdapter enables round-trip conversion between CDA and FHIR using the InteropEngine for seamless legacy-to-modern data integration.</p> <pre><code>from healthchain.io import CdaAdapter\nfrom healthchain.engine import create_interop\n\n# Create an interop engine with default configuration\ninterop_engine = create_interop()\ncda_adapter = CdaAdapter(engine=interop_engine)\n\n# Parse the CDA document to a Document object\ndoc = cda_adapter.parse(request)\n\n# Access list of Condition resources in problem_list accessor\ndoc.fhir.problem_list\n\n# Format the Document object back to a CDA document\nresponse = cda_adapter.format(doc)\n</code></pre> <p>What this adapter does</p> <ul> <li>Parses CDA XML documents and extracts clinical text and coded data</li> <li>Stores text data in <code>doc.text</code></li> <li>Stores CDA XML as a DocumentReference resource in <code>doc.fhir.bundle</code></li> <li>Stores extracted Condition resources in <code>doc.fhir.problem_list</code></li> </ul>"},{"location":"cookbook/clinical_coding/#initialize-the-pipeline","title":"Initialize the Pipeline","text":"<p>Next we'll build our NLP processing pipeline. We'll use a MedicalCodingPipeline, which will run your specified NLP model on extracted text data out-of-the-box. To link extracted entities (e.g., \"chronic kidney disease\", \"asthma\") to standard clinical codes (e.g. SNOMED CT, ICD-10), we'll add a custom node to handle this.</p> <p>For this demo, we'll use a simple dictionary for the SNOMED CT mapping.</p> <pre><code>from healthchain.pipeline.medicalcodingpipeline import MedicalCodingPipeline\nfrom healthchain.io import Document\nfrom spacy.tokens import Span\n\n# Build FHIR-native ML pipeline with automatic problem extraction.\npipeline = MedicalCodingPipeline.from_model_id(\"en_core_sci_sm\", source=\"spacy\")\n\n# Add custom entity linking\n@pipeline.add_node(position=\"after\", reference=\"SpacyNLP\")\ndef link_entities(doc: Document) -&gt; Document:\n    \"\"\"\n    Add CUI codes to medical entities for problem extraction.\n    \"\"\"\n    if not Span.has_extension(\"cui\"):\n        Span.set_extension(\"cui\", default=None)\n\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    # Dummy medical concept mapping to SNOMED CT codes\n    medical_concepts = {\n        \"pneumonia\": \"233604007\",\n        \"type 2 diabetes mellitus\": \"44054006\",\n        \"congestive heart failure\": \"42343007\",\n        \"chronic kidney disease\": \"431855005\",\n        \"hypertension\": \"38341003\",\n        # Add more mappings as needed\n    }\n\n    for ent in spacy_doc.ents:\n        if ent.text.lower() in medical_concepts:\n            # Store as custom spacy attribute 'cui'\n            ent._.cui = medical_concepts[ent.text.lower()]\n\n    return doc\n</code></pre> <p>Note</p> <p>MedicalCodingPipeline automatically:</p> <ul> <li>Extracts medical entities using the <code>scispacy</code> model</li> <li>Converts NLP entities to FHIR <code>problem-list-item</code> Condition resources</li> </ul> <p>This is equivalent to constructing a pipeline with the following components manually:</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import SpacyNLP, FHIRProblemListExtractor\nfrom healthchain.io import Document\n\npipeline = Pipeline[Document]()\n\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_sci_sm\"))\npipeline.add_node(FHIRProblemListExtractor())\n</code></pre>"},{"location":"cookbook/clinical_coding/#set-up-fhir-gateway","title":"Set up FHIR Gateway","text":"<p>FHIR Gateways enable your app to connect to one or more external FHIR servers (like EHRs, registries, billing systems).</p> <p>Use <code>.add_source</code> to register a FHIR endpoint you want to connect to with its connection string; the gateway will automatically manage the authentication and routing.</p> <pre><code>from healthchain.gateway import FHIRGateway\nfrom healthchain.gateway.clients.fhir.base import FHIRAuthConfig\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Load configuration from environment variables\nconfig = FHIRAuthConfig.from_env(\"MEDPLUM\")\nMEDPLUM_URL = config.to_connection_string()\n\n# Initialize FHIR gateway and register external systems\nfhir_gateway = FHIRGateway()\nfhir_gateway.add_source(\"medplum\", MEDPLUM_URL)\n\n# You can add multiple FHIR sources:\n# fhir_gateway.add_source(\"ehr\", \"fhir://epic.example.com/fhir/R4/\")\n# fhir_gateway.add_source(\"registry\", \"fhir://registry.example.com/fhir/R4/\")\n</code></pre>"},{"location":"cookbook/clinical_coding/#set-up-the-notereader-service","title":"Set Up the NoteReader Service","text":"<p>Now let's set up the handler for NoteReaderService method <code>ProcessDocument</code>, which will be called by Epic NoteReader when it is triggered in the CDI workflow. This is where we will combine all our components: adapter, pipeline, and writing to our configured FHIR endpoint:</p> <pre><code>from healthchain.gateway import NoteReaderService\n\n# Create the NoteReader service\nnote_service = NoteReaderService()\n\n@note_service.method(\"ProcessDocument\")\ndef ai_coding_workflow(request: CdaRequest):\n    # Parse CDA document from legacy system\n    doc = cda_adapter.parse(request)\n\n    # Process through ML pipeline to extract medical entities\n    doc = pipeline(doc)\n\n    # Access the extracted FHIR resources\n    for condition in doc.fhir.problem_list:\n        # Add metadata for audit and provenance tracking\n        condition = add_provenance_metadata(\n            condition, source=\"epic-notereader\", tag_code=\"cdi\"\n        )\n        # Send to external FHIR server via gateway\n        fhir_gateway.create(condition, source=\"billing\")\n\n    # Return processed CDA response to the legacy system\n    cda_response = cda_adapter.format(doc)\n\n    return cda_response\n</code></pre>"},{"location":"cookbook/clinical_coding/#build-the-service","title":"Build the Service","text":"<p>Time to put it all together! Using HealthChainAPI, we can create a service with both the FHIR and NoteReader endpoints:</p> <pre><code>from healthchain.gateway import HealthChainAPI\n\n# Register services with the API gateway\napp = HealthChainAPI(title=\"Healthcare Integration Gateway\")\n\napp.register_gateway(fhir_gateway, path=\"/fhir\")\napp.register_service(note_service, path=\"/notereader\")\n</code></pre>"},{"location":"cookbook/clinical_coding/#test-with-sample-documents","title":"Test with Sample Documents","text":"<p>HealthChain provides a sandbox client utility which simulates the NoteReader workflow end-to-end. It loads your sample CDA document, sends it to your service via the configured endpoint, and saves the request/response exchange in an <code>output/</code> directory. This lets you test the complete integration locally before connecting to Epic.</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create sandbox client for SOAP/CDA testing\nclient = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/notereader/ProcessDocument\",\n    workflow=\"sign-note-inpatient\",\n    protocol=\"soap\"\n)\n\n# Load sample CDA document\nclient.load_from_path(\"./data/notereader_cda.xml\")\n</code></pre>"},{"location":"cookbook/clinical_coding/#run-the-complete-example","title":"Run the Complete Example","text":"<p>Now for the moment of truth! Start your service and run the sandbox to see the complete workflow in action.</p> <pre><code>import uvicorn\nimport threading\n\n# Start the API server in a separate thread\ndef start_api():\n    uvicorn.run(app, port=8000)\n\napi_thread = threading.Thread(target=start_api, daemon=True)\napi_thread.start()\n\n# Send requests and save responses with sandbox client\nclient.send_requests()\nclient.save_results(\"./output/\")\n</code></pre> <p>What happens when you run this</p> <ol> <li> <p>Service starts \u2013 <code>HealthChainAPI</code> launches two endpoints:</p> <ul> <li><code>/notereader/ProcessDocument</code>: SOAP endpoint for processing CDA documents</li> <li><code>/fhir</code>: REST API endpoint for FHIR operations (optional, for testing)</li> </ul> </li> <li> <p>Sandbox runs \u2013 Your test CDA document is:</p> <ul> <li>Wrapped in a SOAP envelope</li> <li>Sent to <code>/notereader/ProcessDocument</code></li> </ul> </li> <li> <p>Artifacts \u2013 Sandbox saves request/response XML files to the <code>output/</code> directory for inspection</p> </li> </ol>"},{"location":"cookbook/clinical_coding/#expected-output","title":"Expected Output","text":"<p>Our sample data contains the following note:</p> Test Note <pre><code>This 37 year old gentleman presented with a fever, cough and sore throat. He was diagnosed with a community acquired pneumonia, and started on co-amoxiclav. Unfortunately he developed anaphylaxis and was treated with resuscitation fluids and adrenaline but not hydrocortisone. He had refractory anaphylaxis and so was transferred to intensive care for intubation and ventilation. He then developed a \"ventilation associated pneumonia\", requiring meropenem. Once treated for his CAP and VAP he was stepped down to the ward. He was treated with haloperidol for a presumed 'delirium'. He improved medically, but deteriorated in terms of his psychiatric health, with depression, anxiety and paranoid schizophrenia. He was self-medicating with his own supply of Librium.\n\nHe has a past medical history of asthma and COPD but not cirrhosis.\n\nHe regularly takes penicillin, Ventolin and tiotropium inhalers, as well as an ACE inhibitor, beta blocker and calcium channel blocker.\n\nHe is allergic to all opiates, including morphine.\n\nHe has previously had a cholecystectomy and appendicectomy.\n\nPlan:\n- Discharge planning\n\nI reviewed the Resident's note and agree with the documented findings and plan of care.  The reason the patient is critically ill and the nature of the treatment and management provided by the teaching physician (me) to manage the critically ill patient is: as aove\n\nThe patient was critically ill during the time that I saw the patient. The Critical Care Time excluding procedures was 6 minutes.\n</code></pre> <p>So you should expect to see the following conditions extracted, which we have linked to SNOMED CT codes in our processing pipeline:</p> Condition SNOMED CT Code pneumonia 233604007 anaphylaxis 39579001 delirium 2776000 depression 35489007 asthma 195967001 COPD 13645005"},{"location":"cookbook/clinical_coding/#medplum-console","title":"Medplum Console","text":"<p>After running the example, go to Medplum to see your extracted conditions in action:</p> <ol> <li>Log in to your Medplum account</li> <li>Search and navigate to Condition resources in the search bar under the Medplum logo. You should see a list of all the Condition data you have in Medplum's FHIR server:</li> </ol> <p></p> <p>You should be able to interact with the resources you've just created in the Medplum web UI. Click on JSON to see the original data:</p> <p></p> <p>Example output: Condition FHIR resource</p> <pre><code>{\n  \"resourceType\": \"Condition\",\n  \"id\": \"e8105940-2714-4274-b693-03a09a76eeb8\",\n  \"meta\": {\n    \"lastUpdated\": \"2025-10-13T16:36:40.435Z\",\n    \"source\": \"urn:healthchain:source:epic-notereader\",\n    \"tag\": [\n      {\n        \"system\": \"https://dotimplement.github.io/HealthChain/fhir/tags\",\n        \"code\": \"cdi\",\n        \"display\": \"cdi\"\n      }\n    ],\n    \"versionId\": \"fd21c838-1fe6-45c9-84d7-00184338b8ee\",\n    \"author\": {\n      \"reference\": \"ClientApplication/01977d2b-244e-75ea-af98-0c35157e1a9b\",\n      \"display\": \"HealthChain Test Default Client\"\n    },\n    \"project\": \"01977d2b-243b-7476-b9eb-81a5298febbc\",\n    \"compartment\": [\n      {\n        \"reference\": \"Project/01977d2b-243b-7476-b9eb-81a5298febbc\"\n      }\n    ]\n  },\n  \"clinicalStatus\": {\n    \"coding\": [\n      {\n        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n        \"code\": \"active\",\n        \"display\": \"Active\"\n      }\n    ]\n  },\n  \"category\": [\n    {\n      \"coding\": [\n        {\n          \"system\": \"http://terminology.hl7.org/CodeSystem/condition-category\",\n          \"code\": \"problem-list-item\",\n          \"display\": \"Problem List Item\"\n        }\n      ]\n    }\n  ],\n  \"code\": {\n    \"coding\": [\n      {\n        \"system\": \"http://snomed.info/sct\",\n        \"code\": \"195967001\",\n        \"display\": \"asthma\"\n      }\n    ]\n  },\n  \"subject\": {\n    \"reference\": \"Patient/123\"\n  }\n}\n</code></pre>"},{"location":"cookbook/clinical_coding/#output-directory","title":"<code>/output</code> Directory","text":"<p>Check that the extracted conditions also exist in the CDA response sent back to our simulated Epic backend:</p> response.xml <p><pre><code>&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n    ...\n    &lt;component&gt;\n        &lt;structuredBody&gt;\n            ...\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"233604007\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Pneumonia\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"39579001\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Anaphylaxis\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"2776000\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Delirium\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"35489007\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Depressive disorder\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"195967001\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Asthma\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"13645005\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Chronic obstructive lung disease\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            ...\n        &lt;/structuredBody&gt;\n    &lt;/component&gt;\n    ...\n&lt;/ClinicalDocument&gt;\n</code></pre> Lines with only problem/condition <code>code</code> elements are shown within their parent structure; <code>...</code> is used to indicate omitted sections for clarity and brevity.</p> <p>Your extracted diagnoses are now available as structured FHIR resources, ready for analytics, reporting, or downstream processing, while Epic continues receiving the original CDA responses!</p>"},{"location":"cookbook/clinical_coding/#what-youve-built","title":"What You've Built","text":"<p>A clinical coding service that bridges legacy CDA systems with modern FHIR infrastructure:</p> <ul> <li>Legacy system integration - Processes CDA documents from Epic NoteReader workflows</li> <li>AI-powered extraction - Uses NLP to extract medical entities and map to SNOMED CT codes</li> <li>FHIR interoperability - Converts extracted conditions to FHIR resources and syncs with external servers</li> <li>Audit trail - Tracks provenance metadata for compliance and debugging</li> <li>Dual interface - Maintains CDA compatibility while enabling modern FHIR operations</li> </ul> <p>Use Cases</p> <ul> <li> <p>Clinical Documentation Improvement (CDI):   Automatically extract billable conditions from clinical notes and populate problem lists in real-time during clinician workflows.</p> </li> <li> <p>Terminology Harmonization:   Bridge legacy ICD-9 systems with modern SNOMED CT standards by processing historical CDA documents and creating FHIR-compliant problem lists.</p> </li> <li> <p>Research Data Extraction:   Extract structured condition data from unstructured clinical notes for cohort building and retrospective studies.</p> </li> </ul> <p>Next Steps</p> <ul> <li>Enhance entity linking: Replace the dictionary lookup with terminology servers or entity linking models for comprehensive medical terminology coverage.</li> <li>Add validation: Implement FHIR resource validation before sending to external servers.</li> <li>Expand to other workflows: Adapt the pattern for lab results, medications, or radiology reports.</li> <li>Build on it: Use the extracted conditions in the Data Aggregation example to combine with other FHIR sources.</li> </ul>"},{"location":"cookbook/discharge_summarizer/","title":"Build a CDS Hooks Service for Discharge Summarization","text":"<p>This example shows you how to build a CDS service that integrates with EHR systems. We'll automatically summarize discharge notes and return actionable recommendations using the CDS Hooks standard.</p> <p>Check out the full working example here!</p> <p> Illustrative Architecture - actual implementation may vary.</p>"},{"location":"cookbook/discharge_summarizer/#setup","title":"Setup","text":""},{"location":"cookbook/discharge_summarizer/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install healthchain python-dotenv\n</code></pre> <p>This example uses a Hugging Face model for the summarization task, so make sure you have a Hugging Face API token and set it as the <code>HUGGINGFACEHUB_API_TOKEN</code> environment variable.</p> <p>If you are using a chat model, make sure you have the necessary <code>langchain</code> packages installed.</p> <pre><code>pip install langchain langchain-huggingface\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#download-sample-data","title":"Download Sample Data","text":"<p>Download the sample data <code>discharge_notes.csv</code> into a <code>data/</code> folder in your project root using <code>wget</code>:</p> <pre><code>mkdir -p data\ncd data\nwget https://github.com/dotimplement/HealthChain/raw/main/cookbook/data/discharge_notes.csv\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#initialize-the-pipeline","title":"Initialize the pipeline","text":"<p>First, we'll create a summarization pipeline with domain-specific prompting for discharge workflows. You can choose between:</p> <ul> <li>Transformer models fine-tuned for clinical summarization (like <code>google/pegasus-xsum</code>)</li> <li>Large Language Models with custom clinical prompting (like <code>zephyr-7b-beta</code>)</li> </ul> <p>For LLM approaches, we'll use LangChain for better prompting.</p> Non-chat modelChat model <pre><code>from healthchain.pipeline import SummarizationPipeline\n\npipeline = SummarizationPipeline.from_model_id(\n  \"google/pegasus-xsum\", source=\"huggingface\", task=\"summarization\"\n  )\n</code></pre> <pre><code>from healthchain.pipeline import SummarizationPipeline\n\nfrom langchain_huggingface.llms import HuggingFaceEndpoint\nfrom langchain_huggingface import ChatHuggingFace\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\n\nhf = HuggingFaceEndpoint(\n    repo_id=\"deepseek-ai/DeepSeek-R1-0528\",\n    task=\"text-generation\",\n    max_new_tokens=512,\n    do_sample=False,\n    repetition_penalty=1.03,\n)\n\nmodel = ChatHuggingFace(llm=hf)\n\ntemplate = \"\"\"\nYou are a discharge planning assistant for hospital operations.\nProvide a concise, objective summary focusing on actionable items\nfor care coordination, including appointments, medications, and\nfollow-up instructions. Format as bullet points.\\n'''{text}'''\n\"\"\"\nprompt = PromptTemplate.from_template(template)\n\nchain = prompt | model | StrOutputParser()\n\npipeline = SummarizationPipeline.load(chain, source=\"langchain\")\n</code></pre> <p>The <code>SummarizationPipeline</code> automatically:</p> <ul> <li>Parses FHIR resources from CDS Hooks requests</li> <li>Extracts clinical text from discharge documents</li> <li>Formats outputs as CDS cards</li> </ul>"},{"location":"cookbook/discharge_summarizer/#add-the-cds-fhir-adapter","title":"Add the CDS FHIR Adapter","text":"<p>The CdsFhirAdapter converts between CDS Hooks requests and HealthChain's Document format. This makes it easy to work with FHIR data in CDS workflows.</p> <pre><code>from healthchain.io import CdsFhirAdapter\n\ncds_adapter = CdsFhirAdapter()\n\n# Parse the CDS request to a Document object\ncds_adapter.parse(request)\n\n# Format the Document object back to a CDS response\ncds_adapter.format(doc)\n</code></pre> <p>What this adapter does</p> <ul> <li>Parses FHIR resources from CDS Hooks requests</li> <li>Extracts text from DocumentReference resources</li> <li>Formats responses as CDS cards according to the CDS Hooks specification</li> </ul>"},{"location":"cookbook/discharge_summarizer/#set-up-the-cds-hook-handler","title":"Set Up the CDS Hook Handler","text":"<p>Create the CDS Hooks handler to receive discharge note requests, run the AI summarization pipeline, and return results as CDS cards.</p> <pre><code>from healthchain.gateway import CDSHooksService\nfrom healthchain.models import CDSRequest, CDSResponse\n\n# Initialize the CDS service\ncds_service = CDSHooksService()\n\n# Define the CDS service function\n@cds_service.hook(\"encounter-discharge\", id=\"discharge-summary\")\ndef handle_discharge_summary(request: CDSRequest) -&gt; CDSResponse:\n    \"\"\"Process discharge summaries with AI\"\"\"\n    # Parse CDS request to internal Document format\n    doc = cds_adapter.parse(request)\n\n    # Process through AI pipeline\n    processed_doc = pipeline(doc)\n\n    # Format response with CDS cards\n    response = cds_adapter.format(processed_doc)\n    return response\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#build-the-service","title":"Build the Service","text":"<p>Register the CDS service with HealthChainAPI to create REST endpoints:</p> <pre><code>from healthchain.gateway import HealthChainAPI\n\napp = HealthChainAPI(title=\"Discharge Summary CDS Service\")\napp.register_service(cds_service)\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#test-with-sample-data","title":"Test with Sample Data","text":"<p>HealthChain provides a sandbox client utility which simulates the CDS hooks workflow end-to-end. It loads your sample free text data and formats it into CDS requests, sends it to your service, and saves the request/response exchange in an <code>output/</code> directory. This lets you test the complete integration locally and inspect the inputs and outputs before connecting to a real EHR instance.</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create sandbox client for testing\nclient = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/cds/cds-services/discharge-summarizer\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load discharge notes from CSV and generate FHIR data\nclient.load_free_text(\n    csv_path=\"data/discharge_notes.csv\",\n    column_name=\"text\",\n    workflow=\"encounter-discharge\"\n)\n</code></pre> <p>Learn More About Test Data Generation</p> <p>Read more about the test FHIR data generator for CDS hooks here</p>"},{"location":"cookbook/discharge_summarizer/#run-the-complete-example","title":"Run the Complete Example","text":"<p>Put it all together and run both the service and sandbox client:</p> <pre><code>import uvicorn\nimport threading\n\n# Start the API server in a separate thread\ndef start_api():\n    uvicorn.run(app, port=8000)\n\napi_thread = threading.Thread(target=start_api, daemon=True)\napi_thread.start()\n\n# Send requests and save responses with sandbox client\nclient.send_requests()\nclient.save_results(\"./output/\")\n</code></pre> <p>Service Endpoints</p> <p>Once running, your service will be available at:</p> <ul> <li>Service discovery: <code>http://localhost:8000/cds-services</code></li> <li>Discharge summary endpoint: <code>http://localhost:8000/cds-services/discharge-summary</code></li> </ul> Example CDS Response <pre><code>{\n  \"cards\": [\n    {\n      \"summary\": \"Discharge Transportation\",\n      \"indicator\": \"info\",\n      \"source\": {\n        \"label\": \"HealthChain Discharge Assistant\"\n      },\n      \"detail\": \"\u2022 Transport arranged for 11:00 HRs\\n\u2022 Requires bariatric ambulance and 2 crew members\\n\u2022 Confirmation number: TR-2024-001\"\n    },\n    {\n      \"summary\": \"Medication Management\",\n      \"indicator\": \"warning\",\n      \"source\": {\n        \"label\": \"HealthChain Discharge Assistant\"\n      },\n      \"detail\": \"\u2022 Discharge medications: Apixaban 5mg, Baclofen 20mg MR\\n\u2022 New anticoagulation card prepared\\n\u2022 Collection by daughter scheduled\"\n    }\n  ]\n}\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#what-youve-built","title":"What You've Built","text":"<p>A CDS Hooks service for discharge workflows that integrates seamlessly with EHR systems:</p> <ul> <li>Standards-compliant - Implements the CDS Hooks specification for EHR interoperability</li> <li>AI-powered summarization - Processes discharge notes using transformer models or LLMs</li> <li>Actionable recommendations - Returns structured cards with discharge planning tasks</li> <li>Flexible pipeline - Supports both fine-tuned models and prompt-engineered LLMs</li> <li>Auto-discovery - Provides service discovery endpoint for EHR registration</li> </ul> <p>Use Cases</p> <ul> <li> <p>Discharge Planning Coordination   Automatically extract and highlight critical discharge tasks (appointments, medications, equipment needs) to reduce care coordination errors and readmissions.</p> </li> <li> <p>Clinical Decision Support   Provide real-time recommendations during discharge workflows, surfacing potential issues like medication interactions or missing follow-up appointments.</p> </li> <li> <p>Documentation Efficiency   Generate concise discharge summaries from lengthy clinical notes, saving clinicians time while ensuring all critical information is captured.</p> </li> </ul> <p>Next Steps</p> <ul> <li>Enhance prompts: Tune your clinical prompts to extract specific discharge criteria or care plan elements.</li> <li>Add validation: Implement checks for required discharge elements (medications, follow-ups, equipment).</li> <li>Multi-card support: Expand to generate separate cards for different discharge aspects (medication reconciliation, transportation, follow-up scheduling).</li> <li>Integrate with workflows: Deploy to Epic App Orchard or Cerner Code Console for production EHR integration.</li> </ul>"},{"location":"cookbook/ml_model_deployment/","title":"Deploy ML Models as Healthcare APIs","text":"<p>This example is coming soon! \ud83d\udea7</p>"},{"location":"cookbook/ml_model_deployment/#overview","title":"Overview","text":"<p>This tutorial will demonstrate how to deploy any trained ML model as a production-ready healthcare API with FHIR input/output, multi-EHR connectivity, and comprehensive monitoring.</p>"},{"location":"cookbook/ml_model_deployment/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Model serving architecture - Deploy Hugging Face, scikit-learn, PyTorch, and custom models</li> <li>FHIR-native endpoints - Serve predictions with structured healthcare data formats</li> <li>Multi-EHR integration - Connect your model to live FHIR servers for real-time inference</li> <li>Healthcare data validation - Ensure type-safe input/output with Pydantic models</li> <li>Production monitoring - Track model performance, data drift, and API health</li> <li>Scalable deployment - Configure auto-scaling and load balancing for healthcare workloads</li> </ul>"},{"location":"cookbook/ml_model_deployment/#architecture","title":"Architecture","text":"<p>The example will showcase:</p> <ol> <li>Model Packaging - Wrap any ML model with HealthChain's deployment framework</li> <li>FHIR Endpoint Creation - Automatically generate OpenAPI-compliant healthcare APIs</li> <li>Real-time Inference - Process FHIR resources and return structured predictions</li> <li>Multi-source Integration - Connect to Epic, Cerner, and other FHIR systems</li> <li>Performance Monitoring - Track latency, throughput, and prediction quality</li> <li>Security &amp; Compliance - Implement OAuth2, audit logging, and data governance</li> </ol>"},{"location":"cookbook/ml_model_deployment/#use-cases","title":"Use Cases","text":"<p>Perfect for: - Clinical Decision Support - Deploy diagnostic or prognostic models in EHR workflows - Population Health - Serve risk stratification models for large patient cohorts - Research Platforms - Make trained models available to clinical researchers - AI-powered Applications - Build healthcare apps with ML-driven features</p>"},{"location":"cookbook/ml_model_deployment/#example-models","title":"Example Models","text":"<p>We'll show deployment patterns for: - Clinical NLP models - Named entity recognition, clinical coding, text classification - Diagnostic models - Medical imaging analysis, lab result interpretation - Risk prediction models - Readmission risk, mortality prediction, drug interactions - Recommendation systems - Treatment recommendations, medication optimization</p>"},{"location":"cookbook/ml_model_deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>A trained ML model (any framework supported)</li> <li>Understanding of FHIR resources and healthcare data standards</li> <li>Python environment with HealthChain installed</li> <li>Basic knowledge of API deployment concepts</li> </ul>"},{"location":"cookbook/ml_model_deployment/#coming-soon","title":"Coming Soon","text":"<p>We're building comprehensive examples covering multiple model types and deployment scenarios!</p> <p>In the meantime, explore our Gateway documentation to understand the deployment infrastructure.</p> <p>Want to be notified when this example is ready? Join our Discord community for updates!</p>"},{"location":"cookbook/multi_ehr_aggregation/","title":"Multi-Source Patient Data Aggregation","text":"<p>This example shows you how to aggregate patient data from multiple FHIR sources and track data provenance: essential for building AI applications that train on diverse data, query multiple EHR vendors in RAG systems, or construct unified patient timelines from fragmented health records.</p> <p>Check out the full working example here!</p> <p> Illustrative Architecture - actual implementation may vary.</p>"},{"location":"cookbook/multi_ehr_aggregation/#setup","title":"Setup","text":"<pre><code>pip install healthchain python-dotenv\n</code></pre> <p>We'll use Epic's public FHIR sandbox. If you haven't set up Epic sandbox access yet, see the FHIR Sandbox Setup Guide for detailed instructions.</p> <p>Once you have your Epic credentials, configure them in a <code>.env</code> file:</p> <pre><code># .env file\nEPIC_BASE_URL=https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4\nEPIC_CLIENT_ID=your_non_production_client_id\nEPIC_CLIENT_SECRET_PATH=path/to/privatekey.pem\nEPIC_TOKEN_URL=https://fhir.epic.com/interconnect-fhir-oauth/oauth2/token\nEPIC_USE_JWT_ASSERTION=true\n</code></pre> <p>Load your Epic credentials from the <code>.env</code> file and create a connection string compatible with the FHIR gateway:</p> <pre><code>from healthchain.gateway.clients import FHIRAuthConfig\n\nconfig = FHIRAuthConfig.from_env(\"EPIC\")\nEPIC_URL = config.to_connection_string()\n</code></pre>"},{"location":"cookbook/multi_ehr_aggregation/#set-up-fhir-gateway","title":"Set Up FHIR Gateway","text":"<p>FHIR Gateways connect to external FHIR servers and handles authentication, connection pooling, and token refresh automatically. Add the Epic sandbox as a source:</p> <pre><code>from healthchain.gateway import FHIRGateway\n\ngateway = FHIRGateway()\ngateway.add_source(\"epic\", EPIC_URL)\n\n# Optional: Add Cerner's public sandbox (no auth required)\nCERNER_URL = \"fhir://fhir-open.cerner.com/r4/ec2458f2-1e24-41c8-b71b-0e701af7583d\"\ngateway.add_source(\"cerner\", CERNER_URL)\n\n# You can add more sources:\n# gateway.add_source(\"other source\", fhir://url)\n</code></pre> <p>Note</p> <p>Cerner's public sandbox patient cohort differs from Epic's. For demo/testing with sandboxes, expect incomplete aggregation if patient cohorts don't overlap - this is normal for the public test data.</p> <p>In production, you must perform your own patient identity matching (MPI/crosswalk) before aggregation.</p>"},{"location":"cookbook/multi_ehr_aggregation/#create-aggregation-handler","title":"Create Aggregation Handler","text":"<p>Define an aggregation handler that queries multiple FHIR sources for Condition resources.</p> <pre><code>from healthchain.fhir import merge_bundles\n\n@gateway.aggregate(Condition)\ndef get_unified_patient(patient_id: str, sources: List[str]) -&gt; Bundle:\n    \"\"\"Aggregate conditions from multiple FHIR sources with provenance tracking.\"\"\"\n    bundles = []\n    for source in sources:\n        try:\n            bundle = gateway.search(\n                Condition,\n                {\"patient\": patient_id},\n                source,\n                add_provenance=True,  # Track which EHR the data came from\n                provenance_tag=\"aggregated\",\n            )\n            bundles.append(bundle)\n        except Exception as e:\n            print(f\"Error from {source}: {e}\")\n            # Continue with partial data rather than fail completely\n\n    # Combine conditions across sources\n    merged_bundle = merge_bundles(bundles, deduplicate=True)\n    return merged_bundle\n</code></pre> <p>What this handler does</p> <ul> <li>Queries each configured FHIR source for patient conditions</li> <li>Adds Meta tags to track data provenance (which source each condition came from, preserves existing metadata)</li> <li>Handles errors gracefully \u2013 partial data is better than no data</li> <li>Deduplicates identical conditions across sources</li> </ul> Example FHIR Metadata <pre><code>{\n  \"resourceType\": \"Condition\",\n  \"id\": ...,\n  \"meta\": {\n    \"lastUpdated\": \"2025-10-10T15:23:50.167941Z\",  // Updated timestamp\n    \"source\": \"urn:healthchain:source:epic\",  // Adds source\n    \"tag\": [\n      {\n        \"system\": \"https://dotimplement.github.io/HealthChain/fhir/tags\",\n        \"code\": \"aggregated\",\n        \"display\": \"Aggregated\"\n      }  // Appends a custom HealthChain tag\n    ]\n  }\n  ...\n}\n</code></pre>"},{"location":"cookbook/multi_ehr_aggregation/#build-the-service","title":"Build the Service","text":"<p>Register the gateway with HealthChainAPI to create REST endpoints.</p> <pre><code>import uvicorn\nfrom healthchain.gateway import HealthChainAPI\n\napp = HealthChainAPI()\napp.register_gateway(gateway, path=\"/fhir\")\n\nuvicorn.run(app)\n</code></pre> <p>FHIR Endpoints Provided by the Service</p> <ul> <li><code>/fhir/*</code> - Standard FHIR operations (<code>read</code>, <code>search</code>, <code>create</code>, <code>update</code>)</li> <li><code>/fhir/metadata</code> - CapabilityStatement describing supported resources and operations</li> <li><code>/fhir/status</code> - Operational status and metadata for gateway</li> </ul>"},{"location":"cookbook/multi_ehr_aggregation/#add-processing-pipeline-optional","title":"Add Processing Pipeline (Optional)","text":"<p>For additional processing like terminology mapping or quality checks, create a Document Pipeline.</p> <p>Document pipelines are optimized for text and structured data processing, such as FHIR resources. When you initialize a Document with FHIR Bundle data, it automatically extracts and separates metadata resources from the clinical resources for easier inspection and error handling:</p> <pre><code># Initialize Document with a Bundle\ndoc = Document(data=merged_bundle)\n\n# OperationOutcomes are automatically extracted and available\ndoc.fhir.operation_outcomes  # List of OperationOutcome resources\n\n# Clinical resources remain in the bundle\ndoc.fhir.bundle              # Bundle with clinical resources\ndoc.fhir.problem_list        # List of Condition resources\ndoc.fhir.medication_list     # List of MedicationStatement resources\n</code></pre> <p>Add processing nodes using decorators:</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io.containers import Document\n\npipeline = Pipeline[Document]()\n\n@pipeline.add_node\ndef deduplicate(doc: Document) -&gt; Document:\n  ...\n\n@pipeline.add_node\ndef add_annotation(doc: Document) -&gt; Document:\n  ...\n\n# Apply the pipeline\ndoc = Document(data=merged_bundle)\ndoc = pipeline(doc)\n</code></pre> <p>Common Pipeline Uses</p> <ul> <li>Terminology mapping (ICD-10 \u2194 SNOMED CT)</li> <li>Data enrichment (risk scores, clinical decision support)</li> <li>Quality checks (validate completeness, flag inconsistencies)</li> <li>Consent filtering (apply patient consent rules)</li> </ul>"},{"location":"cookbook/multi_ehr_aggregation/#test-the-service","title":"Test the Service","text":"<p>To test aggregation, request <code>/fhir/aggregate/Condition/{patientId}</code> with the <code>sources</code> parameter (e.g., <code>epic,cerner</code>).</p> <p>Example uses Epic patient <code>eIXesllypH3M9tAA5WdJftQ3</code>; see Epic sandbox for more test patients.</p> cURLPython <pre><code>curl -X 'GET' \\\n  'http://127.0.0.1:8888/fhir/aggregate/Condition?id=eIXesllypH3M9tAA5WdJftQ3&amp;sources=epic&amp;sources=cerner' \\\n  -H 'accept: application/fhir+json'\n</code></pre> <pre><code>  import requests\n\n  url = \"http://127.0.0.1:8888/fhir/aggregate/Condition\"\n  params = {\n      \"id\": \"eIXesllypH3M9tAA5WdJftQ3\",\n      \"sources\": [\"epic\", \"cerner\"]\n  }\n  headers = {\n      \"accept\": \"application/fhir+json\"\n  }\n  response = requests.get(url, headers=headers, params=params)\n  print(response.json)\n</code></pre>"},{"location":"cookbook/multi_ehr_aggregation/#expected-outputs","title":"Expected Outputs","text":"<p>Example output when querying Linda Ross (Epic patient <code>eIXesllypH3M9tAA5WdJftQ3</code>):</p> <pre><code>\u2713 Patient: Ross, Linda Jane\n\u2713 Conditions retrieved: 2\n\nSample conditions:\n  \u2022 Moderate persistent asthma\n    Codes: ICD10-CM:J45.40, SNOMED:427295004, ICD9:493.90\n    Source: urn:healthchain:source:epic\n    Severity: Medium\n    Onset: 1999-03-08\n\n  \u2022 Bronchitis with asthma, acute\n    Codes: ICD10-CM:J20.9/J45.909, SNOMED:405944004, ICD9:466.0\n    Source: urn:healthchain:source:epic\n    Severity: High\n    Onset: 2019-05-24\n</code></pre> Aggregated Result: With provenance tags and pipeline processing <p>Sample Bundle with deduplicated Conditions aggregated from Epic and Cerner. Each includes source details (<code>meta.source</code>, <code>meta.tag</code>) and a pipeline-added <code>note</code>.</p> <pre><code>{\n  \"resourceType\": \"Bundle\",\n  \"type\": \"collection\",\n  \"entry\": [\n    {\n      \"resource\": {\n        \"resourceType\": \"Condition\",\n        \"id\": \"eOCME6XUbCLYmFlVf2l1G0w3\",\n        \"meta\": {\n          \"lastUpdated\": \"2025-10-10T15:23:50.167941Z\",  // Updated by HealthChain Gateway\n          \"source\": \"urn:healthchain:source:epic\",       // Added by HealthChain Gateway\n          \"tag\": [{\n            \"system\": \"https://dotimplement.github.io/HealthChain/fhir/tags\",\n            \"code\": \"aggregated\",\n            \"display\": \"Aggregated\"\n          }]  // Added by HealthChain Gateway\n        },\n        \"clinicalStatus\": { \"text\": \"Active\" },\n        \"severity\": { \"text\": \"Medium\" },\n        \"code\": {\n          \"coding\": [\n            {\n              \"system\": \"http://hl7.org/fhir/sid/icd-10-cm\",\n              \"code\": \"J45.40\",\n              \"display\": \"Moderate persistent asthma, uncomplicated\"\n            },\n            {\n              \"system\": \"http://snomed.info/sct\",\n              \"code\": \"427295004\",\n              \"display\": \"Moderate Persistent Asthma\"\n            },\n            {\n              \"system\": \"http://hl7.org/fhir/sid/icd-9-cm\",\n              \"code\": \"493.90\"\n            }\n          ],\n          \"text\": \"Moderate persistent asthma\"\n        },\n        \"subject\": {\n          \"reference\": \"Patient/eIXesllypH3M9tAA5WdJftQ3\",\n          \"display\": \"Ross, Linda Jane\"\n        },\n        \"onsetDateTime\": \"1999-03-08\",\n        \"note\": [{\n          \"text\": \"This resource has been processed by healthchain pipeline\"\n        }]  // Added by HealthChain Pipeline\n      }\n    },\n    {\n      \"resource\": {\n        \"resourceType\": \"Condition\",\n        \"id\": \"etZVq9vWdHQ4q0Y6INaFhig3\",\n        \"meta\": {\n          \"lastUpdated\": \"2025-10-10T15:23:50.168175Z\", // Updated by HealthChain Gateway\n          \"source\": \"urn:healthchain:source:epic\",      // Added by HealthChain Gateway\n          \"tag\": [{\n            \"system\": \"https://dotimplement.github.io/HealthChain/fhir/tags\",\n            \"code\": \"aggregated\"\n          }]  // Added by HealthChain Gateway\n        },\n        \"severity\": { \"text\": \"High\" },\n        \"code\": {\n          \"coding\": [\n            {\n              \"system\": \"http://hl7.org/fhir/sid/icd-10-cm\",\n              \"code\": \"J20.9\",\n              \"display\": \"Acute bronchitis, unspecified\"\n            },\n            {\n              \"system\": \"http://snomed.info/sct\",\n              \"code\": \"405944004\",\n              \"display\": \"Asthmatic Bronchitis\"\n            }\n          ],\n          \"text\": \"Bronchitis with asthma, acute\"\n        },\n        \"onsetDateTime\": \"2019-05-24\",\n        \"note\": [{\n          \"text\": \"This resource has been processed by healthchain pipeline\"\n        }]  // Added by HealthChain Pipeline\n      }\n    }\n  ]\n}\n</code></pre> OperationOutcome: Authorization warnings <p>You'll see this if you haven't authorized access to the correct FHIR resources when you set up your FHIR sandbox.</p> <pre><code>print([outcome.model_dump() for outcome in doc.fhir.operation_outcomes])\n</code></pre> <pre><code>{\n  \"resourceType\": \"OperationOutcome\",\n  \"meta\": {\n    \"source\": \"urn:healthchain:source:epic\"\n  },\n  \"issue\": [\n    {\n      \"severity\": \"warning\",\n      \"code\": \"suppressed\",\n      \"details\": {\n        \"coding\": [{\n          \"system\": \"urn:oid:1.2.840.114350.1.13.0.1.7.2.657369\",\n          \"code\": \"59204\"\n        }]\n      },\n      \"diagnostics\": \"Client not authorized for Condition - Encounter Diagnosis\"\n    },\n    {\n      \"severity\": \"warning\",\n      \"code\": \"suppressed\",\n      \"diagnostics\": \"Client not authorized for Condition - Health Concerns\"\n    },\n    {\n      \"severity\": \"warning\",\n      \"code\": \"suppressed\",\n      \"diagnostics\": \"Client not authorized for Condition - Medical History\"\n    }\n  ]\n}\n</code></pre> Expected Error Handling <p>You'll see this when querying a patient that doesn't exist in a source:</p> <pre><code>Error from cerner: [FHIR request failed: 400 - Unknown error]\nsearch &lt;class 'fhir.resources.condition.Condition'&gt; failed:\nResource could not be parsed or failed basic FHIR validation rules\n</code></pre>"},{"location":"cookbook/multi_ehr_aggregation/#what-youve-built","title":"What You've Built","text":"<p>A production-ready data aggregation service with:</p> <ul> <li>Multi-vendor support - Query Epic, Cerner, and other FHIR sources simultaneously</li> <li>Automatic provenance tracking - <code>meta.source</code> field shows which EHR each resource came from</li> <li>Error resilience - Handles missing patients, network failures, auth issues gracefully</li> <li>Deduplication - Merges identical conditions across sources</li> <li>Pipeline extensibility - Add custom processing for terminology mapping, NLP, or quality checks</li> </ul> <p>Use Cases</p> <ul> <li> <p>Data Harmonization: Use pipelines to normalize terminology (ICD-10 \u2194 SNOMED CT), validate completeness, and flag inconsistencies across sources. Combine with clinical NLP engines to extract and aggregate data from unstructured clinical notes alongside structured FHIR resources.</p> </li> <li> <p>RAG Systems: Build retrieval systems that search across multiple health systems. The aggregator provides the unified patient context LLMs need for clinical reasoning.</p> </li> <li> <p>Training Data for AI Models: Aggregate diverse patient data across EHR vendors for model training. Provenance tags enable stratified analysis (e.g., \"how does model performance vary by data source?\").</p> </li> </ul> <p>Next Steps</p> <ul> <li>Try another FHIR server: Set up a different FHIR server where you can upload the same test patients to multiple instances for true multi-source aggregation.</li> <li>Expand resource types: Change <code>Condition</code> to <code>MedicationStatement</code>, <code>Observation</code>, or <code>Procedure</code> to aggregate different data.</li> <li>Add processing: Extend the pipeline with terminology mapping, entity extraction, or quality checks.</li> <li>Build on it: Use aggregated data in the Clinical Coding tutorial or feed it to your LLM application.</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/","title":"Working with FHIR Sandboxes","text":"<p>This guide covers setting up access to public FHIR sandboxes for testing and development. These sandboxes provide free access to test data and realistic FHIR APIs without requiring production EHR credentials.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#epic-on-fhir-sandbox","title":"Epic on FHIR Sandbox","text":"<p>Epic provides a public testing sandbox with sample patients and resource specifications available for developing against their FHIR Server.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Free Epic on FHIR developer account: https://fhir.epic.com/</li> <li>No existing Epic customer account required (it only takes a minute)</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#step-1-create-an-app","title":"Step 1: Create an App","text":"<ol> <li>Log in to https://fhir.epic.com/</li> </ol> <ol> <li>Navigate to \"Build Apps\" \u2192 \"Create\"</li> </ol> <ol> <li>Fill out the application form:</li> <li>Application Name: Choose any descriptive name</li> <li>Application Type: Check \"Backend Systems\"</li> <li>FHIR APIs: Select the APIs you need (note the versions)</li> </ol>"},{"location":"cookbook/setup_fhir_sandboxes/#step-2-configure-oauth2-with-jwt-authentication","title":"Step 2: Configure OAuth2 with JWT Authentication","text":"<p>Epic uses OAuth2 with JWT assertion for authentication.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#generate-key-pair","title":"Generate Key Pair","text":"<p>Follow Epic's instructions to create a Public Private key pair for JWT signature:</p> <pre><code># Generate private key - make sure the key length is at least 2048 bits.\nopenssl genrsa -out privatekey.pem 2048\n\n# Export public key as base64 encoded X.509 certificate\nopenssl req -new -x509 -key privatekey.pem -out publickey509.pem -subj '/CN=myapp'\n</code></pre> <p>Where <code>/CN=myapp</code> is the subject name (e.g., your app name). The subject name doesn't have functional impact but is required for creating an X.509 certificate.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#upload-public-key","title":"Upload Public Key","text":"<ol> <li>In your Epic app configuration, upload the <code>publickey509.pem</code> file</li> <li>Click Save</li> <li>Note down your Non-Production Client ID</li> </ol>"},{"location":"cookbook/setup_fhir_sandboxes/#step-3-complete-app-setup","title":"Step 3: Complete App Setup","text":"<ol> <li>Fill out remaining required fields (description, etc.)</li> <li>Check to confirm terms of use</li> <li>Click Save &amp; Ready for Sandbox</li> </ol>"},{"location":"cookbook/setup_fhir_sandboxes/#step-4-configure-environment-variables","title":"Step 4: Configure Environment Variables","text":"<p>Create a <code>.env</code> file with your credentials:</p> <pre><code># .env file\nEPIC_BASE_URL=https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4\nEPIC_CLIENT_ID=your_non_production_client_id\nEPIC_CLIENT_SECRET_PATH=path/to/privatekey.pem\nEPIC_TOKEN_URL=https://fhir.epic.com/interconnect-fhir-oauth/oauth2/token\nEPIC_USE_JWT_ASSERTION=true\n</code></pre>"},{"location":"cookbook/setup_fhir_sandboxes/#using-epic-sandbox-in-code","title":"Using Epic Sandbox in Code","text":"<pre><code>from healthchain.gateway.clients import FHIRAuthConfig\n\n# Load configuration from environment variables\nconfig = FHIRAuthConfig.from_env(\"EPIC\")\nEPIC_URL = config.to_connection_string()\n\n# Add to FHIR gateway\nfrom healthchain.gateway import FHIRGateway\n\ngateway = FHIRGateway()\ngateway.add_source(\"epic\", EPIC_URL)\n</code></pre>"},{"location":"cookbook/setup_fhir_sandboxes/#available-test-patients","title":"Available Test Patients","text":"<p>Epic provides sample test patients including:</p> <ul> <li>Derrick Lin - Patient ID: <code>eq081-VQEgP8drUUqCWzHfw3</code></li> <li>Linda Ross - Patient ID: <code>eIXesllypH3M9tAA5WdJftQ3</code></li> <li>Many others with various clinical scenarios</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#cerner-sandbox","title":"Cerner Sandbox","text":"<p>Cerner (now Oracle Health) provides both open and secure public sandboxes for the FHIR R4 APIs for Oracle Health Millennium Platform.</p> <p>The Open Sandbox is read-only. It does not require authentication and is handy for quick proof of concepts:</p> <p><pre><code>https://fhir-open.cerner.com/r4/ec2458f2-1e24-41c8-b71b-0e701af7583d/:resource[?:parameters]\n</code></pre> You can get an idea of patients available in the open sandbox by querying some common last names:</p> <pre><code>curl -i -H \"Accept: application/json+fhir\" \"https://fhir-open.cerner.com/r4/ec2458f2-1e24-41c8-b71b-0e701af7583d/Patient?family=smith\"\n</code></pre> <p>Documentation on Secure Sandbox coming soon.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#medplum","title":"Medplum","text":"<p>Medplum is an open-source healthcare platform that provides a compliant FHIR server. It's useful for testing with controlled data where you can upload your own test patients. Medplum uses standard OAuth2/OpenID authentication.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#prerequisites_1","title":"Prerequisites","text":"<ul> <li>Medplum account: Register here</li> <li>Free tier available</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#step-1-create-a-client-application","title":"Step 1: Create a Client Application","text":"<ol> <li>Log in to your Medplum account</li> <li>Navigate to Client Application:</li> <li>Option 1: Use this direct link: ClientApplication</li> <li>Option 2: Click the Medplum logo (top-left) and search for \"Client Application\" in the resources search bar</li> <li>Create a new Client</li> <li>Configure Access Policy if needed:</li> <li>Required for: Production deployments, multi-user environments, restricted data access</li> <li>Optional for: Sandbox testing with personal test data</li> <li>For production setup, see Medplum's access control documentation</li> </ol>"},{"location":"cookbook/setup_fhir_sandboxes/#step-2-get-credentials","title":"Step 2: Get Credentials","text":"<p>After creating the client:</p> <ol> <li>Note your Client ID</li> <li>Copy your Client Secret</li> </ol> <p></p>"},{"location":"cookbook/setup_fhir_sandboxes/#step-3-configure-environment-variables","title":"Step 3: Configure Environment Variables","text":"<p>Create a <code>.env</code> file with your credentials:</p> <pre><code># .env file\nMEDPLUM_BASE_URL=https://api.medplum.com/fhir/R4\nMEDPLUM_CLIENT_ID=your_client_id\nMEDPLUM_CLIENT_SECRET=your_client_secret\nMEDPLUM_TOKEN_URL=https://api.medplum.com/oauth2/token\nMEDPLUM_SCOPE=openid\n</code></pre>"},{"location":"cookbook/setup_fhir_sandboxes/#using-medplum-in-code","title":"Using Medplum in Code","text":"<pre><code>from healthchain.gateway import FHIRGateway\nfrom healthchain.gateway.clients import FHIRAuthConfig\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Load configuration from environment variables\nconfig = FHIRAuthConfig.from_env(\"MEDPLUM\")\nMEDPLUM_URL = config.to_connection_string()\n\n# Add to FHIR gateway\ngateway = FHIRGateway()\ngateway.add_source(\"medplum\", MEDPLUM_URL)\n</code></pre>"},{"location":"cookbook/setup_fhir_sandboxes/#benefits-of-medplum","title":"Benefits of Medplum","text":"<ul> <li>Full control: Upload your own test data</li> <li>FHIR R4 compliant: Complete FHIR API implementation</li> <li>Multi-source testing: Create multiple projects for different data sources</li> <li>Web interface: Browse and manage resources via UI</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#tips-for-multi-source-testing","title":"Tips for Multi-Source Testing","text":""},{"location":"cookbook/setup_fhir_sandboxes/#different-test-data","title":"Different Test Data","text":"<p>Public sandboxes (Epic, Cerner) contain different test patients. When testing multi-source aggregation:</p> <ul> <li>Expected behavior: Queries for patients not in a source should fail gracefully</li> <li>Production use: Map patient identifiers across systems or use sources sharing patient cohorts</li> <li>Controlled testing: Use Medplum where you can upload the same test patients to multiple instances</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#error-handling","title":"Error Handling","text":"<p>Your code should handle:</p> <ul> <li>Network issues or downtime</li> <li>Patient not found in specific sources</li> <li>Rate limiting</li> <li>Authorization failures</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#authentication","title":"Authentication","text":"Sandbox Auth Mechanism Epic OAuth2 with JWT assertion (backend) Medplum OAuth2 client credentials (Client Credentials Flow) <p>HealthChain's FHIRGateway handles these automatically via connection strings.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#next-steps","title":"Next Steps","text":"<ul> <li>Return to your tutorial to continue with the specific use case</li> <li>See FHIR Gateway documentation for advanced configuration</li> <li>Check FHIR Resources documentation for working with different resource types</li> </ul>"},{"location":"reference/","title":"Welcome!","text":""},{"location":"reference/#core-components","title":"Core Components","text":"<ul> <li>Gateway: Connect to multiple healthcare systems and services.</li> <li>Pipeline: Build and manage processing pipelines for healthcare NLP and ML tasks.</li> <li>Sandbox: Test your pipelines in a simulated healthcare environment.</li> <li>Interoperability: Convert between healthcare data formats like FHIR, CDA, and HL7v2.</li> <li>Utilities: Additional tools for development and testing.</li> </ul>"},{"location":"reference/gateway/api/","title":"HealthChainAPI \ud83c\udfe5","text":"<p>The <code>HealthChainAPI</code> is your main application that coordinates all the different gateways and services.</p> <p>It's a FastAPI app under the hood, so you get all the benefits of FastAPI (automatic docs, type safety, performance) plus healthcare-specific features that makes it easier to work with healthcare data sources, such as FHIR APIs, CDS Hooks, and SOAP/CDA services.</p>"},{"location":"reference/gateway/api/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.gateway import HealthChainAPI, FHIRGateway\nimport uvicorn\n\n# Create your app\napp = HealthChainAPI(\n    title=\"My Healthcare App\",\n    description=\"AI-powered patient care\",\n)\n\n# Add a FHIR gateway\nfhir = FHIRGateway()\napp.register_gateway(fhir)\n\n# Run it (docs automatically available at /docs)\nif __name__ == \"__main__\":\n    uvicorn.run(app)\n</code></pre> <p>You can also register multiple services of different protocols:</p> <pre><code>from healthchain.gateway import (\n    HealthChainAPI, FHIRGateway,\n    CDSHooksService, NoteReaderService\n)\n\napp = HealthChainAPI()\n\n# Register everything you need\napp.register_gateway(FHIRGateway(), path=\"/fhir\")\napp.register_service(CDSHooksService(), path=\"/cds\")\napp.register_service(NoteReaderService(), path=\"/soap\")\n\n# Your API now handles:\n# /fhir/* - Patient data, observations, etc.\n# /cds/* - Real-time clinical alerts\n# /soap/* - Clinical document processing\n</code></pre>"},{"location":"reference/gateway/api/#default-endpoints","title":"Default Endpoints","text":"<p>The HealthChainAPI automatically provides several default endpoints:</p>"},{"location":"reference/gateway/api/#root-endpoint-get","title":"Root Endpoint: <code>GET /</code>","text":"<p>Returns basic API information and registered components.</p> <pre><code>{\n  \"name\": \"HealthChain API\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Healthcare Integration Platform\",\n  \"gateways\": [\"FHIRGateway\"],\n  \"services\": [\"CDSHooksService\", \"NoteReaderService\"]\n}\n</code></pre>"},{"location":"reference/gateway/api/#health-check-get-health","title":"Health Check: <code>GET /health</code>","text":"<p>Simple health check endpoint for monitoring.</p> <pre><code>{\n  \"status\": \"healthy\"\n}\n</code></pre>"},{"location":"reference/gateway/api/#gateway-status-get-gatewaystatus","title":"Gateway Status: <code>GET /gateway/status</code>","text":"<p>Comprehensive status of all registered gateways and services.</p> <pre><code>{\n  \"gateways\": {\n    \"FHIRGateway\": {\n      \"status\": \"active\",\n      \"sources\": [\"epic\", \"cerner\"],\n      \"connection_pool\": {...}\n    }\n  },\n  \"services\": {\n    \"CDSHooksService\": {\n      \"status\": \"active\",\n      \"hooks\": [\"patient-view\", \"order-select\"]\n    }\n  },\n  \"events\": {\n    \"enabled\": true,\n    \"dispatcher\": \"LocalEventDispatcher\"\n  }\n}\n</code></pre>"},{"location":"reference/gateway/api/#event-integration","title":"Event Integration","text":"<p>The HealthChainAPI coordinates events across all registered components. This is useful for auditing, workflow automation, and other use cases. For more information, see the Events page.</p> <pre><code>from healthchain.gateway.events.dispatcher import local_handler\n\napp = HealthChainAPI()\n\n# Register global event handler\n@local_handler.register(event_name=\"fhir.patient.read\")\nasync def log_patient_access(event):\n    event_name, payload = event\n    print(f\"Patient accessed: {payload['resource_id']}\")\n\n# Register handler for all events from specific component\n@local_handler.register(event_name=\"cdshooks.*\")\nasync def log_cds_events(event):\n    event_name, payload = event\n    print(f\"CDS Hook fired: {event_name}\")\n</code></pre>"},{"location":"reference/gateway/api/#dependencies-and-injection","title":"Dependencies and Injection","text":"<p>The HealthChainAPI provides dependency injection for accessing registered components.</p>"},{"location":"reference/gateway/api/#gateway-dependencies","title":"Gateway Dependencies","text":"<pre><code>from healthchain.gateway.api.dependencies import get_gateway\nfrom fastapi import Depends\n\n@app.get(\"/custom/patient/{id}\")\nasync def get_enhanced_patient(\n    id: str,\n    fhir: FHIRGateway = Depends(get_gateway(\"FHIRGateway\"))\n):\n    \"\"\"Custom endpoint using FHIR gateway dependency.\"\"\"\n    patient = await fhir.read(Patient, id)\n    return patient\n\n# Or get all gateways\nfrom healthchain.gateway.api.dependencies import get_all_gateways\n\n@app.get(\"/admin/gateways\")\nasync def list_gateways(\n    gateways: Dict[str, Any] = Depends(get_all_gateways)\n):\n    return {\"gateways\": list(gateways.keys())}\n</code></pre>"},{"location":"reference/gateway/api/#application-dependencies","title":"Application Dependencies","text":"<pre><code>from healthchain.gateway.api.dependencies import get_app\n\n@app.get(\"/admin/status\")\nasync def admin_status(\n    app_instance: HealthChainAPI = Depends(get_app)\n):\n    return {\n        \"gateways\": len(app_instance.gateways),\n        \"services\": len(app_instance.services),\n        \"events_enabled\": app_instance.enable_events\n    }\n</code></pre>"},{"location":"reference/gateway/api/#see-also","title":"See Also","text":"<ul> <li>FHIR Gateway: Complete FHIR operations reference</li> <li>CDS Hooks Service: Complete CDS Hooks service reference</li> <li>NoteReader Service: Complete NoteReader service reference</li> </ul>"},{"location":"reference/gateway/cdshooks/","title":"CDS Hooks Protocol","text":"<p>CDS Hooks is an HL7 published specification for clinical decision support that enables external services to provide real-time recommendations during clinical workflows.</p>"},{"location":"reference/gateway/cdshooks/#overview","title":"Overview","text":"<p>CDS hooks are triggered at specific events during a clinician's workflow in an electronic health record (EHR), such as when a patient record is opened or when an order is selected. The hooks communicate using FHIR (Fast Healthcare Interoperability Resources).</p> <p>CDS Hooks are unique in that they are real-time webhooks that are triggered by the EHR, not by external services. This makes them ideal for real-time clinical decision support and alerts, but also trickier to test and debug for a developer. They are also a relatively new standard, so not all EHRs support them yet.</p> When Where What you receive What you send back Common Use Cases Triggered at certain events during a clinician's workflow EHR The context of the event and FHIR resources that are requested by your service \"Cards\" displaying text, actionable suggestions, or links to launch a SMART app Allergy alerts, medication reconciliation, clinical decision support"},{"location":"reference/gateway/cdshooks/#healthchainapi-integration","title":"HealthChainAPI Integration","text":"<p>Use the <code>CDSHooksService</code> with HealthChainAPI to handle CDS Hooks workflows:</p> <pre><code>from healthchain.gateway import HealthChainAPI, CDSHooksService\nfrom healthchain.models import CDSRequest, CDSResponse\n\napp = HealthChainAPI()\ncds = CDSHooksService()\n\n@cds.hook(\"patient-view\", id=\"allergy-alerts\")\ndef check_allergies(request: CDSRequest) -&gt; CDSResponse:\n    # Your AI logic here\n    return CDSResponse(cards=[...])\n\napp.register_service(cds, path=\"/cds\")\n</code></pre>"},{"location":"reference/gateway/cdshooks/#supported-workflows","title":"Supported Workflows","text":"Workflow Name Description Trigger Status <code>patient-view</code> Triggered when a patient chart is opened Opening a patient's chart \u2705 <code>order-select</code> Triggered when a new order is selected Selecting a new order \u23f3 <code>order-sign</code> Triggered when orders are being signed Signing orders \u23f3 <code>encounter-discharge</code> Triggered when a patient is being discharged Discharging a patient \u2705"},{"location":"reference/gateway/cdshooks/#api-endpoints","title":"API Endpoints","text":"<p>When registered with HealthChainAPI, the following endpoints are automatically created:</p> Endpoint Method Function Description <code>/cds-services</code> GET Service Discovery Lists all available CDS services <code>/cds-services/{id}</code> POST Hook Execution Executes the specified CDS hook"},{"location":"reference/gateway/cdshooks/#requestresponse-format","title":"Request/Response Format","text":""},{"location":"reference/gateway/cdshooks/#cdsrequest-example","title":"CDSRequest Example","text":"<pre><code>{\n   \"hookInstance\": \"23f1a303-991f-4118-86c5-11d99a39222e\",\n   \"fhirServer\": \"https://fhir.example.org\",\n   \"hook\": \"patient-view\",\n   \"context\": {\n     \"patientId\": \"1288992\",\n     \"userId\": \"Practitioner/example\"\n    },\n   \"prefetch\": {\n      \"patientToGreet\": {\n        \"resourceType\": \"Patient\",\n        \"gender\": \"male\",\n        \"birthDate\": \"1925-12-23\",\n        \"id\": \"1288992\",\n        \"active\": true\n      }\n   }\n}\n</code></pre>"},{"location":"reference/gateway/cdshooks/#cdsresponse-example","title":"CDSResponse Example","text":"<pre><code>{\n  \"cards\": [{\n    \"summary\": \"Bilirubin: Based on the age of this patient consider overlaying bilirubin results\",\n    \"indicator\": \"info\",\n    \"detail\": \"The focus of this app is to reduce the incidence of severe hyperbilirubinemia...\",\n    \"source\": {\n      \"label\": \"Intermountain\",\n      \"url\": null\n    },\n    \"links\": [{\n      \"label\": \"Bilirubin SMART app\",\n      \"url\": \"https://example.com/launch\",\n      \"type\": \"smart\"\n    }]\n  }]\n}\n</code></pre>"},{"location":"reference/gateway/cdshooks/#supported-fhir-resources","title":"Supported FHIR Resources","text":"<ul> <li><code>Patient</code></li> <li><code>Encounter</code></li> <li><code>Procedure</code></li> <li><code>MedicationRequest</code></li> </ul> <p>For more information, see the official CDS Hooks documentation.</p>"},{"location":"reference/gateway/cdshooks/#advanced-workflow-example","title":"Advanced Workflow Example","text":"<p>This example demonstrates how to build a custom CDS Hooks workflow that performs advanced clinical analysis and generates tailored decision support cards. By combining adapters and a custom pipeline, you can process incoming FHIR data, apply your own logic (such as risk assessment), and return dynamic CDS cards to the EHR.</p> <pre><code>from healthchain.io import CdsFhirAdapter, Document\nfrom healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import CdsCardCreator\nfrom healthchain.models import CDSRequest, CDSResponse\nfrom healthchain.gateway import HealthChainAPI, CDSHooksService\n\n# Build custom pipeline with analysis and card creation\npipeline = Pipeline([Document])\n\n@pipeline.add_node\ndef analyze_patient_data(doc: Document) -&gt; Document:\n    \"\"\"Custom function to analyze patient data and document content\"\"\"\n    # Access FHIR prefetch resources\n    patient = doc.fhir.get_prefetch_resources(\"patient\")\n    document_ref = doc.fhir.get_prefetch_resources(\"document\")\n\n    # Perform custom analysis\n    if patient:\n        age = 2024 - int(patient.birthDate[:4])  # Simple age calculation\n        if age &gt; 65:\n            doc._custom_analysis = {\"high_risk\": True, \"reason\": \"Age &gt; 65\"}\n        else:\n            doc._custom_analysis = {\"high_risk\": False}\n    return doc\n\n# Add card creator to format output\npipeline.add_node(CdsCardCreator(\n    template='{\"summary\": \"Risk Assessment\", \"detail\": \"Patient risk level: {{ high_risk }}\"}'\n))\n\npipe = pipeline.build()\n\n# Set up CDS service with custom workflow\napp = HealthChainAPI()\ncds = CDSHooksService()\n\n@cds.hook(\"encounter-discharge\", id=\"risk-assessment\")\ndef assess_patient_risk(request: CDSRequest) -&gt; CDSResponse:\n    # Use adapter for explicit format conversion\n    adapter = CdsFhirAdapter()\n\n    # Manual conversion with full document access\n    doc = adapter.parse(request)        # CDSRequest \u2192 Document\n    processed_doc = pipe(doc)           # Custom analysis + card creation\n\n    # Convert back to CDS response\n    return adapter.format(processed_doc)  # Document \u2192 CDSResponse\n\napp.register_service(cds, path=\"/cds\")\n</code></pre>"},{"location":"reference/gateway/events/","title":"Events","text":"<p>The FHIR Gateway emits events for all operations. The events are emitted using the <code>EventDispatcher</code>.</p> <p>Develoment Use Only</p> <p>This is a development feature and may change in future releases.</p>"},{"location":"reference/gateway/events/#event-system","title":"Event System","text":"<p>The FHIR Gateway uses the <code>EventDispatcher</code> to emit events.</p>"},{"location":"reference/gateway/events/#event-types","title":"Event Types","text":"<ul> <li><code>ehr.generic</code></li> <li><code>fhir.read</code></li> <li><code>fhir.search</code></li> <li><code>fhir.update</code></li> <li><code>fhir.delete</code></li> <li><code>fhir.create</code></li> <li><code>cds.patient.view</code></li> <li><code>cds.encounter.discharge</code></li> <li><code>cds.order.sign</code></li> <li><code>cds.order.select</code></li> <li><code>notereader.sign.note</code></li> <li><code>notereader.process.note</code></li> </ul>"},{"location":"reference/gateway/events/#automatic-events","title":"Automatic Events","text":"<p>The FHIR Gateway automatically emits events for all operations:</p> <pre><code>from healthchain.gateway.events.dispatcher import local_handler\n\n# Listen for FHIR read events\n@local_handler.register(event_name=\"fhir.read\")\nasync def audit_fhir_access(event):\n    event_name, payload = event\n    print(f\"FHIR Read: {payload['resource_type']}/{payload['resource_id']} from {payload.get('source', 'unknown')}\")\n\n# Listen for patient-specific events\n@local_handler.register(event_name=\"fhir.patient.*\")\nasync def track_patient_access(event):\n    event_name, payload = event\n    operation = event_name.split('.')[-1]  # read, create, update, delete\n    print(f\"Patient {operation}: {payload['resource_id']}\")\n</code></pre>"},{"location":"reference/gateway/events/#custom-event-creation","title":"Custom Event Creation","text":"<pre><code># Configure custom event creation\ndef custom_event_creator(operation, resource_type, resource_id, resource=None, source=None):\n    \"\"\"Create custom events with additional metadata.\"\"\"\n    return EHREvent(\n        event_type=EHREventType.FHIR_READ,\n        source_system=source or \"unknown\",\n        timestamp=datetime.now(),\n        payload={\n            \"operation\": operation,\n            \"resource_type\": resource_type,\n            \"resource_id\": resource_id,\n            \"user_id\": get_current_user_id(),  # Your auth system\n            \"session_id\": get_session_id(),\n            \"ip_address\": get_client_ip()\n        },\n        metadata={\n            \"compliance\": \"HIPAA\",\n            \"audit_required\": True\n        }\n    )\n\n# Apply to gateway\ngateway.events.set_event_creator(custom_event_creator)\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/","title":"FHIR Gateway","text":"<p>The FHIR Gateway provides a unified interface for connecting to multiple FHIR servers with automatic authentication, connection pooling, error handling, and simplified CRUD operations. It comes in two variants:</p> <ul> <li><code>FHIRGateway</code> - Synchronous FHIR client (<code>httpx.Client</code>)</li> <li><code>AsyncFHIRGateway</code> - Asynchronous FHIR client (<code>httpx.AsyncClient</code>)</li> </ul> <p>Both handle the complexity of managing multiple FHIR clients and provide a consistent API across different healthcare systems.</p> <p>Sync vs Async: When to Choose What</p> <p>Choose sync for: Getting started, interaction with legacy systems, simpler debugging - safe for most use cases</p> <p>Choose async for: High-throughput scenarios, concurrent requests, modern applications</p> <p>Key difference: Async version includes connection pooling and the <code>modify()</code> context manager for automatic resource saving.</p>"},{"location":"reference/gateway/fhir_gateway/#basic-usage","title":"Basic Usage","text":""},{"location":"reference/gateway/fhir_gateway/#synchronous-gateway","title":"Synchronous Gateway","text":"<pre><code>from healthchain.gateway import FHIRGateway\nfrom fhir.resources.patient import Patient\n\ngateway = FHIRGateway()\n\n# Connect to FHIR server\ngateway.add_source(\n    \"my_fhir_server\",\n    \"fhir://fhir.example.com/api/FHIR/R4/?client_id=your_app&amp;client_secret=secret&amp;token_url=https://fhir.example.com/oauth2/token\"\n)\n\nwith gateway:\n    # FHIR operations\n    patient = gateway.read(Patient, \"123\", \"my_fhir_server\")\n    print(f\"Patient: {patient.name[0].family}\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#asynchronous-gateway","title":"Asynchronous Gateway","text":"<pre><code>import asyncio\n\nfrom healthchain.gateway import AsyncFHIRGateway\nfrom fhir.resources.patient import Patient\n\ngateway = AsyncFHIRGateway()\n\n# Connect to FHIR server\ngateway.add_source(\n    \"my_fhir_server\",\n    \"fhir://fhir.example.com/api/FHIR/R4/?client_id=your_app&amp;client_secret=secret&amp;token_url=https://fhir.example.com/oauth2/token\"\n)\n\nasync with gateway:\n    # Fetch multiple resources concurrently\n    tasks = [\n        gateway.read(Patient, \"123\", \"my_fhir_server\"),\n        gateway.read(Patient, \"456\", \"my_fhir_server\"),\n        gateway.read(Patient, \"789\", \"my_fhir_server\")\n    ]\n    patients = await asyncio.gather(*tasks)\n\n    for patient in patients:\n        print(f\"Patient: {patient.name[0].family}\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#adding-sources","title":"Adding Sources \ud83c\udfe5","text":"<p>The gateway currently supports adding sources with OAuth2 authentication flow.</p> <pre><code># Epic Sandbox (JWT assertion)\ngateway.add_source(\n    \"epic\",\n    (\n        \"fhir://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4/\"\n        \"?client_id=your_app\"\n        \"&amp;client_secret_path=keys/private.pem\"\n        \"&amp;token_url=https://fhir.epic.com/interconnect-fhir-oauth/oauth2/token\"\n        \"&amp;use_jwt_assertion=true\"\n    )\n)\n\n# Medplum (Client Credentials)\ngateway.add_source(\n    \"medplum\",\n    (\n        \"fhir://api.medplum.com/fhir/R4/\"\n        \"?client_id=your_app\"\n        \"&amp;client_secret=secret\"\n        \"&amp;token_url=https://api.medplum.com/oauth2/token\"\n        \"&amp;scope=openid\"\n    )\n)\n</code></pre> <p>For more information on configuring specific FHIR servers</p> <p>Epic FHIR API:</p> <ul> <li>Epic on FHIR Documentation</li> <li>Epic OAuth2 Setup</li> <li>Test Patients in Epic Sandbox</li> <li>Useful Epic Sandbox Setup Guide</li> </ul> <p>Medplum FHIR API:</p> <ul> <li>Medplum app tutorial</li> <li>Medplum OAuth2 Client Credentials Setup</li> </ul> <p>General Resources:</p> <ul> <li>OAuth2</li> <li>FHIR RESTful API</li> <li>FHIR Specification</li> </ul>"},{"location":"reference/gateway/fhir_gateway/#connection-string-format","title":"Connection String Format","text":"<p>Connection strings use the <code>fhir://</code> scheme with query parameters:</p> <pre><code>fhir://hostname:port/path?param1=value1&amp;param2=value2\n</code></pre> <p>Required Parameters:</p> <ul> <li><code>client_id</code>: OAuth2 client ID</li> <li><code>token_url</code>: OAuth2 token endpoint</li> </ul> <p>Optional Parameters:</p> <ul> <li><code>client_secret</code>: OAuth2 client secret (for client credentials flow)</li> <li><code>client_secret_path</code>: Path to private key file (for JWT assertion)</li> <li><code>scope</code>: OAuth2 scope (default: \"<code>system/*.read system/*.write</code>\")</li> <li><code>use_jwt_assertion</code>: Use JWT assertion flow (default: false)</li> <li><code>audience</code>: Token audience (for some servers)</li> </ul>"},{"location":"reference/gateway/fhir_gateway/#fhir-operations","title":"FHIR Operations \ud83d\udd25","text":"<p>Note</p> <p>These examples assume you have already created and configured your gateway as shown in the Basic Usage section above.</p>"},{"location":"reference/gateway/fhir_gateway/#create-resources","title":"Create Resources","text":"<pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.humanname import HumanName\n\n# Create a new patient\npatient = Patient(\n    name=[HumanName(family=\"Smith\", given=[\"John\"])],\n    gender=\"male\",\n    birthDate=\"1990-01-01\"\n)\n\ncreated_patient = gateway.create(resource=patient, source=\"medplum\")\nprint(f\"Created patient with ID: {created_patient.id}\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#read-resources","title":"Read Resources","text":"<pre><code>from fhir.resources.patient import Patient\n\n# Read a specific patient (Derrick Lin, Epic Sandbox)\npatient = gateway.read(\n    resource_type=Patient,\n    fhir_id=\"eq081-VQEgP8drUUqCWzHfw3\",\n    source=\"epic\"\n)\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#update-resources","title":"Update Resources","text":"SyncAsync <pre><code>from fhir.resources.patient import Patient\n\n# Read, modify, and update (sync)\npatient = gateway.read(Patient, \"123\", \"medplum\")\npatient.name[0].family = \"Johnson\"\nupdated_patient = gateway.update(patient, \"medplum\")\n</code></pre> <pre><code>from fhir.resources.patient import Patient\n\n# Read, modify, and update (async)\npatient = await gateway.read(Patient, \"123\", \"medplum\")\npatient.name[0].family = \"Johnson\"\nupdated_patient = await gateway.update(patient, \"medplum\")\n\n# Using async context manager - automatically saves on exit\nasync with gateway.modify(Patient, \"123\", \"medplum\") as patient:\n    patient.active = True\n    patient.name[0].given = [\"Jane\"]\n    # Automatic save on exit\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#delete-resources","title":"Delete Resources","text":"<pre><code>from fhir.resources.patient import Patient\n\n# Delete a patient\nsuccess = gateway.delete(Patient, \"123\", \"medplum\")\nif success:\n    print(\"Patient deleted successfully\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#search-operations","title":"Search Operations","text":""},{"location":"reference/gateway/fhir_gateway/#basic-search","title":"Basic Search","text":"<pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.bundle import Bundle\n\n# Search by name\nsearch_params = {\"family\": \"Smith\", \"given\": \"John\"}\nresults: Bundle = gateway.search(Patient, search_params, \"epic\")\n\nfor entry in results.entry:\n    patient = entry.resource\n    print(f\"Found: {patient.name[0].family}, {patient.name[0].given[0]}\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#advanced-search","title":"Advanced Search","text":"<pre><code>from fhir.resources.patient import Patient\n\n# Complex search with multiple parameters\nsearch_params = {\n    \"birthdate\": \"1990-01-01\",\n    \"gender\": \"male\",\n    \"address-city\": \"Boston\",\n    \"_count\": 50,\n    \"_sort\": \"family\"\n}\n\nresults = gateway.search(Patient, search_params, \"epic\")\nprint(f\"Found {len(results.entry)} patients\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#transform-handlers","title":"Transform Handlers \ud83e\udd16","text":"<p>Transform handlers allow you to create custom API endpoints that process and enhance FHIR resources with additional logic, AI insights, or data transformations before returning them to clients. These handlers run before the response is sent, enabling real-time data enrichment and processing.</p> SyncAsync <pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.observation import Observation\n\n@fhir_gateway.transform(Patient)\ndef get_enhanced_patient_summary(id: str, source: str = None) -&gt; Patient:\n    \"\"\"Create enhanced patient summary with AI insights\"\"\"\n\n    # Read the patient\n    patient = fhir_gateway.read(Patient, id, source)\n\n    # Get lab results\n    lab_results = fhir_gateway.search(\n        resource_type=Observation,\n        search_params={\"patient\": id, \"category\": \"laboratory\"},\n        source=source\n    )\n    insights = nlp_pipeline.process(patient, lab_results)\n\n    # Add AI summary\n    patient.extension = patient.extension or []\n    patient.extension.append({\n        \"url\": \"http://healthchain.org/fhir/summary\",\n        \"valueString\": insights.summary\n    })\n\n    # Update the patient\n    fhir_gateway.update(patient, source)\n\n    return patient\n\n# The handler is automatically called via HTTP endpoint:\n# GET /fhir/transform/Patient/123?source=epic\n</code></pre> <pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.observation import Observation\n\n@fhir_gateway.transform(Patient)\nasync def get_enhanced_patient_summary(id: str, source: str = None) -&gt; Patient:\n\n    # Use the context manager to modify the patient\n    async with fhir_gateway.modify(Patient, id, source=source) as patient:\n        # Get lab results\n        lab_results = await fhir_gateway.search(\n            resource_type=Observation,\n            search_params={\"patient\": id, \"category\": \"laboratory\"},\n            source=source\n        )\n        insights = nlp_pipeline.process(patient, lab_results)\n\n        # Add AI summary\n        patient.extension = patient.extension or []\n        patient.extension.append({\n            \"url\": \"http://healthchain.org/fhir/summary\",\n            \"valueString\": insights.summary\n        })\n\n        return patient\n\n# The handler is automatically called via HTTP endpoint:\n# GET /fhir/transform/Patient/123?source=epic\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#aggregate-handlers","title":"Aggregate Handlers \ud83d\udd17","text":"<p>Aggregate handlers allow you to combine data from multiple FHIR sources into a single resource. This is useful for creating unified views across different EHR systems or consolidating patient data from various healthcare providers.</p> SyncAsync <pre><code>from fhir.resources.observation import Observation\nfrom fhir.resources.bundle import Bundle\n\n@gateway.aggregate(Observation)\ndef aggregate_vitals(patient_id: str, sources: list = None) -&gt; Bundle:\n    \"\"\"Aggregate vital signs from multiple sources.\"\"\"\n    sources = sources or [\"epic\", \"cerner\"]\n    all_observations = []\n\n    for source in sources:\n        try:\n            results = gateway.search(\n                Observation,\n                {\"patient\": patient_id, \"category\": \"vital-signs\"},\n                source\n            )\n            processed_observations = process_observations(results)\n            all_observations.append(processed_observations)\n        except Exception as e:\n            print(f\"Could not get vitals from {source}: {e}\")\n\n    return Bundle(type=\"searchset\", entry=[{\"resource\": obs} for obs in all_observations])\n\n# The handler is automatically called via HTTP endpoint:\n# GET /fhir/aggregate/Observation?patient_id=123&amp;sources=epic&amp;sources=cerner\n</code></pre> <pre><code>from fhir.resources.observation import Observation\nfrom fhir.resources.bundle import Bundle\n\n@gateway.aggregate(Observation)\nasync def aggregate_vitals(patient_id: str, sources: list = None) -&gt; Bundle:\n    \"\"\"Aggregate vital signs from multiple sources.\"\"\"\n    sources = sources or [\"epic\", \"cerner\"]\n    all_observations = []\n\n    for source in sources:\n        try:\n            results = await gateway.search(\n                Observation,\n                {\"patient\": patient_id, \"category\": \"vital-signs\"},\n                source\n            )\n            processed_observations = process_observations(results)\n            all_observations.append(processed_observations)\n        except Exception as e:\n            print(f\"Could not get vitals from {source}: {e}\")\n\n    return Bundle(type=\"searchset\", entry=[{\"resource\": obs} for obs in all_observations])\n\n# The handler is automatically called via HTTP endpoint:\n# GET /fhir/aggregate/Observation?patient_id=123&amp;sources=epic&amp;sources=cerner\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#server-capabilities","title":"Server Capabilities","text":"<ul> <li>GET <code>/fhir/metadata</code> - Returns FHIR-style <code>CapabilityStatement</code> of transform and aggregate endpoints</li> <li>GET <code>/fhir/status</code> - Returns Gateway status and connection health</li> </ul>"},{"location":"reference/gateway/fhir_gateway/#connection-pool-management-async-only","title":"Connection Pool Management (Async Only)","text":"<p>When you add a connection to a FHIR server, the async gateway will automatically add it to a connection pool to manage connections to FHIR servers.</p>"},{"location":"reference/gateway/fhir_gateway/#pool-configuration","title":"Pool Configuration","text":"<pre><code># Create gateway with optimized connection settings\ngateway = AsyncFHIRGateway(\n    max_connections=100,           # Total connections across all sources\n    max_keepalive_connections=20,  # Keep-alive connections per source\n    keepalive_expiry=30.0,         # Keep connections alive for 30 seconds\n)\n\n# Add multiple sources - they share the connection pool\ngateway.add_source(\"epic\", \"fhir://epic.org/...\")\ngateway.add_source(\"cerner\", \"fhir://cerner.org/...\")\ngateway.add_source(\"medplum\", \"fhir://medplum.com/...\")\n\nstats = gateway.get_pool_status()\nprint(stats)\n</code></pre>"},{"location":"reference/gateway/gateway/","title":"Gateway","text":"<p>The HealthChain Gateway module provides a secure integration layer for connecting your NLP/ML pipelines with multiple healthcare systems.</p> <p>It provides a unified interface for connecting to FHIR servers, CDS Hooks, and SOAP/CDA services and is designed to be used in conjunction with the HealthChainAPI to create a complete healthcare integration platform.</p>"},{"location":"reference/gateway/gateway/#features","title":"Features \ud83d\ude80","text":"<p>The Gateway handles the complex parts of healthcare integration:</p> <ul> <li>Multiple Protocols: Works with FHIR RESTful APIs, CDS Hooks, and Epic NoteReader CDI (SOAP/CDA service) out of the box</li> <li>Multi-Source: Context managers to work with data from multiple EHR systems and FHIR servers safely</li> <li>Smart Connections: Handles OAuth2.0 authentication, connection pooling, and automatic token refresh</li> <li>Event-Driven: Native asyncio support for real-time events, audit trails, and workflow automation</li> <li>Transform &amp; Aggregate: FastAPI-style declarative patterns to create endpoints for enhancing and combining data</li> <li>Developer-Friendly: Modern Python typing and validation support via fhir.resources (powered by Pydantic), protocol-based interfaces, and informative error messages</li> </ul>"},{"location":"reference/gateway/gateway/#key-components","title":"Key Components","text":"Component Description Use Case HealthChainAPI FastAPI app with gateway and service registration Main app that coordinates everything FHIRGateway Sync and async FHIR client with connection pooling and authentication Reading/writing patient data from EHRs (Epic, Cerner, etc.) or application FHIR servers (Medplum, Hapi etc.) CDSHooksService Clinical Decision Support hooks service Real-time alerts and recommendations NoteReaderService SOAP/CDA document processing service Processing clinical documents and notes Event System Event-driven integration Audit trails, workflow automation"},{"location":"reference/gateway/gateway/#basic-usage","title":"Basic Usage","text":"SyncAsync <pre><code>from healthchain.gateway import HealthChainAPI, FHIRGateway\nfrom fhir.resources.patient import Patient\n\n# Create the application\napp = HealthChainAPI()\n\n# Synchronous FHIR gateway\nfhir = FHIRGateway()\nfhir.add_source(\"epic\", \"fhir://epic.org/api/FHIR/R4?client_id=...\")\n\n@fhir.transform(Patient)\ndef enhance_patient(id: str, source: str = None) -&gt; Patient:\n    patient = fhir.read(Patient, id, source)\n    patient.active = True  # Your custom logic here\n    fhir.update(patient, source)\n    return patient\n\napp.register_gateway(fhir)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app)\n    # Default: http://127.0.0.1:8000/\n</code></pre> <pre><code>from healthchain.gateway import HealthChainAPI, AsyncFHIRGateway\nfrom fhir.resources.patient import Patient\n\n# Create the application\napp = HealthChainAPI()\n\n# Asynchronous FHIR gateway\nasync_fhir = AsyncFHIRGateway()\nasync_fhir.add_source(\"medplum\", \"fhir://api.medplum.com/fhir/R4/?client_id=...\")\n\n@async_fhir.transform(Patient)\nasync def enhance_patient_async(id: str, source: str = None) -&gt; Patient:\n    # modify is a context manager that allows you to modify the patient resource\n    async with async_fhir.modify(Patient, id, source) as patient:\n        patient.active = True  # Your custom logic here\n        return patient\n\napp.register_gateway(async_fhir)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app)\n</code></pre> <p>You can also register multiple services of different protocols:</p> <pre><code>from healthchain.gateway import (\n    HealthChainAPI, FHIRGateway,\n    CDSHooksService, NoteReaderService\n)\n\napp = HealthChainAPI()\n\n# FHIR for patient data\nfhir = FHIRGateway()\nfhir.add_source(\"epic\", \"fhir://fhir.epic.com/r4?...\")\n\n# CDS Hooks for real-time alerts\ncds = CDSHooksService()\n\n@cds.hook(\"patient-view\", id=\"allergy-alerts\")\ndef check_allergies(request):\n    # Your logic here\n    return {\"cards\": [...]}\n\n# SOAP for clinical documents\nnotes = NoteReaderService()\n\n@notes.method(\"ProcessDocument\")\ndef process_note(request):\n    # Your NLP pipeline here\n    return processed_document\n\n# Register everything\napp.register_gateway(fhir)\napp.register_service(cds)\napp.register_service(notes)\n</code></pre>"},{"location":"reference/gateway/gateway/#protocol-support","title":"Protocol Support","text":"Protocol Implementation Features FHIR API <code>FHIRGateway</code><code>AsyncFHIRGateway</code> FHIR-instance level CRUD operations - read, create, update, delete, search, register <code>transform</code> and <code>aggregate</code> handlers, connection pooling and authentication management CDS Hooks <code>CDSHooksService</code> Hook Registration, Service Discovery SOAP/CDA <code>NoteReaderService</code> Method Registration (<code>ProcessDocument</code>), SOAP Service Discovery (WSDL)"},{"location":"reference/gateway/soap_cda/","title":"SOAP/CDA Protocol","text":"<p>The SOAP/CDA protocol enables real-time Clinical Documentation Improvement (CDI) services. This implementation follows the Epic-integrated NoteReader CDI specification for analyzing clinical notes and extracting structured data.</p>"},{"location":"reference/gateway/soap_cda/#overview","title":"Overview","text":"<p>Clinical Documentation workflows communicate using CDA (Clinical Document Architecture). CDAs are standardized electronic documents for exchanging clinical information between different healthcare systems. They provide a common structure for capturing and sharing patient data like medical history, medications, and care plans between different healthcare systems and providers. Think of it as a collaborative Google Doc that you can add, amend, and remove entries from. CDA support is currently limited to Epic systems, but we plan to add support for other IHE SOAP/CDA services in the future.</p>"},{"location":"reference/gateway/soap_cda/#epic-notereader-cdi","title":"Epic NoteReader CDI","text":"<p>The Epic NoteReader CDI is a SOAP/CDA-based NLP service that extracts structured data from clinical notes. Like CDS Hooks, it operates in real-time and is triggered when a clinician opts into CDI functionality and signs or pends a note.</p> <p>The primary use case for Epic NoteReader is to convert free-text medical documentation into coded information that can be used for billing, quality reporting, continuity of care, and clinical decision support at the point-of-care (example).</p> When Where What you receive What you send back Triggered when a clinician opts in to CDI functionality and signs or pends a note EHR documentation modules (e.g. NoteReader in Epic) A CDA document containing continuity of care data and free-text clinical notes A CDA document with additional structured data extracted by your CDI service"},{"location":"reference/gateway/soap_cda/#cda-services","title":"CDA Services","text":"<p>CDA services facilitate the exchange of clinical information between different healthcare systems and are governed by the IHE standard. The Epic HIE (Health Information Exchange) platform is CareEverywhere.</p>"},{"location":"reference/gateway/soap_cda/#healthchainapi-integration","title":"HealthChainAPI Integration","text":"<p>Use the <code>NoteReaderService</code> with HealthChainAPI to handle SOAP/CDA workflows:</p> <pre><code>from healthchain.gateway import HealthChainAPI, NoteReaderService\nfrom healthchain.models import CdaRequest, CdaResponse\n\napp = HealthChainAPI()\nnotes = NoteReaderService()\n\n@notes.method(\"ProcessDocument\")\ndef process_note(request: CdaRequest) -&gt; CdaResponse:\n    # Your NLP pipeline here\n    processed_document = nlp_pipeline.process(request)\n    return processed_document\n\napp.register_service(notes, path=\"/soap\")\n</code></pre>"},{"location":"reference/gateway/soap_cda/#supported-workflows","title":"Supported Workflows","text":"Workflow Name Description Trigger Status <code>sign-note-inpatient</code> CDI processing for inpatient clinical notes Signing or pending a note in Epic inpatient setting \u2705 <code>sign-note-outpatient</code> CDI processing for outpatient clinical notes Signing or pending a note in Epic outpatient setting \u23f3 <p>Currently supports parsing of problems, medications, and allergies sections.</p>"},{"location":"reference/gateway/soap_cda/#api-endpoints","title":"API Endpoints","text":"<p>When registered with HealthChainAPI, the following endpoints are automatically created:</p> Endpoint Method Function Protocol <code>/notereader/</code> POST <code>process_notereader_document</code> SOAP <p>Note: NoteReader is a vendor-specific component (Epic). Different EHR vendors have varying support for third-party CDI services.</p>"},{"location":"reference/gateway/soap_cda/#requestresponse-format","title":"Request/Response Format","text":""},{"location":"reference/gateway/soap_cda/#cda-request-example","title":"CDA Request Example","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;typeId root=\"2.16.840.1.113883.1.3\" extension=\"POCD_HD000040\"/&gt;\n  &lt;templateId root=\"2.16.840.1.113883.10.20.22.1.2\"/&gt;\n  &lt;id root=\"2.16.840.1.113883.19.5.99999.1\"/&gt;\n  &lt;code code=\"34133-9\" displayName=\"Summarization of Episode Note\"\n        codeSystem=\"2.16.840.1.113883.6.1\" codeSystemName=\"LOINC\"/&gt;\n  &lt;title&gt;CDA Document with Problem List and Progress Note&lt;/title&gt;\n  &lt;effectiveTime value=\"20240712\"/&gt;\n  &lt;confidentialityCode code=\"N\" codeSystem=\"2.16.840.1.113883.5.25\"/&gt;\n  &lt;languageCode code=\"en-US\"/&gt;\n\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;!-- Problem List Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.5.1\"/&gt;\n          &lt;code code=\"11450-4\" codeSystem=\"2.16.840.1.113883.6.1\"\n                displayName=\"Problem List\"/&gt;\n          &lt;title&gt;Problems&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Hypertension&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;!-- Entry details... --&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n\n      &lt;!-- Progress Note Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.65\"/&gt;\n          &lt;code code=\"11506-3\" codeSystem=\"2.16.840.1.113883.6.1\"\n                displayName=\"Progress Note\"/&gt;\n          &lt;title&gt;Progress Note&lt;/title&gt;\n          &lt;text&gt;\n            &lt;paragraph&gt;Patient's blood pressure remains elevated.\n            Discussed lifestyle modifications and medication adherence.\n            Started Lisinopril 10 mg daily for hypertension management.&lt;/paragraph&gt;\n          &lt;/text&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n</code></pre>"},{"location":"reference/gateway/soap_cda/#cda-response-example","title":"CDA Response Example","text":"<p>The response includes additional structured sections extracted from the clinical text:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;!-- Header information same as request --&gt;\n\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;!-- Original sections plus extracted medications --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.1.1\"/&gt;\n          &lt;code code=\"10160-0\" codeSystem=\"2.16.840.1.113883.6.1\"\n                displayName=\"History of medication use\"/&gt;\n          &lt;title&gt;Medications&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Lisinopril 10 mg oral tablet, once daily&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;!-- Structured medication entries extracted by AI... --&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n</code></pre>"},{"location":"reference/gateway/soap_cda/#supported-cda-sections","title":"Supported CDA Sections","text":"<ul> <li>Problems/Conditions: ICD-10/SNOMED CT coded diagnoses</li> <li>Medications: SNOMED CT/RxNorm coded medications with dosage and frequency</li> <li>Allergies: Allergen identification and reaction severity</li> <li>Progress Notes: Free-text clinical documentation</li> </ul>"},{"location":"reference/gateway/soap_cda/#data-flow","title":"Data Flow","text":"Stage Input Output Gateway Receives <code>CdaRequest</code> Processed by your service Gateway Returns Your processed result <code>CdaResponse</code> <p>You can use the CdaAdapter to handle conversion between CDA documents and HealthChain pipeline data containers.</p>"},{"location":"reference/interop/configuration/","title":"Configuration","text":"<p>The interoperability module uses a configuration system to control its behavior. This includes mappings between different healthcare data formats, validation rules, and environment-specific settings.</p>"},{"location":"reference/interop/configuration/#configuration-overview","title":"Configuration Overview","text":"<p>HealthChain works out-of-the-box with default configurations, but you can customize them for your specific needs.</p>"},{"location":"reference/interop/configuration/#default-usage","title":"Default Usage","text":"<pre><code>from healthchain.interop import create_interop\n\n# Uses bundled default configurations\nengine = create_interop()\n</code></pre>"},{"location":"reference/interop/configuration/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Use custom config directory\nengine = create_interop(config_dir=\"/path/to/custom/configs\")\n</code></pre>"},{"location":"reference/interop/configuration/#creating-custom-configs","title":"Creating Custom Configs","text":"<p>To create editable configuration templates:</p> <pre><code># Create customizable config templates\nhealthchain init-configs ./my_configs\n\n# Then use them in your code\nengine = create_interop(config_dir=\"./my_configs\")\n</code></pre> <p>This gives you editable copies of: - Templates: CDA \u2194 FHIR conversion templates - Mappings: Code system mappings (SNOMED, LOINC, etc.) - Validation: Schema validation rules - Environment settings: Development, testing, production configs</p>"},{"location":"reference/interop/configuration/#configuration-components","title":"Configuration Components","text":"Component Description <code>InteropConfigManager</code> Manages access to configuration files and values <code>defaults.yaml</code> Default configuration values for FHIR required fields <code>environments/</code> Environment-specific configuration values <code>interop/</code> Configuration for format specific settings (e.g. CDA, HL7v2) <code>mappings/</code> Mapping tables for codes, identifiers, and terminology systems <code>templates/</code> Templates for generating healthcare documents"},{"location":"reference/interop/configuration/#configuration-structure","title":"Configuration Structure","text":"<p>The configuration system uses <code>YAML</code> files with a hierarchical structure. The main configuration sections include:</p> <ul> <li><code>defaults</code>: Global default values</li> <li><code>cda</code>: Contains CDA specific configurations<ul> <li><code>sections</code>: Configuration for CDA document sections</li> <li><code>document</code>: Configuration for CDA document types</li> </ul> </li> <li><code>mappings</code>: Mappings between different terminology systems</li> <li><code>templates</code>: Template configuration</li> </ul>"},{"location":"reference/interop/configuration/#default-configuration","title":"Default Configuration","text":"<p>The default configuration is stored in <code>configs/defaults.yaml</code> and contains global settings and default fallback values for required fields in FHIR resources in the event that they are not provided in the source document.</p> <pre><code>defaults:\n  # Common defaults for all resources\n  common:\n    id_prefix: \"hc-\"\n    timestamp: \"%Y%m%d\"\n    reference_name: \"#{uuid}name\"\n    subject:\n      reference: \"Patient/example\"\n\n  # Resource-specific defaults\n  resources:\n    Condition:\n      clinicalStatus:\n        coding:\n          - system: \"http://terminology.hl7.org/CodeSystem/condition-clinical\"\n            code: \"unknown\"\n            display: \"Unknown\"\n    MedicationStatement:\n      status: \"unknown\"\n      medication:\n        concept:\n          coding:\n            - system: \"http://terminology.hl7.org/CodeSystem/v3-NullFlavor\"\n              code: \"UNK\"\n              display: \"Unknown\"\n</code></pre>"},{"location":"reference/interop/configuration/#cda-configurations","title":"CDA Configurations","text":"<p>CDA configurations primarily concern the extraction and rendering processes on the document and section level. While Templates are used to define the syntactic structure of the document, the YAML configurations are used to define the semantic content of the document structure, such as template IDs, status codes, and other metadata.</p> <p>Configs are loaded from the <code>configs/interop/cda/</code> directory and loaded in the <code>ConfigManager</code> with the folder and filenames as keys. e.g. given the following directory structure:</p> <p><pre><code>configs/\n  interop/\n    cda/\n      document/\n        ccd.yaml\n      sections/\n        problems.yaml\n</code></pre> The config will be loaded into the config manager under the key <code>cda.document.ccd</code> and <code>cda.sections.problems</code>.</p>"},{"location":"reference/interop/configuration/#example-document-configuration","title":"Example Document Configuration","text":"<pre><code># configs/interop/cda/document/ccd.yaml\n\n# Configured template names in templates/ directory (required)\ntemplates:\n  document: \"fhir_cda/document\"\n  section: \"fhir_cda/section\"\n\n# Basic document information\ncode:\n  code: \"34133-9\"\n  code_system: \"2.16.840.1.113883.6.1\"\n  code_system_name: \"LOINC\"\n  display: \"Summarization of Episode Note\"\nrealm_code: \"GB\"\ntype_id:\n  extension: \"POCD_HD000040\"\n  root: \"2.16.840.1.113883.1.3\"\ntemplate_id:\n  root: \"1.2.840.114350.1.72.1.51693\"\n# ...\n\n# Document structure\nstructure:\n  # Header configuration\n  header:\n    include_patient: false\n    include_author: false\n    include_custodian: false\n\n  # Body configuration\n  body:\n    structured_body: true\n    non_xml_body: false\n    include_sections:\n      - \"allergies\"\n      - \"medications\"\n      - \"problems\"\n</code></pre>"},{"location":"reference/interop/configuration/#example-section-configuration","title":"Example Section Configuration","text":"<pre><code># configs/interop/cda/sections/problems.yaml\n\n# Metadata for both extraction and rendering processes (required)\nresource: \"Condition\" # The FHIR resource this section maps to\nresource_template: \"cda_fhir/condition\" # The template to use for the FHIR resource rendering\nentry_template: \"fhir_cda/problem_entry\" # The template to use for the CDA section entry rendering\n\n# Section identifiers (used for extraction) (required)\nidentifiers:\n  template_id: \"2.16.840.1.113883.10.20.1.11\"\n  code: \"11450-4\"\n\n# Template configuration (used for rendering)\ntemplate:\n  act:\n    template_id:\n      - \"2.16.840.1.113883.10.20.1.27\"\n    status_code: \"completed\"\n    # ...\n</code></pre>"},{"location":"reference/interop/configuration/#mapping-tables","title":"Mapping Tables","text":"<p>Mapping tables are used to translate codes and identifiers between different terminology systems. These are stored in the <code>mappings/</code> directory.</p> <p>Example mapping table for coding systems:</p> <p><pre><code># mappings/cda_default/systems.yaml\nsystems:\n  \"http://snomed.info/sct\":\n    oid: \"2.16.840.1.113883.6.96\"\n    name: \"SNOMED CT\"\n\n  \"http://loinc.org\":\n    oid: \"2.16.840.1.113883.6.1\"\n    name: \"LOINC\"\n\n  \"http://www.nlm.nih.gov/research/umls/rxnorm\":\n    oid: \"2.16.840.1.113883.6.88\"\n    name: \"RxNorm\"\n</code></pre> (Full Documentation on Mappings)</p>"},{"location":"reference/interop/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>The configuration system supports different environments (development, testing, production) with environment-specific overrides. These are stored in the <code>environments/</code> directory. In development and subject to change.</p> <pre><code># environments/development.yaml\ndefaults:\n  common:\n    id_prefix: \"dev-\"     # Development-specific ID prefix\n    subject:\n      reference: \"Patient/Foo\"\n\n# environments/production.yaml\ndefaults:\n  common:\n    id_prefix: \"hc-\"      # Production ID prefix\n    subject:\n      reference: \"Patient/example\"\n</code></pre>"},{"location":"reference/interop/configuration/#using-the-configuration-manager","title":"Using the Configuration Manager","text":""},{"location":"reference/interop/configuration/#basic-configuration-access","title":"Basic Configuration Access","text":"<pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n# OR\nengine = create_interop(config_dir=\"custom_configs/\")\n\n# Get all configurations\nengine.config.get_configs()\n\n# Get a configuration value by dot notation\nid_prefix = engine.config.get_config_value(\"defaults.common.id_prefix\")\n\n# Set the environment (this reloads configuration from the specified environment)\nengine = create_interop(environment=\"production\")\n\n# Validation level is set during initialization or using set_validation_level\nengine = create_interop(validation_level=\"warn\")\n# OR\nengine.config.set_validation_level(\"strict\")\n\n# Set a runtime configuration override\nengine.config.set_config_value(\"cda.sections.problems.identifiers.code\", \"10160-0\")\n</code></pre>"},{"location":"reference/interop/configuration/#section-configuration","title":"Section Configuration","text":"<pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n\n# Get all section configurations\nsections = engine.config.get_cda_section_configs()\n\n# Get a specific section configuration\nproblems_config = engine.config.get_cda_section_configs(\"problems\")\n\n# Get section identifiers\ntemplate_id = problems_config[\"identifiers\"][\"template_id\"]\ncode = problems_config[\"identifiers\"][\"code\"]\n</code></pre>"},{"location":"reference/interop/configuration/#mapping-access","title":"Mapping Access","text":"<pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n\n# Get all mappings\nmappings = engine.config.get_mappings()\n\n# Get a specific mapping\nsystems = mappings.get(\"cda_fhir\", {}).get(\"systems\", {})\nsnomed = systems.get(\"http://snomed.info/sct\", {})\nsnomed_oid = snomed.get(\"oid\")  # \"2.16.840.1.113883.6.96\"\n</code></pre>"},{"location":"reference/interop/configuration/#configuration-precedence","title":"Configuration Precedence","text":"<p>Configuration values are loaded in order of precedence:</p> <ol> <li>Base configuration (defaults.yaml) - lowest precedence</li> <li>Environment configuration (environments/{env}.yaml) - overrides defaults</li> <li>Runtime overrides (via API) - highest precedence</li> </ol> <pre><code># Example: Override configuration at runtime\nengine = create_interop()\nengine.config.set_config_value(\"defaults.common.id_prefix\", \"custom-\")\n</code></pre>"},{"location":"reference/interop/configuration/#validation-levels","title":"Validation Levels","text":"<p>The configuration system supports different validation levels:</p> Level Description <code>strict</code> Raise exceptions for any configuration errors <code>warn</code> Log warnings for configuration errors but continue <code>ignore</code> Ignore configuration errors <pre><code>from healthchain.interop import create_interop\n\n# Create an engine with a specific validation level\nengine = create_interop(validation_level=\"warn\")\n\n# Change the validation level\nengine.config.set_validation_level(\"strict\")\n</code></pre>"},{"location":"reference/interop/engine/","title":"InteropEngine","text":"<p>The <code>InteropEngine</code> is the core component of the HealthChain interoperability module. It provides a unified interface for converting between different healthcare data formats.</p>"},{"location":"reference/interop/engine/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.interop import create_interop, FormatType\n\n# Create an interoperability engine\nengine = create_interop()\n\n# Convert CDA XML to FHIR resources\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Convert FHIR resources to CDA XML\ncda_xml = engine.from_fhir(fhir_resources, dest_format=FormatType.CDA)\n\n# Convert HL7v2 message to FHIR resources\nfhir_resources = engine.to_fhir(hl7v2_message, src_format=FormatType.HL7V2)\n</code></pre>"},{"location":"reference/interop/engine/#creating-an-engine","title":"Creating an Engine","text":"<p>The <code>create_interop()</code> function is the recommended way to create an engine instance:</p> <pre><code>from healthchain.interop import create_interop\n\n# Create with default configuration\nengine = create_interop()\n</code></pre>"},{"location":"reference/interop/engine/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Use custom config directory\nengine = create_interop(config_dir=\"/path/to/custom/configs\")\n\n# Create with custom validation level and environment\nengine = create_interop(validation_level=\"warn\", environment=\"production\")\n</code></pre> <p>\ud83d\udca1 Tip: To create editable configuration templates, run:</p> <p><pre><code>healthchain init-configs ./my_configs\n</code></pre> This will create a <code>my_configs</code> directory with editable default configuration templates.</p>"},{"location":"reference/interop/engine/#conversion-methods","title":"Conversion Methods","text":"<p>All conversions convert to and from FHIR.</p> Method Description <code>to_fhir(data, src_format)</code> Convert from source format to FHIR resources <code>from_fhir(resources, dest_format)</code> Convert from FHIR resources to destination format"},{"location":"reference/interop/engine/#converting-to-fhir","title":"Converting to FHIR","text":"<pre><code># From CDA\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# From HL7v2\nfhir_resources = engine.to_fhir(hl7v2_message, src_format=FormatType.HL7V2)\n</code></pre>"},{"location":"reference/interop/engine/#converting-from-fhir","title":"Converting from FHIR","text":"<pre><code># To CDA\ncda_xml = engine.from_fhir(fhir_resources, dest_format=FormatType.CDA)\n\n# To HL7v2\nhl7v2_message = engine.from_fhir(fhir_resources, dest_format=FormatType.HL7V2)\n</code></pre>"},{"location":"reference/interop/engine/#accessing-configuration","title":"Accessing Configuration","text":"<p>The engine provides direct access to the underlying configuration manager:</p> <pre><code># Access configuration directly\nengine.config.set_environment(\"production\")\nengine.config.set_validation_level(\"warn\")\nvalue = engine.config.get_config_value(\"cda.sections.problems.resource\")\n</code></pre>"},{"location":"reference/interop/engine/#custom-components","title":"Custom Components","text":"<p>You can register custom parsers and generators to extend the engine's capabilities. Note that registering a custom parser / generator for an existing format type will replace the default.</p> <pre><code>from healthchain.interop import FormatType\n\n# Register a custom parser\nengine.register_parser(FormatType.CDA, custom_parser)\n\n# Register a custom generator\nengine.register_generator(FormatType.FHIR, custom_generator)\n</code></pre>"},{"location":"reference/interop/engine/#advanced-configuration","title":"Advanced Configuration","text":"<p>For more information on the configuration options, see the Configuration page.</p>"},{"location":"reference/interop/experimental/","title":"Experimental Templates","text":"<p>This page tracks templates that are under development or have known issues. Use these at your own risk and please contribute fixes!</p>"},{"location":"reference/interop/experimental/#template-status","title":"Template Status","text":"Template Type Status Known Issues Location Problems \ud83d\udfe2 Basic Stable None, but not fully tested for edge cases Bundled in default configs Medications \ud83d\udfe2 Basic Stable None, but not fully tested for edge cases Bundled in default configs Notes \ud83d\udfe2 Basic Stable None, but not fully tested for edge cases, html tags are parsed as text Bundled in default configs Allergies \u26a0\ufe0f Experimental Clinical status parsing bugs, round-trip issues <code>dev-templates/allergies/</code>"},{"location":"reference/interop/experimental/#using-experimental-templates","title":"Using Experimental Templates","text":""},{"location":"reference/interop/experimental/#allergies-allergyintolerance","title":"Allergies (AllergyIntolerance)","text":"<p>Status: \u26a0\ufe0f Experimental - Known bugs prevent inclusion in bundled configs</p> <p>Known Issues: - Clinical status parsing has bugs (see integration test comments) - Round-trip conversion may not preserve all data correctly - Template logic is fragile and may fail with edge cases</p> <p>Location: <code>dev-templates/allergies/</code></p> <p>Usage:</p> <ol> <li> <p>Copy experimental files to your custom config:    <pre><code># After running: healthchain init-configs my_configs\ncp dev-templates/allergies/allergies.yaml my_configs/interop/cda/sections/\ncp dev-templates/allergies/allergy_*.liquid my_configs/templates/cda_fhir/\ncp dev-templates/allergies/allergy_*.liquid my_configs/templates/fhir_cda/\n</code></pre></p> </li> <li> <p>Enable in your CCD document config:    <pre><code># my_configs/interop/cda/document/ccd.yaml\nbody:\n  include_sections:\n    - \"allergies\"  # Add this line\n    - \"medications\"\n    - \"problems\"\n    - \"notes\"\n</code></pre></p> </li> <li> <p>Test thoroughly with your specific data before production use.</p> </li> </ol>"},{"location":"reference/interop/experimental/#contributing-template-fixes","title":"Contributing Template Fixes","text":"<p>We welcome contributions to improve experimental templates!</p>"},{"location":"reference/interop/experimental/#for-allergies","title":"For Allergies:","text":"<ul> <li>Clinical status mapping - The biggest issue is parsing clinical status from CDA observations</li> <li>Round-trip fidelity - Ensure CDA \u2192 FHIR \u2192 CDA preserves all important data</li> <li>Edge case handling - Make templates robust to various CDA structures</li> </ul>"},{"location":"reference/interop/experimental/#general-guidelines","title":"General Guidelines:","text":"<ol> <li>Test with real data - Use the example CDAs in <code>resources/</code> for testing</li> <li>Add comprehensive tests - Include both unit and integration tests</li> <li>Document limitations - Be clear about what your fix does/doesn't solve</li> <li>Follow template patterns - Keep consistent with existing stable templates</li> </ol>"},{"location":"reference/interop/experimental/#submitting-fixes","title":"Submitting Fixes:","text":"<ol> <li>Fix the templates in <code>dev-templates/</code></li> <li>Add/update tests to cover your changes</li> <li>Move stable templates to bundled configs in your PR</li> <li>Update this documentation</li> </ol>"},{"location":"reference/interop/experimental/#roadmap","title":"Roadmap","text":"<p>Next Priorities:</p> <ol> <li>\ud83c\udfaf Allergies stabilization - Fix clinical status parsing and round-trip issues</li> <li>\ud83d\udd2e Future sections - Procedures, Vital Signs, Lab Results</li> <li>\ud83d\udd27 Template tooling - Better validation and testing framework</li> </ol> <p>Want to help? Check our contribution guidelines and pick up one of these challenges!</p>"},{"location":"reference/interop/generators/","title":"Generators","text":"<p>Generators in the interoperability module are responsible for producing healthcare data in various formats from FHIR resources. The module includes built-in generators for common formats including CDA, HL7v2, and FHIR.</p> <p>The generators are largely configuration-driven, with rendering done using Liquid templates. We highly recommend that you read through the Templates and Configuration sections before using the generators!</p>"},{"location":"reference/interop/generators/#available-generators","title":"Available Generators","text":"Generator Description <code>CDAGenerator</code> Generates CDA XML documents from FHIR resources <code>FHIRGenerator</code> Generates FHIR JSON/XML from FHIR resources"},{"location":"reference/interop/generators/#cda-generator","title":"CDA Generator","text":"<p>The CDA Generator produces Clinical Document Architecture (CDA) XML documents from FHIR resources.</p>"},{"location":"reference/interop/generators/#usage-examples","title":"Usage Examples","text":"<pre><code>from healthchain.interop import create_interop, FormatType\nfrom healthchain.fhir import create_condition\n\n# Create an engine\nengine = create_interop()\n\n# Use the FHIR helper functions to create a condition resource\ncondition = create_condition(\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\",\n    subject=\"Patient/Foo\",\n    clinical_status=\"active\"\n)\n\n# Generate CDA from FHIR resources\ncda_xml = engine.from_fhir([condition], dest_format=FormatType.CDA)\n\n# Access the CDA generator directly (advanced use case)\ncda_generator = engine.cda_generator\ncda_xml = cda_generator.transform([condition])\n</code></pre>"},{"location":"reference/interop/generators/#fhir-generator","title":"FHIR Generator","text":"<p>The FHIR Generator transforms data from other formats into FHIR resources. It currently only supports transforming CDA documents into FHIR resources.</p>"},{"location":"reference/interop/generators/#usage-examples_1","title":"Usage Examples","text":"<pre><code>from healthchain.interop import create_interop, FormatType\n\n# Create an engine\nengine = create_interop()\n\n# CDA section entries in dictionary format (@ is used to represent XML attributes)\ncda_section_entries = {\n    \"problems\": {\n        \"act\": {\n            \"@classCode\": \"ACT\",\n            \"@moodCode\": \"EVN\"\n            ...\n        }\n    }\n}\n\n# Generate FHIR resources\nfhir_generator = engine.fhir_generator\nfhir_resources = fhir_generator.transform(cda_section_entries, src_format=FormatType.CDA)\n</code></pre> View full input data <p>The FHIR generator transforms this structure into a FHIR Condition resource by:</p> <ol> <li>Identifying the section type (\"problems\") from the dictionary key</li> <li>Looking up the corresponding FHIR resource type (\"Condition\") from configuration</li> <li>Extracting relevant data from the nested structure (codes, dates, statuses)</li> <li>Using templates to map specific fields to FHIR attributes</li> </ol> <pre><code>{\n  \"problems\": [{\n    'act': {\n      '@classCode': 'ACT',\n      '@moodCode': 'EVN',\n      'templateId': [\n        {'@root': '2.16.840.1.113883.10.20.1.27'},\n        {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5.1'},\n        {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5.2'},\n        {'@root': '2.16.840.1.113883.3.88.11.32.7'},\n        {'@root': '2.16.840.1.113883.3.88.11.83.7'}\n      ],\n      'id': {\n        '@extension': '51854-concern',\n        '@root': '1.2.840.114350.1.13.525.3.7.2.768076'\n      },\n      'code': {\n        '@nullFlavor': 'NA'\n      },\n      'text': {\n        'reference': {'@value': '#problem12'}\n      },\n      'statusCode': {\n        '@code': 'active'\n      },\n      'effectiveTime': {\n        'low': {'@value': '20210317'}\n      },\n      'entryRelationship': {\n        '@typeCode': 'SUBJ',\n        '@inversionInd': False,\n        'observation': {\n          '@classCode': 'OBS',\n          '@moodCode': 'EVN',\n          'templateId': [\n            {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5'},\n            {'@root': '2.16.840.1.113883.10.20.1.28'}\n          ],\n          'id': {\n            '@extension': '51854',\n            '@root': '1.2.840.114350.1.13.525.3.7.2.768076'\n          },\n          'code': {\n            '@code': '64572001',\n            '@codeSystem': '2.16.840.1.113883.6.96',\n            '@codeSystemName': 'SNOMED CT'\n          },\n          'text': {\n            'reference': {'@value': '#problem12name'}\n          },\n          'statusCode': {\n            '@code': 'completed'\n          },\n          'effectiveTime': {\n            'low': {'@value': '20190517'}\n          },\n          'value': {\n            '@code': '38341003',\n            '@codeSystem': '2.16.840.1.113883.6.96',\n            '@codeSystemName': 'SNOMED CT',\n            '@xsi:type': 'CD',\n            '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n            'originalText': {\n              'reference': {'@value': '#problem12name'}\n            }\n          },\n          'entryRelationship': {\n            '@typeCode': 'REFR',\n            '@inversionInd': False,\n            'observation': {\n              '@classCode': 'OBS',\n              '@moodCode': 'EVN',\n              'templateId': [\n                {'@root': '2.16.840.1.113883.10.20.1.50'},\n                {'@root': '2.16.840.1.113883.10.20.1.57'},\n                {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.1.1'}\n              ],\n              'code': {\n                '@code': '33999-4',\n                '@codeSystem': '2.16.840.1.113883.6.1',\n                '@displayName': 'Status'\n              },\n              'statusCode': {\n                '@code': 'completed'\n              },\n              'effectiveTime': {\n                'low': {'@value': '20190517'}\n              },\n              'value': {\n                '@code': '55561003',\n                '@codeSystem': '2.16.840.1.113883.6.96',\n                '@xsi:type': 'CE',\n                '@displayName': 'Active',\n                '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'\n              }\n            }\n          }\n        }\n      }\n    }\n  }]\n}\n</code></pre>"},{"location":"reference/interop/generators/#creating-a-custom-generator","title":"Creating a Custom Generator","text":"<p>You can create a custom generator by implementing a class that inherits from <code>BaseGenerator</code> and registering it with the engine (this will replace the default generator for the format type):</p> <pre><code>from healthchain.interop import create_interop, FormatType\nfrom healthchain.interop.config_manager import InteropConfigManager\nfrom healthchain.interop.template_registry import TemplateRegistry\nfrom healthchain.interop.generators import BaseGenerator\n\nfrom typing import List\nfrom fhir.resources.resource import Resource\n\n\nclass CustomGenerator(BaseGenerator):\n    def __init__(self, config: InteropConfigManager, templates: TemplateRegistry):\n        super().__init__(config, templates)\n\n    def transform(self, resources: List[Resource], **kwargs) -&gt; str:\n        # Generate output from FHIR resources\n        return \"Custom output format\"\n\n# Register the custom generator with the engine\nengine = create_interop()\nengine.register_generator(FormatType.CDA, CustomGenerator(engine.config, engine.template_registry))\n</code></pre>"},{"location":"reference/interop/interop/","title":"Interoperability Engine","text":"<p>The HealthChain Interop Engine provides a robust and customizable framework for converting between different HL7 healthcare data formats, including:</p> <ul> <li>FHIR</li> <li>CDA</li> <li>HL7v2 (Coming soon)</li> </ul>"},{"location":"reference/interop/interop/#architecture","title":"Architecture","text":"<p>The interoperability module is built around a central <code>InteropEngine</code> that coordinates format conversion through specialized parsers and generators:</p> <pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 InteropEngine \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502                 \u2502                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Parsers      \u2502 \u2502 Templates \u2502 \u2502     Generators    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                 \u2502                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   - CDA Parser    \u2502 \u2502 Registry  \u2502 \u2502   - CDA Generator \u2502\n\u2502   - HL7v2 Parser  \u2502 \u2502 Renderer  \u2502 \u2502  - FHIR Generator \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 - HL7v2 Generator \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/interop/interop/#key-components","title":"Key Components","text":"Component Description InteropEngine Core engine that manages the conversion process Templates Liquid-based template system for customizing output syntactic generation Mappings Mappings between different terminology systems Configuration Configuration system for controlling engine behavior and template variations Parsers Components for parsing different healthcare formats Generators Components for generating output in different formats"},{"location":"reference/interop/interop/#basic-usage","title":"Basic Usage","text":"<p>FHIR serves as the de facto modern data standard in HealthChain and in the world of healthcare more broadly, therefore everything converts to and from FHIR resources.</p> <p>The main conversion methods are (hold on to your hats):</p> <ul> <li><code>.to_fhir()</code> - Convert a source format to FHIR resources</li> <li><code>.from_fhir()</code> - Convert FHIR resources to a destination format</li> </ul> <pre><code>from healthchain.interop import create_interop, FormatType\n\n# Create an interoperability engine\nengine = create_interop()\n\n# Convert CDA XML to FHIR resources\nwith open('patient_ccd.xml', 'r') as f:\n    cda_xml = f.read()\n\nfhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")\n\n# Convert FHIR resources back to CDA\ncda_document = engine.from_fhir(fhir_resources, dest_format=\"cda\")\n</code></pre>"},{"location":"reference/interop/interop/#custom-configs","title":"Custom Configs","text":"<p>The default templates that come with the package are limited to problems, medications, and notes and are meant for basic testing and prototyping. Use the <code>healthchain init-configs</code> command to create editable configuration templates:</p> <pre><code># Create editable configuration templates\nhealthchain init-configs ./my_configs\n</code></pre> <p>Then use the <code>config_dir</code> parameter to specify the path to your custom configs:</p> <pre><code># Use your customized configs\nengine = create_interop(config_dir=\"./my_configs\")\n\n# Now you can customize:\n# \u2022 Add experimental features (allergies, procedures)\n# \u2022 Modify terminology mappings (SNOMED, LOINC codes)\n# \u2022 Customize templates for your organization's CDA format\n# \u2022 Configure validation rules and environments\n</code></pre>"},{"location":"reference/interop/interop/#customization-points","title":"Customization Points","text":"<p>The interoperability module is designed with extensibility at its core. You can customize and extend the framework in several ways:</p>"},{"location":"reference/interop/interop/#custom-parsers","title":"Custom Parsers","text":"<p>Parsers convert source formats (CDA or HL7v2) into mapped dictionaries that can be processed by generators:</p> <pre><code># Register a custom parser with the engine\nengine.register_parser(FormatType.CDA, CustomCDAParser(engine.config))\n</code></pre> <p>For detailed implementation examples, see Creating a Custom Parser.</p>"},{"location":"reference/interop/interop/#custom-generators","title":"Custom Generators","text":"<p>Generators transform mapped dictionaries into target formats:</p> <pre><code># Register a custom generator with the engine\nengine.register_generator(FormatType.CDA,\n                         CustomCDAGenerator(engine.config, engine.template_registry))\n</code></pre> <p>For detailed implementation examples, see Creating a Custom Generator.</p>"},{"location":"reference/interop/interop/#environment-configuration","title":"Environment Configuration","text":"<p>You can customize the engine's behavior for different environments:</p> <pre><code># Create an engine with specific environment settings\nengine = create_interop(\n    config_dir=Path(\"/path/to/custom/configs\"),\n    validation_level=\"warn\",  # Options: strict, warn, ignore\n    environment=\"production\"  # Options: development, testing, production\n)\n\n# Change environment settings after creation\nengine.config.set_environment(\"testing\")\nengine.config.set_validation_level(\"strict\")\n\n# Access environment-specific configuration\nid_prefix = engine.config.get_config_value(\"defaults.common.id_prefix\")\n</code></pre> <p>Environment-specific configurations are loaded from the <code>environments/</code> directory and can override default settings for different deployment scenarios.</p>"},{"location":"reference/interop/interop/#template-customization","title":"Template Customization","text":"<p>The template system uses Liquid templates to generate output formats. You can:</p> <ol> <li>Override existing templates by placing custom versions in the configured template directory</li> <li>Add new templates for custom formats or content types</li> <li>Extend the template system with custom logic via filters</li> </ol> <p>For more details on extending the system, check out the Templates and Configuration pages.</p>"},{"location":"reference/interop/mappings/","title":"Mappings","text":"<p>Mapping tables are used to translate between different healthcare terminology systems, code sets, and formats. These mappings are essential for semantic interoperability between CDA, HL7v2, and FHIR formats where the same concept may be represented differently.</p>"},{"location":"reference/interop/mappings/#mapping-types","title":"Mapping Types","text":"<p>The system supports several types of mappings:</p> Mapping Type Description Example Code Systems Maps between URI-based systems (FHIR) and OID-based systems (CDA) SNOMED CT: <code>http://snomed.info/sct</code> \u2194 <code>2.16.840.1.113883.6.96</code> Status Codes Maps status codes between formats <code>active</code> \u2194 <code>55561003</code> Severity Codes Maps severity designations between formats <code>moderate</code> \u2194 <code>6736007</code>"},{"location":"reference/interop/mappings/#mapping-directory-structure","title":"Mapping Directory Structure","text":"<p>Mappings are stored in YAML files in the <code>configs/mappings/</code> directory, organized by the formats they translate between:</p> <pre><code>configs/mappings/\n\u251c\u2500\u2500 cda_fhir/\n\u2502   \u251c\u2500\u2500 systems.yaml\n\u2502   \u251c\u2500\u2500 status_codes.yaml\n\u2502   \u2514\u2500\u2500 severity_codes.yaml\n\u251c\u2500\u2500 hl7v2_fhir/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"reference/interop/mappings/#mapping-file-format","title":"Mapping File Format","text":""},{"location":"reference/interop/mappings/#code-systems-mapping","title":"Code Systems Mapping","text":"<p>The <code>systems.yaml</code> file maps between FHIR URI-based code systems and CDA OID-based systems:</p> <pre><code># mappings/cda_fhir/systems.yaml\nsystems:\n  \"http://snomed.info/sct\":\n    oid: \"2.16.840.1.113883.6.96\"\n    name: \"SNOMED CT\"\n\n  \"http://loinc.org\":\n    oid: \"2.16.840.1.113883.6.1\"\n    name: \"LOINC\"\n\n  \"http://www.nlm.nih.gov/research/umls/rxnorm\":\n    oid: \"2.16.840.1.113883.6.88\"\n    name: \"RxNorm\"\n</code></pre>"},{"location":"reference/interop/mappings/#status-codes-mapping","title":"Status Codes Mapping","text":"<p>The <code>status_codes.yaml</code> file maps between different formats' status codes:</p> <pre><code># mappings/cda_fhir/status_codes.yaml\n# Clinical status codes (CDA to FHIR)\n\"55561003\":\n  code: \"active\"\n  display: \"Active\"\n\n\"73425007\":\n  code: \"inactive\"\n  display: \"Inactive\"\n\n\"413322009\":\n  code: \"resolved\"\n  display: \"Resolved\"\n</code></pre>"},{"location":"reference/interop/mappings/#severity-codes-mapping","title":"Severity Codes Mapping","text":"<p>The <code>severity_codes.yaml</code> file maps severity designations between formats:</p> <pre><code># mappings/cda_fhir/severity_codes.yaml\n# Allergy and reaction severity codes (CDA to FHIR)\n\"255604002\":  # Mild (SNOMED CT)\n  code: \"mild\"\n  display: \"Mild\"\n\n\"6736007\":  # Moderate (SNOMED CT)\n  code: \"moderate\"\n  display: \"Moderate\"\n\n\"24484000\":  # Severe (SNOMED CT)\n  code: \"severe\"\n  display: \"Severe\"\n</code></pre>"},{"location":"reference/interop/mappings/#using-mappings","title":"Using Mappings","text":"<p>The <code>InteropEngine</code> automatically loads and applies mappings during the conversion process. You can also access mappings directly through the configuration manager:</p> <pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n\n# Get all mappings\nmappings = engine.config.get_mappings()\n\n# Access specific mapping\nsystems = mappings.get(\"cda_fhir\", {}).get(\"systems\", {})\nsnomed = systems.get(\"http://snomed.info/sct\", {})\nsnomed_oid = snomed.get(\"oid\")  # \"2.16.840.1.113883.6.96\"\n</code></pre>"},{"location":"reference/interop/mappings/#template-filters-for-mappings","title":"Template Filters for Mappings","text":"<p>The mapping system provides several Liquid template filters to help with code translation:</p> Filter Description Example Usage <code>map_system</code> Maps between CDA and FHIR code systems <code>{{ \"http://snomed.info/sct\" | map_system: 'fhir_to_cda' }}</code> <code>map_status</code> Maps between CDA and FHIR status codes <code>{{ \"active\" | map_status: 'fhir_to_cda' }}</code> <code>map_severity</code> Maps between CDA and FHIR severity codes <code>{{ \"moderate\" | map_severity: 'fhir_to_cda' }}</code> <p>Example in a template:</p> <pre><code>{\n  \"code\": {\n    \"@codeSystem\": \"{{ resource.code.coding[0].system | map_system: 'fhir_to_cda' }}\",\n    \"@code\": \"{{ resource.code.coding[0].code }}\"\n  }\n}\n</code></pre>"},{"location":"reference/interop/mappings/#adding-custom-mappings","title":"Adding Custom Mappings","text":"<p>To add new mappings:</p> <ol> <li>Create or modify the appropriate YAML file in the <code>configs/mappings/</code> directory</li> <li>Follow the structure of existing mapping files</li> <li>The changes will be automatically loaded the next time the <code>InteropEngine</code> is initialized</li> </ol> <p>For more complex mapping needs, you can create custom mapping filters:</p> <pre><code>def custom_map_filter(value, mappings, direction=\"fhir_to_cda\"):\n    # Custom mapping logic here\n    return mapped_value\n\n# Register with the template registry\nengine.template_registry.add_filter(\"custom_map\", custom_map_filter)\n</code></pre>"},{"location":"reference/interop/mappings/#related-documentation","title":"Related Documentation","text":"<ul> <li>Configuration Management</li> <li>Templates</li> <li>Custom Filters</li> </ul>"},{"location":"reference/interop/parsers/","title":"Parsers","text":"<p>Parsers are responsible for extracting structured data from various healthcare document formats. The module includes built-in parsers for common formats like CDA and HL7v2.</p>"},{"location":"reference/interop/parsers/#available-parsers","title":"Available Parsers","text":"Parser Description <code>CDAParser</code> Parses CDA XML documents into structured data <code>HL7v2Parser</code> Parses HL7v2 messages into structured data"},{"location":"reference/interop/parsers/#cda-parser","title":"CDA Parser","text":"<p>The CDA Parser extracts data from Clinical Document Architecture (CDA) XML documents based on configured section identifiers.</p> <p>Internally, it uses xmltodict to parse the XML into a dictionary, validates the dictionary with Pydantic, and then maps each entry to the section keys. See Working with xmltodict in HealthChain for more details.</p> <p>Each extracted entry should be mapped to the name of the corresponding configuration file, which will be used as the <code>section_key</code>. The configuration file contains information about the section identifiers that are used to extract the correct section entries.</p> <p>The input data should be in the format <code>{&lt;section_key&gt;}: {&lt;section_entries&gt;}</code>.</p> <p>(Full Documentation on Configuration)</p>"},{"location":"reference/interop/parsers/#usage-examples","title":"Usage Examples","text":"<pre><code>from healthchain.interop import create_interop, FormatType\n\n# Create an engine\nengine = create_interop()\n\n# Parse a CDA document directly to FHIR\nwith open(\"tests/data/test_cda.xml\", \"r\") as f:\n    cda_xml = f.read()\n\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Access the CDA parser directly (advanced use case)\ncda_parser = engine.cda_parser\nsections = cda_parser.parse_document(cda_xml)\n\n# Extract problems section data\nproblems = sections.get(\"problems\", [])\n# parsed CDA section entry in xmltodict format - note that '@' is used to access attributes\n# {\n#   \"act\": {\n#     \"@classCode\": \"ACT\",\n#     \"@moodCode\": \"EVN\",\n#     ...\n#   }\n# }\n</code></pre> View full parsed output <p>This data structure represents a problem (condition) entry from a CDA document, containing:</p> <ul> <li>A problem act with template IDs and status</li> <li>An observation with clinical details (SNOMED code 38341003 - Hypertension)</li> <li>Status information (Active)</li> <li>Dates (onset date: May 17, 2019)</li> </ul> <p>Note how the original XML structure is preserved in dictionary format with '@' used to denote attributes:</p> <pre><code>[{\n  'act': {\n    '@classCode': 'ACT',\n    '@moodCode': 'EVN',\n    'templateId': [\n      {'@root': '2.16.840.1.113883.10.20.1.27'},\n      {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5.1'},\n      {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5.2'},\n      {'@root': '2.16.840.1.113883.3.88.11.32.7'},\n      {'@root': '2.16.840.1.113883.3.88.11.83.7'}\n    ],\n    'id': {\n      '@extension': '51854-concern',\n      '@root': '1.2.840.114350.1.13.525.3.7.2.768076'\n    },\n    'code': {\n      '@nullFlavor': 'NA'\n    },\n    'text': {\n      'reference': {'@value': '#problem12'}\n    },\n    'statusCode': {\n      '@code': 'active'\n    },\n    'effectiveTime': {\n      'low': {'@value': '20210317'}\n    },\n    'entryRelationship': {\n      '@typeCode': 'SUBJ',\n      '@inversionInd': False,\n      'observation': {\n        '@classCode': 'OBS',\n        '@moodCode': 'EVN',\n        'templateId': [\n          {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5'},\n          {'@root': '2.16.840.1.113883.10.20.1.28'}\n        ],\n        'id': {\n          '@extension': '51854',\n          '@root': '1.2.840.114350.1.13.525.3.7.2.768076'\n        },\n        'code': {\n          '@code': '64572001',\n          '@codeSystem': '2.16.840.1.113883.6.96',\n          '@codeSystemName': 'SNOMED CT'\n        },\n        'text': {\n          'reference': {'@value': '#problem12name'}\n        },\n        'statusCode': {\n          '@code': 'completed'\n        },\n        'effectiveTime': {\n          'low': {'@value': '20190517'}\n        },\n        'value': {\n          '@code': '38341003',\n          '@codeSystem': '2.16.840.1.113883.6.96',\n          '@codeSystemName': 'SNOMED CT',\n          '@xsi:type': 'CD',\n          '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n          'originalText': {\n            'reference': {'@value': '#problem12name'}\n          }\n        },\n        'entryRelationship': {\n          '@typeCode': 'REFR',\n          '@inversionInd': False,\n          'observation': {\n            '@classCode': 'OBS',\n            '@moodCode': 'EVN',\n            'templateId': [\n              {'@root': '2.16.840.1.113883.10.20.1.50'},\n              {'@root': '2.16.840.1.113883.10.20.1.57'},\n              {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.1.1'}\n            ],\n            'code': {\n              '@code': '33999-4',\n              '@codeSystem': '2.16.840.1.113883.6.1',\n              '@displayName': 'Status'\n            },\n            'statusCode': {\n              '@code': 'completed'\n            },\n            'effectiveTime': {\n              'low': {'@value': '20190517'}\n            },\n            'value': {\n              '@code': '55561003',\n              '@codeSystem': '2.16.840.1.113883.6.96',\n              '@xsi:type': 'CE',\n              '@displayName': 'Active',\n              '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'\n            }\n          }\n        }\n      }\n    }\n  }\n}]\n</code></pre>"},{"location":"reference/interop/parsers/#section-configuration","title":"Section Configuration","text":"<p>Sections make up the structure of a CDA document. The CDA parser uses <code>identifiers</code> in the section configuration file to determine which sections to extract and map to FHIR resources. Each section is identified by a template ID, code, or both:</p> <pre><code># Example section configuration\ncda:\n  sections:\n    problems:\n      identifiers:\n        template_id: \"2.16.840.1.113883.10.20.1.11\"\n        code: \"11450-4\"\n      resource: \"Condition\"\n</code></pre>"},{"location":"reference/interop/parsers/#creating-a-custom-parser","title":"Creating a Custom Parser","text":"<p>You can create a custom parser by implementing a class that inherits from <code>BaseParser</code> and registering it with the engine (this will replace the default parser for the format type):</p> <pre><code>from healthchain.interop import create_interop, FormatType\nfrom healthchain.interop.config_manager import InteropConfigManager\nfrom healthchain.interop.parsers.base import BaseParser\n\nclass CustomParser(BaseParser):\n    def __init__(self, config: InteropConfigManager):\n        super().__init__(config)\n\n    def from_string(self, data: str) -&gt; dict:\n        # Parse the document and return structured data\n        return {\"structured_data\": \"example\"}\n\n# Register the custom parser with the engine\nengine = create_interop()\nengine.register_parser(FormatType.CDA, CustomParser(engine.config))\n</code></pre>"},{"location":"reference/interop/templates/","title":"Templates","text":"<p>The HealthChain interoperability module uses a template system based on Liquid, an open-source templating language to generate healthcare data in various formats. This allows for flexible and customizable document generation on a syntactic level.</p>"},{"location":"reference/interop/templates/#template-directory-structure","title":"Template Directory Structure","text":"<p>Templates are stored in the <code>configs/templates</code> directory by default. The directory structure follows a convention based on format and resource type:</p> <p><pre><code>templates/\n\u251c\u2500\u2500 cda_fhir/\n\u2502   \u251c\u2500\u2500 document.liquid\n\u2502   \u251c\u2500\u2500 section.liquid\n\u2502   \u251c\u2500\u2500 problem_entry.liquid\n\u2502   \u251c\u2500\u2500 medication_entry.liquid\n\u2502   \u2514\u2500\u2500 allergy_entry.liquid\n\u251c\u2500\u2500 cda_fhir/\n\u2502   \u251c\u2500\u2500 condition.liquid\n\u2502   \u251c\u2500\u2500 medication_statement.liquid\n\u2502   \u2514\u2500\u2500 allergy_intolerance.liquid\n\u251c\u2500\u2500 hl7v2_fhir/\n\u2502   \u251c\u2500\u2500 adt_a01.liquid\n\u2502   \u251c\u2500\u2500 oru_r01.liquid\n\u2502   \u2514\u2500\u2500 obx_r01.liquid\n\u251c\u2500\u2500 fhir_hl7v2/\n\u2502   \u251c\u2500\u2500 patient_adt.liquid\n\u2502   \u251c\u2500\u2500 encounter_adt.liquid\n\u2502   \u2514\u2500\u2500 observation_oru.liquid\n</code></pre> Templates can be accessed through the <code>TemplateRegistry</code>:</p> <ol> <li>Using their full path within the template directory without extension as a key: <code>cda_fhir/document</code></li> <li>Using just their stem name as a key: <code>document</code></li> </ol> <p>Using full paths is recommended for clarity and to avoid confusion when templates with the same filename exist in different directories. However, both methods will work as long as template names are unique across all directories and matches the template name in the configuration files.</p>"},{"location":"reference/interop/templates/#default-templates","title":"Default Templates","text":"<p>HealthChain provides default templates for the transformation of Problems, Medications, and Notes sections in a Continuity of Care (CCD) CDA to FHIR and the reverse. They are configured to work out of the box with the default configuration and the example CDAs here.</p> <p>You are welcome to modify these templates at your own discretion or use them as a starting reference point for your writing your own templates. Always verify that templates work for your use case.</p> <p>Note: Some templates are experimental and not included in the default configs. See Experimental Templates for details on templates under development.</p> CDA Section FHIR Resource Problems Condition Medications MedicationStatement Notes DocumentReference <p>CDA to FHIR templates:</p> CDA Section Default Template Problems <code>fhir_cda/problem_entry.liquid</code> Medications <code>fhir_cda/medication_entry.liquid</code> Notes <code>fhir_cda/note_entry.liquid</code> <p>FHIR to CDA templates:</p> Resource Type Default Template Condition <code>cda_fhir/condition.liquid</code> MedicationStatement <code>cda_fhir/medication_statement.liquid</code> DocumentReference <code>cda_fhir/document_reference.liquid</code>"},{"location":"reference/interop/templates/#template-format","title":"Template Format","text":"<p>Templates use Python Liquid syntax with additional custom filters provided by the interoperability module. Note that HealthChain uses xmltodict to parse and unparse XML documents into dictionaries and vice versa, therefore templates should be written in JSON format that is compatible with <code>xmltodict</code>. For more information, see the Working with xmltodict in HealthChain guide (it's not that bad, I promise).</p> <p>Example template for a CDA to FHIR conversion:</p> <pre><code>{\n  \"act\": {\n    \"@classCode\": \"ACT\",\n    \"@moodCode\": \"EVN\",\n    \"templateId\": [\n    {% for template_id in config.template.act.template_id %}\n      {\"@root\": \"{{template_id}}\"} {% if forloop.last != true %},{% endif %}\n    {% endfor %}\n    ],\n    {% if resource.id %}\n    \"id\": {\"@root\": \"{{ resource.id }}\"},\n    {% endif %}\n    \"code\": {\"@nullFlavor\": \"NA\"},\n    \"statusCode\": {\n      \"@code\": \"{{ config.template.act.status_code }}\"\n    }\n  }\n}\n</code></pre>"},{"location":"reference/interop/templates/#using-the-template-system","title":"Using the Template System","text":""},{"location":"reference/interop/templates/#interoperability-engine-api","title":"Interoperability Engine API","text":"<p>The Interoperability Engine API provides a high-level interface (<code>.to_fhir()</code> and <code>.from_fhir()</code>) for transforming healthcare data between different formats using templates.</p> <pre><code>from healthchain.interop import create_interop, FormatType\nfrom healthchain.fhir import create_condition\n\n# Create an engine\nengine = create_interop()\n\n# Create a FHIR resource\ncondition = create_condition(\n  code=\"38341003\",\n  system=\"http://snomed.info/sct\",\n  display=\"Hypertension\",\n  subject=\"Patient/123\",\n  clinical_status=\"active\"\n)\n\n# Generate CDA from FHIR resources\ncda_xml = engine.from_fhir([condition], dest_format=FormatType.CDA)\n\n# Generate FHIR from CDA\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n</code></pre>"},{"location":"reference/interop/templates/#direct-template-access-advanced","title":"Direct Template Access (Advanced)","text":"<p>For advanced use cases, you can access the template system directly:</p> <pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n\n# Access the template registry\nregistry = engine.template_registry\n\n# Get a template by name\ntemplate = registry.get_template(\"cda_fhir/condition\")\n</code></pre>"},{"location":"reference/interop/templates/#creating-custom-templates","title":"Creating Custom Templates","text":"<p>To create a custom template:</p> <ol> <li>Create a new file in the appropriate template directory. Use a descriptive name for the template, e.g. <code>cda_fhir/procedure.liquid</code>.</li> <li>Create a template using Python Liquid syntax with available filters if needed.</li> <li>Access source data properties using dot notation. (e.g. <code>entry.act.id</code>)</li> <li>Access configuration values (see Configuration) using the <code>config</code> object.</li> </ol> <p>For example, to create a custom template to transform a CDA section into a FHIR Procedure resource:</p> <pre><code>&lt;!-- configs/templates/cda_fhir/procedure.liquid --&gt;\n{\n  \"procedure\": {\n    \"@classCode\": \"PROC\",\n    \"@moodCode\": \"EVN\",\n    \"templateId\": {\n      \"@root\": \"2.16.840.1.113883.10.20.1.29\"\n    },\n    \"id\": {\n      \"@root\": \"{{ entry.act.id | generate_id }}\"\n    },\n    \"code\": {\n      \"@code\": \"{{ entry.act.entryRelationship.observation.value['@code'] }}\",\n      \"@displayName\": \"{{ entry.act.entryRelationship.observation.value['@displayName'] }}\",\n      \"@codeSystem\": \"{{ entry.act.entryRelationship.observation.value['@codeSystem'] | map_system: 'fhir_to_cda' }}\",\n    },\n    \"statusCode\": {\n      \"@code\": \"{{ entry.act.statusCode['@code'] | map_status: 'fhir_to_cda' }}\"\n    },\n    \"effectiveTime\": {\n      \"@value\": \"{{ entry.act.effectiveTime['@value'] | format_date }}\"\n    },\n    {% if entry.act.performer %}\n    \"performer\": {\n      \"assignedEntity\": {\n        \"id\": {\n          \"@root\": \"{{ entry.act.performer[0].actor.reference }}\"\n        }\n      }\n    }\n    {% endif %}\n  }\n}\n</code></pre>"},{"location":"reference/interop/templates/#custom-template-filters","title":"Custom Template Filters","text":"<p>The template system provides several custom filters for common healthcare document transformation tasks:</p> Filter Description <code>map_system</code> Maps between CDA and FHIR code systems <code>map_status</code> Maps between CDA and FHIR status codes <code>map_severity</code> Maps between CDA and FHIR severity codes <code>format_date</code> Formats a date in the correct format for the output document <code>format_timestamp</code> Formats a timestamp or uses current time <code>generate_id</code> Generates an ID or uses provided value <code>to_json</code> Converts object to JSON string <code>extract_effective_period</code> Extracts effective period data from CDA effectiveTime elements <code>extract_effective_timing</code> Extracts timing data from effectiveTime elements <code>extract_clinical_status</code> Extracts clinical status from an observation <code>clean_empty</code> Recursively removes empty values from dictionaries and lists <code>to_base64</code> Encodes text to base64 <code>from_base64</code> Decodes base64 to text <code>xmldict_to_html</code> Converts xmltodict format to HTML string"},{"location":"reference/interop/templates/#using-filters","title":"Using Filters","text":"<p><pre><code>&lt;!-- Map a system --&gt;\n{{ resource.code.coding[0].system | map_system: 'fhir_to_cda' }}\n\n&lt;!-- Base64 encoding and decoding --&gt;\n{{ \"Hello World\" | to_base64 }}\n&lt;!-- Outputs: SGVsbG8gV29ybGQ= --&gt;\n\n{{ \"SGVsbG8gV29ybGQ=\" | from_base64 }}\n&lt;!-- Outputs: Hello World --&gt;\n\n&lt;!-- Convert XML dictionary to HTML --&gt;\n{% assign xml_dict = {'div': {'p': 'Hello', '@class': 'note'}} %}\n{{ xml_dict | xmldict_to_html }}\n&lt;!-- Outputs: &lt;div&gt;&lt;p class=\"note\"&gt;Hello&lt;/p&gt;&lt;/div&gt; --&gt;\n</code></pre> For more information on using filters, see Liquid's official documentation.</p>"},{"location":"reference/interop/templates/#adding-custom-filters","title":"Adding Custom Filters","text":"<p>You can add custom filters to the template system:</p> <pre><code>from healthchain.interop import create_interop\n\ndef custom_filter(value):\n    return f\"CUSTOM:{value}\"\n\n# Create an engine\nengine = create_interop()\n\n# Add a custom filter\nengine.template_registry.add_filter(\"custom\", custom_filter)\n</code></pre>"},{"location":"reference/interop/xmltodict/","title":"Working with xmltodict in HealthChain","text":"<p>The HealthChain interoperability engine uses xmltodict to convert between XML and Python dictionaries. This guide explains key conventions to be aware of when working with the parsed data.</p> <p>Why use <code>xmltodict</code>? You say, Why not use the <code>lxml</code> or <code>xml.etree.ElementTree</code> or some other decent library so you can work on the XML tree directly?</p> <p>There are two main reasons:</p> <ul> <li> <p>HealthChain uses Pydantic models for validation and type checking extensively, which works best with JSON-able data. We wanted to keep everything in modern Python ecosystem whilst still being able to work with XML, which is still a very common format in healthcare</p> </li> <li> <p>Developer experience: it's just easier to work with JSON than XML trees in Python \ud83e\udd37\u200d\u2640\ufe0f</p> </li> </ul> <p>The flow roughly looks like this:</p> <pre><code>XML \u2194 Dictionary with @ prefixes \u2194 Pydantic Model\n</code></pre> <p>Still with me? Cool. Let's dive into the key conventions to be aware of when working with the parsed data.</p>"},{"location":"reference/interop/xmltodict/#key-conventions","title":"Key Conventions","text":""},{"location":"reference/interop/xmltodict/#attribute-prefixes","title":"Attribute Prefixes","text":"<p>XML attributes are prefixed with <code>@</code>: <pre><code>&lt;code code=\"55607006\" displayName=\"Problem\"/&gt;\n</code></pre> becomes: <pre><code>{\n    \"code\": {\n        \"@code\": \"55607006\",\n        \"@displayName\": \"Problem\"\n    }\n}\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#text-content","title":"Text Content","text":"<p>Text content of elements is represented with <code>#text</code>: <pre><code>&lt;displayName&gt;Hypertension&lt;/displayName&gt;\n</code></pre> becomes: <pre><code>{\n    \"displayName\": \"Hypertension\"\n}\n</code></pre> or for mixed content: <pre><code>&lt;text&gt;Some &lt;b&gt;bold&lt;/b&gt; text&lt;/text&gt;\n</code></pre> becomes: <pre><code>{\n    \"text\": {\n        \"#text\": \"Some  text\",\n        \"b\": \"bold\"\n    }\n}\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#lists-vs-single-items","title":"Lists vs Single Items","text":"<p>A collection of elements with the same name becomes a list: <pre><code>&lt;component&gt;\n  &lt;section&gt;...&lt;/section&gt;\n&lt;/component&gt;\n&lt;component&gt;\n  &lt;section&gt;...&lt;/section&gt;\n&lt;/component&gt;\n</code></pre> becomes: <pre><code>{\n    \"component\": [\n        {\"section\": {...}},\n        {\"section\": {...}}\n    ]\n}\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#force-list-parameter","title":"Force List Parameter","text":"<p>When parsing, you can force certain elements to always be lists even when there's only one: <pre><code>xmltodict.parse(xml_string, force_list=('component', 'entry'))\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#namespaces","title":"Namespaces","text":"<p>Namespaces are included in element names: <pre><code>&lt;ns1:element xmlns:ns1=\"http://example.org\"&gt;value&lt;/ns1:element&gt;\n</code></pre> becomes: <pre><code>{\n    \"ns1:element\": {\n        \"@xmlns:ns1\": \"http://example.org\",\n        \"#text\": \"value\"\n    }\n}\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#tips-for-working-with-cda-documents","title":"Tips for Working with CDA Documents","text":"<ul> <li>Remember to use the <code>@</code> prefix for attributes</li> <li>Always check if an element might be a list before accessing it directly</li> <li>In Liquid, use <code>['string']</code> to access attributes with <code>@</code> prefixes. e.g. <code>act.entry.code['@code']</code></li> <li>When generating XML, make sure to include required namespaces</li> </ul>"},{"location":"reference/pipeline/data_container/","title":"Data Container","text":"<p>The <code>healthchain.io.containers</code> module provides FHIR-native containers for healthcare data processing. These containers handle the complexities of clinical data formats while providing a clean Python interface for NLP/ML pipelines.</p>"},{"location":"reference/pipeline/data_container/#datacontainer","title":"DataContainer \ud83d\udce6","text":"<p><code>DataContainer</code> is a generic base class for storing data of any type.</p> <pre><code>from healthchain.io.containers import DataContainer\n\n# Create a DataContainer with string data\ncontainer = DataContainer(\"Some data\")\n\n# Convert to dictionary and JSON\ndata_dict = container.to_dict()\ndata_json = container.to_json()\n\n# Create from dictionary or JSON\ncontainer_from_dict = DataContainer.from_dict(data_dict)\ncontainer_from_json = DataContainer.from_json(data_json)\n</code></pre>"},{"location":"reference/pipeline/data_container/#document","title":"Document \ud83d\udcc4","text":"<p>The <code>Document</code> class is HealthChain's core container for clinical text and structured healthcare data. It handles FHIR resources natively, automatically manages validation and conversion, and integrates seamlessly with NLP models and CDS workflows.</p> <p>Use Document containers for clinical notes, discharge summaries, patient records, and any healthcare data that combines text with structured FHIR resources.</p> Attribute Access Primary Purpose Key Features Common Use Cases FHIR Data <code>doc.fhir</code> Manage clinical data in FHIR format \u2022 Resource bundles\u2022 Clinical lists (problems, meds, allergies)\u2022 Document references\u2022 CDS prefetch \u2022 Store patient records\u2022 Track medical history\u2022 Manage clinical documents NLP <code>doc.nlp</code> Process and analyze text \u2022 Tokenization\u2022 Entity recognition\u2022 Embeddings\u2022 spaCy integration \u2022 Extract medical terms\u2022 Analyze clinical text\u2022 Generate features CDS <code>doc.cds</code> Clinical decision support \u2022 Recommendation cards\u2022 Suggested actions\u2022 Clinical alerts \u2022 Generate alerts\u2022 Suggest interventions\u2022 Guide clinical decisions Model Outputs <code>doc.models</code> Store ML model results \u2022 Multi-framework support\u2022 Task-specific outputs\u2022 Text generation \u2022 Store classifications\u2022 Keep predictions\u2022 Track generations"},{"location":"reference/pipeline/data_container/#fhir-data-docfhir","title":"FHIR Data (<code>doc.fhir</code>)","text":"<p>The FHIR component provides production-ready management of FHIR resources with automatic validation, error handling, and convenient accessors for common clinical workflows:</p> <p>Storage and Management:</p> <ul> <li>Automatic <code>Bundle</code> creation and management</li> <li>Resource type validation</li> <li>Convenient access to common clinical data lists</li> <li>Automatic extraction of <code>OperationOutcome</code> and <code>Provenance</code> resources into <code>doc.fhir.operation_outcomes</code> and <code>doc.fhir.provenances</code> (removed from bundle)</li> </ul> <p>Convenience Accessors:</p> <ul> <li><code>patient</code>: First Patient resource in the bundle, or <code>None</code></li> <li><code>patients</code>: List of Patient resources</li> <li><code>problem_list</code>: List of <code>Condition</code> resources (diagnoses, problems)</li> <li><code>medication_list</code>: List of <code>MedicationStatement</code> resources</li> <li><code>allergy_list</code>: List of <code>AllergyIntolerance</code> resources</li> </ul> <p>Document Reference Management:</p> <ul> <li>Document relationship tracking (parent/child/sibling)</li> <li>Attachment handling with <code>base64</code> encoding</li> <li>Document family retrieval</li> </ul> <p>CDS Support:</p> <ul> <li>Support for CDS Hooks prefetch resources</li> <li>Resource indexing by type</li> </ul> <p>Example: Clinical Documentation Workflow</p> <pre><code>from healthchain.io import Document\nfrom healthchain.fhir import (\n    create_condition,\n    create_medication_statement,\n    create_document_reference,\n)\n\n# Initialize with clinical text from EHR\ndoc = Document(\"Patient presents with uncontrolled hypertension and Type 2 diabetes\")\n\n# Build problem list with SNOMED CT codes\ndoc.fhir.problem_list = [\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"38341003\",\n        display=\"Hypertension\"\n    ),\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"44054006\",\n        display=\"Type 2 diabetes mellitus\"\n    )\n]\n\n# Document current medications\ndoc.fhir.medication_list = [\n    create_medication_statement(\n        subject=\"Patient/123\",\n        code=\"197361\",\n        display=\"Lisinopril 10 MG\"\n    ),\n    create_medication_statement(\n        subject=\"Patient/123\",\n        code=\"860975\",\n        display=\"Metformin 500 MG\"\n    )\n]\n\n# Track document versions and amendments\ninitial_note = create_document_reference(\n    data=\"Initial assessment: Patient presents with chest pain\",\n    content_type=\"text/plain\",\n    description=\"Initial ED note\"\n)\ninitial_id = doc.fhir.add_document_reference(initial_note)\n\n# Add amended note\namended_note = create_document_reference(\n    data=\"Amended: Patient presents with chest pain, ruling out cardiac etiology\",\n    content_type=\"text/plain\",\n    description=\"Amended ED note\"\n)\namended_id = doc.fhir.add_document_reference(\n    amended_note,\n    parent_id=initial_id,\n    relationship_type=\"replaces\"\n)\n\n# Retrieve document history for audit trail\nfamily = doc.fhir.get_document_reference_family(amended_id)\nprint(f\"Original note: {family['parents'][0].description}\")\n\n# Prepare data for CDS Hooks integration\nprefetch = {\n    \"Condition\": doc.fhir.problem_list,\n    \"MedicationStatement\": doc.fhir.medication_list,\n}\ndoc.fhir.prefetch_resources = prefetch\n\n# CDS service can query prefetch data\nconditions = doc.fhir.get_prefetch_resources(\"Condition\")\nprint(f\"Active conditions: {len(conditions)}\")\n\n# Handle errors and track data provenance\nif doc.fhir.operation_outcomes:\n    for outcome in doc.fhir.operation_outcomes:\n        print(f\"Warning: {outcome.issue[0].diagnostics}\")\n\n# Access patient demographics\nif doc.fhir.patient:\n    print(f\"Patient: {doc.fhir.patient.name[0].given[0]} {doc.fhir.patient.name[0].family}\")\n</code></pre> <p>Technical Notes:</p> <ul> <li>All FHIR resources are validated using fhir.resources</li> <li>Document relationships follow the FHIR DocumentReference.relatesTo standard</li> </ul> <p>Resource Documentation:</p> <ul> <li>FHIR Bundle</li> <li>FHIR DocumentReference</li> <li>FHIR Condition</li> <li>FHIR MedicationStatement</li> <li>FHIR AllergyIntolerance</li> </ul>"},{"location":"reference/pipeline/data_container/#nlp-component-docnlp","title":"NLP Component (<code>doc.nlp</code>)","text":"<p>Process clinical text with medical NLP models and access extracted features:</p> <ul> <li><code>get_tokens()</code>: Tokenized clinical text for downstream processing</li> <li><code>get_entities()</code>: Medical entities with optional CUI codes (SNOMED CT, RxNorm)</li> <li><code>get_embeddings()</code>: Vector representations for similarity search and clustering</li> <li><code>get_spacy_doc()</code>: Direct access to spaCy document for custom processing</li> <li><code>word_count()</code>: Token-based word count</li> </ul> <p>Example: Medical Entity Extraction <pre><code># Extract medical concepts from clinical note\ndoc = Document(\"Patient diagnosed with pneumonia, started on azithromycin\")\n\n# Get medical entities\nentities = doc.nlp.get_entities()\nfor entity in entities:\n    print(f\"{entity.text}: {entity.label_}\")  # \"pneumonia: CONDITION\"\n\n# Access full spaCy document for custom processing\nspacy_doc = doc.nlp.get_spacy_doc()\nfor ent in spacy_doc.ents:\n    if hasattr(ent._, \"cui\"):\n        print(f\"{ent.text} -&gt; SNOMED: {ent._.cui}\")\n</code></pre></p>"},{"location":"reference/pipeline/data_container/#clinical-decision-support-doccds","title":"Clinical Decision Support (<code>doc.cds</code>)","text":"<p>Generate CDS Hooks cards and actions for real-time EHR integration:</p> <ul> <li><code>cards</code>: Clinical recommendation cards displayed in EHR workflows</li> <li><code>actions</code>: Suggested interventions (orders, referrals, documentation)</li> </ul> <p>Example: CDS Hooks Response <pre><code>from healthchain.models import Card, Action\n\n# Generate clinical alert\ndoc.cds.cards = [\n    Card(\n        summary=\"Drug interaction detected\",\n        indicator=\"critical\",\n        detail=\"Warfarin + NSAIDs: Increased bleeding risk\",\n        source={\"label\": \"Clinical Decision Support\"},\n    )\n]\n\n# Suggest action\ndoc.cds.actions = [\n    Action(\n        type=\"create\",\n        description=\"Order CBC to monitor platelets\",\n        resource={\n            \"resourceType\": \"ServiceRequest\",\n            \"code\": {\"text\": \"Complete Blood Count\"}\n        }\n    )\n]\n</code></pre></p>"},{"location":"reference/pipeline/data_container/#model-outputs-docmodels","title":"Model Outputs (<code>doc.models</code>)","text":"<p>Store and retrieve ML model predictions across multiple frameworks:</p> <ul> <li><code>get_output(model_name, task)</code>: Retrieve model predictions by name and task</li> <li><code>get_generated_text(model_name, task)</code>: Extract generated text from LLMs</li> <li>Supports Hugging Face, LangChain, spaCy, and custom models</li> </ul> <p>Example: Multi-Model Pipeline <pre><code># Store classification results\ndoc.models.add_output(\n    model_name=\"clinical_classifier\",\n    task=\"diagnosis_prediction\",\n    output={\"prediction\": \"diabetes\", \"confidence\": 0.95}\n)\n\n# Store LLM summary\ndoc.models.add_output(\n    model_name=\"gpt4\",\n    task=\"summarization\",\n    output=\"Patient presents with classic diabetic symptoms...\"\n)\n\n# Retrieve outputs\ndiagnosis = doc.models.get_output(\"clinical_classifier\", \"diagnosis_prediction\")\nsummary = doc.models.get_generated_text(\"gpt4\", \"summarization\")\n</code></pre></p> <p>Example: Complete Clinical Workflow <pre><code>from healthchain.io import Document\nfrom healthchain.fhir import create_condition\nfrom healthchain.models import Card, Action\n\n# Initialize with clinical note from EHR\ndoc = Document(\"67yo M presents with acute chest pain radiating to left arm, diaphoresis\")\n\n# Process with NLP model\nprint(f\"Clinical note length: {doc.nlp.word_count()} words\")\nentities = doc.nlp.get_entities()\n\n# Extract FHIR conditions from text\nspacy_doc = doc.nlp.get_spacy_doc()\nfor ent in spacy_doc.ents:\n    if ent.label_ == \"CONDITION\" and hasattr(ent._, \"cui\"):\n        doc.fhir.problem_list.append(\n            create_condition(\n                subject=\"Patient/123\",\n                code=ent._.cui,\n                display=ent.text\n            )\n        )\n\n# Or use helper method for automatic extraction\ndoc.update_problem_list_from_nlp()\n\n# Generate CDS alert based on findings\ndoc.cds.cards = [\n    Card(\n        summary=\"STEMI Alert - Activate Cath Lab\",\n        indicator=\"critical\",\n        detail=\"Patient meets criteria for ST-elevation myocardial infarction\",\n        source={\"label\": \"Cardiology Protocol\"},\n    )\n]\n\n# Track model predictions\ndoc.models.add_output(\n    model_name=\"cardiac_risk_model\",\n    task=\"classification\",\n    output={\"risk_level\": \"high\", \"score\": 0.89}\n)\n\n# Access all components\nprint(f\"Problem list: {len(doc.fhir.problem_list)} conditions\")\nprint(f\"CDS cards: {len(doc.cds.cards)} alerts\")\nprint(f\"Risk assessment: {doc.models.get_output('cardiac_risk_model', 'classification')}\")\n</code></pre></p> <p>Document API Reference</p>"},{"location":"reference/pipeline/data_container/#tabular","title":"Tabular \ud83d\udcca","text":"<p>The <code>Tabular</code> class handles structured healthcare data like lab results, patient cohorts, and claims data. It wraps pandas DataFrame with healthcare-specific operations.</p> <p>Example: Patient Cohort Analysis <pre><code>import pandas as pd\nfrom healthchain.io.containers import Tabular\n\n# Load patient cohort data\ndf = pd.DataFrame({\n    'patient_id': ['P001', 'P002', 'P003'],\n    'age': [45, 62, 58],\n    'diagnosis': ['diabetes', 'hypertension', 'diabetes'],\n    'hba1c': [7.2, None, 8.1]\n})\ncohort = Tabular(df)\n\n# Analyze cohort characteristics\nprint(f\"Cohort size: {cohort.row_count()} patients\")\nprint(f\"Average age: {cohort.data['age'].mean():.1f} years\")\nprint(f\"\\nClinical measures:\\n{cohort.describe()}\")\n\n# Filter for diabetic patients\ndiabetic_cohort = cohort.data[cohort.data['diagnosis'] == 'diabetes']\nprint(f\"\\nDiabetic patients: {len(diabetic_cohort)}\")\nprint(f\"Mean HbA1c: {diabetic_cohort['hba1c'].mean():.1f}%\")\n\n# Export for reporting\ncohort.to_csv('patient_cohort_analysis.csv')\n</code></pre></p> <p>Example: Lab Results Processing <pre><code># Load lab results from EHR export\nlabs = Tabular.from_csv('lab_results.csv')\n\nprint(f\"Total lab orders: {labs.row_count()}\")\nprint(f\"Test types: {labs.data['test_name'].nunique()}\")\n\n# Identify abnormal results\nabnormal = labs.data[labs.data['flag'] == 'ABNORMAL']\nprint(f\"Abnormal results: {len(abnormal)} ({len(abnormal)/labs.row_count()*100:.1f}%)\")\n</code></pre></p> <p>These containers provide a consistent, FHIR-aware interface for healthcare data processing throughout HealthChain pipelines, handling validation, conversion, and integration with clinical workflows automatically.</p>"},{"location":"reference/pipeline/pipeline/","title":"Pipeline","text":"<p>HealthChain pipelines enable FHIR-native workflows that integrate directly with EHR systems. Pipelines handle the complexities of healthcare data standards like CDA (Clinical Document Architecture) and FHIR (Fast Healthcare Interoperability Resources), allowing you to focus on building AI models while maintaining production-ready interoperability.</p> <p>You can either use prebuilt pipelines optimized for common clinical workflows, or build custom pipelines from scratch for specialized use cases.</p>"},{"location":"reference/pipeline/pipeline/#prebuilt","title":"Prebuilt \ud83d\udce6","text":"<p>HealthChain comes with a set of prebuilt pipelines that are out-of-the-box implementations of common healthcare data processing tasks:</p> Pipeline Container Use Case Description Example Application MedicalCodingPipeline <code>Document</code> Clinical Documentation Processes clinical notes into FHIR Condition resources with standard medical codes Automated ICD-10/SNOMED CT coding for billing and CDI workflows SummarizationPipeline <code>Document</code> Clinical Decision Support Generates clinical summaries as CDS Hooks cards for EHR integration Real-time discharge summaries in Epic or Cerner workflows <p>Prebuilt pipelines are production-ready workflows that automatically handle FHIR conversion, validation, and formatting. They integrate seamlessly with EHR systems through adapters and gateways, supporting standards like CDS Hooks and FHIR REST APIs.</p> <p>Load your models from Hugging Face, local files, or pipeline objects:</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\n#\u00a0Load from Hugging Face\npipeline = MedicalCodingPipeline.from_model_id(\n    'blaze999/Medical-NER', task=\"token-classification\", source=\"huggingface\"\n)\n# Load from local model files\npipeline = MedicalCodingPipeline.from_local_model(\n    '/path/to/model', source=\"spacy\"\n)\n# Load from a pipeline object\npipeline = MedicalCodingPipeline.load(pipeline_object)\n\n# Simple end-to-end processing\ncda_request = CdaRequest(document=\"&lt;Clinical Document&gt;\")\ncda_response = pipeline.process_request(cda_request)\n\n# Or manual adapter control for more granular control\nfrom healthchain.io import CdaAdapter\nadapter = CdaAdapter()\ndoc = adapter.parse(cda_request)\ndoc = pipeline(doc)\n# Access: doc.fhir.problem_list, doc.fhir.medication_list\nresponse = adapter.format(doc)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#customizing-prebuilt-pipelines","title":"Customizing Prebuilt Pipelines","text":"<p>To customize a prebuilt pipeline, you can use the pipeline management methods to add, remove, and replace components. For example, you may want to change the model being used. [TODO]</p> <p>If you need more control and don't mind writing more code, you can subclass <code>BasePipeline</code> and implement your own pipeline logic.</p> <p>(BasePipeline API Reference)</p>"},{"location":"reference/pipeline/pipeline/#integrations","title":"Integrations","text":"<p>HealthChain offers powerful integrations with popular NLP libraries, enhancing its capabilities and allowing you to build more sophisticated pipelines. These integrations include components for spaCy, Hugging Face Transformers, and LangChain, enabling you to leverage state-of-the-art NLP models and techniques within your HealthChain workflows.</p> <p>Integrations are covered in detail on the Integrations homepage.</p>"},{"location":"reference/pipeline/pipeline/#freestyle","title":"Freestyle \ud83d\udd7a","text":"<p>To build your own pipeline, you can start with an empty pipeline and add components to it. Initialize your pipeline with the appropriate container type, such as <code>Document</code> or <code>Tabular</code>. This is not essential, but it allows the pipeline to enforce type safety (If you don't specify the container type, it will be inferred from the first component added.)</p> <p>You can see the full list of available containers at the Container page.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io.containers import Document\n\npipeline = Pipeline[Document]()\n\n# Or if you live dangerously\n# pipeline = Pipeline()\n</code></pre> <p>To use a built pipeline, compile it by running <code>.build()</code>. This will return a compiled pipeline that you can run on your data.</p> <pre><code>pipe = pipeline.build()\ndoc = pipe(Document(\"Patient is diagnosed with diabetes\"))\n\nprint(doc.entities)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#adding-nodes","title":"Adding Nodes","text":"<p>There are three types of nodes you can add to your pipeline with the method <code>.add_node()</code>:</p> <ul> <li>Inline Functions</li> <li>Components</li> <li>Custom Components</li> </ul>"},{"location":"reference/pipeline/pipeline/#inline-functions","title":"Inline Functions","text":"<p>Inline functions are simple functions that process Document containers. Use them for custom clinical logic without creating full components.</p> <pre><code>from spacy.tokens import Span\n\n@pipeline.add_node\ndef link_snomed_codes(doc: Document) -&gt; Document:\n    \"\"\"Map medical entities to SNOMED CT codes.\"\"\"\n    if not Span.has_extension(\"cui\"):\n        Span.set_extension(\"cui\", default=None)\n\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    # Map clinical terms to SNOMED CT\n    snomed_mapping = {\n        \"hypertension\": \"38341003\",\n        \"diabetes\": \"73211009\",\n        \"pneumonia\": \"233604007\",\n    }\n\n    for ent in spacy_doc.ents:\n        if ent.text.lower() in snomed_mapping:\n            ent._.cui = snomed_mapping[ent.text.lower()]\n\n    return doc\n\n# Equivalent to:\npipeline.add_node(link_snomed_codes)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#components","title":"Components","text":"<p>Components are pre-configured building blocks for common clinical NLP tasks. They handle FHIR conversion, entity extraction, and CDS formatting automatically.</p> <p>See the full list at the Components page.</p> <pre><code>from healthchain.pipeline.components import SpacyNLP, FHIRProblemListExtractor\n\n# Add medical NLP processing\nnlp = SpacyNLP.from_model_id(\"en_core_sci_sm\")\npipeline.add_node(nlp)\n\n# Extract FHIR Condition resources from entities\nextractor = FHIRProblemListExtractor()\npipeline.add_node(extractor)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#custom-components","title":"Custom Components","text":"<p>Custom components implement the <code>BaseComponent</code> interface for reusable clinical processing logic.</p> <pre><code>from healthchain.pipeline import BaseComponent\nfrom healthchain.fhir import create_condition\n\nclass ClinicalEntityLinker(BaseComponent):\n    \"\"\"Links extracted entities to standard medical terminologies.\"\"\"\n\n    def __init__(self, terminology_service_url: str):\n        super().__init__()\n        self.terminology_url = terminology_service_url\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Convert medical entities to FHIR Conditions.\"\"\"\n        spacy_doc = doc.nlp.get_spacy_doc()\n\n        for ent in spacy_doc.ents:\n            if ent._.cui:  # Has SNOMED CT code\n                condition = create_condition(\n                    subject=f\"Patient/{doc.patient_id}\",\n                    code=ent._.cui,\n                    display=ent.text\n                )\n                doc.fhir.problem_list.append(condition)\n\n        return doc\n\n# Add to pipeline\nlinker = ClinicalEntityLinker(terminology_service_url=\"https://terminology.hl7.org/\")\npipeline.add_node(linker)\n</code></pre> <p>(BaseComponent API Reference)</p>"},{"location":"reference/pipeline/pipeline/#working-with-healthcare-data-formats","title":"Working with Healthcare Data Formats \ud83d\udd04","text":"<p>Adapters convert between healthcare formats (CDA, FHIR, CDS Hooks) and HealthChain's internal Document objects, enabling clean separation between ML processing and format handling. This allows your pipeline to work with any healthcare data source while maintaining FHIR-native outputs.</p> <pre><code>from healthchain.io import CdaAdapter, Document\n\nadapter = CdaAdapter()\n\n# Parse healthcare data into Document\ndoc = adapter.parse(cda_request)\n\n# Process with pure pipeline\nprocessed_doc = pipeline(doc)\n\n# Convert back to healthcare format\nresponse = adapter.format(processed_doc)\n</code></pre> <p>You can learn more about adapters at the Adapters documentation page.</p>"},{"location":"reference/pipeline/pipeline/#pipeline-management","title":"Pipeline Management \ud83d\udd28","text":""},{"location":"reference/pipeline/pipeline/#adding","title":"Adding","text":"<p>Use <code>.add_node()</code> to add a component to the pipeline. By default, the component will be added to the end of the pipeline and named as the function name provided.</p> <p>You can specify the position of the component using the <code>position</code> parameter. Available positions are:</p> <ul> <li><code>\"first\"</code></li> <li><code>\"last\"</code></li> <li><code>\"default\"</code></li> <li><code>\"after\"</code></li> <li><code>\"before\"</code></li> </ul> <p>When using <code>\"after\"</code> or <code>\"before\"</code>, you must also specify the <code>reference</code> parameter with the name of the node you want to add the component after or before.</p> <p>You can also specify the <code>stage</code> parameter to add the component to a specific stage group of the pipeline.</p> <pre><code>@pipeline.add_node(position=\"after\", reference=\"SpacyNLP\", stage=\"entity_linking\")\ndef link_snomed_codes(doc: Document) -&gt; Document:\n    \"\"\"Add SNOMED CT codes to extracted medical entities.\"\"\"\n    spacy_doc = doc.nlp.get_spacy_doc()\n    snomed_mapping = {\n        \"hypertension\": \"38341003\",\n        \"diabetes\": \"73211009\",\n    }\n    for ent in spacy_doc.ents:\n        if ent.text.lower() in snomed_mapping:\n            ent._.cui = snomed_mapping[ent.text.lower()]\n    return doc\n</code></pre> <p>You can specify dependencies between components using the <code>dependencies</code> parameter. This is useful if you want to ensure that a component is run after another component.</p> <pre><code>@pipeline.add_node(dependencies=[\"SpacyNLP\"])\ndef extract_medications(doc: Document) -&gt; Document:\n    \"\"\"Extract medication entities and convert to FHIR MedicationStatements.\"\"\"\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    for ent in spacy_doc.ents:\n        if ent.label_ == \"MEDICATION\":\n            # Create FHIR MedicationStatement\n            med_statement = create_medication_statement(\n                subject=f\"Patient/{doc.patient_id}\",\n                code=ent._.cui if hasattr(ent._, \"cui\") else None,\n                display=ent.text\n            )\n            doc.fhir.medication_list.append(med_statement)\n\n    return doc\n</code></pre>"},{"location":"reference/pipeline/pipeline/#removing","title":"Removing","text":"<p>Use <code>.remove()</code> to remove a component from the pipeline.</p> <pre><code>pipeline.remove(\"link_snomed_codes\")\n</code></pre>"},{"location":"reference/pipeline/pipeline/#replacing","title":"Replacing","text":"<p>Use <code>.replace()</code> to replace a component in the pipeline.</p> <pre><code>def enhanced_entity_linking(doc: Document) -&gt; Document:\n    \"\"\"Enhanced entity linking with external terminology service.\"\"\"\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    for ent in spacy_doc.ents:\n        # Call external terminology service for validation\n        validated_code = terminology_service.validate(ent.text)\n        if validated_code:\n            ent._.cui = validated_code\n\n    return doc\n\n# Replace basic linking with enhanced version\npipeline.replace(\"link_snomed_codes\", enhanced_entity_linking)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#inspecting-the-pipeline","title":"Inspecting the Pipeline","text":"<pre><code>print(pipeline)\nprint(pipeline.stages)\n\n# [\"SpacyNLP\", \"ClinicalEntityLinker\", \"FHIRProblemListExtractor\"]\n# preprocessing:\n#   - SpacyNLP\n# entity_linking:\n#   - ClinicalEntityLinker\n# fhir_conversion:\n#   - FHIRProblemListExtractor\n</code></pre>"},{"location":"reference/pipeline/adapters/adapters/","title":"Adapters","text":"<p>Adapters handle conversion between healthcare data formats (CDA, FHIR) and HealthChain's internal <code>Document</code> objects. They enable clean separation between ML processing logic and healthcare format handling, making your pipelines more maintainable and testable.</p> <p>Unlike the legacy connector pattern, adapters are used explicitly and provide clear control over data flow.</p>"},{"location":"reference/pipeline/adapters/adapters/#available-adapters","title":"Available adapters","text":"<p>Adapters parse data from specific healthcare formats into FHIR resources and store them in a <code>Document</code> container for processing.</p> <p>(Document API Reference)</p> Adapter Input Format Output Format FHIR Resources Document Access CdaAdapter <code>CdaRequest</code> <code>CdaResponse</code> DocumentReference <code>Document.text</code>, <code>Document.fhir.problem_list</code>, <code>Document.fhir.medication_list</code>, <code>Document.fhir.allergy_list</code> CdsFhirAdapter <code>CDSRequest</code> <code>CDSResponse</code> Any FHIR Resource <code>Document.fhir.get_prefetch_resources()</code>"},{"location":"reference/pipeline/adapters/adapters/#use-cases","title":"Use Cases","text":"<p>Each adapter is designed for specific healthcare integration scenarios.</p> Adapter Use Case Protocol <code>CdaAdapter</code> Clinical Documentation SOAP/CDA <code>CdsFhirAdapter</code> Clinical Decision Support CDS Hooks/FHIR"},{"location":"reference/pipeline/adapters/adapters/#usage-patterns","title":"Usage Patterns","text":""},{"location":"reference/pipeline/adapters/adapters/#1-simple-end-to-end-processing","title":"1. Simple End-to-End Processing","text":"<p>Use prebuilt pipelines with the <code>process_request()</code> method for straightforward workflows:</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\npipeline = MedicalCodingPipeline.from_model_id(\"en_core_sci_sm\", source=\"spacy\")\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\n\n# Adapter used internally\nresponse = pipeline.process_request(cda_request)\n</code></pre>"},{"location":"reference/pipeline/adapters/adapters/#2-manual-adapter-control-document-access","title":"2. Manual Adapter Control (Document Access)","text":"<p>Use adapters <code>parse()</code> and <code>format()</code> methods directly when you need access to the intermediate <code>Document</code> object:</p> <pre><code>from healthchain.io import CdaAdapter\nfrom healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\npipeline = MedicalCodingPipeline.from_model_id(\"en_core_sci_sm\", source=\"spacy\")\nadapter = CdaAdapter()\n\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\n\n# Manual adapter control\ndoc = adapter.parse(cda_request)      # CdaRequest \u2192 Document\ndoc = pipeline(doc)                   # Document \u2192 Document (pure ML)\n\n# Access extracted clinical data\nprint(f\"Problems: {doc.fhir.problem_list}\")\nprint(f\"Medications: {doc.fhir.medication_list}\")\nprint(f\"Allergies: {doc.fhir.allergy_list}\")\n\n# Convert back to healthcare format\nresponse = adapter.format(doc)        # Document \u2192 CdaResponse\n</code></pre>"},{"location":"reference/pipeline/adapters/adapters/#adapter-configuration","title":"Adapter Configuration","text":""},{"location":"reference/pipeline/adapters/adapters/#custom-interop-engine","title":"Custom Interop Engine","text":"<p>Both CDA and CDS adapters can be configured with custom interoperability engines. By default, the adapter uses the built-in InteropEngine with default CDA templates.</p> <p><pre><code>from healthchain.io import CdaAdapter\nfrom healthchain.interop import create_interop\n\n# Custom engine with specific configuration\ncustom_engine = create_interop(config_dir=\"/path/to/custom/config\")\nadapter = CdaAdapter(engine=custom_engine)\n</code></pre> For more information on the InteropEngine, see the InteropEngine documentation.</p>"},{"location":"reference/pipeline/adapters/cdaadapter/","title":"CDA Adapter","text":"<p>The <code>CdaAdapter</code> handles conversion between CDA (Clinical Document Architecture) documents and HealthChain's internal <code>Document</code> objects. It parses CDA documents to extract free-text notes and structured clinical data into FHIR resources, and can convert processed Documents back into annotated CDA format.</p> <p>This adapter is particularly useful for clinical documentation improvement (CDI) workflows where documents need to be processed with ML models and updated with additional structured data.</p> <p>(Full Documentation on Clinical Documentation)</p>"},{"location":"reference/pipeline/adapters/cdaadapter/#input-and-output","title":"Input and Output","text":"Input Output Document Access CdaRequest CdaResponse <code>Document.fhir.problem_list</code>, <code>Document.fhir.medication_list</code>, <code>Document.text</code>"},{"location":"reference/pipeline/adapters/cdaadapter/#document-data-access","title":"Document Data Access","text":"<p>Data parsed from the CDA document is converted into FHIR resources and stored in the <code>Document.fhir</code> attribute. The adapter supports the following CDA section to FHIR resource mappings:</p> CDA Section FHIR Resource Document.fhir Attribute Problem List Condition <code>Document.fhir.problem_list</code> Medication List MedicationStatement <code>Document.fhir.medication_list</code> Clinical Notes DocumentReference <code>Document.text</code> + <code>Document.fhir.bundle</code> <p>All FHIR resources are Pydantic models, so you can access them using the <code>model_dump()</code> method:</p> <pre><code># Access structured clinical data\nfor condition in doc.fhir.problem_list:\n    print(condition.model_dump())\n\n# Access free-text content\nprint(f\"Clinical notes: {doc.text}\")\n</code></pre>"},{"location":"reference/pipeline/adapters/cdsfhiradapter/","title":"CDS FHIR Adapter","text":"<p>The <code>CdsFhirAdapter</code> handles conversion between CDS Hooks requests/responses and HealthChain's internal <code>Document</code> objects. It processes FHIR data in the context of Clinical Decision Support (CDS) services, following the CDS Hooks specification.</p> <p>This adapter is specifically designed for building CDS services that receive FHIR data through prefetch and return clinical decision cards.</p> <p>(Full Documentation on Clinical Decision Support)</p>"},{"location":"reference/pipeline/adapters/cdsfhiradapter/#input-and-output","title":"Input and Output","text":"Input Output Document Access CDSRequest CDSResponse <code>Document.fhir.get_prefetch_resources()</code>, <code>Document.cds.cards</code>"},{"location":"reference/pipeline/adapters/cdsfhiradapter/#document-data-access","title":"Document Data Access","text":""},{"location":"reference/pipeline/adapters/cdsfhiradapter/#fhir-prefetch-resources","title":"FHIR Prefetch Resources","text":"<p>Data from the CDS request's <code>prefetch</code> field is stored in the <code>Document.fhir.prefetch_resources</code> attribute as a dictionary mapping prefetch keys to FHIR resources:</p> <pre><code># After processing with adapter.parse()\ndoc = adapter.parse(cds_request)\n\n# Access prefetch resources by key\npatient = doc.fhir.get_prefetch_resources(\"patient\")\nconditions = doc.fhir.get_prefetch_resources(\"condition\")\ndocument_ref = doc.fhir.get_prefetch_resources(\"document\")\n\n# Access all prefetch resources\nall_resources = doc.fhir.prefetch_resources\nfor key, resource in all_resources.items():\n    print(f\"Resource '{key}': {resource.resourceType}\")\n</code></pre>"},{"location":"reference/pipeline/adapters/cdsfhiradapter/#cds-cards","title":"CDS Cards","text":"<p>Generated CDS cards are stored in the <code>Document.cds.cards</code> attribute:</p> <pre><code># After ML processing\nfor card in processed_doc.cds.cards:\n    print(f\"Summary: {card.summary}\")\n    print(f\"Indicator: {card.indicator}\")\n    print(f\"Detail: {card.detail}\")\n    print(f\"Source: {card.source}\")\n</code></pre>"},{"location":"reference/pipeline/adapters/cdsfhiradapter/#document-text-extraction","title":"Document Text Extraction","text":"<p>When the prefetch contains a <code>DocumentReference</code> resource, the adapter automatically extracts the document content and stores it in <code>Document.text</code>:</p> <pre><code># If prefetch contains document with base64 content\ncds_request = CDSRequest(\n    prefetch={\n        \"document\": {\n            \"resourceType\": \"DocumentReference\",\n            \"content\": [{\n                \"attachment\": {\n                    \"contentType\": \"text/plain\",\n                    \"data\": \"UGF0aWVudCBkaXNjaGFyZ2Ugbm90ZXM=\"  # base64 encoded\n                }\n            }]\n        }\n    }\n)\n\ndoc = adapter.parse(cds_request)\nprint(doc.text)  # \"Patient discharge notes\" (decoded)\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/","title":"CdsCardCreator","text":"<p>The <code>CdsCardCreator</code> is a pipeline component that creates CDS Hooks cards from either model outputs or static content. These cards can be displayed in Electronic Health Record (EHR) systems as part of clinical decision support workflows.</p>"},{"location":"reference/pipeline/components/cdscardcreator/#overview","title":"Overview","text":"<p>The component takes text input and formats it into standardized CDS Hooks cards using <code>Jinja2</code> templates. It can create cards from:</p> <ol> <li>Model-generated text stored in a document's model outputs container</li> <li>Static content provided during initialization</li> </ol>"},{"location":"reference/pipeline/components/cdscardcreator/#usage","title":"Usage","text":""},{"location":"reference/pipeline/components/cdscardcreator/#basic-usage-with-model-output","title":"Basic Usage with Model Output","text":"<pre><code>from healthchain.pipeline.components import CdsCardCreator\n\n# Create cards from model output\ncreator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\ndoc = creator(doc)  # Creates cards from model output\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#using-static-content","title":"Using Static Content","text":"<pre><code># Create cards with static content\ncreator = CdsCardCreator(static_content=\"Static card message\")\ndoc = creator(doc)  # Creates card with static content\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#custom-template","title":"Custom Template","text":"<pre><code># Create cards with custom template\ntemplate = '''\n{\n    \"summary\": \"Warning heading!\",\n    \"indicator\": \"warning\",\n    \"source\": {{ default_source | tojson }},\n    \"detail\": \"{{ model_output }}\"\n}\n'''\n\ncreator = CdsCardCreator(\n    template=template,\n    source=\"langchain\",\n    task=\"chat\",\n    delimiter=\"\\n\"\n)\ndoc = creator(doc)  # Creates cards split by newlines\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#configuration-options","title":"Configuration Options","text":"Parameter Type Description <code>template</code> <code>str</code> Optional Jinja2 template string for card creation <code>template_path</code> <code>str</code> or <code>Path</code> Optional path to a Jinja2 template file <code>static_content</code> <code>str</code> Optional static text to use instead of model output <code>source</code> <code>str</code> Source framework to get model output from (e.g. \"huggingface\") <code>task</code> <code>str</code> Task name to get model output from (e.g. \"summarization\") <code>delimiter</code> <code>str</code> Optional string to split model output into multiple cards <code>default_source</code> <code>Dict[str, Any]</code> Default source info for cards. Defaults to <code>{\"label\": \"Card Generated by HealthChain\"}</code>"},{"location":"reference/pipeline/components/cdscardcreator/#card-template-format","title":"Card Template Format","text":"<p>The default template creates an info card with the following structure:</p> <pre><code>{\n    \"summary\": \"{{ model_output[:140] }}\",\n    \"indicator\": \"info\",\n    \"source\": {{ default_source | tojson }},\n    \"detail\": \"{{ model_output }}\"\n}\n</code></pre> <p>Available template variables: - <code>model_output</code>: The text content to display in the card - <code>default_source</code>: Source information dictionary</p>"},{"location":"reference/pipeline/components/cdscardcreator/#card-properties","title":"Card Properties","text":"<p>The created cards have the following properties:</p> <ul> <li><code>summary</code>: Brief description (max 140 characters)</li> <li><code>indicator</code>: Card urgency level (\"info\", \"warning\", \"critical\")</li> <li><code>source</code>: Source information object</li> <li><code>detail</code>: Full text content</li> <li><code>suggestions</code>: Optional suggested actions</li> <li><code>selectionBehavior</code>: Optional selection behavior</li> <li><code>overrideReasons</code>: Optional override reasons</li> <li><code>links</code>: Optional external links</li> </ul>"},{"location":"reference/pipeline/components/cdscardcreator/#integration-with-summarizationpipeline","title":"Integration with SummarizationPipeline","text":"<p>The CdsCardCreator can be used as part of a larger pipeline:</p> <pre><code>from healthchain.pipeline import SummarizationPipeline\nfrom healthchain.pipeline.components import CdsCardCreator\n\npipeline = SummarizationPipeline()\npipeline.add_component(CdsCardCreator(\n    source=\"huggingface\",\n    task=\"summarization\",\n    template_path=\"path/to/template.json\",\n    delimiter=\"\\n\"\n))\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#related-documentation","title":"Related Documentation","text":"<ul> <li>CDS Hooks Specification</li> <li>Clinical Decision Support Documentation</li> </ul>"},{"location":"reference/pipeline/components/components/","title":"Component","text":"<p>Components are the building blocks of the healthchain pipeline. They are designed to process data in a consistent manner, allowing for easy composition and reusability.</p>"},{"location":"reference/pipeline/components/components/#available-components","title":"Available Components","text":"Component Description Methods <code>TextPreprocessor</code> Handles text preprocessing tasks <code>tokenizer</code>: Specifies the tokenization method (e.g., <code>\"basic\"</code> or <code>\"spacy\"</code>)  <code>lowercase</code>: Converts text to lowercase if <code>True</code> <code>remove_punctuation</code>: Removes punctuation if <code>True</code> <code>standardize_spaces</code>: Standardizes spaces if <code>True</code> <code>regex</code>: List of custom regex patterns and replacements <code>TextPostProcessor</code> Handles text postprocessing tasks <code>postcoordination_lookup</code>: Dictionary for entity refinement lookups CdsCardCreator Formats model outputs into CDS cards for clinical decision support <code>create_card</code>: Creates a CDS card FHIRProblemListExtractor Extracts entities with medical codes and creates FHIR Condition resources with the problem_list extension <code>__call__</code>: Extracts the problem list"},{"location":"reference/pipeline/components/components/#creating-custom-components","title":"Creating Custom Components","text":"<p>You can create your own custom components by extending the <code>BaseComponent</code> class and implementing the <code>__call__</code> method.</p> <pre><code>from healthchain.pipeline.base import BaseComponent\n\nclass MyCustomComponent(BaseComponent):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def __call__(self, data):\n        # Your custom processing logic here\n        return data\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/","title":"FHIRProblemListExtractor","text":"<p>The <code>FHIRProblemListExtractor</code> is a pipeline component that automatically extracts NLP annotations and formats them into FHIR Condition resources with the the category <code>problem-list-item</code> and the status <code>active</code>.</p>"},{"location":"reference/pipeline/components/fhirproblemextractor/#usage","title":"Usage","text":""},{"location":"reference/pipeline/components/fhirproblemextractor/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.pipeline.components import FHIRProblemListExtractor\n\n# Extract conditions with default settings\nextractor = FHIRProblemListExtractor()\ndoc = extractor(doc)  # Extracts from NLP entities stored in document's .nlp.entities or spaCy doc\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#configuration-options","title":"Configuration Options","text":"<pre><code># Use SNOMED CT codes\nextractor = FHIRProblemListExtractor(\n    patient_ref=\"Patient/456\",  # optional, defaults to \"Patient/123\"\n    code_attribute=\"snomed_id\", # optional, defaults to \"cui\"\n    coding_system=\"http://snomed.info/sct\" # optional, defaults to \"http://snomed.info/sct\"\n)\n\n# Use ICD-10 codes\nextractor = FHIRProblemListExtractor(\n    patient_ref=\"Patient/456\",\n    code_attribute=\"icd10\",\n    coding_system=\"http://hl7.org/fhir/sid/icd-10\"\n)\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#entity-extraction","title":"Entity Extraction","text":"<p>The component extracts entities from the document's NLP annotations.</p>"},{"location":"reference/pipeline/components/fhirproblemextractor/#spacy-entities","title":"spaCy Entities","text":"<p>Extracts from spaCy entities with extension attributes:</p> <pre><code># spaCy entity with CUI code\nent._.cui = \"C0015967\"  # Extracted automatically\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#generic-nlp-entities","title":"Generic NLP Entities","text":"<p>Works with any NLP framework via generic entity dictionaries: <pre><code>entities = [\n    {\"text\": \"fever\", \"cui\": \"C0015967\"},\n    {\"text\": \"hypertension\", \"snomed_id\": \"38341003\"}\n]\n</code></pre></p>"},{"location":"reference/pipeline/components/fhirproblemextractor/#fhir-condition-creation","title":"FHIR Condition Creation","text":"<p>Example of a FHIR Condition resource created by the component:</p> <pre><code>{\n  \"resourceType\": \"Condition\",\n  \"id\": \"hc-0aa85ff7-5e40-472b-a676-cb3df83d8313\",\n  \"clinicalStatus\": {\n    \"coding\": [\n      {\n        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n        \"code\": \"active\",\n        \"display\": \"Active\"\n      }\n    ]\n  },\n  \"code\": {\n    \"coding\": [\n      {\n        \"system\": \"http://snomed.info/sct\",\n        \"code\": \"C0242429\",  # extracted from doc entity\n        \"display\": \"sore throat\"  # extracted from doc entity\n      }\n    ]\n  },\n  \"subject\": {\n    \"reference\": \"Patient/123\"\n  }\n}\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#medicalcodingpipeline-integration","title":"MedicalCodingPipeline Integration","text":"<pre><code>from healthchain.pipeline import MedicalCodingPipeline\n\n# Automatic problem extraction\npipeline = MedicalCodingPipeline(\n    extract_problems=True,\n    patient_ref=\"Patient/456\",\n    code_attribute=\"cui\"\n)\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#related-documentation","title":"Related Documentation","text":"<ul> <li>FHIR Condition Resources</li> <li>Medical Coding Pipeline</li> <li>Document Container</li> </ul>"},{"location":"reference/pipeline/integrations/integrations/","title":"HealthChain Integrations","text":"<p>This document provides an overview of the integration components available in the HealthChain package. These components allow you to easily incorporate popular NLP libraries into your HealthChain pipelines.</p>"},{"location":"reference/pipeline/integrations/integrations/#table-of-contents","title":"Table of Contents","text":"<ol> <li>SpacyNLP</li> <li>HFTransformer</li> <li>LangChainLLM</li> </ol>"},{"location":"reference/pipeline/integrations/integrations/#installation-requirements","title":"Installation Requirements","text":"<p>Before utilizing the integration components, it is important to note that the required third-party libraries are not included in HealthChain's default installation. This design decision was made to:</p> <ul> <li>Maintain a lean and flexible core package</li> <li>Allow users to selectively install only the necessary dependencies</li> <li>Avoid potential version conflicts with other packages in your environment</li> </ul> <p>To use these integrations, you will need to manually install the corresponding libraries using <code>pip</code>.</p> <pre><code>pip install spacy\npython -m spacy download en_core_web_sm  # or another desired model\npip install transformers\npip install langchain\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#spacynlp","title":"SpacyNLP","text":"<p>The <code>SpacyNLP</code> component allows you to integrate spaCy models into your HealthChain pipeline. There are two ways to initialize this component:</p> <ol> <li> <p>Using a pre-configured spaCy <code>Language</code> object:    <pre><code>import spacy\nfrom healthchain.pipeline.components.integrations import SpacyNLP\n\nnlp = spacy.load(\"en_core_web_sm\")\nspacy_component = SpacyNLP(nlp)\n</code></pre></p> </li> <li> <p>Using the factory method with a model identifier or path to a custom local model:    <pre><code>from healthchain.pipeline.components.integrations import SpacyNLP\n\n# Using a standard spaCy model\nspacy_component = SpacyNLP.from_model_id(\n   \"en_core_web_sm\",\n   disable=[\"parser\"]  # kwargs passed to spacy.load()\n)\n\n# Using a custom local model\nspacy_component = SpacyNLP.from_model_id(\"/path/to/your/model\")\n</code></pre></p> </li> </ol> <p>Choose the appropriate model based on your specific needs - standard models for general text, custom-trained models for domain-specific tasks, or specialized models like scispaCy for biomedical text analysis.</p> <pre><code># Using scispaCy models for biomedical text (requires: pip install scispacy)\nspacy_component = SpacyNLP.from_model_id(\"en_core_sci_sm\")\n</code></pre> <p>The component will process documents using spaCy and store the spaCy Doc object in the document's <code>nlp</code> annotations. It can be accessed using the <code>Document.nlp.get_spacy_doc()</code> method.</p>"},{"location":"reference/pipeline/integrations/integrations/#example","title":"Example","text":"<pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import SpacyNLP\n\npipeline = Pipeline()\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_web_sm\"))\n\ndoc = Document(\"This is a test sentence.\")\nprocessed_doc = pipeline(doc)\n\n# Access spaCy annotations\nspacy_doc = processed_doc.nlp.get_spacy_doc()\nfor token in spacy_doc:\n    print(f\"Token: {token.text}, POS: {token.pos_}, Lemma: {token.lemma_}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#hftransformer","title":"HFTransformer","text":"<p>The <code>HFTransformer</code> integrates HuggingFace <code>transformers</code> models into your HealthChain pipeline. Models can be browsed on the HuggingFace website.</p> <p>HuggingFace offers models for a wide range of different tasks, and while not all of these have been thoroughly tested for HealthChain compatibility, we expect that all NLP models and tasks should be compatible. If you have an issues integrating any models please raise an issue on our Github homepage!</p> <p>There are two ways to initialize this component:</p> <ol> <li> <p>Using a pre-configured HuggingFace pipeline:    <pre><code>from transformers import pipeline, AutoTokenizer, AutoModelForCausalLM\nfrom healthchain.pipeline.components.integrations import HFTransformer\n\nmodel_id = \"gpt2\"\ntokenizer = AutoTokenizer.from_pretrained(model_id)\nmodel = AutoModelForCausalLM.from_pretrained(model_id)\npipe = pipeline(\n   \"text-generation\",\n   model=model,\n   tokenizer=tokenizer,\n   max_new_tokens=10\n)\n\nhuggingface_component = HFTransformer(pipe)\n</code></pre></p> </li> <li> <p>Using the factory method with a model identifier:    <pre><code>from healthchain.pipeline.components.integrations import HFTransformer\n\nhuggingface_component = HFTransformer.from_model_id(\n    model=\"facebook/bart-large-cnn\",\n    task=\"summarization\",\n    max_length=130,  # kwargs passed to pipeline()\n    min_length=30,\n    do_sample=False\n)\n</code></pre></p> </li> </ol> <p>The factory method requires the following arguments:</p> <ul> <li><code>task</code> (str): The NLP task to perform (e.g., \"sentiment-analysis\", \"named-entity-recognition\").</li> <li><code>model</code> (str): The name or path of the Hugging Face model to use.</li> <li><code>**kwargs**</code>: Additional keyword arguments passed to the <code>pipeline()</code> function.</li> </ul> <p>This component applies the specified Hugging Face model to the input document and stores the output in the HealthChain <code>Document.models</code>.</p> <p>It can be accessed using the <code>Document.models.get_output()</code> method with the key <code>\"huggingface\"</code> and the task name.</p>"},{"location":"reference/pipeline/integrations/integrations/#example_1","title":"Example","text":"<pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import HFTransformer\n\npipeline = Pipeline()\npipeline.add_node(HFTransformer.from_model_id(\n   task=\"sentiment-analysis\",\n   model=\"distilbert-base-uncased-finetuned-sst-2-english\"\n   )\n)\n\ndoc = Document(\"I love using HealthChain for my NLP projects!\")\nprocessed_doc = pipeline(doc)\n\n# Access Hugging Face output\nsentiment_result = processed_doc.models.get_output(\n   \"huggingface\", \"sentiment-analysis\"\n)\n\nprint(f\"Sentiment: {sentiment_result}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#langchainllm","title":"LangChainLLM","text":"<p>The <code>LangChainLLM</code> allows you to integrate LangChain chains into your HealthChain pipeline.</p> <pre><code>from langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\nfrom healthchain.pipeline.components.integrations import LangChainLLM\n\n# Let's create a simple FakeListLLM for demonstration\nfake_llm = FakeListLLM(responses=[\"This is a great summary!\"])\n\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\n\n# Create the component\nlangchain_component = LangChainLLM(\n    chain=chain,\n    task=\"chat\",\n    temperature=0.7  # Optional kwargs passed to invoke()\n)\n</code></pre> <p>The component requires the following arguments:</p> <ul> <li><code>chain</code>: A LangChain chain object to be executed within the pipeline.</li> <li><code>task</code>: The key to store the output in <code>Document.models</code>.</li> <li><code>**kwargs**</code>: Additional keyword arguments passed to the <code>invoke()</code> method.</li> </ul> <p>This component runs the specified LangChain chain on the input document's text and stores the output in the HealthChain <code>Document.models</code>.</p> <p>It can be accessed using the <code>Document.models.get_output()</code> method with the key <code>\"langchain\"</code> and the task name.</p>"},{"location":"reference/pipeline/integrations/integrations/#example_2","title":"Example","text":"<pre><code>from langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\nfrom healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import LangChainLLM\n\n# Set up LangChain with a FakeListLLM\nfake_llm = FakeListLLM(\n    responses=[\"HealthChain integrates NLP libraries for easy pipeline creation.\"]\n)\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\n\n# Set up your HealthChain pipeline\npipeline = Pipeline()\npipeline.add_node(LangChainLLM(chain=chain, task=\"summarization\"))\n\n# Let's summarize something\ndoc = Document(\n    \"HealthChain is a powerful package for building NLP pipelines. It integrates seamlessly with popular libraries like spaCy, Hugging Face Transformers, and LangChain, allowing users to create complex NLP workflows with ease.\"\n)\nprocessed_doc = pipeline(doc)\n\n# What summary did we get?\nsummary = processed_doc.models.get_output(\"langchain\", \"summarization\")\nprint(f\"Summary: {summary}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#combining-components","title":"Combining Components","text":"<p>You can easily combine multiple integration components in a single HealthChain pipeline:</p> <pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import (\n    SpacyNLP,\n    HFTransformer,\n    LangChainLLM,\n)\n\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\n# Set up our components\nspacy_component = SpacyNLP.from_model_id(\"en_core_web_sm\")\nhuggingface_component = HFTransformer.from_model_id(\n    model=\"distilbert-base-uncased-finetuned-sst-2-english\",\n    task=\"sentiment-analysis\",\n)\n\n# Set up LangChain with a FakeListLLM\nfake_llm = FakeListLLM(responses=[\"HealthChain: Powerful NLP pipeline builder.\"])\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\nlangchain_component = LangChainLLM(chain=chain, task=\"summarization\")\n\n# Build our pipeline\npipeline = Pipeline()\npipeline.add_node(spacy_component)\npipeline.add_node(huggingface_component)\npipeline.add_node(langchain_component)\npipeline.build()\n\n# Process a document\ndoc = Document(\"HealthChain makes it easy to build powerful NLP pipelines!\")\nprocessed_doc = pipeline(doc)\n\n# Let's see what we got!\nspacy_doc = processed_doc.nlp.get_spacy_doc()\nsentiment = processed_doc.models.get_output(\"huggingface\", \"sentiment-analysis\")\nsummary = processed_doc.models.get_output(\"langchain\", \"summarization\")\n\nprint(f\"Tokens: {[token.text for token in spacy_doc]}\")\nprint(f\"Sentiment: {sentiment}\")\nprint(f\"Summary: {summary}\")\n</code></pre> <p>This documentation provides an overview of the integration components available in HealthChain. For more detailed information on each library, please refer to their respective documentation:</p> <ul> <li>spaCy Documentation</li> <li>Hugging Face Transformers Documentation</li> <li>LangChain Documentation</li> </ul>"},{"location":"reference/pipeline/prebuilt_pipelines/medicalcoding/","title":"MedicalCodingPipeline","text":"<p>Full documentation coming soon!</p>"},{"location":"reference/pipeline/prebuilt_pipelines/summarization/","title":"SummarizationPipeline","text":"<p>Full documentation coming soon! Check out this cookbook example for now.</p>"},{"location":"reference/utilities/data_generator/","title":"Data Generator","text":"<p>Healthcare systems use standardized data formats, but each hospital or clinic configures their data differently. This creates challenges when building applications that need to work across multiple healthcare systems.</p> <p>The data generator creates test data that matches the structure and format expected by Electronic Health Record (EHR) systems. It's designed for testing your applications, not for research studies that need realistic patient populations.</p> <p>According to the UK ONS synthetic data classification, HealthChain generates \"level 1: synthetic structural data\" - data that follows the correct format but contains fictional information.</p> <p></p>"},{"location":"reference/utilities/data_generator/#cds-data-generator","title":"CDS Data Generator","text":"<p>The <code>.generate_prefetch()</code> method will return a <code>Prefetch</code> model with the <code>prefetch</code> field populated with a dictionary of FHIR resources. Each key in the dictionary corresponds to a FHIR resource type, and the value is a list of FHIR resources of that type. For more information, check out the CDS Hooks documentation.</p> <p>For each workflow, a pre-configured list of FHIR resources is randomly generated and placed in the <code>prefetch</code> field of a <code>CDSRequest</code>.</p> <p>Current implemented workflows:</p> Workflow Implementation Completeness Generated Synthetic Resources patient-view <code>Patient</code>, <code>Encounter</code> (Future: <code>MedicationStatement</code>, <code>AllergyIntolerance</code>) encounter-discharge <code>Patient</code>, <code>Encounter</code>, <code>Procedure</code>, <code>MedicationRequest</code>, Optional <code>DocumentReference</code> order-sign  Partial Future: <code>MedicationRequest</code>, <code>ProcedureRequest</code>, <code>ServiceRequest</code> order-select  Partial Future: <code>MedicationRequest</code>, <code>ProcedureRequest</code>, <code>ServiceRequest</code> <p>For more information on CDS workflows, see the CDS Hooks Protocol documentation.</p> <p>You can use the data generator with <code>SandboxClient.load_free_text()</code> or standalone:</p> With SandboxClientStandalone <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create client\nclient = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\"\n)\n\n# Generate FHIR data from clinical notes\nclient.load_free_text(\n    csv_path=\"./data/discharge_notes.csv\",\n    column_name=\"text\",\n    workflow=\"encounter-discharge\",\n    random_seed=42\n)\n\nresponses = client.send_requests()\n</code></pre> <pre><code>from healthchain.sandbox.generators import CdsDataGenerator\nfrom healthchain.sandbox.workflows import Workflow\n\n# Initialize data generator\ndata_generator = CdsDataGenerator()\n\n# Generate FHIR resources for use case workflow\ndata_generator.set_workflow(Workflow.encounter_discharge)\nprefetch = data_generator.generate_prefetch()\n\nprint(prefetch.model_dump())\n\n# {\n#    \"prefetch\": {\n#        \"encounter\":\n#            {\n#              \"resourceType\": ...\n#            }\n#    }\n#}\n</code></pre>"},{"location":"reference/utilities/data_generator/#loading-free-text","title":"Loading free-text","text":"<p>You can specify the <code>free_text_csv</code> field of the <code>.generate_prefetch()</code> method to load in free-text sources into the data generator, e.g. discharge summaries. This will wrap the text into a FHIR DocumentReference resource (N.B. currently we place the text directly in the resource attachment, although it is technically supposed to be base64 encoded).</p> <p>A random text document from the <code>csv</code> file will be picked for each generation.</p> <pre><code># Load free text into a DocumentResource FHIR resource\ndata = data_generator.generate_prefetch(free_text_csv=\"./dir/to/csv/file\")\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/","title":"FHIR Utilities","text":"<p>The <code>fhir</code> module provides a set of helper functions to make it easier for you to work with FHIR resources.</p>"},{"location":"reference/utilities/fhir_helpers/#resource-creation","title":"Resource Creation","text":"<p>FHIR is the modern de facto standard for storing and exchanging healthcare data, but working with FHIR resources can often involve complex and nested JSON structures with required and optional fields that vary between contexts.</p> <p>Creating FHIR resources can involve a lot of boilerplate code, validation errors and manual comparison with FHIR specifications.</p> <p>For example, as an ML practitioner, you may only care about extracting and inserting certain codes and texts within a FHIR resource. If you want to locate the SNOMED CT code for a medication, you may have to do something headache-inducing like:</p> <pre><code>medication_statement = {\n    \"resourceType\": \"MedicationStatement\",\n    \"status\": \"active\",  # required\n    \"medication\": {  # required\n        \"concept\": {\n            \"coding\": [\n                {\n                    \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                    \"code\": \"1049221\",\n                    \"display\": \"Acetaminophen 325 MG Oral Tablet\",\n                }\n            ]\n        }\n    },\n    \"subject\": {  # required\n        \"reference\": \"Patient/example\"\n    },\n}\n\nmedication_statement[\"medication\"][\"concept\"][\"coding\"][0][\"code\"]\nmedication_statement[\"medication\"][\"concept\"][\"coding\"][0][\"display\"]\n</code></pre> <p>Sensible Defaults for Resource Creation</p> <p>The <code>fhir</code> <code>create_*</code> functions create FHIR resources with sensible defaults, automatically setting:   - A reference ID prefixed by \"<code>hc-</code>\"   - A status of \"<code>active</code>\" (or equivalent)   - A creation date where necessary</p> <p>You can modify and manipulate these resources as you would any other Pydantic object after their creation.</p> <p>Validation of FHIR Resources</p> <p>Internally, HealthChain uses fhir.resources to validate FHIR resources, which is powered by Pydantic V2. These helpers create minimal valid FHIR objects to help you get started easily.  ALWAYS check that the sensible defaults fit your needs, and validate your resource!</p>"},{"location":"reference/utilities/fhir_helpers/#overview","title":"Overview","text":"Resource Type Required Fields Sensible Defaults Common Use Cases Condition \u2022 <code>clinicalStatus</code>\u2022 <code>subject</code> \u2022 <code>clinicalStatus</code>: \"active\"\u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Recording diagnoses\u2022 Problem list items\u2022 Active conditions MedicationStatement \u2022 <code>subject</code>\u2022 <code>status</code>\u2022 <code>medication</code> \u2022 <code>status</code>: \"recorded\"\u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Current medications\u2022 Medication history\u2022 Prescribed medications AllergyIntolerance \u2022 <code>patient</code> \u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Allergies\u2022 Intolerances\u2022 Adverse reactions DocumentReference \u2022 <code>type</code> \u2022 <code>status</code>: \"current\"\u2022 <code>date</code>: UTC now\u2022 <code>description</code>: default text\u2022 <code>content.attachment.title</code>: default text \u2022 Clinical notes\u2022 Lab reports\u2022 Imaging reports"},{"location":"reference/utilities/fhir_helpers/#create_condition","title":"create_condition()","text":"<p>Creates a new Condition resource.</p> <p>Required fields</p> <ul> <li>clinicalStatus</li> <li>subject</li> </ul> <p>Sensible Defaults</p> <p><code>clinicalStatus</code> is set to \"<code>active</code>\"</p> <pre><code>from healthchain.fhir import create_condition\n\n# Create a condition representing hypertension\ncondition = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\",\n)\n\n# Output the created resource\nprint(condition.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"Condition\",\n    \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n    \"clinicalStatus\": {\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n        }]\n    },\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"38341003\",\n            \"display\": \"Hypertension\"\n        }]\n    },\n    \"subject\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_medication_statement","title":"create_medication_statement()","text":"<p>Creates a new MedicationStatement resource.</p> <p>Required fields</p> <ul> <li>subject</li> <li>status</li> <li>medication</li> </ul> <p>Sensible Defaults</p> <p><code>status</code> is set to \"<code>recorded</code>\"</p> <pre><code>from healthchain.fhir import create_medication_statement\n\n# Create a medication statement for Acetaminophen\nmedication = create_medication_statement(\n    subject=\"Patient/123\",\n    code=\"1049221\",\n    display=\"Acetaminophen 325 MG Oral Tablet\",\n    system=\"http://www.nlm.nih.gov/research/umls/rxnorm\",\n)\n\n# Output the created resource\nprint(medication.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"MedicationStatement\",\n    \"id\": \"hc-86a26eba-63f9-4017-b7b2-5b36f9bad5f1\",\n    \"status\": \"recorded\",\n    \"medication\": {\n        \"concept\": {\n            \"coding\": [{\n                \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                \"code\": \"1049221\",\n                \"display\": \"Acetaminophen 325 MG Oral Tablet\"\n            }]\n        }\n    },\n    \"subject\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_allergy_intolerance","title":"create_allergy_intolerance()","text":"<p>Creates a new AllergyIntolerance resource.</p> <p>Required fields</p> <ul> <li>patient</li> </ul> <p>Sensible Defaults</p> <p>None (besides the auto-generated id)</p> <pre><code>from healthchain.fhir import create_allergy_intolerance\n\n# Create an allergy intolerance record\nallergy = create_allergy_intolerance(\n    patient=\"Patient/123\",\n    code=\"418038007\",\n    display=\"Propensity to adverse reactions to substance\",\n    system=\"http://snomed.info/sct\"\n)\n\n# Output the created resource\nprint(allergy.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"AllergyIntolerance\",\n    \"id\": \"hc-65edab39-d90b-477b-bdb5-a173b21efd44\",\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"418038007\",\n            \"display\": \"Propensity to adverse reactions to substance\"\n        }]\n    },\n    \"patient\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_document_reference","title":"create_document_reference()","text":"<p>Creates a new DocumentReference resource. Handles base64 encoding of the attachment data.</p> <p>Required fields</p> <ul> <li>type</li> </ul> <p>Sensible Defaults</p> <ul> <li><code>type</code> is set to \"<code>collection</code>\"</li> <li><code>status</code> is set to \"<code>current</code>\"</li> <li><code>date</code> is set to the current UTC timestamp</li> <li><code>description</code> is set to \"<code>DocumentReference created by HealthChain</code>\"</li> <li><code>content[0].attachment.title</code> is set to \"<code>Attachment created by HealthChain</code>\"</li> </ul> <pre><code>from healthchain.fhir import create_document_reference\n\n# Create a document reference with a simple text attachment\ndoc_ref = create_document_reference(\n    data=\"Hello World\",\n    content_type=\"text/plain\",\n    description=\"A simple text document\"\n)\n\n# Output the created resource\nprint(doc_ref.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"DocumentReference\",\n    \"id\": \"hc-60fcfdad-9617-4557-88d8-8c8db9b9fe70\",\n    \"status\": \"current\",\n    \"date\": \"2025-02-28T14:55:33+00:00\",\n    \"description\": \"A simple text document\",\n    \"content\": [{\n        \"attachment\": {\n            \"contentType\": \"text/plain\",\n            \"data\": \"SGVsbG8gV29ybGQ=\",\n            \"title\": \"Attachment created by HealthChain\",\n            \"creation\": \"2025-02-28T14:55:33+00:00\"\n        }\n    }]\n}\n</code></pre> View Decoded Content <pre><code>Hello World\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#utilities","title":"Utilities","text":""},{"location":"reference/utilities/fhir_helpers/#set_problem_list_item_category","title":"set_problem_list_item_category()","text":"<p>Sets the category of a Condition resource to \"<code>problem-list-item</code>\".</p> <pre><code>from healthchain.fhir import set_problem_list_item_category, create_condition\n\n# Create a condition and set it as a problem list item\nproblem_list_item = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\"\n)\n\nset_problem_list_item_category(problem_list_item)\n\n# Output the modified resource\nprint(problem_list_item.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"Condition\",\n    \"id\": \"hc-3d5f62e7-729b-4da1-936c-e8e16e5a9358\",\n    \"clinicalStatus\": {\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n        }]\n    },\n    \"category\": [{\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-category\",\n            \"code\": \"problem-list-item\",\n            \"display\": \"Problem List Item\"\n        }]\n    }],\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"38341003\",\n            \"display\": \"Hypertension\"\n        }]\n    },\n    \"subject\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#read_content_attachment","title":"read_content_attachment()","text":"<p>Reads attachments from a DocumentReference in a human-readable format.</p> <pre><code>from healthchain.fhir import read_content_attachment\n\nattachments = read_content_attachment(document_reference)\n# Returns a list of dictionaries containing:\n# [\n#     {\n#         \"data\": \"Hello World\",\n#         \"metadata\": {\n#             \"content_type\": \"text/plain\",\n#             \"title\": \"My Document\",\n#             \"creation\": datetime.datetime(2025, 2, 28, 15, 27, 55, tzinfo=TzInfo(UTC)),\n#         },\n#     }\n# ]\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#bundle-operations","title":"Bundle Operations","text":"<p>FHIR Bundles are containers that can hold multiple FHIR resources together. They are commonly used to group related resources or to send/receive multiple resources in a single request.</p> <p>The bundle operations make it easy to:</p> <ul> <li>Create and manage bundles</li> <li>Add or update resources within bundles</li> <li>Retrieve specific resource types from bundles</li> <li>Work with multiple resource types in a single bundle</li> </ul>"},{"location":"reference/utilities/fhir_helpers/#create_bundle","title":"create_bundle()","text":"<p>Creates a new Bundle resource.</p> <p>Required field</p> <ul> <li>type</li> </ul> <p>Sensible Defaults</p> <p><code>type</code> is set to \"<code>collection</code>\"</p> <pre><code>from healthchain.fhir import create_bundle\n\n# Create an empty bundle\nbundle = create_bundle(bundle_type=\"collection\")\n\n# Output the created resource\nprint(bundle.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": []\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#add_resource","title":"add_resource()","text":"<p>Adds a single resource to a Bundle.</p> <pre><code>from healthchain.fhir import add_resource, create_condition, create_bundle\n\n# Create a condition to add to the bundle\ncondition = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\"\n)\n\n# Create a bundle and add the condition\nbundle = create_bundle()\nadd_resource(bundle, condition)\n\n# Output the modified bundle\nprint(bundle.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [{\n        \"resource\": {\n            \"resourceType\": \"Condition\",\n            \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n            \"clinicalStatus\": {\n                \"coding\": [{\n                    \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                    \"code\": \"active\",\n                    \"display\": \"Active\"\n                }]\n            },\n            \"code\": {\n                \"coding\": [{\n                    \"system\": \"http://snomed.info/sct\",\n                    \"code\": \"38341003\",\n                    \"display\": \"Hypertension\"\n                }]\n            },\n            \"subject\": {\n                \"reference\": \"Patient/123\"\n            }\n        }\n    }]\n}\n</code></pre> Field Descriptions Field Required Description <code>entry</code> - Array of resources in the bundle <code>entry[].resource</code> \u2713 The FHIR resource being added <code>entry[].fullUrl</code> - Optional full URL for the resource"},{"location":"reference/utilities/fhir_helpers/#get_resources","title":"get_resources()","text":"<p>Retrieves all resources of a specific type from a Bundle.</p> <pre><code>from healthchain.fhir import get_resources\n\n# Get all conditions in the bundle\nconditions = get_resources(bundle, \"Condition\")\n\n# Or using the resource type directly\nfrom fhir.resources.condition import Condition\nconditions = get_resources(bundle, Condition)\n\nfor condition in conditions:\n    print(f\"Found condition: {condition.code.coding[0].display}\")\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#set_resources","title":"set_resources()","text":"<p>Sets or updates resources of a specific type in a Bundle.</p> <pre><code>from healthchain.fhir import set_resources, create_condition\n\n# Create some conditions\nconditions = [\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"38341003\",\n        display=\"Hypertension\"\n    ),\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"44054006\",\n        display=\"Diabetes\"\n    )\n]\n\n# Replace all existing conditions with new ones\nset_resources(bundle, conditions, \"Condition\", replace=True)\n\n# Or append new conditions to existing ones\nset_resources(bundle, conditions, \"Condition\", replace=False)\n</code></pre> Bundle with Multiple Conditions <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"38341003\",\n                        \"display\": \"Hypertension\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-9876fedc-ba98-7654-3210-fedcba987654\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"44054006\",\n                        \"display\": \"Diabetes\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#merge_bundles","title":"merge_bundles()","text":"<p>Merges multiple FHIR Bundle resources into a single bundle.</p> <ul> <li>Resources from each bundle are combined into a single output bundle of <code>type: collection</code>.</li> <li>All entries from all input bundles will appear in the resulting bundle's <code>entry</code> array.</li> <li>If bundles have the same resource (e.g. matching <code>id</code> or identical resources), they will all be included unless you handle duplicates before/after calling <code>merge_bundles</code>.</li> </ul> <pre><code>from healthchain.fhir import merge_bundles, create_bundle, create_condition\n\n# Create two bundles with different resources\nbundle1 = create_bundle()\nadd_resource(bundle1, create_condition(\n    subject=\"Patient/123\", code=\"38341003\", display=\"Hypertension\"\n))\nbundle2 = create_bundle()\nadd_resource(bundle2, create_condition(\n    subject=\"Patient/123\", code=\"44054006\", display=\"Diabetes\"\n))\n\n# Merge the bundles together\nmerged = merge_bundles(bundle1, bundle2)\n\n# Output the merged bundle\nprint(merged.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n  \"resourceType\": \"Bundle\",\n  \"type\": \"collection\",\n  \"entry\": [\n    {\n      \"resource\": {\n        \"resourceType\": \"Condition\",\n        \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n        \"clinicalStatus\": {\n          \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n          }]\n        },\n        \"code\": {\n          \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"38341003\",\n            \"display\": \"Hypertension\"\n          }]\n        },\n        \"subject\": { \"reference\": \"Patient/123\" }\n      }\n    },\n    {\n      \"resource\": {\n        \"resourceType\": \"Condition\",\n        \"id\": \"hc-9876fedc-ba98-7654-3210-fedcba987654\",\n        \"clinicalStatus\": {\n          \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n          }]\n        },\n        \"code\": {\n          \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"44054006\",\n            \"display\": \"Diabetes\"\n          }]\n        },\n        \"subject\": { \"reference\": \"Patient/123\" }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#common-patterns","title":"Common Patterns","text":""},{"location":"reference/utilities/fhir_helpers/#working-with-multiple-resource-types","title":"Working with Multiple Resource Types","text":"<p>This example shows how to work with multiple types of FHIR resources in a single bundle.</p> <pre><code>from healthchain.fhir import (\n    create_bundle,\n    create_condition,\n    create_medication_statement,\n    create_allergy_intolerance,\n    get_resources,\n    set_resources,\n)\n\n# Create a bundle to hold patient data\nbundle = create_bundle()\n\n# Add conditions (diagnoses)\nconditions = [\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"38341003\",\n        display=\"Hypertension\"\n    ),\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"44054006\",\n        display=\"Diabetes\"\n    )\n]\nset_resources(bundle, conditions, \"Condition\")\n\n# Add medications\nmedications = [\n    create_medication_statement(\n        subject=\"Patient/123\",\n        code=\"1049221\",\n        display=\"Acetaminophen 325 MG\"\n    )\n]\nset_resources(bundle, medications, \"MedicationStatement\")\n\n# Add allergies\nallergies = [\n    create_allergy_intolerance(\n        patient=\"Patient/123\",\n        code=\"418038007\",\n        display=\"Penicillin allergy\"\n    )\n]\nset_resources(bundle, allergies, \"AllergyIntolerance\")\n\n# Later, retrieve resources by type\nconditions = get_resources(bundle, \"Condition\")\nmedications = get_resources(bundle, \"MedicationStatement\")\nallergies = get_resources(bundle, \"AllergyIntolerance\")\n</code></pre> Complete Bundle Example Output <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"38341003\",\n                        \"display\": \"Hypertension\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-9876fedc-ba98-7654-3210-fedcba987654\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"44054006\",\n                        \"display\": \"Diabetes\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"MedicationStatement\",\n                \"id\": \"hc-86a26eba-63f9-4017-b7b2-5b36f9bad5f1\",\n                \"status\": \"recorded\",\n                \"medication\": {\n                    \"concept\": {\n                        \"coding\": [{\n                            \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                            \"code\": \"1049221\",\n                            \"display\": \"Acetaminophen 325 MG\"\n                        }]\n                    }\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"AllergyIntolerance\",\n                \"id\": \"hc-65edab39-d90b-477b-bdb5-a173b21efd44\",\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"418038007\",\n                        \"display\": \"Penicillin allergy\"\n                    }]\n                },\n                \"patient\": {\"reference\": \"Patient/123\"}\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/utilities/sandbox/","title":"Sandbox Client","text":"<p>The sandbox client provides a simplified interface for testing and validating your applications in realistic healthcare contexts. Use <code>SandboxClient</code> to quickly spin up demos and test with various data sources and workflows.</p>"},{"location":"reference/utilities/sandbox/#quick-example","title":"Quick Example","text":"<p>Test CDS Hooks workflows with synthetic data:</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create client\nclient = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load data and send requests\nclient.load_from_registry(\"synthea\", num_patients=5)\nresponses = client.send_requests()\n</code></pre>"},{"location":"reference/utilities/sandbox/#sandboxclient","title":"SandboxClient","text":""},{"location":"reference/utilities/sandbox/#initializing","title":"Initializing","text":"<pre><code>from healthchain.sandbox import SandboxClient\n\nclient = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\",  # Optional, auto-detected if not provided\n    protocol=\"rest\",  # \"rest\" for CDS Hooks, \"soap\" for CDA\n    timeout=10.0\n)\n</code></pre>"},{"location":"reference/utilities/sandbox/#loading-data","title":"Loading Data","text":"From RegistryFrom FilesFrom Free Text CSV <pre><code># Load from pre-configured datasets\nclient.load_from_registry(\"mimic-on-fhir\", sample_size=10)\nclient.load_from_registry(\"synthea\", num_patients=5)\n\n# See available datasets\nfrom healthchain.sandbox import list_available_datasets\nprint(list_available_datasets())\n</code></pre> <pre><code># Load single file\nclient.load_from_path(\"./data/clinical_note.xml\")\n\n# Load directory\nclient.load_from_path(\"./data/cda_files/\", pattern=\"*.xml\")\n</code></pre> <pre><code># Generate synthetic FHIR from clinical notes\nclient.load_free_text(\n    csv_path=\"./data/discharge_notes.csv\",\n    column_name=\"text\",\n    workflow=\"encounter-discharge\",\n    random_seed=42\n)\n</code></pre>"},{"location":"reference/utilities/sandbox/#sending-requests","title":"Sending Requests","text":"<pre><code># Send all queued requests\nresponses = client.send_requests()\n\n# Save results\nclient.save_results(\"./output/\")\n\n# Get status\nstatus = client.get_status()\nprint(status)\n</code></pre>"},{"location":"reference/utilities/sandbox/#available-testing-scenarios","title":"Available Testing Scenarios","text":"<p>CDS Hooks (REST protocol):</p> <ul> <li><code>workflow</code>: \"patient-view\", \"encounter-discharge\", \"order-select\", etc.</li> <li>Load FHIR Prefetch data</li> <li>Test clinical decision support services</li> </ul> <p>Clinical Documentation (SOAP protocol):</p> <ul> <li><code>workflow</code>: \"sign-note-inpatient\", \"sign-note-outpatient\"</li> <li>Load CDA XML documents</li> <li>Test SOAP/CDA document processing</li> </ul>"},{"location":"reference/utilities/sandbox/#complete-examples","title":"Complete Examples","text":"CDS Hooks TestClinical Documentation Test <pre><code>from healthchain.sandbox import SandboxClient\n\n# Initialize for CDS Hooks\nclient = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/cds/cds-services/discharge-summarizer\",\n    workflow=\"encounter-discharge\",\n    protocol=\"rest\"\n)\n\n# Load and send\nclient.load_from_registry(\"synthea\", num_patients=3)\nresponses = client.send_requests()\nclient.save_results(\"./output/\")\n</code></pre> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Initialize for SOAP/CDA\nclient = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/notereader/fhir/\",\n    workflow=\"sign-note-inpatient\",\n    protocol=\"soap\"\n)\n\n# Load CDA files\nclient.load_from_path(\"./data/cda_files/\", pattern=\"*.xml\")\nresponses = client.send_requests()\nclient.save_results(\"./output/\")\n</code></pre>"},{"location":"reference/utilities/sandbox/#migration-guide","title":"Migration Guide","text":"<p>Decorator Pattern Deprecated</p> <p>The <code>@hc.sandbox</code> and <code>@hc.ehr</code> decorators with <code>ClinicalDecisionSupport</code> and <code>ClinicalDocumentation</code> base classes are deprecated. Use <code>SandboxClient</code> instead.</p> <p>Before: <pre><code>@hc.sandbox\nclass TestCDS(ClinicalDecisionSupport):\n    @hc.ehr(workflow=\"patient-view\")\n    def load_data(self):\n        return prefetch_data\n</code></pre></p> <p>After: <pre><code>client = SandboxClient(\n    api_url=\"http://localhost:8000\",\n    endpoint=\"/cds/cds-services/my-service\",\n    workflow=\"patient-view\"\n)\nclient.load_from_registry(\"synthea\", num_patients=5)\nresponses = client.send_requests()\n</code></pre></p>"},{"location":"reference/utilities/sandbox/#next-steps","title":"Next Steps","text":"<ol> <li>Testing: Use <code>SandboxClient</code> for local development and testing</li> <li>Production: Migrate to HealthChainAPI Gateway</li> <li>Protocols: See CDS Hooks and SOAP/CDA</li> </ol>"},{"location":"tutorials/interop/basic_conversion/","title":"Basic Format Conversion","text":"<p>This tutorial demonstrates how to use the HealthChain interoperability module to convert between different healthcare data formats.</p>"},{"location":"tutorials/interop/basic_conversion/#prerequisites","title":"Prerequisites","text":"<ul> <li>HealthChain installed (<code>pip install healthchain</code>)</li> <li>Basic understanding of FHIR resources</li> <li>Sample CDA or HL7v2 files (or you can use the examples below)</li> </ul>"},{"location":"tutorials/interop/basic_conversion/#setup","title":"Setup","text":"<p>First, let's import the required modules and create an interoperability engine:</p> <pre><code>from healthchain.interop import create_interop, FormatType\nfrom pathlib import Path\nimport json\n\n# Create an engine\nengine = create_interop()\n</code></pre>"},{"location":"tutorials/interop/basic_conversion/#converting-cda-to-fhir","title":"Converting CDA to FHIR","text":"<p>Let's convert a CDA document to FHIR resources:</p> <pre><code># Sample CDA document\ncda_xml = \"\"\"\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;templateId root=\"2.16.840.1.113883.10.20.22.1.2\"/&gt;\n  &lt;id root=\"2.16.840.1.113883.19.5.99999.1\"/&gt;\n  &lt;code code=\"34133-9\" displayName=\"Summarization of Episode Note\" codeSystem=\"2.16.840.1.113883.6.1\" codeSystemName=\"LOINC\"/&gt;\n  &lt;title&gt;Example CDA Document&lt;/title&gt;\n  &lt;effectiveTime value=\"20150519\"/&gt;\n  &lt;confidentialityCode code=\"N\" codeSystem=\"2.16.840.1.113883.5.25\"/&gt;\n  &lt;languageCode code=\"en-US\"/&gt;\n  &lt;recordTarget&gt;\n    &lt;patientRole&gt;\n      &lt;id extension=\"12345\" root=\"2.16.840.1.113883.19.5.99999.2\"/&gt;\n      &lt;patient&gt;\n        &lt;name&gt;\n          &lt;given&gt;John&lt;/given&gt;\n          &lt;family&gt;Smith&lt;/family&gt;\n        &lt;/name&gt;\n        &lt;administrativeGenderCode code=\"M\" codeSystem=\"2.16.840.1.113883.5.1\"/&gt;\n        &lt;birthTime value=\"19701101\"/&gt;\n      &lt;/patient&gt;\n    &lt;/patientRole&gt;\n  &lt;/recordTarget&gt;\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.1.11\"/&gt;\n          &lt;code code=\"11450-4\" codeSystem=\"2.16.840.1.113883.6.1\" displayName=\"Problem List\"/&gt;\n          &lt;title&gt;Problems&lt;/title&gt;\n          &lt;text&gt;Hypertension&lt;/text&gt;\n          &lt;entry&gt;\n            &lt;observation classCode=\"OBS\" moodCode=\"EVN\"&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.1.28\"/&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.1.54\"/&gt;\n              &lt;id root=\"2.16.840.1.113883.19.5.99999.3\"/&gt;\n              &lt;code code=\"64572001\" displayName=\"Hypertension\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n              &lt;statusCode code=\"completed\"/&gt;\n              &lt;effectiveTime value=\"20180101\"/&gt;\n              &lt;value xsi:type=\"CD\" code=\"64572001\" displayName=\"Hypertension\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"/&gt;\n            &lt;/observation&gt;\n          &lt;/entry&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n\"\"\"\n\n# Convert CDA to FHIR resources\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Print the resulting FHIR resources\nfor resource in fhir_resources:\n    print(f\"Resource Type: {resource.resource_type}\")\n    print(json.dumps(resource.dict(), indent=2))\n    print(\"-\" * 40)\n</code></pre>"},{"location":"tutorials/interop/basic_conversion/#converting-fhir-to-cda","title":"Converting FHIR to CDA","text":"<p>You can also convert FHIR resources to a CDA document:</p> <pre><code>from fhir.resources.condition import Condition\nfrom fhir.resources.patient import Patient\n\n# Create some FHIR resources\npatient = Patient(\n    resourceType=\"Patient\",\n    id=\"patient-1\",\n    name=[{\"family\": \"Smith\", \"given\": [\"John\"]}],\n    gender=\"male\",\n    birthDate=\"1970-11-01\"\n)\n\ncondition = Condition(\n    resourceType=\"Condition\",\n    id=\"condition-1\",\n    subject={\"reference\": \"Patient/patient-1\"},\n    code={\n        \"coding\": [\n            {\n                \"system\": \"http://snomed.info/sct\",\n                \"code\": \"38341003\",\n                \"display\": \"Hypertension\"\n            }\n        ],\n        \"text\": \"Hypertension\"\n    },\n    clinicalStatus={\n        \"coding\": [\n            {\n                \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                \"code\": \"active\"\n            }\n        ]\n    },\n    verificationStatus={\n        \"coding\": [\n            {\n                \"system\": \"http://terminology.hl7.org/CodeSystem/condition-ver-status\",\n                \"code\": \"confirmed\"\n            }\n        ]\n    },\n    onsetDateTime=\"2018-01-01\"\n)\n\n# Convert FHIR resources to CDA\nresources = [patient, condition]\ncda_document = engine.from_fhir(resources, dest_format=FormatType.CDA)\n\n# Print the resulting CDA document\nprint(cda_document)\n</code></pre>"},{"location":"tutorials/interop/basic_conversion/#converting-hl7v2-to-fhir","title":"Converting HL7v2 to FHIR","text":"<p>Let's convert an HL7v2 message to FHIR resources:</p> <pre><code># Sample HL7v2 message\nhl7v2_message = \"\"\"\nMSH|^~\\&amp;|EPIC|EPICADT|SMS|SMSADT|199912271408|CHARRIS|ADT^A01|1817457|D|2.5|\nPID|1||PATID1234^5^M11^ADT1^MR^GOOD HEALTH HOSPITAL~123456789^^^USSSA^SS||EVERYMAN^ADAM^A^III||19610615|M||C|2222 HOME STREET^^GREENSBORO^NC^27401-1020|GL|(555) 555-2004|(555)555-2004||S||PATID12345001^2^M10^ADT1^AN^A|444333333|987654^NC|\nNK1|1|NUCLEAR^NELDA^W|SPO||(555)555-3333||EC|||||||||||||||||||||||||\nPV1|1|I|2000^2012^01||||004777^ATTEND^AARON^A|||SUR||||ADM|A0|\n\"\"\"\n\n# Convert HL7v2 to FHIR resources\nfhir_resources = engine.to_fhir(hl7v2_message, src_format=FormatType.HL7V2)\n\n# Print the resulting FHIR resources\nfor resource in fhir_resources:\n    print(f\"Resource Type: {resource.resource_type}\")\n    print(json.dumps(resource.dict(), indent=2))\n    print(\"-\" * 40)\n</code></pre>"},{"location":"tutorials/interop/basic_conversion/#converting-fhir-to-hl7v2","title":"Converting FHIR to HL7v2","text":"<p>You can also convert FHIR resources to an HL7v2 message:</p> <pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.encounter import Encounter\n\n# Create some FHIR resources\npatient = Patient(\n    resourceType=\"Patient\",\n    id=\"patient-1\",\n    name=[{\"family\": \"Everyman\", \"given\": [\"Adam\", \"A\"], \"suffix\": [\"III\"]}],\n    gender=\"male\",\n    birthDate=\"1961-06-15\",\n    identifier=[\n        {\n            \"system\": \"urn:oid:1.2.36.146.595.217.0.1\",\n            \"value\": \"PATID1234\"\n        }\n    ],\n    address=[\n        {\n            \"line\": [\"2222 Home Street\"],\n            \"city\": \"Greensboro\",\n            \"state\": \"NC\",\n            \"postalCode\": \"27401\"\n        }\n    ],\n    telecom=[\n        {\n            \"system\": \"phone\",\n            \"value\": \"(555) 555-2004\",\n            \"use\": \"home\"\n        }\n    ]\n)\n\nencounter = Encounter(\n    resourceType=\"Encounter\",\n    id=\"encounter-1\",\n    status=\"finished\",\n    class_fhir={\n        \"system\": \"http://terminology.hl7.org/CodeSystem/v3-ActCode\",\n        \"code\": \"IMP\",\n        \"display\": \"inpatient encounter\"\n    },\n    subject={\n        \"reference\": \"Patient/patient-1\"\n    }\n)\n\n# Convert FHIR resources to HL7v2\nresources = [patient, encounter]\nhl7v2_message = engine.from_fhir(resources, dest_format=FormatType.HL7V2)\n\n# Print the resulting HL7v2 message\nprint(hl7v2_message)\n</code></pre>"},{"location":"tutorials/interop/basic_conversion/#saving-conversion-results","title":"Saving Conversion Results","text":"<p>Let's save our conversion results to files:</p> <pre><code># Save FHIR resources to JSON files\noutput_dir = Path(\"./output\")\noutput_dir.mkdir(exist_ok=True)\n\nfor resource in fhir_resources:\n    filename = f\"{resource.resource_type.lower()}_{resource.id}.json\"\n    with open(output_dir / filename, \"w\") as f:\n        json.dump(resource.dict(), f, indent=2)\n\n# Save CDA document to XML file\nwith open(output_dir / \"document.xml\", \"w\") as f:\n    f.write(cda_document)\n\n# Save HL7v2 message to file\nwith open(output_dir / \"message.hl7\", \"w\") as f:\n    f.write(hl7v2_message)\n</code></pre>"},{"location":"tutorials/interop/basic_conversion/#conclusion","title":"Conclusion","text":"<p>In this tutorial, you learned how to:</p> <ul> <li>Convert CDA documents to FHIR resources</li> <li>Convert FHIR resources to CDA documents</li> <li>Convert HL7v2 messages to FHIR resources</li> <li>Convert FHIR resources to HL7v2 messages</li> <li>Save conversion results to files</li> </ul> <p>For more advanced interoperability features, see the InteropEngine documentation and other cookbook examples.</p>"}]}