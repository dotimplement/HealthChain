{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to HealthChain","text":"<p>HealthChain is an open-source Python toolkit that streamlines productionizing healthcare AI. Built for AI/ML practitioners, it simplifies the complexity of real-time EHR integrations by providing seamless FHIR integration, unified data pipelines, and production-ready deployment.</p> <p>  Join our Discord  Quickstart Guide</p>"},{"location":"#what-are-the-main-features","title":"What are the main features?","text":"<ul> <li> <p> FHIR-native Pipelines</p> <p>Create custom pipelines or use pre-built ones for healthcare NLP and ML tasks with automatic FHIR output</p> <p> Pipeline</p> </li> <li> <p> Multi-EHR Gateway</p> <p>Connect to multiple healthcare systems with unified API supporting FHIR, CDS Hooks, and SOAP/CDA protocols</p> <p> Gateway</p> </li> <li> <p> Healthcare Data Conversion</p> <p>Convert between FHIR, CDA, and HL7v2 formats using configuration-driven InteropEngine</p> <p> Interoperability</p> </li> <li> <p> Developer Utilities</p> <p>Type-safe FHIR resources, validation helpers, and sandbox environments for rapid development</p> <p> Utilities</p> </li> </ul>"},{"location":"#getting-started-with-healthcare-ai","title":"Getting Started with Healthcare AI","text":"<p>HealthChain provides the missing middleware layer between healthcare systems and modern AI/ML development. Whether you're building clinical decision support tools, processing medical documents, or creating multi-system integrations, these docs will guide you through:</p> <ul> <li>\ud83d\udd27 Core concepts - Understand FHIR resources, pipelines, and gateway patterns</li> <li>\ud83d\udcda Real examples - Step-by-step tutorials for common healthcare AI use cases</li> <li>\ud83c\udfd7\ufe0f Advanced patterns - Production deployment, authentication, and multi-EHR workflows</li> <li>\ud83e\uddea Testing tools - Sandbox environments and utilities for development</li> </ul>"},{"location":"#what-you-can-build-with-healthchain","title":"What You Can Build with HealthChain","text":"Use Case Description \ud83d\udea8 CDS alerts for discharge summaries Generate clinical recommendations directly in Epic workflows \ud83d\udccb Automatic medical coding Extract ICD-10 or SNOMED-CT codes from physician notes with confidence scores \ud83d\udd17 Multi-EHR patient aggregation Combine patient records from Epic, Cerner, and specialty systems \ud83e\udd16 ML model deployment Serve your trained healthcare models as FHIR-compliant APIs \ud83d\udd04 Legacy document conversion Transform CDA documents to modern FHIR resources <p>New to healthcare AI? Start with our Quickstart Guide to build your first medical NLP pipeline in under 10 minutes.</p> <p>Ready to integrate with EHRs? Jump to our Cookbook for complete examples including CDS Hooks and FHIR integration.</p> <p>HealthChain is made by a small team with experience in software engineering, machine learning, and healthcare NLP. We understand that good data science is about more than just building models, and that good engineering is about more than just building systems. This rings especially true in healthcare, where people, processes, and technology all play a role in making an impact.</p> <p>For inquiries and collaborations, please get in touch!</p>"},{"location":"distribution/","title":"Licence and citations","text":"<p>HealthChain is licensed under Apache 2.0. To comply with the licence you need to add the following notice at the top every file that uses part of HealthChain code:</p> <pre><code>Copyright 2024 - dotimplement\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>You can install HealthChain with <code>pip</code>:</p> <pre><code>pip install healthchain\n</code></pre> <p>Note you need to download any libraries that you require separetly:</p> <pre><code>pip install langchain\npip install transformers\npip install torch\n...\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>After installing HealthChain, get up to speed quickly with the core components before diving further into the full documentation! HealthChain has three main components:</p> <ul> <li>Gateway: Connect to multiple healthcare systems with a single API.</li> <li>Pipelines: Easily build data processing pipelines for both clinical text and FHIR data.</li> <li>InteropEngine: Seamlessly convert between data formats like FHIR, HL7 CDA, and HL7v2.</li> </ul>"},{"location":"quickstart/#core-components","title":"Core Components \ud83e\udde9","text":""},{"location":"quickstart/#gateway","title":"Gateway \ud83d\udd0c","text":"<p>The HealthChainAPI provides a unified interface for connecting your AI application and models to multiple healthcare systems through a single API. It automatically handles FHIR API, CDS Hooks, and SOAP/CDA protocols with OAuth2 authentication.</p> <p>(Full Documentation on Gateway)</p> <pre><code>from healthchain.gateway import HealthChainAPI, FHIRGateway\nfrom fhir.resources.patient import Patient\n\n# Create your healthcare application\napp = HealthChainAPI(title=\"My Healthcare AI App\")\n\n# Connect to multiple FHIR servers\nfhir = FHIRGateway()\nfhir.add_source(\"epic\", \"fhir://fhir.epic.com/r4?client_id=...\")\nfhir.add_source(\"medplum\", \"fhir://api.medplum.com/fhir/R4/?client_id=...\")\n\n# Add AI transformations to FHIR data\n@fhir.transform(Patient)\ndef enhance_patient(id: str, source: str = None) -&gt; Patient:\n    patient = fhir.read(Patient, id, source)\n    # Your AI logic here\n    patient.active = True\n    fhir.update(patient, source)\n    return patient\n\n# Register and run\napp.register_gateway(fhir)\n\n# Available at: GET /fhir/transform/Patient/123?source=epic\n</code></pre>"},{"location":"quickstart/#pipeline","title":"Pipeline \ud83d\udee0\ufe0f","text":"<p>HealthChain Pipelines provide a flexible way to build and manage processing pipelines for NLP and ML tasks that can easily integrate with electronic health record (EHR) systems.</p> <p>You can build pipelines with three different approaches:</p>"},{"location":"quickstart/#1-quick-inline-functions","title":"1. Quick Inline Functions","text":"<p>For quick experiments, start by picking the right Container when you initialize your pipeline (e.g. <code>Pipeline[Document]()</code> for clinical text).</p> <p>Containers make your pipeline FHIR-native by loading and transforming your data (free text, EHR resources, etc.) into structured FHIR-ready formats. Just add your processing functions with <code>@add_node</code>, compile with <code>.build()</code>, and your pipeline is ready to process FHIR data end-to-end.</p> <p>(Full Documentation on Containers)</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io import Document\nfrom healthchain.fhir import create_condition\n\npipeline = Pipeline[Document]()\n\n@pipeline.add_node\ndef extract_diabetes(doc: Document) -&gt; Document:\n    \"\"\"Adds a FHIR Condition for diabetes if mentioned in the text.\"\"\"\n    if \"diabetes\" in doc.text.lower():\n        condition = create_condition(\n            code=\"73211009\",\n            display=\"Diabetes mellitus\",\n        )\n        doc.fhir.problem_list.append(condition)\n\n    return doc\n\npipe = pipeline.build()\n\ndoc = Document(\"Patient has a history of diabetes.\")\ndoc = pipe(doc)\n\nprint(doc.fhir.problem_list)  # FHIR Condition\n</code></pre>"},{"location":"quickstart/#2-build-with-components-and-adapters","title":"2. Build With Components and Adapters","text":"<p>Components are reusable, stateful classes that encapsulate specific processing logic, model loading, or configuration for your pipeline. Use them to organize complex workflows, handle model state, or integrate third-party libraries with minimal setup.</p> <p>HealthChain provides a set of ready-to-use NLP Integrations for common clinical NLP and ML tasks, and you can easily implement your own.</p> <p>(Full Documentation on Components)</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import TextPreProcessor, SpacyNLP, TextPostProcessor\nfrom healthchain.io import Document\n\npipeline = Pipeline[Document]()\n\npipeline.add_node(TextPreProcessor())\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_sci_sm\"))\npipeline.add_node(TextPostProcessor())\n\npipe = pipeline.build()\n\ndoc = Document(\"Patient presents with hypertension.\")\noutput = pipe(doc)\n</code></pre> <p>You can process legacy healthcare data formats too. Adapters convert between healthcare formats like CDA and your pipeline \u2014 just parse, process, and format without worrying about low-level data conversion.</p> <p>(Full Documentation on Adapters)</p> <pre><code>from healthchain.io import CdaAdapter\nfrom healthchain.models import CdaRequest\n\n# Use adapter for format conversion\nadapter = CdaAdapter()\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\n\n# Parse, process, format\ndoc = adapter.parse(cda_request)\nprocessed_doc = pipe(doc)\noutput = adapter.format(processed_doc)\n</code></pre>"},{"location":"quickstart/#3-use-prebuilt-pipelines","title":"3. Use Prebuilt Pipelines","text":"<p>Prebuilt pipelines are the fastest way to jump into healthcare AI with minimal setup: just load and run. Each pipeline bundles best-practice components and models for common clinical tasks (like coding or summarization) and handles all FHIR/CDA conversion for you. Easily customize or extend pipelines by adding/removing components, or swap models as needed.</p> <p>(Full Documentation on Pipelines)</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\n# Or load from local model\npipeline = MedicalCodingPipeline.from_local_model(\"./path/to/model\", source=\"spacy\")\n\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\noutput = pipeline.process_request(cda_request)\n</code></pre>"},{"location":"quickstart/#interoperability","title":"Interoperability \ud83d\udd04","text":"<p>The HealthChain Interoperability module provides tools for converting between different healthcare data formats, including FHIR, CDA, and HL7v2 messages.</p> <p>(Full Documentation on Interoperability Engine)</p> <pre><code>from healthchain.interop import create_interop, FormatType\n\n# Uses bundled configs - basic CDA \u2194 FHIR conversion\nengine = create_interop()\n\n# Load a CDA document\nwith open(\"tests/data/test_cda.xml\", \"r\") as f:\n    cda_xml = f.read()\n\n# Convert CDA XML to FHIR resources\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Convert FHIR resources back to CDA\ncda_document = engine.from_fhir(fhir_resources, dest_format=FormatType.CDA)\n</code></pre>"},{"location":"quickstart/#utilities","title":"Utilities \u2699\ufe0f","text":""},{"location":"quickstart/#sandbox-client","title":"Sandbox Client \ud83e\uddea","text":"<p>Use SandboxClient to quickly test your app against real-world EHR scenarios like CDS Hooks or Clinical Documentation Improvement (CDI) workflows. Load test datasets, send requests to your service, and validate responses in a few lines of code.</p> <p>(Full Documentation on Sandbox)</p>"},{"location":"quickstart/#workflows","title":"Workflows","text":"<p>A workflow represents a specific event in an EHR system that triggers your service (e.g., <code>patient-view</code> when opening a patient chart, <code>encounter-discharge</code> when discharging a patient).</p> <p>Workflows determine the request structure, required FHIR resources, and validation rules. Different workflows are compatible with different protocols:</p> Workflow Type Protocol Example Workflows CDS Hooks REST <code>patient-view</code>, <code>order-select</code>, <code>order-sign</code>, <code>encounter-discharge</code> Clinical Documentation SOAP <code>sign-note-inpatient</code>, <code>sign-note-outpatient</code>"},{"location":"quickstart/#available-dataset-loaders","title":"Available Dataset Loaders","text":"<p>Dataset Loaders are shortcuts for loading common clinical test datasets from file. Currently available:</p> Dataset Key Description FHIR Version Source Download Link <code>mimic-on-fhir</code> MIMIC-IV on FHIR Demo Dataset R4 PhysioNet Project Download ZIP (49.5 MB) <code>synthea-patient</code> Synthea FHIR Patient Records R4 Synthea Downloads Download ZIP (100 Sample, 36 MB) <pre><code>from healthchain.sandbox import list_available_datasets\n\n# See all registered datasets with descriptions\ndatasets = list_available_datasets()\nprint(datasets)\n</code></pre>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.sandbox import SandboxClient\n\n# Initialize client with your service URL and workflow\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/encounter-discharge\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load test data from a registered dataset\nclient.load_from_registry(\n    \"synthea-patient\",\n    data_dir=\"./data/synthea\",\n    resource_types=[\"Condition\", \"DocumentReference\"],\n    sample_size=3\n)\n\n# Optionally inspect before sending\nclient.preview_requests()  # See what will be sent\nclient.get_status()        # Check client state\n\n# Send requests to your service\nresponses = client.send_requests()\n</code></pre> <p>For clinical documentation workflows using SOAP/CDA:</p> <pre><code># Use context manager for automatic result saving\nwith SandboxClient(\n    url=\"http://localhost:8000/notereader/ProcessDocument\",\n    workflow=\"sign-note-inpatient\",\n    protocol=\"soap\"\n) as client:\n    client.load_from_path(\"./cookbook/data/notereader_cda.xml\")\n    responses = client.send_requests()\n    # Results automatically saved to ./output/ on success\n</code></pre>"},{"location":"quickstart/#fhir-helpers","title":"FHIR Helpers \ud83d\udd25","text":"<p>Use <code>healthchain.fhir</code> helpers to quickly create and manipulate FHIR resources (like <code>Condition</code>, <code>Observation</code>, etc.) in your code, ensuring they\u2019re standards-compliant with minimal boilerplate.</p> <p>(Full Documentation on FHIR Helpers)</p> <pre><code>from healthchain.fhir import create_condition\n\ncondition = create_condition(\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\",\n    subject=\"Patient/Foo\",\n    clinical_status=\"active\"\n)\n</code></pre>"},{"location":"quickstart/#going-further","title":"Going further \u2728","text":"<p>Check out our Cookbook section for more worked examples! HealthChain is still in its early stages, so if you have any questions please feel free to reach us on Github or Discord.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/adapters/","title":"Adapters","text":""},{"location":"api/adapters/#healthchain.io.adapters.cdaadapter.CdaAdapter","title":"<code>CdaAdapter</code>","text":"<p>               Bases: <code>BaseAdapter[CdaRequest, CdaResponse]</code></p> <p>CdaAdapter class for handling CDA (Clinical Document Architecture) documents.</p> <p>This adapter facilitates parsing CDA documents into Document objects and formatting Document objects back into CDA responses. It uses the InteropEngine to convert between CDA and FHIR formats, preserving clinical content while allowing for manipulation of the data within HealthChain pipelines.</p> ATTRIBUTE DESCRIPTION <code>engine</code> <p>The interoperability engine for CDA conversions. If not provided, the default engine is used.</p> <p> TYPE: <code>InteropEngine</code> </p> <code>original_cda</code> <p>The original CDA document for use in output.</p> <p> TYPE: <code>str</code> </p> <code>note_document_reference</code> <p>Reference to the note document                                         extracted from the CDA.</p> <p> TYPE: <code>DocumentReference</code> </p> METHOD DESCRIPTION <code>parse</code> <p>Parses a CDA document and extracts clinical data into a Document.</p> <code>format</code> <p>Converts a Document back to CDA format and returns a CdaResponse.</p> Source code in <code>healthchain/io/adapters/cdaadapter.py</code> <pre><code>class CdaAdapter(BaseAdapter[CdaRequest, CdaResponse]):\n    \"\"\"\n    CdaAdapter class for handling CDA (Clinical Document Architecture) documents.\n\n    This adapter facilitates parsing CDA documents into Document objects and formatting\n    Document objects back into CDA responses. It uses the InteropEngine to convert\n    between CDA and FHIR formats, preserving clinical content while allowing for\n    manipulation of the data within HealthChain pipelines.\n\n    Attributes:\n        engine (InteropEngine): The interoperability engine for CDA conversions. If not provided, the default engine is used.\n        original_cda (str): The original CDA document for use in output.\n        note_document_reference (DocumentReference): Reference to the note document\n                                                    extracted from the CDA.\n\n    Methods:\n        parse: Parses a CDA document and extracts clinical data into a Document.\n        format: Converts a Document back to CDA format and returns a CdaResponse.\n    \"\"\"\n\n    def __init__(self, engine: Optional[InteropEngine] = None):\n        \"\"\"\n        Initialize CdaAdapter with optional interop engine.\n\n        Args:\n            engine (Optional[InteropEngine]): Custom interop engine for CDA conversions.\n                                            If None, creates a default engine.\n        \"\"\"\n        # Initialize engine with default if not provided\n        initialized_engine = engine or create_interop()\n        super().__init__(engine=initialized_engine)\n        self.engine = initialized_engine\n        self.original_cda = None\n        self.note_document_reference = None\n\n    def parse(self, cda_request: CdaRequest) -&gt; Document:\n        \"\"\"\n        Parse a CDA document and extract clinical data into a HealthChain Document object.\n\n        This method takes a CdaRequest object as input, parses it using the InteropEngine to convert\n        CDA to FHIR resources, and creates a Document object with the extracted data. It creates a\n        DocumentReference for the original CDA XML and extracts clinical data (problems, medications,\n        allergies) into FHIR resources.\n\n        Args:\n            cda_request (CdaRequest): Request object containing the CDA XML document to process.\n\n        Returns:\n            Document: A Document object containing:\n                - The extracted note text as the document data\n                - FHIR resources organized into appropriate lists:\n                  - problem_list: List of Condition resources\n                  - medication_list: List of MedicationStatement resources\n                  - allergy_list: List of AllergyIntolerance resources\n                - DocumentReference resources for the original CDA and extracted notes\n\n        Note:\n            If a DocumentReference resource is found in the converted FHIR resources,\n            it is assumed to contain the note text and is stored for later use.\n        \"\"\"\n        # Store original CDA for later use\n        self.original_cda = cda_request.document\n\n        # Convert CDA to FHIR using the InteropEngine\n        fhir_resources = self.engine.to_fhir(\n            self.original_cda, src_format=FormatType.CDA\n        )\n\n        # Create a FHIR DocumentReference for the original CDA document\n        cda_document_reference = create_document_reference(\n            data=self.original_cda,\n            content_type=\"text/xml\",\n            description=\"Original CDA Document processed by HealthChain\",\n            attachment_title=\"Original CDA document in XML format\",\n        )\n\n        # Extract any DocumentReference resources for notes\n        note_text = \"\"\n        doc = Document(data=note_text)  # Create document with empty text initially\n\n        # Create FHIR Bundle and add documents\n        doc.fhir.bundle = create_bundle()\n        doc.fhir.add_document_reference(cda_document_reference)\n\n        problem_list = []\n        medication_list = []\n        allergy_list = []\n\n        for resource in fhir_resources:\n            if isinstance(resource, Condition):\n                problem_list.append(resource)\n                set_condition_category(resource, \"problem-list-item\")\n            elif isinstance(resource, MedicationStatement):\n                medication_list.append(resource)\n            elif isinstance(resource, AllergyIntolerance):\n                allergy_list.append(resource)\n            elif isinstance(resource, DocumentReference):\n                if (\n                    resource.content\n                    and resource.content[0].attachment\n                    and resource.content[0].attachment.data is not None\n                ):\n                    content = read_content_attachment(resource)\n                    if content is not None:\n                        note_text = content[0][\"data\"]\n                        self.note_document_reference = resource\n                    else:\n                        log.warning(\n                            f\"No content found in DocumentReference: {resource.id}\"\n                        )\n\n        doc.fhir.problem_list = problem_list\n        doc.fhir.medication_list = medication_list\n        doc.fhir.allergy_list = allergy_list\n\n        # Update document text\n        doc.data = note_text\n\n        # Add the note document reference\n        if self.note_document_reference is not None:\n            doc.fhir.add_document_reference(\n                self.note_document_reference, parent_id=cda_document_reference.id\n            )\n\n        return doc\n\n    def format(self, document: Document) -&gt; CdaResponse:\n        \"\"\"\n        Convert a Document object back to CDA format and return the response.\n\n        This method takes a Document object containing FHIR resources (problems,\n        medications, allergies) and converts them back to CDA format using the\n        InteropEngine. It combines all resources from the document's FHIR lists\n        and includes the note document reference if available.\n\n        Args:\n            document (Document): A Document object containing FHIR resources\n                                 in problem_list, medication_list, and allergy_list.\n\n        Returns:\n            CdaResponse: A response object containing the CDA document generated\n                        from the FHIR resources.\n        \"\"\"\n        # Collect all FHIR resources to convert to CDA\n        resources = []\n\n        if document.fhir.problem_list:\n            resources.extend(document.fhir.problem_list)\n\n        if document.fhir.allergy_list:\n            resources.extend(document.fhir.allergy_list)\n\n        if document.fhir.medication_list:\n            resources.extend(document.fhir.medication_list)\n\n        # Add the note document reference\n        if self.note_document_reference is not None:\n            resources.append(self.note_document_reference)\n\n        # Convert FHIR resources to CDA using InteropEngine\n        response_document = self.engine.from_fhir(resources, dest_format=FormatType.CDA)\n\n        return CdaResponse(document=response_document)\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdaadapter.CdaAdapter.__init__","title":"<code>__init__(engine=None)</code>","text":"<p>Initialize CdaAdapter with optional interop engine.</p> PARAMETER DESCRIPTION <code>engine</code> <p>Custom interop engine for CDA conversions.                             If None, creates a default engine.</p> <p> TYPE: <code>Optional[InteropEngine]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/io/adapters/cdaadapter.py</code> <pre><code>def __init__(self, engine: Optional[InteropEngine] = None):\n    \"\"\"\n    Initialize CdaAdapter with optional interop engine.\n\n    Args:\n        engine (Optional[InteropEngine]): Custom interop engine for CDA conversions.\n                                        If None, creates a default engine.\n    \"\"\"\n    # Initialize engine with default if not provided\n    initialized_engine = engine or create_interop()\n    super().__init__(engine=initialized_engine)\n    self.engine = initialized_engine\n    self.original_cda = None\n    self.note_document_reference = None\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdaadapter.CdaAdapter.format","title":"<code>format(document)</code>","text":"<p>Convert a Document object back to CDA format and return the response.</p> <p>This method takes a Document object containing FHIR resources (problems, medications, allergies) and converts them back to CDA format using the InteropEngine. It combines all resources from the document's FHIR lists and includes the note document reference if available.</p> PARAMETER DESCRIPTION <code>document</code> <p>A Document object containing FHIR resources                  in problem_list, medication_list, and allergy_list.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>CdaResponse</code> <p>A response object containing the CDA document generated         from the FHIR resources.</p> <p> TYPE: <code>CdaResponse</code> </p> Source code in <code>healthchain/io/adapters/cdaadapter.py</code> <pre><code>def format(self, document: Document) -&gt; CdaResponse:\n    \"\"\"\n    Convert a Document object back to CDA format and return the response.\n\n    This method takes a Document object containing FHIR resources (problems,\n    medications, allergies) and converts them back to CDA format using the\n    InteropEngine. It combines all resources from the document's FHIR lists\n    and includes the note document reference if available.\n\n    Args:\n        document (Document): A Document object containing FHIR resources\n                             in problem_list, medication_list, and allergy_list.\n\n    Returns:\n        CdaResponse: A response object containing the CDA document generated\n                    from the FHIR resources.\n    \"\"\"\n    # Collect all FHIR resources to convert to CDA\n    resources = []\n\n    if document.fhir.problem_list:\n        resources.extend(document.fhir.problem_list)\n\n    if document.fhir.allergy_list:\n        resources.extend(document.fhir.allergy_list)\n\n    if document.fhir.medication_list:\n        resources.extend(document.fhir.medication_list)\n\n    # Add the note document reference\n    if self.note_document_reference is not None:\n        resources.append(self.note_document_reference)\n\n    # Convert FHIR resources to CDA using InteropEngine\n    response_document = self.engine.from_fhir(resources, dest_format=FormatType.CDA)\n\n    return CdaResponse(document=response_document)\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdaadapter.CdaAdapter.parse","title":"<code>parse(cda_request)</code>","text":"<p>Parse a CDA document and extract clinical data into a HealthChain Document object.</p> <p>This method takes a CdaRequest object as input, parses it using the InteropEngine to convert CDA to FHIR resources, and creates a Document object with the extracted data. It creates a DocumentReference for the original CDA XML and extracts clinical data (problems, medications, allergies) into FHIR resources.</p> PARAMETER DESCRIPTION <code>cda_request</code> <p>Request object containing the CDA XML document to process.</p> <p> TYPE: <code>CdaRequest</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>A Document object containing: - The extracted note text as the document data - FHIR resources organized into appropriate lists:   - problem_list: List of Condition resources   - medication_list: List of MedicationStatement resources   - allergy_list: List of AllergyIntolerance resources - DocumentReference resources for the original CDA and extracted notes</p> <p> TYPE: <code>Document</code> </p> Note <p>If a DocumentReference resource is found in the converted FHIR resources, it is assumed to contain the note text and is stored for later use.</p> Source code in <code>healthchain/io/adapters/cdaadapter.py</code> <pre><code>def parse(self, cda_request: CdaRequest) -&gt; Document:\n    \"\"\"\n    Parse a CDA document and extract clinical data into a HealthChain Document object.\n\n    This method takes a CdaRequest object as input, parses it using the InteropEngine to convert\n    CDA to FHIR resources, and creates a Document object with the extracted data. It creates a\n    DocumentReference for the original CDA XML and extracts clinical data (problems, medications,\n    allergies) into FHIR resources.\n\n    Args:\n        cda_request (CdaRequest): Request object containing the CDA XML document to process.\n\n    Returns:\n        Document: A Document object containing:\n            - The extracted note text as the document data\n            - FHIR resources organized into appropriate lists:\n              - problem_list: List of Condition resources\n              - medication_list: List of MedicationStatement resources\n              - allergy_list: List of AllergyIntolerance resources\n            - DocumentReference resources for the original CDA and extracted notes\n\n    Note:\n        If a DocumentReference resource is found in the converted FHIR resources,\n        it is assumed to contain the note text and is stored for later use.\n    \"\"\"\n    # Store original CDA for later use\n    self.original_cda = cda_request.document\n\n    # Convert CDA to FHIR using the InteropEngine\n    fhir_resources = self.engine.to_fhir(\n        self.original_cda, src_format=FormatType.CDA\n    )\n\n    # Create a FHIR DocumentReference for the original CDA document\n    cda_document_reference = create_document_reference(\n        data=self.original_cda,\n        content_type=\"text/xml\",\n        description=\"Original CDA Document processed by HealthChain\",\n        attachment_title=\"Original CDA document in XML format\",\n    )\n\n    # Extract any DocumentReference resources for notes\n    note_text = \"\"\n    doc = Document(data=note_text)  # Create document with empty text initially\n\n    # Create FHIR Bundle and add documents\n    doc.fhir.bundle = create_bundle()\n    doc.fhir.add_document_reference(cda_document_reference)\n\n    problem_list = []\n    medication_list = []\n    allergy_list = []\n\n    for resource in fhir_resources:\n        if isinstance(resource, Condition):\n            problem_list.append(resource)\n            set_condition_category(resource, \"problem-list-item\")\n        elif isinstance(resource, MedicationStatement):\n            medication_list.append(resource)\n        elif isinstance(resource, AllergyIntolerance):\n            allergy_list.append(resource)\n        elif isinstance(resource, DocumentReference):\n            if (\n                resource.content\n                and resource.content[0].attachment\n                and resource.content[0].attachment.data is not None\n            ):\n                content = read_content_attachment(resource)\n                if content is not None:\n                    note_text = content[0][\"data\"]\n                    self.note_document_reference = resource\n                else:\n                    log.warning(\n                        f\"No content found in DocumentReference: {resource.id}\"\n                    )\n\n    doc.fhir.problem_list = problem_list\n    doc.fhir.medication_list = medication_list\n    doc.fhir.allergy_list = allergy_list\n\n    # Update document text\n    doc.data = note_text\n\n    # Add the note document reference\n    if self.note_document_reference is not None:\n        doc.fhir.add_document_reference(\n            self.note_document_reference, parent_id=cda_document_reference.id\n        )\n\n    return doc\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdsfhiradapter.CdsFhirAdapter","title":"<code>CdsFhirAdapter</code>","text":"<p>               Bases: <code>BaseAdapter[CDSRequest, CDSResponse]</code></p> <p>CdsFhirAdapter class for handling FHIR (Fast Healthcare Interoperability Resources) documents for CDS Hooks.</p> <p>This adapter facilitates the conversion between CDSRequest objects and Document objects, as well as the creation of CDSResponse objects from processed Documents. Unlike CdaAdapter, this adapter works directly with FHIR data and does not require interop conversion.</p> ATTRIBUTE DESCRIPTION <code>hook_name</code> <p>The name of the CDS Hook being used.</p> <p> TYPE: <code>str</code> </p> <code>engine</code> <p>Optional interoperability engine (not used by this adapter).</p> <p> TYPE: <code>Optional[Any]</code> </p> METHOD DESCRIPTION <code>parse</code> <p>Converts a CDSRequest object into a Document object.</p> <code>format</code> <p>Converts a Document object into a CDSResponse object.</p> Source code in <code>healthchain/io/adapters/cdsfhiradapter.py</code> <pre><code>class CdsFhirAdapter(BaseAdapter[CDSRequest, CDSResponse]):\n    \"\"\"\n    CdsFhirAdapter class for handling FHIR (Fast Healthcare Interoperability Resources) documents\n    for CDS Hooks.\n\n    This adapter facilitates the conversion between CDSRequest objects and Document objects,\n    as well as the creation of CDSResponse objects from processed Documents. Unlike CdaAdapter,\n    this adapter works directly with FHIR data and does not require interop conversion.\n\n    Attributes:\n        hook_name (str): The name of the CDS Hook being used.\n        engine (Optional[Any]): Optional interoperability engine (not used by this adapter).\n\n    Methods:\n        parse: Converts a CDSRequest object into a Document object.\n        format: Converts a Document object into a CDSResponse object.\n    \"\"\"\n\n    def __init__(self, hook_name: str = None, engine: Optional[Any] = None):\n        \"\"\"\n        Initialize CdsFhirAdapter with hook name and optional engine.\n\n        Args:\n            hook_name (str): The name of the CDS Hook being used. Defaults to None.\n            engine (Optional[Any]): Optional interoperability engine (not used by this adapter).\n        \"\"\"\n        super().__init__(engine=engine)\n        self.hook_name = hook_name\n\n    def parse(\n        self, cds_request: CDSRequest, prefetch_document_key: Optional[str] = \"document\"\n    ) -&gt; Document:\n        \"\"\"\n        Convert a CDSRequest object into a Document object.\n\n        Takes a CDSRequest containing FHIR resources and extracts them into a Document object.\n        The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources.\n        If a DocumentReference resource is provided via prefetch_document_key, its text content\n        will be extracted into Document.data. For multiple attachments, the text content will be\n        concatenated with newlines.\n\n        Args:\n            cds_request (CDSRequest): The CDSRequest containing FHIR resources in its prefetch\n                and/or a FHIR server URL.\n            prefetch_document_key (str, optional): Key in the prefetch data containing a\n                DocumentReference resource whose text content should be extracted.\n                Defaults to \"document\".\n\n        Returns:\n            Document: A Document object containing:\n                - All prefetched FHIR resources in fhir.prefetch_resources\n                - Any text content from the DocumentReference in data (empty string if none found)\n                - For multiple attachments, text content is concatenated with newlines\n\n        Raises:\n            ValueError: If neither prefetch nor fhirServer is provided in cds_request\n            NotImplementedError: If fhirServer is provided (FHIR server support not implemented)\n        \"\"\"\n        if cds_request.prefetch is None and cds_request.fhirServer is None:\n            raise ValueError(\n                \"Either prefetch or fhirServer must be provided to extract FHIR data!\"\n            )\n\n        if cds_request.fhirServer is not None:\n            raise NotImplementedError(\"FHIR server is not implemented yet!\")\n\n        # Create an empty Document object\n        doc = Document(data=\"\")\n\n        # Convert prefetch dict resources to FHIR objects\n        doc.fhir.prefetch_resources = convert_prefetch_to_fhir_objects(\n            cds_request.prefetch or {}\n        )\n\n        # Extract text content from DocumentReference resource if provided\n        document_resource = doc.fhir.prefetch_resources.get(prefetch_document_key)\n\n        if not document_resource:\n            log.warning(\n                f\"No DocumentReference resource found in prefetch data with key {prefetch_document_key}\"\n            )\n        elif isinstance(document_resource, DocumentReference):\n            try:\n                attachments = read_content_attachment(\n                    document_resource, include_data=True\n                )\n                for attachment in attachments:\n                    if len(attachments) &gt; 1:\n                        doc.data += attachment.get(\"data\", \"\") + \"\\n\"\n                    else:\n                        doc.data += attachment.get(\"data\", \"\")\n            except Exception as e:\n                log.warning(f\"Error extracting text from DocumentReference: {e}\")\n\n        return doc\n\n    def format(self, document: Document) -&gt; CDSResponse:\n        \"\"\"\n        Convert Document to CDSResponse.\n\n        This method takes a Document object containing CDS cards and actions,\n        and converts them into a CDSResponse object that follows the CDS Hooks\n        specification.\n\n        Args:\n            document (Document): The Document object containing CDS results.\n\n        Returns:\n            CDSResponse: A response object containing CDS cards and optional system actions.\n                         If no cards are found in the Document, an empty list of cards is returned.\n        \"\"\"\n        if document.cds.cards is None:\n            log.warning(\"No CDS cards found in Document, returning empty list of cards\")\n            return CDSResponse(cards=[])\n\n        return CDSResponse(cards=document.cds.cards, systemActions=document.cds.actions)\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdsfhiradapter.CdsFhirAdapter.__init__","title":"<code>__init__(hook_name=None, engine=None)</code>","text":"<p>Initialize CdsFhirAdapter with hook name and optional engine.</p> PARAMETER DESCRIPTION <code>hook_name</code> <p>The name of the CDS Hook being used. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>engine</code> <p>Optional interoperability engine (not used by this adapter).</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/io/adapters/cdsfhiradapter.py</code> <pre><code>def __init__(self, hook_name: str = None, engine: Optional[Any] = None):\n    \"\"\"\n    Initialize CdsFhirAdapter with hook name and optional engine.\n\n    Args:\n        hook_name (str): The name of the CDS Hook being used. Defaults to None.\n        engine (Optional[Any]): Optional interoperability engine (not used by this adapter).\n    \"\"\"\n    super().__init__(engine=engine)\n    self.hook_name = hook_name\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdsfhiradapter.CdsFhirAdapter.format","title":"<code>format(document)</code>","text":"<p>Convert Document to CDSResponse.</p> <p>This method takes a Document object containing CDS cards and actions, and converts them into a CDSResponse object that follows the CDS Hooks specification.</p> PARAMETER DESCRIPTION <code>document</code> <p>The Document object containing CDS results.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>CDSResponse</code> <p>A response object containing CDS cards and optional system actions.          If no cards are found in the Document, an empty list of cards is returned.</p> <p> TYPE: <code>CDSResponse</code> </p> Source code in <code>healthchain/io/adapters/cdsfhiradapter.py</code> <pre><code>def format(self, document: Document) -&gt; CDSResponse:\n    \"\"\"\n    Convert Document to CDSResponse.\n\n    This method takes a Document object containing CDS cards and actions,\n    and converts them into a CDSResponse object that follows the CDS Hooks\n    specification.\n\n    Args:\n        document (Document): The Document object containing CDS results.\n\n    Returns:\n        CDSResponse: A response object containing CDS cards and optional system actions.\n                     If no cards are found in the Document, an empty list of cards is returned.\n    \"\"\"\n    if document.cds.cards is None:\n        log.warning(\"No CDS cards found in Document, returning empty list of cards\")\n        return CDSResponse(cards=[])\n\n    return CDSResponse(cards=document.cds.cards, systemActions=document.cds.actions)\n</code></pre>"},{"location":"api/adapters/#healthchain.io.adapters.cdsfhiradapter.CdsFhirAdapter.parse","title":"<code>parse(cds_request, prefetch_document_key='document')</code>","text":"<p>Convert a CDSRequest object into a Document object.</p> <p>Takes a CDSRequest containing FHIR resources and extracts them into a Document object. The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources. If a DocumentReference resource is provided via prefetch_document_key, its text content will be extracted into Document.data. For multiple attachments, the text content will be concatenated with newlines.</p> PARAMETER DESCRIPTION <code>cds_request</code> <p>The CDSRequest containing FHIR resources in its prefetch and/or a FHIR server URL.</p> <p> TYPE: <code>CDSRequest</code> </p> <code>prefetch_document_key</code> <p>Key in the prefetch data containing a DocumentReference resource whose text content should be extracted. Defaults to \"document\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'document'</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>A Document object containing: - All prefetched FHIR resources in fhir.prefetch_resources - Any text content from the DocumentReference in data (empty string if none found) - For multiple attachments, text content is concatenated with newlines</p> <p> TYPE: <code>Document</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither prefetch nor fhirServer is provided in cds_request</p> <code>NotImplementedError</code> <p>If fhirServer is provided (FHIR server support not implemented)</p> Source code in <code>healthchain/io/adapters/cdsfhiradapter.py</code> <pre><code>def parse(\n    self, cds_request: CDSRequest, prefetch_document_key: Optional[str] = \"document\"\n) -&gt; Document:\n    \"\"\"\n    Convert a CDSRequest object into a Document object.\n\n    Takes a CDSRequest containing FHIR resources and extracts them into a Document object.\n    The Document will contain all prefetched FHIR resources in its fhir.prefetch_resources.\n    If a DocumentReference resource is provided via prefetch_document_key, its text content\n    will be extracted into Document.data. For multiple attachments, the text content will be\n    concatenated with newlines.\n\n    Args:\n        cds_request (CDSRequest): The CDSRequest containing FHIR resources in its prefetch\n            and/or a FHIR server URL.\n        prefetch_document_key (str, optional): Key in the prefetch data containing a\n            DocumentReference resource whose text content should be extracted.\n            Defaults to \"document\".\n\n    Returns:\n        Document: A Document object containing:\n            - All prefetched FHIR resources in fhir.prefetch_resources\n            - Any text content from the DocumentReference in data (empty string if none found)\n            - For multiple attachments, text content is concatenated with newlines\n\n    Raises:\n        ValueError: If neither prefetch nor fhirServer is provided in cds_request\n        NotImplementedError: If fhirServer is provided (FHIR server support not implemented)\n    \"\"\"\n    if cds_request.prefetch is None and cds_request.fhirServer is None:\n        raise ValueError(\n            \"Either prefetch or fhirServer must be provided to extract FHIR data!\"\n        )\n\n    if cds_request.fhirServer is not None:\n        raise NotImplementedError(\"FHIR server is not implemented yet!\")\n\n    # Create an empty Document object\n    doc = Document(data=\"\")\n\n    # Convert prefetch dict resources to FHIR objects\n    doc.fhir.prefetch_resources = convert_prefetch_to_fhir_objects(\n        cds_request.prefetch or {}\n    )\n\n    # Extract text content from DocumentReference resource if provided\n    document_resource = doc.fhir.prefetch_resources.get(prefetch_document_key)\n\n    if not document_resource:\n        log.warning(\n            f\"No DocumentReference resource found in prefetch data with key {prefetch_document_key}\"\n        )\n    elif isinstance(document_resource, DocumentReference):\n        try:\n            attachments = read_content_attachment(\n                document_resource, include_data=True\n            )\n            for attachment in attachments:\n                if len(attachments) &gt; 1:\n                    doc.data += attachment.get(\"data\", \"\") + \"\\n\"\n                else:\n                    doc.data += attachment.get(\"data\", \"\")\n        except Exception as e:\n            log.warning(f\"Error extracting text from DocumentReference: {e}\")\n\n    return doc\n</code></pre>"},{"location":"api/cds_hooks/","title":"CDS Hooks","text":"<p>https://cds-hooks.org/specification/current/#discovery</p> <p>This is not compulsary</p> <p>https://cds-hooks.org/specification/current/#feedback</p>"},{"location":"api/cds_hooks/#healthchain.models.hooks.encounterdischarge.EncounterDischargeContext","title":"<code>EncounterDischargeContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: This hook is triggered during the discharge process for typically inpatient encounters. It can be invoked at any point from the start to the end of the discharge process. The purpose is to allow hook services to intervene in various aspects of the discharge decision. This includes verifying discharge medications, ensuring continuity of care planning, and verifying necessary documentation for discharge processing.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. The ID of the current user, expected to be a Practitioner or PractitionerRole.           For example, 'Practitioner/123'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id of the patient being discharged.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>REQUIRED. The FHIR Encounter.id of the encounter being ended.</p> <p> TYPE: <code>str</code> </p> <p>Documentation: https://cds-hooks.org/hooks/encounter-discharge/</p> Source code in <code>healthchain/models/hooks/encounterdischarge.py</code> <pre><code>class EncounterDischargeContext(BaseHookContext):\n    \"\"\"\n    Workflow:\n    This hook is triggered during the discharge process for typically inpatient encounters. It can be invoked\n    at any point from the start to the end of the discharge process. The purpose is to allow hook services to\n    intervene in various aspects of the discharge decision. This includes verifying discharge medications,\n    ensuring continuity of care planning, and verifying necessary documentation for discharge processing.\n\n    Attributes:\n        userId (str): REQUIRED. The ID of the current user, expected to be a Practitioner or PractitionerRole.\n                      For example, 'Practitioner/123'.\n        patientId (str): REQUIRED. The FHIR Patient.id of the patient being discharged.\n        encounterId (str): REQUIRED. The FHIR Encounter.id of the encounter being ended.\n\n    Documentation: https://cds-hooks.org/hooks/encounter-discharge/\n    \"\"\"\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"The ID of the current user, expected to be in the format 'Practitioner/123'.\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id of the patient being discharged.\",\n    )\n    encounterId: str = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the encounter being ended.\",\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.orderselect.OrderSelectContext","title":"<code>OrderSelectContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The order-select hook occurs after the clinician selects the order and before signing. This hook occurs when a clinician initially selects one or more new orders from a list of potential orders for a specific patient (including orders for medications, procedures, labs and other orders). The newly selected order defines that medication, procedure, lab, etc, but may or may not define the additional details necessary to finalize the order.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. An identifier of the current user, in the format [ResourceType]/[id],           where ResourceType is either 'Practitioner' or 'PractitionerRole'. Examples: 'PractitionerRole/123',           'Practitioner/abc'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>OPTIONAL. The FHIR Encounter.id representing the current encounter in context,                          if applicable.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>selections</code> <p>REQUIRED. A list of the FHIR id(s) of the newly selected orders, referencing resources                 in the draftOrders Bundle. Example: 'MedicationRequest/103'.</p> <p> TYPE: <code>[str]</code> </p> <code>draftOrders</code> <p>REQUIRED. A Bundle of FHIR request resources with a draft status, representing all unsigned                   orders from the current session, including newly selected orders.</p> <p> TYPE: <code>object</code> </p> <p>Documentation: https://cds-hooks.org/hooks/order-select/</p> Source code in <code>healthchain/models/hooks/orderselect.py</code> <pre><code>class OrderSelectContext(BaseHookContext):\n    \"\"\"\n    Workflow: The order-select hook occurs after the clinician selects the order and before signing.\n    This hook occurs when a clinician initially selects one or more new orders from a list of\n    potential orders for a specific patient (including orders for medications, procedures, labs\n    and other orders). The newly selected order defines that medication, procedure, lab, etc,\n    but may or may not define the additional details necessary to finalize the order.\n\n    Attributes:\n        userId (str): REQUIRED. An identifier of the current user, in the format [ResourceType]/[id],\n                      where ResourceType is either 'Practitioner' or 'PractitionerRole'. Examples: 'PractitionerRole/123',\n                      'Practitioner/abc'.\n        patientId (str): REQUIRED. The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): OPTIONAL. The FHIR Encounter.id representing the current encounter in context,\n                                     if applicable.\n        selections ([str]): REQUIRED. A list of the FHIR id(s) of the newly selected orders, referencing resources\n                            in the draftOrders Bundle. Example: 'MedicationRequest/103'.\n        draftOrders (object): REQUIRED. A Bundle of FHIR request resources with a draft status, representing all unsigned\n                              orders from the current session, including newly selected orders.\n\n    Documentation: https://cds-hooks.org/hooks/order-select/\n    \"\"\"\n\n    # TODO: validate selection and FHIR Bundle resource\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"An identifier of the current user in the format [ResourceType]/[id].\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id representing the current patient in context.\",\n    )\n    encounterId: Optional[str] = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the current encounter, if applicable.\",\n    )\n    selections: List[str] = Field(\n        ..., description=\"A list of the FHIR ids of the newly selected orders.\"\n    )\n    draftOrders: Dict[str, Any] = Field(\n        ..., description=\"A Bundle of FHIR request resources with a draft status.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\n            \"userId\",\n            \"patientId\",\n            \"encounterId\",\n            \"selections\",\n            \"draftOrders\",\n        }\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n\n    @model_validator(mode=\"after\")\n    def validate_selections(self) -&gt; Self:\n        for selection in self.selections:\n            if \"/\" not in selection:\n                raise ValueError(\n                    \"Each selection must be a valid FHIR resource identifier in the format 'ResourceType/ResourceID'.\"\n                )\n        return self\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.ordersign.OrderSignContext","title":"<code>OrderSignContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The order-sign hook is triggered when a clinician is ready to sign one or more orders for a patient. This includes orders for medications, procedures, labs, and other orders. It is one of the last workflow events before an order is promoted from a draft status. The context includes all order details such as dose, quantity, route, etc., even though the order is still in a draft status. This hook is also applicable for re-signing revised orders, which may have a status other than 'draft'. The hook replaces the medication-prescribe and order-review hooks.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>REQUIRED. The ID of the current user, expected to be of type 'Practitioner' or 'PractitionerRole'.           Examples include 'PractitionerRole/123' or 'Practitioner/abc'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>REQUIRED. The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>OPTIONAL. The FHIR Encounter.id of the current encounter in context.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>draftOrders</code> <p>REQUIRED. A Bundle of FHIR request resources with a draft status, representing orders that                 aren't yet signed from the current ordering session.</p> <p> TYPE: <code>dict</code> </p> <p>Documentation: https://cds-hooks.org/hooks/order-sign/</p> Source code in <code>healthchain/models/hooks/ordersign.py</code> <pre><code>class OrderSignContext(BaseHookContext):\n    \"\"\"\n    Workflow:\n    The order-sign hook is triggered when a clinician is ready to sign one or more orders for a patient.\n    This includes orders for medications, procedures, labs, and other orders. It is one of the last workflow\n    events before an order is promoted from a draft status. The context includes all order details such as\n    dose, quantity, route, etc., even though the order is still in a draft status. This hook is also applicable\n    for re-signing revised orders, which may have a status other than 'draft'. The hook replaces the\n    medication-prescribe and order-review hooks.\n\n    Attributes:\n        userId (str): REQUIRED. The ID of the current user, expected to be of type 'Practitioner' or 'PractitionerRole'.\n                      Examples include 'PractitionerRole/123' or 'Practitioner/abc'.\n        patientId (str): REQUIRED. The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): OPTIONAL. The FHIR Encounter.id of the current encounter in context.\n        draftOrders (dict): REQUIRED. A Bundle of FHIR request resources with a draft status, representing orders that\n                            aren't yet signed from the current ordering session.\n\n    Documentation: https://cds-hooks.org/hooks/order-sign/\n    \"\"\"\n\n    # TODO: validate draftOrders\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole)/[^\\s]+$\",\n        description=\"The ID of the current user in the format [ResourceType]/[id].\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id representing the current patient in context.\",\n    )\n    encounterId: Optional[str] = Field(\n        default_factory=id_generator.generate_random_encounter_id,\n        description=\"The FHIR Encounter.id of the current encounter, if applicable.\",\n    )\n    draftOrders: Dict[str, Any] = Field(\n        ..., description=\"A Bundle of FHIR request resources with a draft status.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\", \"draftOrders\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.hooks.patientview.PatientViewContext","title":"<code>PatientViewContext</code>","text":"<p>               Bases: <code>BaseHookContext</code></p> <p>Workflow: The user has just opened a patient's record; typically called only once at the beginning of a user's interaction with a specific patient's record.</p> ATTRIBUTE DESCRIPTION <code>userId</code> <p>An identifier of the current user, in the format [ResourceType]/[id],           where ResourceType is one of 'Practitioner', 'PractitionerRole', 'Patient',           or 'RelatedPerson'. Examples: 'Practitioner/abc', 'Patient/123'.</p> <p> TYPE: <code>str</code> </p> <code>patientId</code> <p>The FHIR Patient.id representing the current patient in context.</p> <p> TYPE: <code>str</code> </p> <code>encounterId</code> <p>The FHIR Encounter.id representing the current encounter in context,                          if applicable. This field is optional.</p> <p> TYPE: <code>Optional[str]</code> </p> <p>Documentation: https://cds-hooks.org/hooks/patient-view/</p> Source code in <code>healthchain/models/hooks/patientview.py</code> <pre><code>class PatientViewContext(BaseHookContext):\n    \"\"\"\n    Workflow: The user has just opened a patient's record; typically called only once at the beginning of a user's\n    interaction with a specific patient's record.\n\n    Attributes:\n        userId (str): An identifier of the current user, in the format [ResourceType]/[id],\n                      where ResourceType is one of 'Practitioner', 'PractitionerRole', 'Patient',\n                      or 'RelatedPerson'. Examples: 'Practitioner/abc', 'Patient/123'.\n        patientId (str): The FHIR Patient.id representing the current patient in context.\n        encounterId (Optional[str]): The FHIR Encounter.id representing the current encounter in context,\n                                     if applicable. This field is optional.\n\n    Documentation: https://cds-hooks.org/hooks/patient-view/\n    \"\"\"\n\n    # TODO: more comprehensive validator? for now regex should suffice\n\n    userId: str = Field(\n        default_factory=id_generator.generate_random_user_id,\n        pattern=r\"^(Practitioner|PractitionerRole|Patient|RelatedPerson)/[^\\s]+$\",\n        description=\"The ID of the current user, expected to be in the format 'Practitioner/123'.\",\n    )\n    patientId: str = Field(\n        default_factory=id_generator.generate_random_patient_id,\n        description=\"The FHIR Patient.id of the patient.\",\n    )\n    encounterId: Optional[str] = Field(\n        None, description=\"The FHIR Encounter.id of the encounter, if applicable.\"\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_unexpected_keys(cls, values):\n        allowed_keys = {\"userId\", \"patientId\", \"encounterId\"}\n        unexpected_keys = set(values) - allowed_keys\n        if unexpected_keys:\n            raise ValueError(f\"Unexpected keys provided: {unexpected_keys}\")\n        return values\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsdiscovery.CDSService","title":"<code>CDSService</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing a CDS service configuration.</p> ATTRIBUTE DESCRIPTION <code>hook</code> <p>The hook this service should be invoked on. This should correspond to one of the predefined hooks.</p> <p> TYPE: <code>str</code> </p> <code>title</code> <p>The human-friendly name of this service. It is recommended to provide this for better usability.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>description</code> <p>A detailed description of what this service does and its purpose within the CDS framework.</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>The unique identifier of this service. It forms part of the URL as {baseUrl}/cds-services/{id}.</p> <p> TYPE: <code>str</code> </p> <code>prefetch</code> <p>Optional FHIR queries that the service requests the CDS Client to perform                                 and provide on each service call. Keys describe the type of data and values are the actual FHIR query strings.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> </p> <code>usageRequirements</code> <p>Human-friendly description of any preconditions for the use of this CDS service.</p> <p> TYPE: <code>Optional[str]</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#response</p> Source code in <code>healthchain/models/responses/cdsdiscovery.py</code> <pre><code>class CDSService(BaseModel):\n    \"\"\"\n    A model representing a CDS service configuration.\n\n    Attributes:\n        hook (str): The hook this service should be invoked on. This should correspond to one of the predefined hooks.\n        title (Optional[str]): The human-friendly name of this service. It is recommended to provide this for better usability.\n        description (str): A detailed description of what this service does and its purpose within the CDS framework.\n        id (str): The unique identifier of this service. It forms part of the URL as {baseUrl}/cds-services/{id}.\n        prefetch (Optional[Dict[str, str]]): Optional FHIR queries that the service requests the CDS Client to perform\n                                            and provide on each service call. Keys describe the type of data and values are the actual FHIR query strings.\n        usageRequirements (Optional[str]): Human-friendly description of any preconditions for the use of this CDS service.\n\n    Documentation: https://cds-hooks.org/specification/current/#response\n    \"\"\"\n\n    hook: str\n    description: str\n    id: str\n    title: Optional[str] = None\n    prefetch: Optional[Dict[str, Any]] = None\n    usageRequirements: Optional[str] = None\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsdiscovery.CDSServiceInformation","title":"<code>CDSServiceInformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A CDS Service is discoverable via a stable endpoint by CDS Clients. The Discovery endpoint includes information such as a description of the CDS Service, when it should be invoked, and any data that is requested to be prefetched.</p> Source code in <code>healthchain/models/responses/cdsdiscovery.py</code> <pre><code>class CDSServiceInformation(BaseModel):\n    \"\"\"\n    A CDS Service is discoverable via a stable endpoint by CDS Clients. The Discovery endpoint includes information such as a\n    description of the CDS Service, when it should be invoked, and any data that is requested to be prefetched.\n    \"\"\"\n\n    services: List[CDSService] = []\n</code></pre>"},{"location":"api/cds_hooks/#healthchain.models.responses.cdsfeedback.CDSFeedback","title":"<code>CDSFeedback</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A feedback endpoint enables suggestion tracking &amp; analytics. A CDS Service MAY support a feedback endpoint; a CDS Client SHOULD be capable of sending feedback.</p> ATTRIBUTE DESCRIPTION <code>card</code> <p>The card.uuid from the CDS Hooks response. Uniquely identifies the card.</p> <p> TYPE: <code>str</code> </p> <code>outcome</code> <p>The outcome of the action, either 'accepted' or 'overridden'.</p> <p> TYPE: <code>str</code> </p> <code>acceptedSuggestions</code> <p>An array of accepted suggestions, required if the outcome is 'accepted'.</p> <p> TYPE: <code>List[AcceptedSuggestion]</code> </p> <code>overrideReason</code> <p>The reason for overriding, including any coding and comments.</p> <p> TYPE: <code>Optional[OverrideReason]</code> </p> <code>outcomeTimestamp</code> <p>The ISO8601 timestamp of when the action was taken on the card.</p> <p> TYPE: <code>datetime</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#feedback</p> Source code in <code>healthchain/models/responses/cdsfeedback.py</code> <pre><code>class CDSFeedback(BaseModel):\n    \"\"\"\n    A feedback endpoint enables suggestion tracking &amp; analytics.\n    A CDS Service MAY support a feedback endpoint; a CDS Client SHOULD be capable of sending feedback.\n\n    Attributes:\n        card (str): The card.uuid from the CDS Hooks response. Uniquely identifies the card.\n        outcome (str): The outcome of the action, either 'accepted' or 'overridden'.\n        acceptedSuggestions (List[AcceptedSuggestion]): An array of accepted suggestions, required if the outcome is 'accepted'.\n        overrideReason (Optional[OverrideReason]): The reason for overriding, including any coding and comments.\n        outcomeTimestamp (datetime): The ISO8601 timestamp of when the action was taken on the card.\n\n    Documentation: https://cds-hooks.org/specification/current/#feedback\n    \"\"\"\n\n    card: str\n    outcome: OutcomeEnum\n    outcomeTimestamp: str\n    acceptedSuggestion: Optional[Dict[str, Any]] = None\n    overriddeReason: Optional[OverrideReason] = None\n</code></pre>"},{"location":"api/component/","title":"Component","text":""},{"location":"api/component/#healthchain.pipeline.components.base.BaseComponent","title":"<code>BaseComponent</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for all components in the pipeline.</p> <p>This class should be subclassed to create specific components. Subclasses must implement the call method.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>class BaseComponent(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for all components in the pipeline.\n\n    This class should be subclassed to create specific components.\n    Subclasses must implement the __call__ method.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        \"\"\"\n        Process the input data and return the processed data.\n\n        Args:\n            data (DataContainer[T]): The input data to be processed.\n\n        Returns:\n            DataContainer[T]: The processed data.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.base.BaseComponent.__call__","title":"<code>__call__(data)</code>  <code>abstractmethod</code>","text":"<p>Process the input data and return the processed data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The input data to be processed.</p> <p> TYPE: <code>DataContainer[T]</code> </p> RETURNS DESCRIPTION <code>DataContainer[T]</code> <p>DataContainer[T]: The processed data.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>@abstractmethod\ndef __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n    \"\"\"\n    Process the input data and return the processed data.\n\n    Args:\n        data (DataContainer[T]): The input data to be processed.\n\n    Returns:\n        DataContainer[T]: The processed data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.base.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>BaseComponent[T]</code></p> <p>A concrete implementation of the BaseComponent class.</p> <p>This class can be used as a base for creating specific components that do not require any additional processing logic.</p> METHOD DESCRIPTION <code>__call__</code> <p>DataContainer[T]) -&gt; DataContainer[T]: Process the input data and return the processed data. In this implementation, the input data is returned unmodified.</p> Source code in <code>healthchain/pipeline/components/base.py</code> <pre><code>class Component(BaseComponent[T]):\n    \"\"\"\n    A concrete implementation of the BaseComponent class.\n\n    This class can be used as a base for creating specific components\n    that do not require any additional processing logic.\n\n    Methods:\n        __call__(data: DataContainer[T]) -&gt; DataContainer[T]:\n            Process the input data and return the processed data.\n            In this implementation, the input data is returned unmodified.\n    \"\"\"\n\n    def __call__(self, data: DataContainer[T]) -&gt; DataContainer[T]:\n        return data\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer","title":"<code>HFTransformer</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates Hugging Face transformers models into the pipeline.</p> <p>This component allows using any Hugging Face model and task within the pipeline by wrapping the transformers.pipeline API. The model outputs are stored in the document's model_outputs container under the \"huggingface\" source key.</p> <p>Note that this component is only recommended for non-conversational language tasks. For chat-based tasks, consider using LangChainLLM instead.</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A pre-configured HuggingFace pipeline object to use for inference. Must be an instance of transformers.pipelines.base.Pipeline.</p> <p> TYPE: <code>Any</code> </p> ATTRIBUTE DESCRIPTION <code>task</code> <p>The task name of the underlying pipeline, e.g. \"sentiment-analysis\", \"ner\". Automatically extracted from the pipeline object.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If the transformers package is not installed</p> <code>TypeError</code> <p>If pipeline is not a valid HuggingFace Pipeline instance</p> Example Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class HFTransformer(BaseComponent[str]):\n    \"\"\"\n    A component that integrates Hugging Face transformers models into the pipeline.\n\n    This component allows using any Hugging Face model and task within the pipeline\n    by wrapping the transformers.pipeline API. The model outputs are stored in the\n    document's model_outputs container under the \"huggingface\" source key.\n\n    Note that this component is only recommended for non-conversational language tasks.\n    For chat-based tasks, consider using LangChainLLM instead.\n\n    Args:\n        pipeline (Any): A pre-configured HuggingFace pipeline object to use for inference.\n            Must be an instance of transformers.pipelines.base.Pipeline.\n\n    Attributes:\n        task (str): The task name of the underlying pipeline, e.g. \"sentiment-analysis\", \"ner\".\n            Automatically extracted from the pipeline object.\n\n    Raises:\n        ImportError: If the transformers package is not installed\n        TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n\n    Example:\n        &gt;&gt;&gt; # Initialize for sentiment analysis\n        &gt;&gt;&gt; from transformers import pipeline\n        &gt;&gt;&gt; nlp = pipeline(\"sentiment-analysis\", model=\"distilbert-base-uncased-finetuned-sst-2-english\")\n        &gt;&gt;&gt; component = HFTransformer(pipeline=nlp)\n        &gt;&gt;&gt; doc = component(doc)  # Analyzes sentiment of doc.data\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or use the factory method\n        &gt;&gt;&gt; component = HFTransformer.from_model_id(\n        ...     model=\"facebook/bart-large-cnn\",\n        ...     task=\"summarization\",\n        ...     max_length=130,\n        ...     min_length=30,\n        ...     do_sample=False\n        ... )\n        &gt;&gt;&gt; doc = component(doc)  # Generates summary of doc.data\n    \"\"\"\n\n    @requires_package(\"transformers\", \"transformers.pipelines\")\n    def __init__(self, pipeline: Any):\n        \"\"\"Initialize with a pre-configured HuggingFace pipeline.\n\n        Args:\n            pipeline: A pre-configured HuggingFace pipeline object from transformers.pipeline().\n                     Must be an instance of transformers.pipelines.base.Pipeline.\n\n        Raises:\n            ImportError: If transformers package is not installed\n            TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n        \"\"\"\n        from transformers.pipelines.base import Pipeline\n\n        if not isinstance(pipeline, Pipeline):\n            raise TypeError(\n                f\"Expected HuggingFace Pipeline object, got {type(pipeline)}\"\n            )\n        self._pipe = pipeline\n        self.task = pipeline.task\n\n    @classmethod\n    @requires_package(\"transformers\", \"transformers.pipelines\")\n    def from_model_id(cls, model: str, task: str, **kwargs: Any) -&gt; \"HFTransformer\":\n        \"\"\"Create a transformer component from a model identifier.\n\n        Factory method that initializes a HuggingFace pipeline with the specified model and task,\n        then wraps it in a HFTransformer component.\n\n        Args:\n            model: The model identifier or path to load. Can be:\n                - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\")\n                - A local path to a saved model\n            task: The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")\n            **kwargs: Additional configuration options passed to transformers.pipeline()\n                Common options include:\n                - device: Device to run on (\"cpu\", \"cuda\", etc.)\n                - batch_size: Batch size for inference\n                - model_kwargs: Dict of model-specific args\n\n        Returns:\n            HFTransformer: Initialized transformer component wrapping the pipeline\n\n        Raises:\n            TypeError: If invalid kwargs are passed to pipeline initialization\n            ValueError: If pipeline initialization fails for any other reason\n            ImportError: If transformers package is not installed\n        \"\"\"\n        from transformers import pipeline\n\n        try:\n            pipe = pipeline(task=task, model=model, **kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for transformers.pipeline: {str(e)}\")\n        except Exception as e:\n            raise ValueError(f\"Error initializing transformer pipeline: {str(e)}\")\n\n        return cls(pipeline=pipe)\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].\"\"\"\n        output = self._pipe(doc.data)\n        doc.models.add_output(\"huggingface\", self.task, output)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer--initialize-for-sentiment-analysis","title":"Initialize for sentiment analysis","text":"<p>from transformers import pipeline nlp = pipeline(\"sentiment-analysis\", model=\"distilbert-base-uncased-finetuned-sst-2-english\") component = HFTransformer(pipeline=nlp) doc = component(doc)  # Analyzes sentiment of doc.data</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer--or-use-the-factory-method","title":"Or use the factory method","text":"<p>component = HFTransformer.from_model_id( ...     model=\"facebook/bart-large-cnn\", ...     task=\"summarization\", ...     max_length=130, ...     min_length=30, ...     do_sample=False ... ) doc = component(doc)  # Generates summary of doc.data</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the Hugging Face pipeline. Adds outputs to .model_outputs['huggingface'].\"\"\"\n    output = self._pipe(doc.data)\n    doc.models.add_output(\"huggingface\", self.task, output)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.__init__","title":"<code>__init__(pipeline)</code>","text":"<p>Initialize with a pre-configured HuggingFace pipeline.</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A pre-configured HuggingFace pipeline object from transformers.pipeline().      Must be an instance of transformers.pipelines.base.Pipeline.</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If transformers package is not installed</p> <code>TypeError</code> <p>If pipeline is not a valid HuggingFace Pipeline instance</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@requires_package(\"transformers\", \"transformers.pipelines\")\ndef __init__(self, pipeline: Any):\n    \"\"\"Initialize with a pre-configured HuggingFace pipeline.\n\n    Args:\n        pipeline: A pre-configured HuggingFace pipeline object from transformers.pipeline().\n                 Must be an instance of transformers.pipelines.base.Pipeline.\n\n    Raises:\n        ImportError: If transformers package is not installed\n        TypeError: If pipeline is not a valid HuggingFace Pipeline instance\n    \"\"\"\n    from transformers.pipelines.base import Pipeline\n\n    if not isinstance(pipeline, Pipeline):\n        raise TypeError(\n            f\"Expected HuggingFace Pipeline object, got {type(pipeline)}\"\n        )\n    self._pipe = pipeline\n    self.task = pipeline.task\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.HFTransformer.from_model_id","title":"<code>from_model_id(model, task, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a transformer component from a model identifier.</p> <p>Factory method that initializes a HuggingFace pipeline with the specified model and task, then wraps it in a HFTransformer component.</p> PARAMETER DESCRIPTION <code>model</code> <p>The model identifier or path to load. Can be: - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\") - A local path to a saved model</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to transformers.pipeline() Common options include: - device: Device to run on (\"cpu\", \"cuda\", etc.) - batch_size: Batch size for inference - model_kwargs: Dict of model-specific args</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>HFTransformer</code> <p>Initialized transformer component wrapping the pipeline</p> <p> TYPE: <code>HFTransformer</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If invalid kwargs are passed to pipeline initialization</p> <code>ValueError</code> <p>If pipeline initialization fails for any other reason</p> <code>ImportError</code> <p>If transformers package is not installed</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@classmethod\n@requires_package(\"transformers\", \"transformers.pipelines\")\ndef from_model_id(cls, model: str, task: str, **kwargs: Any) -&gt; \"HFTransformer\":\n    \"\"\"Create a transformer component from a model identifier.\n\n    Factory method that initializes a HuggingFace pipeline with the specified model and task,\n    then wraps it in a HFTransformer component.\n\n    Args:\n        model: The model identifier or path to load. Can be:\n            - A model ID from the HuggingFace Hub (e.g. \"bert-base-uncased\")\n            - A local path to a saved model\n        task: The task to run (e.g. \"text-classification\", \"token-classification\", \"summarization\")\n        **kwargs: Additional configuration options passed to transformers.pipeline()\n            Common options include:\n            - device: Device to run on (\"cpu\", \"cuda\", etc.)\n            - batch_size: Batch size for inference\n            - model_kwargs: Dict of model-specific args\n\n    Returns:\n        HFTransformer: Initialized transformer component wrapping the pipeline\n\n    Raises:\n        TypeError: If invalid kwargs are passed to pipeline initialization\n        ValueError: If pipeline initialization fails for any other reason\n        ImportError: If transformers package is not installed\n    \"\"\"\n    from transformers import pipeline\n\n    try:\n        pipe = pipeline(task=task, model=model, **kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for transformers.pipeline: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Error initializing transformer pipeline: {str(e)}\")\n\n    return cls(pipeline=pipe)\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM","title":"<code>LangChainLLM</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates LangChain chains into the pipeline.</p> <p>This component allows using any LangChain chain within the pipeline by wrapping the chain's invoke method. The chain outputs are stored in the document's model_outputs container under the \"langchain\" source key.</p> PARAMETER DESCRIPTION <code>chain</code> <p>The LangChain chain to run on the document text. Must be a Runnable object from the LangChain library.</p> <p> TYPE: <code>Runnable</code> </p> <code>task</code> <p>The task name to use when storing outputs, e.g. \"summarization\", \"chat\". Used as key to organize model outputs in the document's model container.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional parameters to pass to the chain's invoke method. These are forwarded directly to the chain's invoke() call.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If chain is not a LangChain Runnable object or if invalid kwargs are passed</p> <code>ValueError</code> <p>If there is an error during chain invocation</p> <code>ImportError</code> <p>If langchain-core package is not installed</p> Example <p>from langchain_core.prompts import ChatPromptTemplate from langchain_openai import ChatOpenAI</p> <p>chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI() component = LangChainLLM(chain=chain, task=\"chat\") doc = component(doc)  # Runs the chain on doc.data and stores output</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class LangChainLLM(BaseComponent[str]):\n    \"\"\"\n    A component that integrates LangChain chains into the pipeline.\n\n    This component allows using any LangChain chain within the pipeline by wrapping\n    the chain's invoke method. The chain outputs are stored in the document's\n    model_outputs container under the \"langchain\" source key.\n\n    Args:\n        chain (Runnable): The LangChain chain to run on the document text.\n            Must be a Runnable object from the LangChain library.\n        task (str): The task name to use when storing outputs, e.g. \"summarization\", \"chat\".\n            Used as key to organize model outputs in the document's model container.\n        **kwargs: Additional parameters to pass to the chain's invoke method.\n            These are forwarded directly to the chain's invoke() call.\n\n    Raises:\n        TypeError: If chain is not a LangChain Runnable object or if invalid kwargs are passed\n        ValueError: If there is an error during chain invocation\n        ImportError: If langchain-core package is not installed\n\n    Example:\n        &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n        &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n\n        &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n        &gt;&gt;&gt; component = LangChainLLM(chain=chain, task=\"chat\")\n        &gt;&gt;&gt; doc = component(doc)  # Runs the chain on doc.data and stores output\n    \"\"\"\n\n    @requires_package(\"langchain-core\", \"langchain_core.runnables\")\n    def __init__(self, chain: Any, task: str, **kwargs: Any):\n        \"\"\"Initialize with a LangChain chain.\"\"\"\n        from langchain_core.runnables import Runnable\n\n        if not isinstance(chain, Runnable):\n            raise TypeError(f\"Expected LangChain Runnable object, got {type(chain)}\")\n\n        self.chain = chain\n        self.task = task\n        self.kwargs = kwargs\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].\"\"\"\n        try:\n            output = self.chain.invoke(doc.data, **self.kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for chain.invoke: {str(e)}\")\n        except Exception as e:\n            raise ValueError(f\"Error during chain invocation: {str(e)}\")\n\n        doc.models.add_output(\"langchain\", self.task, output)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the LangChain chain. Adds outputs to .model_outputs['langchain'].\"\"\"\n    try:\n        output = self.chain.invoke(doc.data, **self.kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for chain.invoke: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Error during chain invocation: {str(e)}\")\n\n    doc.models.add_output(\"langchain\", self.task, output)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.LangChainLLM.__init__","title":"<code>__init__(chain, task, **kwargs)</code>","text":"<p>Initialize with a LangChain chain.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@requires_package(\"langchain-core\", \"langchain_core.runnables\")\ndef __init__(self, chain: Any, task: str, **kwargs: Any):\n    \"\"\"Initialize with a LangChain chain.\"\"\"\n    from langchain_core.runnables import Runnable\n\n    if not isinstance(chain, Runnable):\n        raise TypeError(f\"Expected LangChain Runnable object, got {type(chain)}\")\n\n    self.chain = chain\n    self.task = task\n    self.kwargs = kwargs\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP","title":"<code>SpacyNLP</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <p>A component that integrates spaCy models into the pipeline.</p> <p>This component allows using any spaCy model within the pipeline by loading and applying it to process text documents. The spaCy doc outputs are stored in the document's nlp annotations container under .spacy_docs.</p> PARAMETER DESCRIPTION <code>nlp</code> <p>A pre-configured spaCy Language object.</p> <p> TYPE: <code>Language</code> </p> Example Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>class SpacyNLP(BaseComponent[str]):\n    \"\"\"\n    A component that integrates spaCy models into the pipeline.\n\n    This component allows using any spaCy model within the pipeline by loading\n    and applying it to process text documents. The spaCy doc outputs are stored\n    in the document's nlp annotations container under .spacy_docs.\n\n    Args:\n        nlp: A pre-configured spaCy Language object.\n\n    Example:\n        &gt;&gt;&gt; # Using pre-configured pipeline\n        &gt;&gt;&gt; import spacy\n        &gt;&gt;&gt; nlp = spacy.load(\"en_core_web_sm\", disable=[\"parser\"])\n        &gt;&gt;&gt; component = SpacyNLP(nlp)\n        &gt;&gt;&gt; doc = component(doc)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using model name\n        &gt;&gt;&gt; component = SpacyNLP.from_model_id(\"en_core_web_sm\", disable=[\"parser\"])\n        &gt;&gt;&gt; doc = component(doc)\n    \"\"\"\n\n    def __init__(self, nlp: \"Language\"):\n        \"\"\"Initialize with a pre-configured spaCy Language object.\"\"\"\n        self._nlp = nlp\n\n    @classmethod\n    def from_model_id(cls, model: str, **kwargs: Any) -&gt; \"SpacyNLP\":\n        \"\"\"\n        Create a SpacyNLP component from a model identifier.\n\n        Args:\n            model (str): The name or path of the spaCy model to load.\n                Can be a model name like 'en_core_web_sm' or path to saved model.\n            **kwargs: Additional configuration options passed to spacy.load.\n                Common options include disable, exclude, enable.\n\n        Returns:\n            SpacyNLP: Initialized spaCy component\n\n        Raises:\n            ImportError: If spaCy or the specified model is not installed\n            TypeError: If invalid kwargs are passed to spacy.load\n        \"\"\"\n        try:\n            import spacy\n        except ImportError:\n            raise ImportError(\n                \"Could not import spacy. Please install it with: \" \"`pip install spacy`\"\n            )\n\n        try:\n            nlp = spacy.load(model, **kwargs)\n        except TypeError as e:\n            raise TypeError(f\"Invalid kwargs for spacy.load: {str(e)}\")\n        except Exception as e:\n            raise ImportError(\n                f\"Could not load spaCy model {model}! \"\n                \"Make sure you have installed it with: \"\n                f\"`python -m spacy download {model}`\"\n            ) from e\n\n        return cls(nlp)\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.\"\"\"\n        spacy_doc = self._nlp(doc.data)\n        doc.nlp.add_spacy_doc(spacy_doc)\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP--using-pre-configured-pipeline","title":"Using pre-configured pipeline","text":"<p>import spacy nlp = spacy.load(\"en_core_web_sm\", disable=[\"parser\"]) component = SpacyNLP(nlp) doc = component(doc)</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP--or-using-model-name","title":"Or using model name","text":"<p>component = SpacyNLP.from_model_id(\"en_core_web_sm\", disable=[\"parser\"]) doc = component(doc)</p>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"Process the document using the spaCy pipeline. Adds outputs to nlp.spacy_docs.\"\"\"\n    spacy_doc = self._nlp(doc.data)\n    doc.nlp.add_spacy_doc(spacy_doc)\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.__init__","title":"<code>__init__(nlp)</code>","text":"<p>Initialize with a pre-configured spaCy Language object.</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def __init__(self, nlp: \"Language\"):\n    \"\"\"Initialize with a pre-configured spaCy Language object.\"\"\"\n    self._nlp = nlp\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.SpacyNLP.from_model_id","title":"<code>from_model_id(model, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a SpacyNLP component from a model identifier.</p> PARAMETER DESCRIPTION <code>model</code> <p>The name or path of the spaCy model to load. Can be a model name like 'en_core_web_sm' or path to saved model.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to spacy.load. Common options include disable, exclude, enable.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>SpacyNLP</code> <p>Initialized spaCy component</p> <p> TYPE: <code>SpacyNLP</code> </p> RAISES DESCRIPTION <code>ImportError</code> <p>If spaCy or the specified model is not installed</p> <code>TypeError</code> <p>If invalid kwargs are passed to spacy.load</p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>@classmethod\ndef from_model_id(cls, model: str, **kwargs: Any) -&gt; \"SpacyNLP\":\n    \"\"\"\n    Create a SpacyNLP component from a model identifier.\n\n    Args:\n        model (str): The name or path of the spaCy model to load.\n            Can be a model name like 'en_core_web_sm' or path to saved model.\n        **kwargs: Additional configuration options passed to spacy.load.\n            Common options include disable, exclude, enable.\n\n    Returns:\n        SpacyNLP: Initialized spaCy component\n\n    Raises:\n        ImportError: If spaCy or the specified model is not installed\n        TypeError: If invalid kwargs are passed to spacy.load\n    \"\"\"\n    try:\n        import spacy\n    except ImportError:\n        raise ImportError(\n            \"Could not import spacy. Please install it with: \" \"`pip install spacy`\"\n        )\n\n    try:\n        nlp = spacy.load(model, **kwargs)\n    except TypeError as e:\n        raise TypeError(f\"Invalid kwargs for spacy.load: {str(e)}\")\n    except Exception as e:\n        raise ImportError(\n            f\"Could not load spaCy model {model}! \"\n            \"Make sure you have installed it with: \"\n            f\"`python -m spacy download {model}`\"\n        ) from e\n\n    return cls(nlp)\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.integrations.requires_package","title":"<code>requires_package(package_name, import_path)</code>","text":"<p>Decorator to check if an optional package is available.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Name of the package to install (e.g., 'langchain-core')</p> <p> TYPE: <code>str</code> </p> <code>import_path</code> <p>Import path to check (e.g., 'langchain_core.runnables')</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/pipeline/components/integrations.py</code> <pre><code>def requires_package(package_name: str, import_path: str) -&gt; Callable:\n    \"\"\"Decorator to check if an optional package is available.\n\n    Args:\n        package_name: Name of the package to install (e.g., 'langchain-core')\n        import_path: Import path to check (e.g., 'langchain_core.runnables')\n    \"\"\"\n\n    def decorator(func: Callable[..., T]) -&gt; Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -&gt; T:\n            try:\n                __import__(import_path)\n            except ImportError:\n                raise ImportError(\n                    f\"This feature requires {package_name}. \"\n                    f\"Please install it with: `pip install {package_name}`\"\n                )\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor","title":"<code>TextPreProcessor</code>","text":"<p>               Bases: <code>BaseComponent[Document]</code></p> <p>A component for preprocessing text documents.</p> <p>This class applies various cleaning and tokenization steps to a Document object, based on the provided configuration.</p> ATTRIBUTE DESCRIPTION <code>tokenizer</code> <p>The tokenizer to use. Can be \"basic\" or a custom tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".</p> <p> TYPE: <code>Union[str, Callable[[str], List[str]]]</code> </p> <code>lowercase</code> <p>Whether to convert text to lowercase. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>remove_punctuation</code> <p>Whether to remove punctuation. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>standardize_spaces</code> <p>Whether to standardize spaces. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>regex</code> <p>List of regex patterns and replacements. Defaults to an empty list.</p> <p> TYPE: <code>List[Tuple[str, str]]</code> </p> <code>tokenizer_func</code> <p>The tokenization function.</p> <p> TYPE: <code>Callable[[str], List[str]]</code> </p> <code>cleaning_steps</code> <p>List of text cleaning functions.</p> <p> TYPE: <code>List[Callable[[str], str]]</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>class TextPreProcessor(BaseComponent[Document]):\n    \"\"\"\n    A component for preprocessing text documents.\n\n    This class applies various cleaning and tokenization steps to a Document object,\n    based on the provided configuration.\n\n    Attributes:\n        tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n            tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n        lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n        remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n        standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n        regex (List[Tuple[str, str]]): List of regex patterns and replacements. Defaults to an empty list.\n        tokenizer_func (Callable[[str], List[str]]): The tokenization function.\n        cleaning_steps (List[Callable[[str], str]]): List of text cleaning functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        tokenizer: Union[str, Callable[[str], List[str]]] = \"basic\",\n        lowercase: bool = False,\n        remove_punctuation: bool = False,\n        standardize_spaces: bool = False,\n        regex: List[Tuple[str, str]] = None,\n    ):\n        \"\"\"\n        Initialize the TextPreprocessor with the given configuration.\n\n        Args:\n            tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n                tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n            lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n            remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n            standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n            regex (List[Tuple[str, str]], optional): List of regex patterns and replacements. Defaults to None.\n        \"\"\"\n        self.lowercase = lowercase\n        self.remove_punctuation = remove_punctuation\n        self.standardize_spaces = standardize_spaces\n        self.regex = regex or []\n        self.tokenizer = self._get_tokenizer(tokenizer)\n        self.cleaning_steps = self._configure_cleaning_steps()\n\n    def _get_tokenizer(\n        self, tokenizer: Union[str, Callable[[str], List[str]]]\n    ) -&gt; Callable[[str], List[str]]:\n        \"\"\"\n        Get the tokenization function based on the specified tokenizer.\n\n        Args:\n            tokenizer: Either \"basic\" or a custom tokenization function.\n\n        Returns:\n            Callable[[str], List[str]]: The tokenization function.\n\n        Raises:\n            ValueError: If an unsupported tokenizer string is specified.\n        \"\"\"\n        if callable(tokenizer):\n            return tokenizer\n        elif tokenizer == \"basic\":\n            return lambda text: text.split()\n        else:\n            raise ValueError(\n                f\"Unsupported tokenizer: {tokenizer}. Use 'basic' or provide a custom tokenization function.\"\n            )\n\n    def _configure_cleaning_steps(self) -&gt; List[Callable[[str], str]]:\n        \"\"\"\n        Configure the text cleaning steps based on the preprocessor configuration.\n\n        Returns:\n            List[Callable[[str], str]]: List of text cleaning functions.\n        \"\"\"\n        steps = []\n        if self.lowercase:\n            steps.append(lambda text: text.lower())\n\n        regex_steps = []\n        if self.regex:\n            regex_steps.extend(self.regex)\n        else:\n            if self.remove_punctuation:\n                regex_steps.append((r\"[^\\w\\s]\", \"\"))\n            if self.standardize_spaces:\n                regex_steps.append((r\"\\s+\", \" \"))\n\n        for pattern, repl in regex_steps:\n            steps.append(self._create_regex_step(pattern, repl))\n\n        if self.standardize_spaces:\n            steps.append(str.strip)\n\n        return steps\n\n    @staticmethod\n    def _create_regex_step(pattern: str, repl: str) -&gt; Callable[[str], str]:\n        \"\"\"\n        Create a regex-based cleaning step. This can be used in place of other cleaning steps, if required.\n\n        Args:\n            pattern (str): The regex pattern to match.\n            repl (str): The replacement string.\n\n        Returns:\n            Callable[[str], str]: A function that applies the regex substitution.\n        \"\"\"\n        return lambda text: re.sub(pattern, repl, text)\n\n    def _clean_text(self, text: str) -&gt; str:\n        \"\"\"\n        Apply all cleaning steps to the input text.\n\n        Args:\n            text (str): The input text to clean.\n\n        Returns:\n            str: The cleaned text.\n        \"\"\"\n        for step in self.cleaning_steps:\n            text = step(text)\n        return text\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Preprocess the given Document.\n\n        This method applies the configured cleaning steps and tokenization to the document's text (in that order).\n\n        Args:\n            doc (Document): The document to preprocess.\n\n        Returns:\n            Document: The preprocessed document with updated tokens and preprocessed text.\n        \"\"\"\n        # Preprocess text\n        preprocessed_text = self._clean_text(doc.text)\n        doc.preprocessed_text = preprocessed_text\n\n        if self.tokenizer:\n            tokens = self.tokenizer(preprocessed_text)\n            doc.tokens = tokens\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor.__call__","title":"<code>__call__(doc)</code>","text":"<p>Preprocess the given Document.</p> <p>This method applies the configured cleaning steps and tokenization to the document's text (in that order).</p> PARAMETER DESCRIPTION <code>doc</code> <p>The document to preprocess.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The preprocessed document with updated tokens and preprocessed text.</p> <p> TYPE: <code>Document</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Preprocess the given Document.\n\n    This method applies the configured cleaning steps and tokenization to the document's text (in that order).\n\n    Args:\n        doc (Document): The document to preprocess.\n\n    Returns:\n        Document: The preprocessed document with updated tokens and preprocessed text.\n    \"\"\"\n    # Preprocess text\n    preprocessed_text = self._clean_text(doc.text)\n    doc.preprocessed_text = preprocessed_text\n\n    if self.tokenizer:\n        tokens = self.tokenizer(preprocessed_text)\n        doc.tokens = tokens\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.preprocessors.TextPreProcessor.__init__","title":"<code>__init__(tokenizer='basic', lowercase=False, remove_punctuation=False, standardize_spaces=False, regex=None)</code>","text":"<p>Initialize the TextPreprocessor with the given configuration.</p> PARAMETER DESCRIPTION <code>tokenizer</code> <p>The tokenizer to use. Can be \"basic\" or a custom tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".</p> <p> TYPE: <code>Union[str, Callable[[str], List[str]]]</code> DEFAULT: <code>'basic'</code> </p> <code>lowercase</code> <p>Whether to convert text to lowercase. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>remove_punctuation</code> <p>Whether to remove punctuation. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>standardize_spaces</code> <p>Whether to standardize spaces. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>regex</code> <p>List of regex patterns and replacements. Defaults to None.</p> <p> TYPE: <code>List[Tuple[str, str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/pipeline/components/preprocessors.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: Union[str, Callable[[str], List[str]]] = \"basic\",\n    lowercase: bool = False,\n    remove_punctuation: bool = False,\n    standardize_spaces: bool = False,\n    regex: List[Tuple[str, str]] = None,\n):\n    \"\"\"\n    Initialize the TextPreprocessor with the given configuration.\n\n    Args:\n        tokenizer (Union[str, Callable[[str], List[str]]]): The tokenizer to use. Can be \"basic\" or a custom\n            tokenization function that takes a string and returns a list of tokens. Defaults to \"basic\".\n        lowercase (bool): Whether to convert text to lowercase. Defaults to False.\n        remove_punctuation (bool): Whether to remove punctuation. Defaults to False.\n        standardize_spaces (bool): Whether to standardize spaces. Defaults to False.\n        regex (List[Tuple[str, str]], optional): List of regex patterns and replacements. Defaults to None.\n    \"\"\"\n    self.lowercase = lowercase\n    self.remove_punctuation = remove_punctuation\n    self.standardize_spaces = standardize_spaces\n    self.regex = regex or []\n    self.tokenizer = self._get_tokenizer(tokenizer)\n    self.cleaning_steps = self._configure_cleaning_steps()\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor","title":"<code>TextPostProcessor</code>","text":"<p>               Bases: <code>BaseComponent[Document]</code></p> <p>A component for post-processing text documents, specifically for refining entities.</p> <p>This class applies post-coordination rules to entities in a Document object, replacing entities with their refined versions based on a lookup dictionary.</p> ATTRIBUTE DESCRIPTION <code>entity_lookup</code> <p>A dictionary for entity refinement lookups.</p> <p> TYPE: <code>Dict[str, str]</code> </p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>class TextPostProcessor(BaseComponent[Document]):\n    \"\"\"\n    A component for post-processing text documents, specifically for refining entities.\n\n    This class applies post-coordination rules to entities in a Document object,\n    replacing entities with their refined versions based on a lookup dictionary.\n\n    Attributes:\n        entity_lookup (Dict[str, str]): A dictionary for entity refinement lookups.\n    \"\"\"\n\n    def __init__(self, postcoordination_lookup: Dict[str, str] = None):\n        \"\"\"\n        Initialize the TextPostProcessor with an optional postcoordination lookup.\n\n        Args:\n            postcoordination_lookup (Dict[str, str], optional): A dictionary for entity refinement lookups.\n                If not provided, an empty dictionary will be used.\n        \"\"\"\n        self.entity_lookup = postcoordination_lookup or {}\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Apply post-processing to the given Document.\n\n        This method refines the entities in the document based on the entity_lookup.\n        If an entity exists in the lookup, it is replaced with its refined version.\n\n        Args:\n            doc (Document): The document to be post-processed.\n\n        Returns:\n            Document: The post-processed document with refined entities.\n\n        Note:\n            If the entity_lookup is empty or the document has no 'entities' attribute,\n            the document is returned unchanged.\n        \"\"\"\n        if not self.entity_lookup or not hasattr(doc._nlp, \"_entities\"):\n            return doc\n\n        refined_entities = []\n        for entity in doc.nlp.get_entities():\n            entity_text = entity[\"text\"]\n            if entity_text in self.entity_lookup:\n                entity[\"text\"] = self.entity_lookup[entity_text]\n            refined_entities.append(entity)\n\n        doc.nlp.set_entities(refined_entities)\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor.__call__","title":"<code>__call__(doc)</code>","text":"<p>Apply post-processing to the given Document.</p> <p>This method refines the entities in the document based on the entity_lookup. If an entity exists in the lookup, it is replaced with its refined version.</p> PARAMETER DESCRIPTION <code>doc</code> <p>The document to be post-processed.</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The post-processed document with refined entities.</p> <p> TYPE: <code>Document</code> </p> Note <p>If the entity_lookup is empty or the document has no 'entities' attribute, the document is returned unchanged.</p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Apply post-processing to the given Document.\n\n    This method refines the entities in the document based on the entity_lookup.\n    If an entity exists in the lookup, it is replaced with its refined version.\n\n    Args:\n        doc (Document): The document to be post-processed.\n\n    Returns:\n        Document: The post-processed document with refined entities.\n\n    Note:\n        If the entity_lookup is empty or the document has no 'entities' attribute,\n        the document is returned unchanged.\n    \"\"\"\n    if not self.entity_lookup or not hasattr(doc._nlp, \"_entities\"):\n        return doc\n\n    refined_entities = []\n    for entity in doc.nlp.get_entities():\n        entity_text = entity[\"text\"]\n        if entity_text in self.entity_lookup:\n            entity[\"text\"] = self.entity_lookup[entity_text]\n        refined_entities.append(entity)\n\n    doc.nlp.set_entities(refined_entities)\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.postprocessors.TextPostProcessor.__init__","title":"<code>__init__(postcoordination_lookup=None)</code>","text":"<p>Initialize the TextPostProcessor with an optional postcoordination lookup.</p> PARAMETER DESCRIPTION <code>postcoordination_lookup</code> <p>A dictionary for entity refinement lookups. If not provided, an empty dictionary will be used.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/pipeline/components/postprocessors.py</code> <pre><code>def __init__(self, postcoordination_lookup: Dict[str, str] = None):\n    \"\"\"\n    Initialize the TextPostProcessor with an optional postcoordination lookup.\n\n    Args:\n        postcoordination_lookup (Dict[str, str], optional): A dictionary for entity refinement lookups.\n            If not provided, an empty dictionary will be used.\n    \"\"\"\n    self.entity_lookup = postcoordination_lookup or {}\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator","title":"<code>CdsCardCreator</code>","text":"<p>               Bases: <code>BaseComponent[str]</code></p> <pre><code>Component that creates CDS Hooks cards from model outputs or static content.\n\nThis component formats text into CDS Hooks cards that can be displayed in an EHR system.\nIt can create cards from either:\n1. Model-generated text stored in a document's model outputs container\n2. Static content provided during initialization\n\nThe component uses Jinja2 templates to format the text into valid CDS Hooks card JSON.\nThe generated cards are added to the document's CDS container.\n\nArgs:\n    template (str, optional): Jinja2 template string for card creation. If not provided,\n        uses a default template that creates an info card.\n    template_path (Union[str, Path], optional): Path to a Jinja2 template file.\n    static_content (str, optional): Static text to use instead of model output.\n    source (str, optional): Source framework to get model output from (e.g. \"huggingface\").\n    task (str, optional): Task name to get model output from (e.g. \"summarization\").\n    delimiter (str, optional): String to split model output into multiple cards.\n    default_source (Dict[str, Any], optional): Default source info for cards.\n        Defaults to {\"label\": \"Card Generated by HealthChain\"}.\n\nExample:\n    &gt;&gt;&gt; # Create cards from model output\n    &gt;&gt;&gt; creator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\n    &gt;&gt;&gt; doc = creator(doc)  # Creates cards from model output\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create cards with static content\n    &gt;&gt;&gt; creator = CdsCardCreator(static_content=\"Static card message\")\n    &gt;&gt;&gt; doc = creator(doc)  # Creates card with static content\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create cards with custom template\n    &gt;&gt;&gt; template = '''\n    ... {\n    ...     \"summary\": \"{{ model_output[:140] }}\",\n    ...     \"indicator\": \"info\",\n    ...     \"source\": {{ default_source | tojson }},\n    ...     \"detail\": \"{{ model_output }}\"\n    ... }\n    ... '''\n    &gt;&gt;&gt; creator = CdsCardCreator(\n    ...     template=template,\n    ...     source=\"langchain\",\n    ...     task=\"chat\",\n    ...     delimiter=\"\n</code></pre> <p>\"         ... )         &gt;&gt;&gt; doc = creator(doc)  # Creates cards split by newlines</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>class CdsCardCreator(BaseComponent[str]):\n    \"\"\"\n    Component that creates CDS Hooks cards from model outputs or static content.\n\n    This component formats text into CDS Hooks cards that can be displayed in an EHR system.\n    It can create cards from either:\n    1. Model-generated text stored in a document's model outputs container\n    2. Static content provided during initialization\n\n    The component uses Jinja2 templates to format the text into valid CDS Hooks card JSON.\n    The generated cards are added to the document's CDS container.\n\n    Args:\n        template (str, optional): Jinja2 template string for card creation. If not provided,\n            uses a default template that creates an info card.\n        template_path (Union[str, Path], optional): Path to a Jinja2 template file.\n        static_content (str, optional): Static text to use instead of model output.\n        source (str, optional): Source framework to get model output from (e.g. \"huggingface\").\n        task (str, optional): Task name to get model output from (e.g. \"summarization\").\n        delimiter (str, optional): String to split model output into multiple cards.\n        default_source (Dict[str, Any], optional): Default source info for cards.\n            Defaults to {\"label\": \"Card Generated by HealthChain\"}.\n\n    Example:\n        &gt;&gt;&gt; # Create cards from model output\n        &gt;&gt;&gt; creator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\n        &gt;&gt;&gt; doc = creator(doc)  # Creates cards from model output\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create cards with static content\n        &gt;&gt;&gt; creator = CdsCardCreator(static_content=\"Static card message\")\n        &gt;&gt;&gt; doc = creator(doc)  # Creates card with static content\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create cards with custom template\n        &gt;&gt;&gt; template = '''\n        ... {\n        ...     \"summary\": \"{{ model_output[:140] }}\",\n        ...     \"indicator\": \"info\",\n        ...     \"source\": {{ default_source | tojson }},\n        ...     \"detail\": \"{{ model_output }}\"\n        ... }\n        ... '''\n        &gt;&gt;&gt; creator = CdsCardCreator(\n        ...     template=template,\n        ...     source=\"langchain\",\n        ...     task=\"chat\",\n        ...     delimiter=\"\\n\"\n        ... )\n        &gt;&gt;&gt; doc = creator(doc)  # Creates cards split by newlines\n    \"\"\"\n\n    # TODO: make source and other fields configurable from model too\n    DEFAULT_TEMPLATE = \"\"\"\n    {\n        \"summary\": \"{{ model_output[:140] }}\",\n        \"indicator\": \"info\",\n        \"source\": {{ default_source | tojson }},\n        \"detail\": \"{{ model_output }}\"\n    }\n    \"\"\"\n\n    def __init__(\n        self,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        static_content: Optional[str] = None,\n        source: Optional[str] = None,\n        task: Optional[str] = None,\n        delimiter: Optional[str] = None,\n        default_source: Optional[Dict[str, Any]] = None,\n    ):\n        # Load template from file or use string template\n        if template_path:\n            try:\n                template_path = Path(template_path)\n                if not template_path.exists():\n                    raise FileNotFoundError(f\"Template file not found: {template_path}\")\n                with open(template_path) as f:\n                    template = f.read()\n            except Exception as e:\n                logger.error(f\"Error loading template from {template_path}: {str(e)}\")\n                template = self.DEFAULT_TEMPLATE\n\n        self.template = Template(\n            template if template is not None else self.DEFAULT_TEMPLATE\n        )\n        self.static_content = static_content\n        self.source = source\n        self.task = task\n        self.delimiter = delimiter\n        self.default_source = default_source or {\n            \"label\": \"Card Generated by HealthChain\"\n        }\n\n    def create_card(self, content: str) -&gt; Card:\n        \"\"\"Creates a CDS Card using the template and model output.\"\"\"\n        try:\n            # Clean and escape the content\n            # TODO: format to html that can be rendered in card\n            content = content.replace(\"\\n\", \" \").replace(\"\\r\", \" \").strip()\n            content = content.replace('\"', '\\\\\"')  # Escape double quotes\n\n            try:\n                card_json = self.template.render(\n                    model_output=content, default_source=self.default_source\n                )\n            except Exception as e:\n                raise ValueError(f\"Error rendering template: {str(e)}\")\n\n            # Parse the rendered JSON into card fields\n            card_fields = json.loads(card_json)\n\n            return Card(\n                summary=card_fields[\"summary\"][:140],  # Enforce max length\n                indicator=IndicatorEnum(card_fields[\"indicator\"]),\n                source=Source(**card_fields[\"source\"]),\n                detail=card_fields.get(\"detail\"),\n                suggestions=card_fields.get(\"suggestions\"),\n                selectionBehavior=card_fields.get(\"selectionBehavior\"),\n                overrideReasons=card_fields.get(\"overrideReasons\"),\n                links=card_fields.get(\"links\"),\n            )\n        except Exception as e:\n            raise ValueError(\n                f\"Error creating CDS card: Failed to render template or parse card fields: {str(e)}\"\n            )\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"\n        Process a document and create CDS Hooks cards from model outputs or static content.\n\n        Creates cards in one of two ways:\n        1. From model-generated text stored in the document's model outputs container,\n           accessed using the configured source and task\n        2. From static content provided during initialization\n\n        The generated text can optionally be split into multiple cards using a delimiter.\n        Each piece of text is formatted using the configured template into a CDS Hooks card\n        and added to the document's CDS container.\n\n        Args:\n            doc (Document): Document containing model outputs and CDS container\n\n        Returns:\n            Document: The input document with generated CDS cards added to its CDS container\n\n        Raises:\n            ValueError: If neither model configuration (source and task) nor static content\n                is provided for card creation\n        \"\"\"\n        if self.source and self.task:\n            generated_text = doc.models.get_generated_text(self.source, self.task)\n            if not generated_text:\n                logger.warning(\n                    f\"No generated text for {self.source}/{self.task} found for CDS card creation!\"\n                )\n                return doc\n        elif self.static_content:\n            generated_text = [self.static_content]\n        else:\n            raise ValueError(\n                \"Either model output (source and task) or content need to be provided for CDS card creation!\"\n            )\n\n        # Create card from model output\n        cards = []\n        for text in generated_text:\n            texts = [text] if not self.delimiter else text.split(self.delimiter)\n            for t in texts:\n                try:\n                    cards.append(self.create_card(t))\n                except Exception as e:\n                    logger.warning(f\"Error creating card: {str(e)}\")\n\n        if cards:\n            doc.cds.cards = cards\n\n        return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator.__call__","title":"<code>__call__(doc)</code>","text":"<p>Process a document and create CDS Hooks cards from model outputs or static content.</p> <p>Creates cards in one of two ways: 1. From model-generated text stored in the document's model outputs container,    accessed using the configured source and task 2. From static content provided during initialization</p> <p>The generated text can optionally be split into multiple cards using a delimiter. Each piece of text is formatted using the configured template into a CDS Hooks card and added to the document's CDS container.</p> PARAMETER DESCRIPTION <code>doc</code> <p>Document containing model outputs and CDS container</p> <p> TYPE: <code>Document</code> </p> RETURNS DESCRIPTION <code>Document</code> <p>The input document with generated CDS cards added to its CDS container</p> <p> TYPE: <code>Document</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither model configuration (source and task) nor static content is provided for card creation</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>def __call__(self, doc: Document) -&gt; Document:\n    \"\"\"\n    Process a document and create CDS Hooks cards from model outputs or static content.\n\n    Creates cards in one of two ways:\n    1. From model-generated text stored in the document's model outputs container,\n       accessed using the configured source and task\n    2. From static content provided during initialization\n\n    The generated text can optionally be split into multiple cards using a delimiter.\n    Each piece of text is formatted using the configured template into a CDS Hooks card\n    and added to the document's CDS container.\n\n    Args:\n        doc (Document): Document containing model outputs and CDS container\n\n    Returns:\n        Document: The input document with generated CDS cards added to its CDS container\n\n    Raises:\n        ValueError: If neither model configuration (source and task) nor static content\n            is provided for card creation\n    \"\"\"\n    if self.source and self.task:\n        generated_text = doc.models.get_generated_text(self.source, self.task)\n        if not generated_text:\n            logger.warning(\n                f\"No generated text for {self.source}/{self.task} found for CDS card creation!\"\n            )\n            return doc\n    elif self.static_content:\n        generated_text = [self.static_content]\n    else:\n        raise ValueError(\n            \"Either model output (source and task) or content need to be provided for CDS card creation!\"\n        )\n\n    # Create card from model output\n    cards = []\n    for text in generated_text:\n        texts = [text] if not self.delimiter else text.split(self.delimiter)\n        for t in texts:\n            try:\n                cards.append(self.create_card(t))\n            except Exception as e:\n                logger.warning(f\"Error creating card: {str(e)}\")\n\n    if cards:\n        doc.cds.cards = cards\n\n    return doc\n</code></pre>"},{"location":"api/component/#healthchain.pipeline.components.cdscardcreator.CdsCardCreator.create_card","title":"<code>create_card(content)</code>","text":"<p>Creates a CDS Card using the template and model output.</p> Source code in <code>healthchain/pipeline/components/cdscardcreator.py</code> <pre><code>def create_card(self, content: str) -&gt; Card:\n    \"\"\"Creates a CDS Card using the template and model output.\"\"\"\n    try:\n        # Clean and escape the content\n        # TODO: format to html that can be rendered in card\n        content = content.replace(\"\\n\", \" \").replace(\"\\r\", \" \").strip()\n        content = content.replace('\"', '\\\\\"')  # Escape double quotes\n\n        try:\n            card_json = self.template.render(\n                model_output=content, default_source=self.default_source\n            )\n        except Exception as e:\n            raise ValueError(f\"Error rendering template: {str(e)}\")\n\n        # Parse the rendered JSON into card fields\n        card_fields = json.loads(card_json)\n\n        return Card(\n            summary=card_fields[\"summary\"][:140],  # Enforce max length\n            indicator=IndicatorEnum(card_fields[\"indicator\"]),\n            source=Source(**card_fields[\"source\"]),\n            detail=card_fields.get(\"detail\"),\n            suggestions=card_fields.get(\"suggestions\"),\n            selectionBehavior=card_fields.get(\"selectionBehavior\"),\n            overrideReasons=card_fields.get(\"overrideReasons\"),\n            links=card_fields.get(\"links\"),\n        )\n    except Exception as e:\n        raise ValueError(\n            f\"Error creating CDS card: Failed to render template or parse card fields: {str(e)}\"\n        )\n</code></pre>"},{"location":"api/containers/","title":"Containers","text":""},{"location":"api/containers/#healthchain.io.containers.BaseDocument","title":"<code>BaseDocument</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[str]</code></p> <p>Base document container for raw text content.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass BaseDocument(DataContainer[str]):\n    \"\"\"Base document container for raw text content.\"\"\"\n\n    data: str\n    text: str = field(init=False)\n\n    def __post_init__(self):\n        self.text = self.data\n\n    def char_count(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.DataContainer","title":"<code>DataContainer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A generic container for data.</p> <p>This class represents a container for data with a specific type T.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The data stored in the container.</p> <p> TYPE: <code>T</code> </p> METHOD DESCRIPTION <code>to_dict</code> <p>Converts the container's data to a dictionary.</p> <code>to_json</code> <p>Converts the container's data to a JSON string.</p> <code>from_dict</code> <p>Dict[str, Any]) -&gt; \"DataContainer\": Creates a DataContainer instance from a dictionary.</p> <code>from_json</code> <p>str) -&gt; \"DataContainer\": Creates a DataContainer instance from a JSON string.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass DataContainer(Generic[T]):\n    \"\"\"\n    A generic container for data.\n\n    This class represents a container for data with a specific type T.\n\n    Attributes:\n        data (T): The data stored in the container.\n\n    Methods:\n        to_dict() -&gt; Dict[str, Any]:\n            Converts the container's data to a dictionary.\n\n        to_json() -&gt; str:\n            Converts the container's data to a JSON string.\n\n        from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a dictionary.\n\n        from_json(cls, json_str: str) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a JSON string.\n    \"\"\"\n\n    data: T\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    def to_json(self) -&gt; str:\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n        return cls(**data)\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"DataContainer\":\n        return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Dataset","title":"<code>Dataset</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[DataFrame]</code></p> <p>A container for tabular data optimized for ML inference, lightweight wrapper around a pandas DataFrame.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The pandas DataFrame containing the dataset.</p> <p> TYPE: <code>T</code> </p> <code>metadata</code> <p>Dict for storing pipeline results (predictions, probabilities, etc.)</p> <p> TYPE: <code>Dict[str, Any]</code> </p> METHOD DESCRIPTION <code>from_csv</code> <p>Load Dataset from CSV.</p> <code>from_dict</code> <p>Load Dataset from dict.</p> <code>from_fhir_bundle</code> <p>Create Dataset from FHIR Bundle and schema.</p> <code>to_csv</code> <p>Save Dataset to CSV.</p> <code>to_risk_assessment</code> <p>Convert predictions to FHIR RiskAssessment.</p> Source code in <code>healthchain/io/containers/dataset.py</code> <pre><code>@dataclass\nclass Dataset(DataContainer[pd.DataFrame]):\n    \"\"\"\n    A container for tabular data optimized for ML inference, lightweight wrapper around a pandas DataFrame.\n\n    Attributes:\n        data: The pandas DataFrame containing the dataset.\n        metadata: Dict for storing pipeline results (predictions, probabilities, etc.)\n\n    Methods:\n        from_csv: Load Dataset from CSV.\n        from_dict: Load Dataset from dict.\n        from_fhir_bundle: Create Dataset from FHIR Bundle and schema.\n        to_csv: Save Dataset to CSV.\n        to_risk_assessment: Convert predictions to FHIR RiskAssessment.\n    \"\"\"\n\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n    def __post_init__(self):\n        if not isinstance(self.data, pd.DataFrame):\n            raise TypeError(\"data must be a pandas DataFrame\")\n\n    @property\n    def columns(self) -&gt; List[str]:\n        return list(self.data.columns)\n\n    @property\n    def index(self) -&gt; pd.Index:\n        return self.data.index\n\n    @property\n    def dtypes(self) -&gt; Dict[str, str]:\n        return {col: str(dtype) for col, dtype in self.data.dtypes.items()}\n\n    def column_count(self) -&gt; int:\n        return len(self.columns)\n\n    def row_count(self) -&gt; int:\n        return len(self.data)\n\n    def get_dtype(self, column: str) -&gt; str:\n        return str(self.data[column].dtype)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.columns)\n\n    def __len__(self) -&gt; int:\n        return self.row_count()\n\n    def describe(self) -&gt; str:\n        return f\"Dataset with {self.column_count()} columns and {self.row_count()} rows\"\n\n    def remove_column(self, name: str) -&gt; None:\n        self.data.drop(columns=[name], inplace=True)\n\n    @classmethod\n    def from_csv(cls, path: str, **kwargs) -&gt; \"Dataset\":\n        return cls(pd.read_csv(path, **kwargs))\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Dataset\":\n        df = pd.DataFrame(data[\"data\"])\n        return cls(df)\n\n    def to_csv(self, path: str, **kwargs) -&gt; None:\n        self.data.to_csv(path, **kwargs)\n\n    @classmethod\n    def from_fhir_bundle(\n        cls,\n        bundle: Union[Bundle, Dict[str, Any]],\n        schema: Union[str, Path, FeatureSchema],\n        aggregation: str = \"mean\",\n    ) -&gt; \"Dataset\":\n        \"\"\"Create Dataset from a FHIR Bundle using a feature schema.\n\n        Extracts features from FHIR resources according to the schema specification,\n        converting FHIR data to a pandas DataFrame suitable for ML inference.\n\n        Args:\n            bundle: FHIR Bundle resource (object or dict)\n            schema: FeatureSchema object, or path to YAML schema file\n            aggregation: How to aggregate multiple observation values (default: \"mean\")\n                Options: \"mean\", \"median\", \"max\", \"min\", \"last\" (default: \"mean\")\n\n        Returns:\n            Dataset container with extracted features\n\n        Example:\n            &gt;&gt;&gt; from fhir.resources.bundle import Bundle\n            &gt;&gt;&gt; bundle = Bundle(**patient_data)\n            &gt;&gt;&gt; dataset = Dataset.from_fhir_bundle(\n            ...     bundle,\n            ...     schema=\"healthchain/configs/features/sepsis_vitals.yaml\"\n            ... )\n            &gt;&gt;&gt; df = dataset.data\n        \"\"\"\n        # Load schema if path provided\n        if isinstance(schema, (str, Path)):\n            schema = FeatureSchema.from_yaml(schema)\n\n        # Extract features using mapper\n        mapper = FHIRFeatureMapper(schema)\n        df = mapper.extract_features(bundle, aggregation=aggregation)\n\n        return cls(df)\n\n    def validate(\n        self, schema: FeatureSchema, raise_on_error: bool = False\n    ) -&gt; ValidationResult:\n        \"\"\"Validate DataFrame against a feature schema.\n\n        Checks that required features are present and have correct data types.\n\n        Args:\n            schema: FeatureSchema to validate against\n            raise_on_error: Whether to raise exception on validation failure\n\n        Returns:\n            ValidationResult with validation status and details\n\n        Raises:\n            ValueError: If raise_on_error is True and validation fails\n\n        Example:\n            &gt;&gt;&gt; schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")\n            &gt;&gt;&gt; result = dataset.validate(schema)\n            &gt;&gt;&gt; if not result.valid:\n            ...     print(result.errors)\n        \"\"\"\n        result = ValidationResult(valid=True)\n\n        # Check for missing required features\n        required = schema.get_required_features()\n        missing = [f for f in required if f not in self.data.columns]\n\n        for feature in missing:\n            result.add_missing_feature(feature)\n\n        # Check data types for present features\n        for feature_name, mapping in schema.features.items():\n            if feature_name in self.data.columns:\n                actual_dtype = str(self.data[feature_name].dtype)\n                expected_dtype = mapping.dtype\n\n                # Check for type mismatches (allow some flexibility)\n                if not self._dtypes_compatible(actual_dtype, expected_dtype):\n                    result.add_type_mismatch(feature_name, expected_dtype, actual_dtype)\n\n        # Warn about optional missing features\n        optional = set(schema.get_feature_names()) - set(required)\n        missing_optional = [f for f in optional if f not in self.data.columns]\n\n        for feature in missing_optional:\n            result.add_warning(f\"Optional feature '{feature}' is missing\")\n\n        if raise_on_error and not result.valid:\n            raise ValueError(str(result))\n\n        return result\n\n    def _dtypes_compatible(self, actual: str, expected: str) -&gt; bool:\n        \"\"\"Check if actual dtype is compatible with expected dtype.\n\n        Args:\n            actual: Actual dtype string\n            expected: Expected dtype string\n\n        Returns:\n            True if dtypes are compatible\n        \"\"\"\n        # Handle numeric types flexibly\n        numeric_types = {\"int64\", \"int32\", \"float64\", \"float32\"}\n        if expected in numeric_types and actual in numeric_types:\n            return True\n\n        # Exact match for non-numeric types\n        return actual == expected\n\n    def to_risk_assessment(\n        self,\n        outcome_code: str,\n        outcome_display: str,\n        outcome_system: str = \"http://hl7.org/fhir/sid/icd-10\",\n        model_name: Optional[str] = None,\n        model_version: Optional[str] = None,\n        high_threshold: float = 0.7,\n        moderate_threshold: float = 0.4,\n        predictions: Optional[np.ndarray] = None,\n        probabilities: Optional[np.ndarray] = None,\n    ) -&gt; List[RiskAssessment]:\n        \"\"\"Convert model predictions to FHIR RiskAssessment resources.\n\n        Creates RiskAssessment resources from ML model output, suitable for\n        including in FHIR Bundles or sending to FHIR servers.\n\n        Args:\n            outcome_code: Code for the predicted outcome (e.g., \"A41.9\" for sepsis)\n            outcome_display: Display text for the outcome (e.g., \"Sepsis\")\n            outcome_system: Code system for the outcome (default: ICD-10)\n            model_name: Name of the ML model (optional)\n            model_version: Version of the ML model (optional)\n            high_threshold: Threshold for high risk (default: 0.7)\n            moderate_threshold: Threshold for moderate risk (default: 0.4)\n            predictions: Binary predictions array (0/1). Defaults to metadata[\"predictions\"]\n            probabilities: Probability scores array (0-1). Defaults to metadata[\"probabilities\"]\n\n        Returns:\n            List of RiskAssessment resources, one per patient\n\n        Example:\n            &gt;&gt;&gt; risk_assessments = dataset.to_risk_assessment(\n            ...     outcome_code=\"A41.9\",\n            ...     outcome_display=\"Sepsis, unspecified\",\n            ...     model_name=\"RandomForest\",\n            ...     model_version=\"1.0\"\n            ... )\n        \"\"\"\n        # Fall back to metadata if not provided\n        if predictions is None:\n            predictions = self.metadata.get(\"predictions\")\n        if probabilities is None:\n            probabilities = self.metadata.get(\"probabilities\")\n\n        if predictions is None or probabilities is None:\n            raise ValueError(\n                \"predictions and probabilities must be provided or available in metadata\"\n            )\n\n        if len(predictions) != len(self.data):\n            raise ValueError(\n                f\"Predictions length ({len(predictions)}) must match \"\n                f\"DataFrame length ({len(self.data)})\"\n            )\n\n        if len(probabilities) != len(self.data):\n            raise ValueError(\n                f\"Probabilities length ({len(probabilities)}) must match \"\n                f\"DataFrame length ({len(self.data)})\"\n            )\n\n        risk_assessments = []\n\n        # Get patient references\n        if \"patient_ref\" not in self.data.columns:\n            raise ValueError(\"DataFrame must have 'patient_ref' column\")\n\n        for idx, row in self.data.iterrows():\n            patient_ref = row[\"patient_ref\"]\n            prediction = int(predictions[idx])\n            probability = float(probabilities[idx])\n\n            # Determine qualitative risk\n            if probability &gt;= high_threshold:\n                qualitative_risk = \"high\"\n            elif probability &gt;= moderate_threshold:\n                qualitative_risk = \"moderate\"\n            else:\n                qualitative_risk = \"low\"\n\n            # Build prediction dict\n            prediction_dict = {\n                \"outcome\": {\n                    \"code\": outcome_code,\n                    \"display\": outcome_display,\n                    \"system\": outcome_system,\n                },\n                \"probability\": probability,\n                \"qualitative_risk\": qualitative_risk,\n            }\n\n            # Create method CodeableConcept if model info provided\n            method = None\n            if model_name:\n                method = create_single_codeable_concept(\n                    code=model_name,\n                    display=f\"{model_name} v{model_version}\"\n                    if model_version\n                    else model_name,\n                    system=\"https://healthchain.github.io/ml-models\",\n                )\n\n            # Create comment with prediction details\n            comment = (\n                f\"ML prediction: {'Positive' if prediction == 1 else 'Negative'} \"\n                f\"(probability: {probability:.2%}, risk: {qualitative_risk})\"\n            )\n\n            # Create RiskAssessment\n            risk_assessment = create_risk_assessment_from_prediction(\n                subject=patient_ref,\n                prediction=prediction_dict,\n                method=method,\n                comment=comment,\n            )\n\n            risk_assessments.append(risk_assessment)\n\n        return risk_assessments\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Dataset.from_fhir_bundle","title":"<code>from_fhir_bundle(bundle, schema, aggregation='mean')</code>  <code>classmethod</code>","text":"<p>Create Dataset from a FHIR Bundle using a feature schema.</p> <p>Extracts features from FHIR resources according to the schema specification, converting FHIR data to a pandas DataFrame suitable for ML inference.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>FHIR Bundle resource (object or dict)</p> <p> TYPE: <code>Union[Bundle, Dict[str, Any]]</code> </p> <code>schema</code> <p>FeatureSchema object, or path to YAML schema file</p> <p> TYPE: <code>Union[str, Path, FeatureSchema]</code> </p> <code>aggregation</code> <p>How to aggregate multiple observation values (default: \"mean\") Options: \"mean\", \"median\", \"max\", \"min\", \"last\" (default: \"mean\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'mean'</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>Dataset container with extracted features</p> Example <p>from fhir.resources.bundle import Bundle bundle = Bundle(**patient_data) dataset = Dataset.from_fhir_bundle( ...     bundle, ...     schema=\"healthchain/configs/features/sepsis_vitals.yaml\" ... ) df = dataset.data</p> Source code in <code>healthchain/io/containers/dataset.py</code> <pre><code>@classmethod\ndef from_fhir_bundle(\n    cls,\n    bundle: Union[Bundle, Dict[str, Any]],\n    schema: Union[str, Path, FeatureSchema],\n    aggregation: str = \"mean\",\n) -&gt; \"Dataset\":\n    \"\"\"Create Dataset from a FHIR Bundle using a feature schema.\n\n    Extracts features from FHIR resources according to the schema specification,\n    converting FHIR data to a pandas DataFrame suitable for ML inference.\n\n    Args:\n        bundle: FHIR Bundle resource (object or dict)\n        schema: FeatureSchema object, or path to YAML schema file\n        aggregation: How to aggregate multiple observation values (default: \"mean\")\n            Options: \"mean\", \"median\", \"max\", \"min\", \"last\" (default: \"mean\")\n\n    Returns:\n        Dataset container with extracted features\n\n    Example:\n        &gt;&gt;&gt; from fhir.resources.bundle import Bundle\n        &gt;&gt;&gt; bundle = Bundle(**patient_data)\n        &gt;&gt;&gt; dataset = Dataset.from_fhir_bundle(\n        ...     bundle,\n        ...     schema=\"healthchain/configs/features/sepsis_vitals.yaml\"\n        ... )\n        &gt;&gt;&gt; df = dataset.data\n    \"\"\"\n    # Load schema if path provided\n    if isinstance(schema, (str, Path)):\n        schema = FeatureSchema.from_yaml(schema)\n\n    # Extract features using mapper\n    mapper = FHIRFeatureMapper(schema)\n    df = mapper.extract_features(bundle, aggregation=aggregation)\n\n    return cls(df)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Dataset.to_risk_assessment","title":"<code>to_risk_assessment(outcome_code, outcome_display, outcome_system='http://hl7.org/fhir/sid/icd-10', model_name=None, model_version=None, high_threshold=0.7, moderate_threshold=0.4, predictions=None, probabilities=None)</code>","text":"<p>Convert model predictions to FHIR RiskAssessment resources.</p> <p>Creates RiskAssessment resources from ML model output, suitable for including in FHIR Bundles or sending to FHIR servers.</p> PARAMETER DESCRIPTION <code>outcome_code</code> <p>Code for the predicted outcome (e.g., \"A41.9\" for sepsis)</p> <p> TYPE: <code>str</code> </p> <code>outcome_display</code> <p>Display text for the outcome (e.g., \"Sepsis\")</p> <p> TYPE: <code>str</code> </p> <code>outcome_system</code> <p>Code system for the outcome (default: ICD-10)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://hl7.org/fhir/sid/icd-10'</code> </p> <code>model_name</code> <p>Name of the ML model (optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>model_version</code> <p>Version of the ML model (optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>high_threshold</code> <p>Threshold for high risk (default: 0.7)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.7</code> </p> <code>moderate_threshold</code> <p>Threshold for moderate risk (default: 0.4)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.4</code> </p> <code>predictions</code> <p>Binary predictions array (0/1). Defaults to metadata[\"predictions\"]</p> <p> TYPE: <code>Optional[ndarray]</code> DEFAULT: <code>None</code> </p> <code>probabilities</code> <p>Probability scores array (0-1). Defaults to metadata[\"probabilities\"]</p> <p> TYPE: <code>Optional[ndarray]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[RiskAssessment]</code> <p>List of RiskAssessment resources, one per patient</p> Example <p>risk_assessments = dataset.to_risk_assessment( ...     outcome_code=\"A41.9\", ...     outcome_display=\"Sepsis, unspecified\", ...     model_name=\"RandomForest\", ...     model_version=\"1.0\" ... )</p> Source code in <code>healthchain/io/containers/dataset.py</code> <pre><code>def to_risk_assessment(\n    self,\n    outcome_code: str,\n    outcome_display: str,\n    outcome_system: str = \"http://hl7.org/fhir/sid/icd-10\",\n    model_name: Optional[str] = None,\n    model_version: Optional[str] = None,\n    high_threshold: float = 0.7,\n    moderate_threshold: float = 0.4,\n    predictions: Optional[np.ndarray] = None,\n    probabilities: Optional[np.ndarray] = None,\n) -&gt; List[RiskAssessment]:\n    \"\"\"Convert model predictions to FHIR RiskAssessment resources.\n\n    Creates RiskAssessment resources from ML model output, suitable for\n    including in FHIR Bundles or sending to FHIR servers.\n\n    Args:\n        outcome_code: Code for the predicted outcome (e.g., \"A41.9\" for sepsis)\n        outcome_display: Display text for the outcome (e.g., \"Sepsis\")\n        outcome_system: Code system for the outcome (default: ICD-10)\n        model_name: Name of the ML model (optional)\n        model_version: Version of the ML model (optional)\n        high_threshold: Threshold for high risk (default: 0.7)\n        moderate_threshold: Threshold for moderate risk (default: 0.4)\n        predictions: Binary predictions array (0/1). Defaults to metadata[\"predictions\"]\n        probabilities: Probability scores array (0-1). Defaults to metadata[\"probabilities\"]\n\n    Returns:\n        List of RiskAssessment resources, one per patient\n\n    Example:\n        &gt;&gt;&gt; risk_assessments = dataset.to_risk_assessment(\n        ...     outcome_code=\"A41.9\",\n        ...     outcome_display=\"Sepsis, unspecified\",\n        ...     model_name=\"RandomForest\",\n        ...     model_version=\"1.0\"\n        ... )\n    \"\"\"\n    # Fall back to metadata if not provided\n    if predictions is None:\n        predictions = self.metadata.get(\"predictions\")\n    if probabilities is None:\n        probabilities = self.metadata.get(\"probabilities\")\n\n    if predictions is None or probabilities is None:\n        raise ValueError(\n            \"predictions and probabilities must be provided or available in metadata\"\n        )\n\n    if len(predictions) != len(self.data):\n        raise ValueError(\n            f\"Predictions length ({len(predictions)}) must match \"\n            f\"DataFrame length ({len(self.data)})\"\n        )\n\n    if len(probabilities) != len(self.data):\n        raise ValueError(\n            f\"Probabilities length ({len(probabilities)}) must match \"\n            f\"DataFrame length ({len(self.data)})\"\n        )\n\n    risk_assessments = []\n\n    # Get patient references\n    if \"patient_ref\" not in self.data.columns:\n        raise ValueError(\"DataFrame must have 'patient_ref' column\")\n\n    for idx, row in self.data.iterrows():\n        patient_ref = row[\"patient_ref\"]\n        prediction = int(predictions[idx])\n        probability = float(probabilities[idx])\n\n        # Determine qualitative risk\n        if probability &gt;= high_threshold:\n            qualitative_risk = \"high\"\n        elif probability &gt;= moderate_threshold:\n            qualitative_risk = \"moderate\"\n        else:\n            qualitative_risk = \"low\"\n\n        # Build prediction dict\n        prediction_dict = {\n            \"outcome\": {\n                \"code\": outcome_code,\n                \"display\": outcome_display,\n                \"system\": outcome_system,\n            },\n            \"probability\": probability,\n            \"qualitative_risk\": qualitative_risk,\n        }\n\n        # Create method CodeableConcept if model info provided\n        method = None\n        if model_name:\n            method = create_single_codeable_concept(\n                code=model_name,\n                display=f\"{model_name} v{model_version}\"\n                if model_version\n                else model_name,\n                system=\"https://healthchain.github.io/ml-models\",\n            )\n\n        # Create comment with prediction details\n        comment = (\n            f\"ML prediction: {'Positive' if prediction == 1 else 'Negative'} \"\n            f\"(probability: {probability:.2%}, risk: {qualitative_risk})\"\n        )\n\n        # Create RiskAssessment\n        risk_assessment = create_risk_assessment_from_prediction(\n            subject=patient_ref,\n            prediction=prediction_dict,\n            method=method,\n            comment=comment,\n        )\n\n        risk_assessments.append(risk_assessment)\n\n    return risk_assessments\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Dataset.validate","title":"<code>validate(schema, raise_on_error=False)</code>","text":"<p>Validate DataFrame against a feature schema.</p> <p>Checks that required features are present and have correct data types.</p> PARAMETER DESCRIPTION <code>schema</code> <p>FeatureSchema to validate against</p> <p> TYPE: <code>FeatureSchema</code> </p> <code>raise_on_error</code> <p>Whether to raise exception on validation failure</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult with validation status and details</p> RAISES DESCRIPTION <code>ValueError</code> <p>If raise_on_error is True and validation fails</p> Example <p>schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\") result = dataset.validate(schema) if not result.valid: ...     print(result.errors)</p> Source code in <code>healthchain/io/containers/dataset.py</code> <pre><code>def validate(\n    self, schema: FeatureSchema, raise_on_error: bool = False\n) -&gt; ValidationResult:\n    \"\"\"Validate DataFrame against a feature schema.\n\n    Checks that required features are present and have correct data types.\n\n    Args:\n        schema: FeatureSchema to validate against\n        raise_on_error: Whether to raise exception on validation failure\n\n    Returns:\n        ValidationResult with validation status and details\n\n    Raises:\n        ValueError: If raise_on_error is True and validation fails\n\n    Example:\n        &gt;&gt;&gt; schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")\n        &gt;&gt;&gt; result = dataset.validate(schema)\n        &gt;&gt;&gt; if not result.valid:\n        ...     print(result.errors)\n    \"\"\"\n    result = ValidationResult(valid=True)\n\n    # Check for missing required features\n    required = schema.get_required_features()\n    missing = [f for f in required if f not in self.data.columns]\n\n    for feature in missing:\n        result.add_missing_feature(feature)\n\n    # Check data types for present features\n    for feature_name, mapping in schema.features.items():\n        if feature_name in self.data.columns:\n            actual_dtype = str(self.data[feature_name].dtype)\n            expected_dtype = mapping.dtype\n\n            # Check for type mismatches (allow some flexibility)\n            if not self._dtypes_compatible(actual_dtype, expected_dtype):\n                result.add_type_mismatch(feature_name, expected_dtype, actual_dtype)\n\n    # Warn about optional missing features\n    optional = set(schema.get_feature_names()) - set(required)\n    missing_optional = [f for f in optional if f not in self.data.columns]\n\n    for feature in missing_optional:\n        result.add_warning(f\"Optional feature '{feature}' is missing\")\n\n    if raise_on_error and not result.valid:\n        raise ValueError(str(result))\n\n    return result\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseDocument</code></p> <p>Main document container for processing textual and clinical data in HealthChain.</p> <p>The Document class is the primary structure used throughout annotation and analytics pipelines, accumulating transformations, extractions, and results from each stage. It seamlessly integrates raw text, NLP annotations, FHIR resources, clinical decision support (CDS) results, and ML model outputs in one object.</p> Features <ul> <li>Accepts text, FHIR Bundles/resources, or lists of FHIR resources as input.</li> <li>Provides basic tokenization and supports integration with NLP models (spaCy, transformers).</li> <li>Stores and manipulates clinical FHIR data via the .fhir property (access to bundles, problem lists, meds, allergies, etc.).</li> <li>Encapsulates CDS Hooks-style decision support cards and suggested actions via the .cds property.</li> <li>Stores outputs from external ML/LLM models: HuggingFace, LangChain, etc.</li> </ul> ATTRIBUTE DESCRIPTION <code>nlp</code> <p>NLP output (tokens, entities, embeddings, spaCy doc)</p> <p> TYPE: <code>NlpAnnotations</code> </p> <code>fhir</code> <p>FHIR resources and context (problem list, medication, allergy, etc.)</p> <p> TYPE: <code>FhirData</code> </p> <code>cds</code> <p>Clinical decision support (cards and actions)</p> <p> TYPE: <code>CdsAnnotations</code> </p> <code>models</code> <p>Results from ML/LLM models (HuggingFace, LangChain, etc.)</p> <p> TYPE: <code>ModelOutputs</code> </p> <code>text</code> <p>The text content of the document (if available).</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>The original input supplied (raw text, Bundle, resource, or list of resources)</p> <p> TYPE: <code>str</code> </p> Usage example <p>doc = Document(data=\"Patient has hypertension\") doc.nlp._tokens ['Patient', 'has', 'hypertension'] doc.fhir.problem_list = [Condition(...)] doc.cds.cards = [Card(...)] doc.models.huggingface_results = ... for token in doc: ...     print(token)</p> Inherits from <p>BaseDocument</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass Document(BaseDocument):\n    \"\"\"\n    Main document container for processing textual and clinical data in HealthChain.\n\n    The Document class is the primary structure used throughout annotation and analytics\n    pipelines, accumulating transformations, extractions, and results from each stage. It\n    seamlessly integrates raw text, NLP annotations, FHIR resources, clinical decision\n    support (CDS) results, and ML model outputs in one object.\n\n    Features:\n        - Accepts text, FHIR Bundles/resources, or lists of FHIR resources as input.\n        - Provides basic tokenization and supports integration with NLP models (spaCy, transformers).\n        - Stores and manipulates clinical FHIR data via the .fhir property (access to bundles, problem lists, meds, allergies, etc.).\n        - Encapsulates CDS Hooks-style decision support cards and suggested actions via the .cds property.\n        - Stores outputs from external ML/LLM models: HuggingFace, LangChain, etc.\n\n    Attributes:\n        nlp (NlpAnnotations): NLP output (tokens, entities, embeddings, spaCy doc)\n        fhir (FhirData): FHIR resources and context (problem list, medication, allergy, etc.)\n        cds (CdsAnnotations): Clinical decision support (cards and actions)\n        models (ModelOutputs): Results from ML/LLM models (HuggingFace, LangChain, etc.)\n        text (str): The text content of the document (if available).\n        data: The original input supplied (raw text, Bundle, resource, or list of resources)\n\n    Usage example:\n        &gt;&gt;&gt; doc = Document(data=\"Patient has hypertension\")\n        &gt;&gt;&gt; doc.nlp._tokens\n        ['Patient', 'has', 'hypertension']\n        &gt;&gt;&gt; doc.fhir.problem_list = [Condition(...)]\n        &gt;&gt;&gt; doc.cds.cards = [Card(...)]\n        &gt;&gt;&gt; doc.models.huggingface_results = ...\n        &gt;&gt;&gt; for token in doc:\n        ...     print(token)\n\n    Inherits from:\n        BaseDocument\n    \"\"\"\n\n    _nlp: NlpAnnotations = field(default_factory=NlpAnnotations)\n    _fhir: FhirData = field(default_factory=FhirData)\n    _cds: CdsAnnotations = field(default_factory=CdsAnnotations)\n    _models: ModelOutputs = field(default_factory=ModelOutputs)\n\n    @property\n    def nlp(self) -&gt; NlpAnnotations:\n        return self._nlp\n\n    @property\n    def fhir(self) -&gt; FhirData:\n        return self._fhir\n\n    @property\n    def cds(self) -&gt; CdsAnnotations:\n        return self._cds\n\n    @property\n    def models(self) -&gt; ModelOutputs:\n        return self._models\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization setup to process textual or FHIR data.\n\n        - If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.\n        - If input data is a list of FHIR resources, wraps them in a Bundle.\n        - For text input, sets .text field accordingly.\n        - Performs basic whitespace tokenization if necessary.\n        \"\"\"\n        super().__post_init__()\n\n        # Handle FHIR Bundle data\n        if isinstance(self.data, Bundle):\n            self._fhir._bundle = self.data\n\n            # Extract OperationOutcome resources (operation results/errors)\n            outcomes = extract_resources(self._fhir._bundle, \"OperationOutcome\")\n            if outcomes:\n                self._fhir._operation_outcomes = outcomes\n\n            # Extract Provenance resources (data lineage/origin)\n            provenances = extract_resources(self._fhir._bundle, \"Provenance\")\n            if provenances:\n                self._fhir._provenances = provenances\n\n            self.text = \"\"  # No text content for bundle-only documents\n        # Handle list of FHIR resources\n        elif (\n            isinstance(self.data, list)\n            and self.data\n            and isinstance(self.data[0], Resource)\n        ):\n            self._fhir._bundle = create_bundle()\n            for resource in self.data:\n                add_resource(self._fhir._bundle, resource)\n            self.text = \"\"  # No text content for resource-only documents\n        else:\n            # Handle text data\n            self.text = self.data if isinstance(self.data, str) else str(self.data)\n\n        if not self._nlp._tokens and self.text:\n            self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n\n    def word_count(self) -&gt; int:\n        \"\"\"\n        Return the number of word tokens in the document.\n\n        Returns:\n            int: The count of tokenized words in the document.\n        \"\"\"\n        return len(self._nlp._tokens)\n\n    def update_problem_list_from_nlp(\n        self,\n        patient_ref: str = \"Patient/123\",\n        coding_system: str = \"http://snomed.info/sct\",\n        code_attribute: str = \"cui\",\n    ):\n        \"\"\"\n        Populate or update the problem list using entities extracted via NLP.\n\n        This method looks for entities with associated medical codes and creates FHIR Condition\n        resources from them. It supports a two-step process:\n        1. NER: Extract entities from text (spaCy, HuggingFace, etc.)\n        2. Entity Linking: Add medical codes to those entities\n        3. Problem List Creation: Convert linked entities to FHIR conditions (this method)\n\n        The method extracts from:\n        1. spaCy entities with extension attributes (e.g., ent._.cui)\n        2. Generic entities in the NLP annotations container (framework-agnostic)\n\n        TODO: make this more generic and support other resource types\n\n        Args:\n            patient_ref: FHIR reference to the patient (default: \"Patient/123\")\n            coding_system: Coding system URI for the conditions (default: SNOMED CT)\n            code_attribute: Name of the attribute containing the medical code (default: \"cui\")\n\n        Notes:\n            - Preserves any existing problem list Conditions.\n            - Supports framework-agnostic extraction (spaCy and dict entities).\n            - For spaCy, looks for entity extension attribute (e.g. ent._.cui).\n            - For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).\n        \"\"\"\n        # Start with existing conditions to preserve them\n        existing_conditions = self.fhir.problem_list.copy()\n        new_conditions = []\n\n        # 1. Extract from spaCy entities (if available)\n        if self.nlp._spacy_doc and self.nlp._spacy_doc.ents:\n            for ent in self.nlp._spacy_doc.ents:\n                if not Span.has_extension(code_attribute):\n                    logger.debug(\n                        f\"Extension '{code_attribute}' not found for spaCy entity {ent.text}\"\n                    )\n                    continue\n\n                code_value = getattr(ent._, code_attribute, None)\n                if code_value is None:\n                    logger.debug(\n                        f\"No {code_attribute} found for spaCy entity {ent.text}\"\n                    )\n                    continue\n\n                condition = create_condition(\n                    subject=patient_ref,\n                    code=code_value,\n                    display=ent.text,\n                    system=coding_system,\n                )\n                set_condition_category(condition, \"problem-list-item\")\n                logger.debug(\n                    f\"Adding condition from spaCy: {condition.model_dump(exclude_none=True)}\"\n                )\n                new_conditions.append(condition)\n\n        # 2. Extract from generic NLP entities (framework-agnostic)\n        generic_entities = self.nlp.get_entities()\n        if generic_entities:\n            for ent_dict in generic_entities:\n                # Skip if no linked code\n                code_value = ent_dict.get(code_attribute)\n                if code_value is None:\n                    logger.debug(\n                        f\"No {code_attribute} found for entity {ent_dict.get('text', 'unknown')}\"\n                    )\n                    continue\n\n                entity_text = ent_dict.get(\"text\", \"unknown\")\n\n                condition = create_condition(\n                    subject=patient_ref,\n                    code=code_value,\n                    display=entity_text,\n                    system=coding_system,\n                )\n                set_condition_category(condition, \"problem-list-item\")\n                logger.debug(\n                    f\"Adding condition from entities: {condition.model_dump(exclude_none=True)}\"\n                )\n                new_conditions.append(condition)\n\n        # Update problem list with combined conditions (replace to avoid duplication)\n        if new_conditions:\n            all_conditions = existing_conditions + new_conditions\n            self.fhir.add_resources(all_conditions, \"Condition\", replace=True)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        \"\"\"\n        Iterate through the document's tokens.\n\n        Returns:\n            Iterator[str]: Iterator over the document tokens.\n        \"\"\"\n        return iter(self._nlp._tokens)\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Return the length of the document's text.\n\n        Returns:\n            int: Character length of the document text.\n        \"\"\"\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate through the document's tokens.</p> RETURNS DESCRIPTION <code>Iterator[str]</code> <p>Iterator[str]: Iterator over the document tokens.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n    \"\"\"\n    Iterate through the document's tokens.\n\n    Returns:\n        Iterator[str]: Iterator over the document tokens.\n    \"\"\"\n    return iter(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the document's text.</p> RETURNS DESCRIPTION <code>int</code> <p>Character length of the document text.</p> <p> TYPE: <code>int</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Return the length of the document's text.\n\n    Returns:\n        int: Character length of the document text.\n    \"\"\"\n    return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization setup to process textual or FHIR data.</p> <ul> <li>If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.</li> <li>If input data is a list of FHIR resources, wraps them in a Bundle.</li> <li>For text input, sets .text field accordingly.</li> <li>Performs basic whitespace tokenization if necessary.</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization setup to process textual or FHIR data.\n\n    - If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.\n    - If input data is a list of FHIR resources, wraps them in a Bundle.\n    - For text input, sets .text field accordingly.\n    - Performs basic whitespace tokenization if necessary.\n    \"\"\"\n    super().__post_init__()\n\n    # Handle FHIR Bundle data\n    if isinstance(self.data, Bundle):\n        self._fhir._bundle = self.data\n\n        # Extract OperationOutcome resources (operation results/errors)\n        outcomes = extract_resources(self._fhir._bundle, \"OperationOutcome\")\n        if outcomes:\n            self._fhir._operation_outcomes = outcomes\n\n        # Extract Provenance resources (data lineage/origin)\n        provenances = extract_resources(self._fhir._bundle, \"Provenance\")\n        if provenances:\n            self._fhir._provenances = provenances\n\n        self.text = \"\"  # No text content for bundle-only documents\n    # Handle list of FHIR resources\n    elif (\n        isinstance(self.data, list)\n        and self.data\n        and isinstance(self.data[0], Resource)\n    ):\n        self._fhir._bundle = create_bundle()\n        for resource in self.data:\n            add_resource(self._fhir._bundle, resource)\n        self.text = \"\"  # No text content for resource-only documents\n    else:\n        # Handle text data\n        self.text = self.data if isinstance(self.data, str) else str(self.data)\n\n    if not self._nlp._tokens and self.text:\n        self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.update_problem_list_from_nlp","title":"<code>update_problem_list_from_nlp(patient_ref='Patient/123', coding_system='http://snomed.info/sct', code_attribute='cui')</code>","text":"<p>Populate or update the problem list using entities extracted via NLP.</p> <p>This method looks for entities with associated medical codes and creates FHIR Condition resources from them. It supports a two-step process: 1. NER: Extract entities from text (spaCy, HuggingFace, etc.) 2. Entity Linking: Add medical codes to those entities 3. Problem List Creation: Convert linked entities to FHIR conditions (this method)</p> <p>The method extracts from: 1. spaCy entities with extension attributes (e.g., ent._.cui) 2. Generic entities in the NLP annotations container (framework-agnostic)</p> <p>TODO: make this more generic and support other resource types</p> PARAMETER DESCRIPTION <code>patient_ref</code> <p>FHIR reference to the patient (default: \"Patient/123\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Patient/123'</code> </p> <code>coding_system</code> <p>Coding system URI for the conditions (default: SNOMED CT)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>code_attribute</code> <p>Name of the attribute containing the medical code (default: \"cui\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cui'</code> </p> Notes <ul> <li>Preserves any existing problem list Conditions.</li> <li>Supports framework-agnostic extraction (spaCy and dict entities).</li> <li>For spaCy, looks for entity extension attribute (e.g. ent._.cui).</li> <li>For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def update_problem_list_from_nlp(\n    self,\n    patient_ref: str = \"Patient/123\",\n    coding_system: str = \"http://snomed.info/sct\",\n    code_attribute: str = \"cui\",\n):\n    \"\"\"\n    Populate or update the problem list using entities extracted via NLP.\n\n    This method looks for entities with associated medical codes and creates FHIR Condition\n    resources from them. It supports a two-step process:\n    1. NER: Extract entities from text (spaCy, HuggingFace, etc.)\n    2. Entity Linking: Add medical codes to those entities\n    3. Problem List Creation: Convert linked entities to FHIR conditions (this method)\n\n    The method extracts from:\n    1. spaCy entities with extension attributes (e.g., ent._.cui)\n    2. Generic entities in the NLP annotations container (framework-agnostic)\n\n    TODO: make this more generic and support other resource types\n\n    Args:\n        patient_ref: FHIR reference to the patient (default: \"Patient/123\")\n        coding_system: Coding system URI for the conditions (default: SNOMED CT)\n        code_attribute: Name of the attribute containing the medical code (default: \"cui\")\n\n    Notes:\n        - Preserves any existing problem list Conditions.\n        - Supports framework-agnostic extraction (spaCy and dict entities).\n        - For spaCy, looks for entity extension attribute (e.g. ent._.cui).\n        - For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).\n    \"\"\"\n    # Start with existing conditions to preserve them\n    existing_conditions = self.fhir.problem_list.copy()\n    new_conditions = []\n\n    # 1. Extract from spaCy entities (if available)\n    if self.nlp._spacy_doc and self.nlp._spacy_doc.ents:\n        for ent in self.nlp._spacy_doc.ents:\n            if not Span.has_extension(code_attribute):\n                logger.debug(\n                    f\"Extension '{code_attribute}' not found for spaCy entity {ent.text}\"\n                )\n                continue\n\n            code_value = getattr(ent._, code_attribute, None)\n            if code_value is None:\n                logger.debug(\n                    f\"No {code_attribute} found for spaCy entity {ent.text}\"\n                )\n                continue\n\n            condition = create_condition(\n                subject=patient_ref,\n                code=code_value,\n                display=ent.text,\n                system=coding_system,\n            )\n            set_condition_category(condition, \"problem-list-item\")\n            logger.debug(\n                f\"Adding condition from spaCy: {condition.model_dump(exclude_none=True)}\"\n            )\n            new_conditions.append(condition)\n\n    # 2. Extract from generic NLP entities (framework-agnostic)\n    generic_entities = self.nlp.get_entities()\n    if generic_entities:\n        for ent_dict in generic_entities:\n            # Skip if no linked code\n            code_value = ent_dict.get(code_attribute)\n            if code_value is None:\n                logger.debug(\n                    f\"No {code_attribute} found for entity {ent_dict.get('text', 'unknown')}\"\n                )\n                continue\n\n            entity_text = ent_dict.get(\"text\", \"unknown\")\n\n            condition = create_condition(\n                subject=patient_ref,\n                code=code_value,\n                display=entity_text,\n                system=coding_system,\n            )\n            set_condition_category(condition, \"problem-list-item\")\n            logger.debug(\n                f\"Adding condition from entities: {condition.model_dump(exclude_none=True)}\"\n            )\n            new_conditions.append(condition)\n\n    # Update problem list with combined conditions (replace to avoid duplication)\n    if new_conditions:\n        all_conditions = existing_conditions + new_conditions\n        self.fhir.add_resources(all_conditions, \"Condition\", replace=True)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.Document.word_count","title":"<code>word_count()</code>","text":"<p>Return the number of word tokens in the document.</p> RETURNS DESCRIPTION <code>int</code> <p>The count of tokenized words in the document.</p> <p> TYPE: <code>int</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def word_count(self) -&gt; int:\n    \"\"\"\n    Return the number of word tokens in the document.\n\n    Returns:\n        int: The count of tokenized words in the document.\n    \"\"\"\n    return len(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema","title":"<code>FeatureSchema</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema defining how to extract features from FHIR resources.</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>class FeatureSchema(BaseModel):\n    \"\"\"Schema defining how to extract features from FHIR resources.\"\"\"\n\n    name: str\n    version: str\n    features: Dict[str, FeatureMapping] = {}\n    description: Optional[str] = None\n    model_info: Optional[Dict[str, Any]] = None\n    metadata: Optional[Dict[str, Any]] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    @field_validator(\"features\", mode=\"before\")\n    @classmethod\n    def convert_feature_dicts(cls, v):\n        \"\"\"Convert feature dicts to FeatureMapping objects if needed.\"\"\"\n        if v and isinstance(v, dict):\n            # Check if values are dicts (need conversion) or already FeatureMapping\n            if v and isinstance(list(v.values())[0], dict):\n                return {\n                    name: FeatureMapping.from_dict(name, mapping)\n                    for name, mapping in v.items()\n                }\n        return v\n\n    @classmethod\n    def from_yaml(cls, path: Union[str, Path]) -&gt; \"FeatureSchema\":\n        \"\"\"Load schema from a YAML file.\n\n        Args:\n            path: Path to the YAML file\n\n        Returns:\n            FeatureSchema instance\n\n        Example:\n            &gt;&gt;&gt; schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")\n        \"\"\"\n        path = Path(path)\n        with open(path, \"r\") as f:\n            data = yaml.safe_load(f)\n\n        return cls.model_validate(data)\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"FeatureSchema\":\n        \"\"\"Create a FeatureSchema from a dictionary.\n\n        Args:\n            data: Dictionary containing schema configuration\n\n        Returns:\n            FeatureSchema instance\n        \"\"\"\n        return cls.model_validate(data)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert schema to dictionary format.\n\n        Returns:\n            Dictionary representation of the schema\n        \"\"\"\n        result = {\n            \"name\": self.name,\n            \"version\": self.version,\n            \"description\": self.description,\n            \"model_info\": self.model_info,\n            \"features\": {\n                name: {\n                    k: v\n                    for k, v in mapping.model_dump().items()\n                    if k != \"name\" and v is not None\n                }\n                for name, mapping in self.features.items()\n            },\n        }\n        if self.metadata:\n            result[\"metadata\"] = self.metadata\n        return result\n\n    def to_yaml(self, path: Union[str, Path]) -&gt; None:\n        \"\"\"Save schema to a YAML file.\n\n        Args:\n            path: Path where the YAML file will be saved\n        \"\"\"\n        path = Path(path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(path, \"w\") as f:\n            yaml.dump(self.to_dict(), f, default_flow_style=False, sort_keys=False)\n\n    def get_feature_names(self) -&gt; List[str]:\n        \"\"\"Get list of feature names in order.\n\n        Returns:\n            List of feature names\n        \"\"\"\n        return list(self.features.keys())\n\n    def get_required_features(self) -&gt; List[str]:\n        \"\"\"Get list of required feature names.\n\n        Returns:\n            List of required feature names\n        \"\"\"\n        return [name for name, mapping in self.features.items() if mapping.required]\n\n    def get_features_by_resource(self, resource_type: str) -&gt; Dict[str, FeatureMapping]:\n        \"\"\"Get all features mapped to a specific FHIR resource type.\n\n        Args:\n            resource_type: FHIR resource type (e.g., \"Observation\", \"Patient\")\n\n        Returns:\n            Dictionary of features for the specified resource type\n        \"\"\"\n        return {\n            name: mapping\n            for name, mapping in self.features.items()\n            if mapping.fhir_resource == resource_type\n        }\n\n    def get_observation_codes(self) -&gt; Dict[str, FeatureMapping]:\n        \"\"\"Get all Observation features with their codes.\n\n        Returns:\n            Dictionary mapping codes to feature mappings\n        \"\"\"\n        observations = self.get_features_by_resource(\"Observation\")\n        return {\n            mapping.code: mapping for mapping in observations.values() if mapping.code\n        }\n\n    def validate_dataframe_columns(self, columns: List[str]) -&gt; Dict[str, Any]:\n        \"\"\"Validate that a DataFrame has the expected columns.\n\n        Args:\n            columns: List of column names from a DataFrame\n\n        Returns:\n            Dictionary with validation results:\n                - valid: bool\n                - missing_required: List of missing required features\n                - unexpected: List of unexpected columns\n        \"\"\"\n        expected = set(self.get_feature_names())\n        actual = set(columns)\n        required = set(self.get_required_features())\n\n        missing_required = list(required - actual)\n        unexpected = list(actual - expected)\n\n        return {\n            \"valid\": len(missing_required) == 0,\n            \"missing_required\": missing_required,\n            \"unexpected\": unexpected,\n            \"missing_optional\": list((expected - required) - actual),\n        }\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.convert_feature_dicts","title":"<code>convert_feature_dicts(v)</code>  <code>classmethod</code>","text":"<p>Convert feature dicts to FeatureMapping objects if needed.</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>@field_validator(\"features\", mode=\"before\")\n@classmethod\ndef convert_feature_dicts(cls, v):\n    \"\"\"Convert feature dicts to FeatureMapping objects if needed.\"\"\"\n    if v and isinstance(v, dict):\n        # Check if values are dicts (need conversion) or already FeatureMapping\n        if v and isinstance(list(v.values())[0], dict):\n            return {\n                name: FeatureMapping.from_dict(name, mapping)\n                for name, mapping in v.items()\n            }\n    return v\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a FeatureSchema from a dictionary.</p> PARAMETER DESCRIPTION <code>data</code> <p>Dictionary containing schema configuration</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>FeatureSchema</code> <p>FeatureSchema instance</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"FeatureSchema\":\n    \"\"\"Create a FeatureSchema from a dictionary.\n\n    Args:\n        data: Dictionary containing schema configuration\n\n    Returns:\n        FeatureSchema instance\n    \"\"\"\n    return cls.model_validate(data)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.from_yaml","title":"<code>from_yaml(path)</code>  <code>classmethod</code>","text":"<p>Load schema from a YAML file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the YAML file</p> <p> TYPE: <code>Union[str, Path]</code> </p> RETURNS DESCRIPTION <code>FeatureSchema</code> <p>FeatureSchema instance</p> Example <p>schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>@classmethod\ndef from_yaml(cls, path: Union[str, Path]) -&gt; \"FeatureSchema\":\n    \"\"\"Load schema from a YAML file.\n\n    Args:\n        path: Path to the YAML file\n\n    Returns:\n        FeatureSchema instance\n\n    Example:\n        &gt;&gt;&gt; schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")\n    \"\"\"\n    path = Path(path)\n    with open(path, \"r\") as f:\n        data = yaml.safe_load(f)\n\n    return cls.model_validate(data)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.get_feature_names","title":"<code>get_feature_names()</code>","text":"<p>Get list of feature names in order.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of feature names</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def get_feature_names(self) -&gt; List[str]:\n    \"\"\"Get list of feature names in order.\n\n    Returns:\n        List of feature names\n    \"\"\"\n    return list(self.features.keys())\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.get_features_by_resource","title":"<code>get_features_by_resource(resource_type)</code>","text":"<p>Get all features mapped to a specific FHIR resource type.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>FHIR resource type (e.g., \"Observation\", \"Patient\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, FeatureMapping]</code> <p>Dictionary of features for the specified resource type</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def get_features_by_resource(self, resource_type: str) -&gt; Dict[str, FeatureMapping]:\n    \"\"\"Get all features mapped to a specific FHIR resource type.\n\n    Args:\n        resource_type: FHIR resource type (e.g., \"Observation\", \"Patient\")\n\n    Returns:\n        Dictionary of features for the specified resource type\n    \"\"\"\n    return {\n        name: mapping\n        for name, mapping in self.features.items()\n        if mapping.fhir_resource == resource_type\n    }\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.get_observation_codes","title":"<code>get_observation_codes()</code>","text":"<p>Get all Observation features with their codes.</p> RETURNS DESCRIPTION <code>Dict[str, FeatureMapping]</code> <p>Dictionary mapping codes to feature mappings</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def get_observation_codes(self) -&gt; Dict[str, FeatureMapping]:\n    \"\"\"Get all Observation features with their codes.\n\n    Returns:\n        Dictionary mapping codes to feature mappings\n    \"\"\"\n    observations = self.get_features_by_resource(\"Observation\")\n    return {\n        mapping.code: mapping for mapping in observations.values() if mapping.code\n    }\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.get_required_features","title":"<code>get_required_features()</code>","text":"<p>Get list of required feature names.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of required feature names</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def get_required_features(self) -&gt; List[str]:\n    \"\"\"Get list of required feature names.\n\n    Returns:\n        List of required feature names\n    \"\"\"\n    return [name for name, mapping in self.features.items() if mapping.required]\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert schema to dictionary format.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary representation of the schema</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert schema to dictionary format.\n\n    Returns:\n        Dictionary representation of the schema\n    \"\"\"\n    result = {\n        \"name\": self.name,\n        \"version\": self.version,\n        \"description\": self.description,\n        \"model_info\": self.model_info,\n        \"features\": {\n            name: {\n                k: v\n                for k, v in mapping.model_dump().items()\n                if k != \"name\" and v is not None\n            }\n            for name, mapping in self.features.items()\n        },\n    }\n    if self.metadata:\n        result[\"metadata\"] = self.metadata\n    return result\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.to_yaml","title":"<code>to_yaml(path)</code>","text":"<p>Save schema to a YAML file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path where the YAML file will be saved</p> <p> TYPE: <code>Union[str, Path]</code> </p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def to_yaml(self, path: Union[str, Path]) -&gt; None:\n    \"\"\"Save schema to a YAML file.\n\n    Args:\n        path: Path where the YAML file will be saved\n    \"\"\"\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    with open(path, \"w\") as f:\n        yaml.dump(self.to_dict(), f, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.FeatureSchema.validate_dataframe_columns","title":"<code>validate_dataframe_columns(columns)</code>","text":"<p>Validate that a DataFrame has the expected columns.</p> PARAMETER DESCRIPTION <code>columns</code> <p>List of column names from a DataFrame</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary with validation results: - valid: bool - missing_required: List of missing required features - unexpected: List of unexpected columns</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def validate_dataframe_columns(self, columns: List[str]) -&gt; Dict[str, Any]:\n    \"\"\"Validate that a DataFrame has the expected columns.\n\n    Args:\n        columns: List of column names from a DataFrame\n\n    Returns:\n        Dictionary with validation results:\n            - valid: bool\n            - missing_required: List of missing required features\n            - unexpected: List of unexpected columns\n    \"\"\"\n    expected = set(self.get_feature_names())\n    actual = set(columns)\n    required = set(self.get_required_features())\n\n    missing_required = list(required - actual)\n    unexpected = list(actual - expected)\n\n    return {\n        \"valid\": len(missing_required) == 0,\n        \"missing_required\": missing_required,\n        \"unexpected\": unexpected,\n        \"missing_optional\": list((expected - required) - actual),\n    }\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.base","title":"<code>base</code>","text":""},{"location":"api/containers/#healthchain.io.containers.base.BaseDocument","title":"<code>BaseDocument</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[str]</code></p> <p>Base document container for raw text content.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass BaseDocument(DataContainer[str]):\n    \"\"\"Base document container for raw text content.\"\"\"\n\n    data: str\n    text: str = field(init=False)\n\n    def __post_init__(self):\n        self.text = self.data\n\n    def char_count(self) -&gt; int:\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.base.DataContainer","title":"<code>DataContainer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A generic container for data.</p> <p>This class represents a container for data with a specific type T.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The data stored in the container.</p> <p> TYPE: <code>T</code> </p> METHOD DESCRIPTION <code>to_dict</code> <p>Converts the container's data to a dictionary.</p> <code>to_json</code> <p>Converts the container's data to a JSON string.</p> <code>from_dict</code> <p>Dict[str, Any]) -&gt; \"DataContainer\": Creates a DataContainer instance from a dictionary.</p> <code>from_json</code> <p>str) -&gt; \"DataContainer\": Creates a DataContainer instance from a JSON string.</p> Source code in <code>healthchain/io/containers/base.py</code> <pre><code>@dataclass\nclass DataContainer(Generic[T]):\n    \"\"\"\n    A generic container for data.\n\n    This class represents a container for data with a specific type T.\n\n    Attributes:\n        data (T): The data stored in the container.\n\n    Methods:\n        to_dict() -&gt; Dict[str, Any]:\n            Converts the container's data to a dictionary.\n\n        to_json() -&gt; str:\n            Converts the container's data to a JSON string.\n\n        from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a dictionary.\n\n        from_json(cls, json_str: str) -&gt; \"DataContainer\":\n            Creates a DataContainer instance from a JSON string.\n    \"\"\"\n\n    data: T\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    def to_json(self) -&gt; str:\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"DataContainer\":\n        return cls(**data)\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"DataContainer\":\n        return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.dataset","title":"<code>dataset</code>","text":""},{"location":"api/containers/#healthchain.io.containers.dataset.Dataset","title":"<code>Dataset</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer[DataFrame]</code></p> <p>A container for tabular data optimized for ML inference, lightweight wrapper around a pandas DataFrame.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>The pandas DataFrame containing the dataset.</p> <p> TYPE: <code>T</code> </p> <code>metadata</code> <p>Dict for storing pipeline results (predictions, probabilities, etc.)</p> <p> TYPE: <code>Dict[str, Any]</code> </p> METHOD DESCRIPTION <code>from_csv</code> <p>Load Dataset from CSV.</p> <code>from_dict</code> <p>Load Dataset from dict.</p> <code>from_fhir_bundle</code> <p>Create Dataset from FHIR Bundle and schema.</p> <code>to_csv</code> <p>Save Dataset to CSV.</p> <code>to_risk_assessment</code> <p>Convert predictions to FHIR RiskAssessment.</p> Source code in <code>healthchain/io/containers/dataset.py</code> <pre><code>@dataclass\nclass Dataset(DataContainer[pd.DataFrame]):\n    \"\"\"\n    A container for tabular data optimized for ML inference, lightweight wrapper around a pandas DataFrame.\n\n    Attributes:\n        data: The pandas DataFrame containing the dataset.\n        metadata: Dict for storing pipeline results (predictions, probabilities, etc.)\n\n    Methods:\n        from_csv: Load Dataset from CSV.\n        from_dict: Load Dataset from dict.\n        from_fhir_bundle: Create Dataset from FHIR Bundle and schema.\n        to_csv: Save Dataset to CSV.\n        to_risk_assessment: Convert predictions to FHIR RiskAssessment.\n    \"\"\"\n\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n    def __post_init__(self):\n        if not isinstance(self.data, pd.DataFrame):\n            raise TypeError(\"data must be a pandas DataFrame\")\n\n    @property\n    def columns(self) -&gt; List[str]:\n        return list(self.data.columns)\n\n    @property\n    def index(self) -&gt; pd.Index:\n        return self.data.index\n\n    @property\n    def dtypes(self) -&gt; Dict[str, str]:\n        return {col: str(dtype) for col, dtype in self.data.dtypes.items()}\n\n    def column_count(self) -&gt; int:\n        return len(self.columns)\n\n    def row_count(self) -&gt; int:\n        return len(self.data)\n\n    def get_dtype(self, column: str) -&gt; str:\n        return str(self.data[column].dtype)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.columns)\n\n    def __len__(self) -&gt; int:\n        return self.row_count()\n\n    def describe(self) -&gt; str:\n        return f\"Dataset with {self.column_count()} columns and {self.row_count()} rows\"\n\n    def remove_column(self, name: str) -&gt; None:\n        self.data.drop(columns=[name], inplace=True)\n\n    @classmethod\n    def from_csv(cls, path: str, **kwargs) -&gt; \"Dataset\":\n        return cls(pd.read_csv(path, **kwargs))\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Dataset\":\n        df = pd.DataFrame(data[\"data\"])\n        return cls(df)\n\n    def to_csv(self, path: str, **kwargs) -&gt; None:\n        self.data.to_csv(path, **kwargs)\n\n    @classmethod\n    def from_fhir_bundle(\n        cls,\n        bundle: Union[Bundle, Dict[str, Any]],\n        schema: Union[str, Path, FeatureSchema],\n        aggregation: str = \"mean\",\n    ) -&gt; \"Dataset\":\n        \"\"\"Create Dataset from a FHIR Bundle using a feature schema.\n\n        Extracts features from FHIR resources according to the schema specification,\n        converting FHIR data to a pandas DataFrame suitable for ML inference.\n\n        Args:\n            bundle: FHIR Bundle resource (object or dict)\n            schema: FeatureSchema object, or path to YAML schema file\n            aggregation: How to aggregate multiple observation values (default: \"mean\")\n                Options: \"mean\", \"median\", \"max\", \"min\", \"last\" (default: \"mean\")\n\n        Returns:\n            Dataset container with extracted features\n\n        Example:\n            &gt;&gt;&gt; from fhir.resources.bundle import Bundle\n            &gt;&gt;&gt; bundle = Bundle(**patient_data)\n            &gt;&gt;&gt; dataset = Dataset.from_fhir_bundle(\n            ...     bundle,\n            ...     schema=\"healthchain/configs/features/sepsis_vitals.yaml\"\n            ... )\n            &gt;&gt;&gt; df = dataset.data\n        \"\"\"\n        # Load schema if path provided\n        if isinstance(schema, (str, Path)):\n            schema = FeatureSchema.from_yaml(schema)\n\n        # Extract features using mapper\n        mapper = FHIRFeatureMapper(schema)\n        df = mapper.extract_features(bundle, aggregation=aggregation)\n\n        return cls(df)\n\n    def validate(\n        self, schema: FeatureSchema, raise_on_error: bool = False\n    ) -&gt; ValidationResult:\n        \"\"\"Validate DataFrame against a feature schema.\n\n        Checks that required features are present and have correct data types.\n\n        Args:\n            schema: FeatureSchema to validate against\n            raise_on_error: Whether to raise exception on validation failure\n\n        Returns:\n            ValidationResult with validation status and details\n\n        Raises:\n            ValueError: If raise_on_error is True and validation fails\n\n        Example:\n            &gt;&gt;&gt; schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")\n            &gt;&gt;&gt; result = dataset.validate(schema)\n            &gt;&gt;&gt; if not result.valid:\n            ...     print(result.errors)\n        \"\"\"\n        result = ValidationResult(valid=True)\n\n        # Check for missing required features\n        required = schema.get_required_features()\n        missing = [f for f in required if f not in self.data.columns]\n\n        for feature in missing:\n            result.add_missing_feature(feature)\n\n        # Check data types for present features\n        for feature_name, mapping in schema.features.items():\n            if feature_name in self.data.columns:\n                actual_dtype = str(self.data[feature_name].dtype)\n                expected_dtype = mapping.dtype\n\n                # Check for type mismatches (allow some flexibility)\n                if not self._dtypes_compatible(actual_dtype, expected_dtype):\n                    result.add_type_mismatch(feature_name, expected_dtype, actual_dtype)\n\n        # Warn about optional missing features\n        optional = set(schema.get_feature_names()) - set(required)\n        missing_optional = [f for f in optional if f not in self.data.columns]\n\n        for feature in missing_optional:\n            result.add_warning(f\"Optional feature '{feature}' is missing\")\n\n        if raise_on_error and not result.valid:\n            raise ValueError(str(result))\n\n        return result\n\n    def _dtypes_compatible(self, actual: str, expected: str) -&gt; bool:\n        \"\"\"Check if actual dtype is compatible with expected dtype.\n\n        Args:\n            actual: Actual dtype string\n            expected: Expected dtype string\n\n        Returns:\n            True if dtypes are compatible\n        \"\"\"\n        # Handle numeric types flexibly\n        numeric_types = {\"int64\", \"int32\", \"float64\", \"float32\"}\n        if expected in numeric_types and actual in numeric_types:\n            return True\n\n        # Exact match for non-numeric types\n        return actual == expected\n\n    def to_risk_assessment(\n        self,\n        outcome_code: str,\n        outcome_display: str,\n        outcome_system: str = \"http://hl7.org/fhir/sid/icd-10\",\n        model_name: Optional[str] = None,\n        model_version: Optional[str] = None,\n        high_threshold: float = 0.7,\n        moderate_threshold: float = 0.4,\n        predictions: Optional[np.ndarray] = None,\n        probabilities: Optional[np.ndarray] = None,\n    ) -&gt; List[RiskAssessment]:\n        \"\"\"Convert model predictions to FHIR RiskAssessment resources.\n\n        Creates RiskAssessment resources from ML model output, suitable for\n        including in FHIR Bundles or sending to FHIR servers.\n\n        Args:\n            outcome_code: Code for the predicted outcome (e.g., \"A41.9\" for sepsis)\n            outcome_display: Display text for the outcome (e.g., \"Sepsis\")\n            outcome_system: Code system for the outcome (default: ICD-10)\n            model_name: Name of the ML model (optional)\n            model_version: Version of the ML model (optional)\n            high_threshold: Threshold for high risk (default: 0.7)\n            moderate_threshold: Threshold for moderate risk (default: 0.4)\n            predictions: Binary predictions array (0/1). Defaults to metadata[\"predictions\"]\n            probabilities: Probability scores array (0-1). Defaults to metadata[\"probabilities\"]\n\n        Returns:\n            List of RiskAssessment resources, one per patient\n\n        Example:\n            &gt;&gt;&gt; risk_assessments = dataset.to_risk_assessment(\n            ...     outcome_code=\"A41.9\",\n            ...     outcome_display=\"Sepsis, unspecified\",\n            ...     model_name=\"RandomForest\",\n            ...     model_version=\"1.0\"\n            ... )\n        \"\"\"\n        # Fall back to metadata if not provided\n        if predictions is None:\n            predictions = self.metadata.get(\"predictions\")\n        if probabilities is None:\n            probabilities = self.metadata.get(\"probabilities\")\n\n        if predictions is None or probabilities is None:\n            raise ValueError(\n                \"predictions and probabilities must be provided or available in metadata\"\n            )\n\n        if len(predictions) != len(self.data):\n            raise ValueError(\n                f\"Predictions length ({len(predictions)}) must match \"\n                f\"DataFrame length ({len(self.data)})\"\n            )\n\n        if len(probabilities) != len(self.data):\n            raise ValueError(\n                f\"Probabilities length ({len(probabilities)}) must match \"\n                f\"DataFrame length ({len(self.data)})\"\n            )\n\n        risk_assessments = []\n\n        # Get patient references\n        if \"patient_ref\" not in self.data.columns:\n            raise ValueError(\"DataFrame must have 'patient_ref' column\")\n\n        for idx, row in self.data.iterrows():\n            patient_ref = row[\"patient_ref\"]\n            prediction = int(predictions[idx])\n            probability = float(probabilities[idx])\n\n            # Determine qualitative risk\n            if probability &gt;= high_threshold:\n                qualitative_risk = \"high\"\n            elif probability &gt;= moderate_threshold:\n                qualitative_risk = \"moderate\"\n            else:\n                qualitative_risk = \"low\"\n\n            # Build prediction dict\n            prediction_dict = {\n                \"outcome\": {\n                    \"code\": outcome_code,\n                    \"display\": outcome_display,\n                    \"system\": outcome_system,\n                },\n                \"probability\": probability,\n                \"qualitative_risk\": qualitative_risk,\n            }\n\n            # Create method CodeableConcept if model info provided\n            method = None\n            if model_name:\n                method = create_single_codeable_concept(\n                    code=model_name,\n                    display=f\"{model_name} v{model_version}\"\n                    if model_version\n                    else model_name,\n                    system=\"https://healthchain.github.io/ml-models\",\n                )\n\n            # Create comment with prediction details\n            comment = (\n                f\"ML prediction: {'Positive' if prediction == 1 else 'Negative'} \"\n                f\"(probability: {probability:.2%}, risk: {qualitative_risk})\"\n            )\n\n            # Create RiskAssessment\n            risk_assessment = create_risk_assessment_from_prediction(\n                subject=patient_ref,\n                prediction=prediction_dict,\n                method=method,\n                comment=comment,\n            )\n\n            risk_assessments.append(risk_assessment)\n\n        return risk_assessments\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.dataset.Dataset.from_fhir_bundle","title":"<code>from_fhir_bundle(bundle, schema, aggregation='mean')</code>  <code>classmethod</code>","text":"<p>Create Dataset from a FHIR Bundle using a feature schema.</p> <p>Extracts features from FHIR resources according to the schema specification, converting FHIR data to a pandas DataFrame suitable for ML inference.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>FHIR Bundle resource (object or dict)</p> <p> TYPE: <code>Union[Bundle, Dict[str, Any]]</code> </p> <code>schema</code> <p>FeatureSchema object, or path to YAML schema file</p> <p> TYPE: <code>Union[str, Path, FeatureSchema]</code> </p> <code>aggregation</code> <p>How to aggregate multiple observation values (default: \"mean\") Options: \"mean\", \"median\", \"max\", \"min\", \"last\" (default: \"mean\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'mean'</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>Dataset container with extracted features</p> Example <p>from fhir.resources.bundle import Bundle bundle = Bundle(**patient_data) dataset = Dataset.from_fhir_bundle( ...     bundle, ...     schema=\"healthchain/configs/features/sepsis_vitals.yaml\" ... ) df = dataset.data</p> Source code in <code>healthchain/io/containers/dataset.py</code> <pre><code>@classmethod\ndef from_fhir_bundle(\n    cls,\n    bundle: Union[Bundle, Dict[str, Any]],\n    schema: Union[str, Path, FeatureSchema],\n    aggregation: str = \"mean\",\n) -&gt; \"Dataset\":\n    \"\"\"Create Dataset from a FHIR Bundle using a feature schema.\n\n    Extracts features from FHIR resources according to the schema specification,\n    converting FHIR data to a pandas DataFrame suitable for ML inference.\n\n    Args:\n        bundle: FHIR Bundle resource (object or dict)\n        schema: FeatureSchema object, or path to YAML schema file\n        aggregation: How to aggregate multiple observation values (default: \"mean\")\n            Options: \"mean\", \"median\", \"max\", \"min\", \"last\" (default: \"mean\")\n\n    Returns:\n        Dataset container with extracted features\n\n    Example:\n        &gt;&gt;&gt; from fhir.resources.bundle import Bundle\n        &gt;&gt;&gt; bundle = Bundle(**patient_data)\n        &gt;&gt;&gt; dataset = Dataset.from_fhir_bundle(\n        ...     bundle,\n        ...     schema=\"healthchain/configs/features/sepsis_vitals.yaml\"\n        ... )\n        &gt;&gt;&gt; df = dataset.data\n    \"\"\"\n    # Load schema if path provided\n    if isinstance(schema, (str, Path)):\n        schema = FeatureSchema.from_yaml(schema)\n\n    # Extract features using mapper\n    mapper = FHIRFeatureMapper(schema)\n    df = mapper.extract_features(bundle, aggregation=aggregation)\n\n    return cls(df)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.dataset.Dataset.to_risk_assessment","title":"<code>to_risk_assessment(outcome_code, outcome_display, outcome_system='http://hl7.org/fhir/sid/icd-10', model_name=None, model_version=None, high_threshold=0.7, moderate_threshold=0.4, predictions=None, probabilities=None)</code>","text":"<p>Convert model predictions to FHIR RiskAssessment resources.</p> <p>Creates RiskAssessment resources from ML model output, suitable for including in FHIR Bundles or sending to FHIR servers.</p> PARAMETER DESCRIPTION <code>outcome_code</code> <p>Code for the predicted outcome (e.g., \"A41.9\" for sepsis)</p> <p> TYPE: <code>str</code> </p> <code>outcome_display</code> <p>Display text for the outcome (e.g., \"Sepsis\")</p> <p> TYPE: <code>str</code> </p> <code>outcome_system</code> <p>Code system for the outcome (default: ICD-10)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://hl7.org/fhir/sid/icd-10'</code> </p> <code>model_name</code> <p>Name of the ML model (optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>model_version</code> <p>Version of the ML model (optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>high_threshold</code> <p>Threshold for high risk (default: 0.7)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.7</code> </p> <code>moderate_threshold</code> <p>Threshold for moderate risk (default: 0.4)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.4</code> </p> <code>predictions</code> <p>Binary predictions array (0/1). Defaults to metadata[\"predictions\"]</p> <p> TYPE: <code>Optional[ndarray]</code> DEFAULT: <code>None</code> </p> <code>probabilities</code> <p>Probability scores array (0-1). Defaults to metadata[\"probabilities\"]</p> <p> TYPE: <code>Optional[ndarray]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[RiskAssessment]</code> <p>List of RiskAssessment resources, one per patient</p> Example <p>risk_assessments = dataset.to_risk_assessment( ...     outcome_code=\"A41.9\", ...     outcome_display=\"Sepsis, unspecified\", ...     model_name=\"RandomForest\", ...     model_version=\"1.0\" ... )</p> Source code in <code>healthchain/io/containers/dataset.py</code> <pre><code>def to_risk_assessment(\n    self,\n    outcome_code: str,\n    outcome_display: str,\n    outcome_system: str = \"http://hl7.org/fhir/sid/icd-10\",\n    model_name: Optional[str] = None,\n    model_version: Optional[str] = None,\n    high_threshold: float = 0.7,\n    moderate_threshold: float = 0.4,\n    predictions: Optional[np.ndarray] = None,\n    probabilities: Optional[np.ndarray] = None,\n) -&gt; List[RiskAssessment]:\n    \"\"\"Convert model predictions to FHIR RiskAssessment resources.\n\n    Creates RiskAssessment resources from ML model output, suitable for\n    including in FHIR Bundles or sending to FHIR servers.\n\n    Args:\n        outcome_code: Code for the predicted outcome (e.g., \"A41.9\" for sepsis)\n        outcome_display: Display text for the outcome (e.g., \"Sepsis\")\n        outcome_system: Code system for the outcome (default: ICD-10)\n        model_name: Name of the ML model (optional)\n        model_version: Version of the ML model (optional)\n        high_threshold: Threshold for high risk (default: 0.7)\n        moderate_threshold: Threshold for moderate risk (default: 0.4)\n        predictions: Binary predictions array (0/1). Defaults to metadata[\"predictions\"]\n        probabilities: Probability scores array (0-1). Defaults to metadata[\"probabilities\"]\n\n    Returns:\n        List of RiskAssessment resources, one per patient\n\n    Example:\n        &gt;&gt;&gt; risk_assessments = dataset.to_risk_assessment(\n        ...     outcome_code=\"A41.9\",\n        ...     outcome_display=\"Sepsis, unspecified\",\n        ...     model_name=\"RandomForest\",\n        ...     model_version=\"1.0\"\n        ... )\n    \"\"\"\n    # Fall back to metadata if not provided\n    if predictions is None:\n        predictions = self.metadata.get(\"predictions\")\n    if probabilities is None:\n        probabilities = self.metadata.get(\"probabilities\")\n\n    if predictions is None or probabilities is None:\n        raise ValueError(\n            \"predictions and probabilities must be provided or available in metadata\"\n        )\n\n    if len(predictions) != len(self.data):\n        raise ValueError(\n            f\"Predictions length ({len(predictions)}) must match \"\n            f\"DataFrame length ({len(self.data)})\"\n        )\n\n    if len(probabilities) != len(self.data):\n        raise ValueError(\n            f\"Probabilities length ({len(probabilities)}) must match \"\n            f\"DataFrame length ({len(self.data)})\"\n        )\n\n    risk_assessments = []\n\n    # Get patient references\n    if \"patient_ref\" not in self.data.columns:\n        raise ValueError(\"DataFrame must have 'patient_ref' column\")\n\n    for idx, row in self.data.iterrows():\n        patient_ref = row[\"patient_ref\"]\n        prediction = int(predictions[idx])\n        probability = float(probabilities[idx])\n\n        # Determine qualitative risk\n        if probability &gt;= high_threshold:\n            qualitative_risk = \"high\"\n        elif probability &gt;= moderate_threshold:\n            qualitative_risk = \"moderate\"\n        else:\n            qualitative_risk = \"low\"\n\n        # Build prediction dict\n        prediction_dict = {\n            \"outcome\": {\n                \"code\": outcome_code,\n                \"display\": outcome_display,\n                \"system\": outcome_system,\n            },\n            \"probability\": probability,\n            \"qualitative_risk\": qualitative_risk,\n        }\n\n        # Create method CodeableConcept if model info provided\n        method = None\n        if model_name:\n            method = create_single_codeable_concept(\n                code=model_name,\n                display=f\"{model_name} v{model_version}\"\n                if model_version\n                else model_name,\n                system=\"https://healthchain.github.io/ml-models\",\n            )\n\n        # Create comment with prediction details\n        comment = (\n            f\"ML prediction: {'Positive' if prediction == 1 else 'Negative'} \"\n            f\"(probability: {probability:.2%}, risk: {qualitative_risk})\"\n        )\n\n        # Create RiskAssessment\n        risk_assessment = create_risk_assessment_from_prediction(\n            subject=patient_ref,\n            prediction=prediction_dict,\n            method=method,\n            comment=comment,\n        )\n\n        risk_assessments.append(risk_assessment)\n\n    return risk_assessments\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.dataset.Dataset.validate","title":"<code>validate(schema, raise_on_error=False)</code>","text":"<p>Validate DataFrame against a feature schema.</p> <p>Checks that required features are present and have correct data types.</p> PARAMETER DESCRIPTION <code>schema</code> <p>FeatureSchema to validate against</p> <p> TYPE: <code>FeatureSchema</code> </p> <code>raise_on_error</code> <p>Whether to raise exception on validation failure</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult with validation status and details</p> RAISES DESCRIPTION <code>ValueError</code> <p>If raise_on_error is True and validation fails</p> Example <p>schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\") result = dataset.validate(schema) if not result.valid: ...     print(result.errors)</p> Source code in <code>healthchain/io/containers/dataset.py</code> <pre><code>def validate(\n    self, schema: FeatureSchema, raise_on_error: bool = False\n) -&gt; ValidationResult:\n    \"\"\"Validate DataFrame against a feature schema.\n\n    Checks that required features are present and have correct data types.\n\n    Args:\n        schema: FeatureSchema to validate against\n        raise_on_error: Whether to raise exception on validation failure\n\n    Returns:\n        ValidationResult with validation status and details\n\n    Raises:\n        ValueError: If raise_on_error is True and validation fails\n\n    Example:\n        &gt;&gt;&gt; schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")\n        &gt;&gt;&gt; result = dataset.validate(schema)\n        &gt;&gt;&gt; if not result.valid:\n        ...     print(result.errors)\n    \"\"\"\n    result = ValidationResult(valid=True)\n\n    # Check for missing required features\n    required = schema.get_required_features()\n    missing = [f for f in required if f not in self.data.columns]\n\n    for feature in missing:\n        result.add_missing_feature(feature)\n\n    # Check data types for present features\n    for feature_name, mapping in schema.features.items():\n        if feature_name in self.data.columns:\n            actual_dtype = str(self.data[feature_name].dtype)\n            expected_dtype = mapping.dtype\n\n            # Check for type mismatches (allow some flexibility)\n            if not self._dtypes_compatible(actual_dtype, expected_dtype):\n                result.add_type_mismatch(feature_name, expected_dtype, actual_dtype)\n\n    # Warn about optional missing features\n    optional = set(schema.get_feature_names()) - set(required)\n    missing_optional = [f for f in optional if f not in self.data.columns]\n\n    for feature in missing_optional:\n        result.add_warning(f\"Optional feature '{feature}' is missing\")\n\n    if raise_on_error and not result.valid:\n        raise ValueError(str(result))\n\n    return result\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document","title":"<code>document</code>","text":""},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations","title":"<code>CdsAnnotations</code>  <code>dataclass</code>","text":"<p>Container for Clinical Decision Support (CDS) results.</p> <p>This class stores and manages outputs from clinical decision support systems, including CDS Hooks cards and suggested clinical actions. The cards contain recommendations, warnings, and other decision support content that can be displayed to clinicians. Actions represent specific clinical tasks or interventions that are suggested based on the analysis.</p> ATTRIBUTE DESCRIPTION <code>_cards</code> <p>CDS Hooks cards containing clinical recommendations, warnings, or other decision support content.</p> <p> TYPE: <code>Optional[List[Card]]</code> </p> <code>_actions</code> <p>Suggested clinical actions that could be taken based on the CDS analysis.</p> <p> TYPE: <code>Optional[List[Action]]</code> </p> Example <p>cds = CdsAnnotations() cds.cards = [Card(summary=\"Consider aspirin\")] cds.actions = [Action(type=\"create\", description=\"Order aspirin\")]</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass CdsAnnotations:\n    \"\"\"\n    Container for Clinical Decision Support (CDS) results.\n\n    This class stores and manages outputs from clinical decision support systems,\n    including CDS Hooks cards and suggested clinical actions. The cards contain\n    recommendations, warnings, and other decision support content that can be\n    displayed to clinicians. Actions represent specific clinical tasks or\n    interventions that are suggested based on the analysis.\n\n    Attributes:\n        _cards (Optional[List[Card]]): CDS Hooks cards containing clinical\n            recommendations, warnings, or other decision support content.\n        _actions (Optional[List[Action]]): Suggested clinical actions that\n            could be taken based on the CDS analysis.\n\n    Example:\n        &gt;&gt;&gt; cds = CdsAnnotations()\n        &gt;&gt;&gt; cds.cards = [Card(summary=\"Consider aspirin\")]\n        &gt;&gt;&gt; cds.actions = [Action(type=\"create\", description=\"Order aspirin\")]\n    \"\"\"\n\n    _cards: Optional[List[Card]] = None\n    _actions: Optional[List[Action]] = None\n\n    @property\n    def cards(self) -&gt; Optional[List[Card]]:\n        \"\"\"Get the current list of CDS Hooks cards.\"\"\"\n        return self._cards\n\n    @cards.setter\n    def cards(self, cards: Union[List[Card], List[Dict[str, Any]]]) -&gt; None:\n        \"\"\"\n        Set CDS Hooks cards, converting from dictionaries if needed.\n\n        Args:\n            cards: List of Card objects or dictionaries that can be converted to Cards.\n\n        Raises:\n            ValueError: If cards list is empty or has invalid format.\n            TypeError: If cards are neither Card objects nor dictionaries.\n        \"\"\"\n        if not cards:\n            raise ValueError(\"Cards must be provided as a list!\")\n\n        try:\n            if isinstance(cards[0], dict):\n                self._cards = [Card(**card) for card in cards]\n            elif isinstance(cards[0], Card):\n                self._cards = cards\n            else:\n                raise TypeError(\"Cards must be either Card objects or dictionaries\")\n        except (IndexError, KeyError) as e:\n            raise ValueError(\"Invalid card format\") from e\n\n    @property\n    def actions(self) -&gt; Optional[List[Action]]:\n        \"\"\"Get the current list of suggested clinical actions.\"\"\"\n        return self._actions\n\n    @actions.setter\n    def actions(self, actions: Union[List[Action], List[Dict[str, Any]]]) -&gt; None:\n        \"\"\"\n        Set suggested clinical actions, converting from dictionaries if needed.\n\n        Args:\n            actions: List of Action objects or dictionaries that can be converted to Actions.\n\n        Raises:\n            ValueError: If actions list is empty or has invalid format.\n            TypeError: If actions are neither Action objects nor dictionaries.\n        \"\"\"\n        if not actions:\n            raise ValueError(\"Actions must be provided as a list!\")\n\n        try:\n            if isinstance(actions[0], dict):\n                self._actions = [Action(**action) for action in actions]\n            elif isinstance(actions[0], Action):\n                self._actions = actions\n            else:\n                raise TypeError(\"Actions must be either Action objects or dictionaries\")\n        except (IndexError, KeyError) as e:\n            raise ValueError(\"Invalid action format\") from e\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations.actions","title":"<code>actions</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current list of suggested clinical actions.</p>"},{"location":"api/containers/#healthchain.io.containers.document.CdsAnnotations.cards","title":"<code>cards</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current list of CDS Hooks cards.</p>"},{"location":"api/containers/#healthchain.io.containers.document.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseDocument</code></p> <p>Main document container for processing textual and clinical data in HealthChain.</p> <p>The Document class is the primary structure used throughout annotation and analytics pipelines, accumulating transformations, extractions, and results from each stage. It seamlessly integrates raw text, NLP annotations, FHIR resources, clinical decision support (CDS) results, and ML model outputs in one object.</p> Features <ul> <li>Accepts text, FHIR Bundles/resources, or lists of FHIR resources as input.</li> <li>Provides basic tokenization and supports integration with NLP models (spaCy, transformers).</li> <li>Stores and manipulates clinical FHIR data via the .fhir property (access to bundles, problem lists, meds, allergies, etc.).</li> <li>Encapsulates CDS Hooks-style decision support cards and suggested actions via the .cds property.</li> <li>Stores outputs from external ML/LLM models: HuggingFace, LangChain, etc.</li> </ul> ATTRIBUTE DESCRIPTION <code>nlp</code> <p>NLP output (tokens, entities, embeddings, spaCy doc)</p> <p> TYPE: <code>NlpAnnotations</code> </p> <code>fhir</code> <p>FHIR resources and context (problem list, medication, allergy, etc.)</p> <p> TYPE: <code>FhirData</code> </p> <code>cds</code> <p>Clinical decision support (cards and actions)</p> <p> TYPE: <code>CdsAnnotations</code> </p> <code>models</code> <p>Results from ML/LLM models (HuggingFace, LangChain, etc.)</p> <p> TYPE: <code>ModelOutputs</code> </p> <code>text</code> <p>The text content of the document (if available).</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>The original input supplied (raw text, Bundle, resource, or list of resources)</p> <p> TYPE: <code>str</code> </p> Usage example <p>doc = Document(data=\"Patient has hypertension\") doc.nlp._tokens ['Patient', 'has', 'hypertension'] doc.fhir.problem_list = [Condition(...)] doc.cds.cards = [Card(...)] doc.models.huggingface_results = ... for token in doc: ...     print(token)</p> Inherits from <p>BaseDocument</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass Document(BaseDocument):\n    \"\"\"\n    Main document container for processing textual and clinical data in HealthChain.\n\n    The Document class is the primary structure used throughout annotation and analytics\n    pipelines, accumulating transformations, extractions, and results from each stage. It\n    seamlessly integrates raw text, NLP annotations, FHIR resources, clinical decision\n    support (CDS) results, and ML model outputs in one object.\n\n    Features:\n        - Accepts text, FHIR Bundles/resources, or lists of FHIR resources as input.\n        - Provides basic tokenization and supports integration with NLP models (spaCy, transformers).\n        - Stores and manipulates clinical FHIR data via the .fhir property (access to bundles, problem lists, meds, allergies, etc.).\n        - Encapsulates CDS Hooks-style decision support cards and suggested actions via the .cds property.\n        - Stores outputs from external ML/LLM models: HuggingFace, LangChain, etc.\n\n    Attributes:\n        nlp (NlpAnnotations): NLP output (tokens, entities, embeddings, spaCy doc)\n        fhir (FhirData): FHIR resources and context (problem list, medication, allergy, etc.)\n        cds (CdsAnnotations): Clinical decision support (cards and actions)\n        models (ModelOutputs): Results from ML/LLM models (HuggingFace, LangChain, etc.)\n        text (str): The text content of the document (if available).\n        data: The original input supplied (raw text, Bundle, resource, or list of resources)\n\n    Usage example:\n        &gt;&gt;&gt; doc = Document(data=\"Patient has hypertension\")\n        &gt;&gt;&gt; doc.nlp._tokens\n        ['Patient', 'has', 'hypertension']\n        &gt;&gt;&gt; doc.fhir.problem_list = [Condition(...)]\n        &gt;&gt;&gt; doc.cds.cards = [Card(...)]\n        &gt;&gt;&gt; doc.models.huggingface_results = ...\n        &gt;&gt;&gt; for token in doc:\n        ...     print(token)\n\n    Inherits from:\n        BaseDocument\n    \"\"\"\n\n    _nlp: NlpAnnotations = field(default_factory=NlpAnnotations)\n    _fhir: FhirData = field(default_factory=FhirData)\n    _cds: CdsAnnotations = field(default_factory=CdsAnnotations)\n    _models: ModelOutputs = field(default_factory=ModelOutputs)\n\n    @property\n    def nlp(self) -&gt; NlpAnnotations:\n        return self._nlp\n\n    @property\n    def fhir(self) -&gt; FhirData:\n        return self._fhir\n\n    @property\n    def cds(self) -&gt; CdsAnnotations:\n        return self._cds\n\n    @property\n    def models(self) -&gt; ModelOutputs:\n        return self._models\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization setup to process textual or FHIR data.\n\n        - If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.\n        - If input data is a list of FHIR resources, wraps them in a Bundle.\n        - For text input, sets .text field accordingly.\n        - Performs basic whitespace tokenization if necessary.\n        \"\"\"\n        super().__post_init__()\n\n        # Handle FHIR Bundle data\n        if isinstance(self.data, Bundle):\n            self._fhir._bundle = self.data\n\n            # Extract OperationOutcome resources (operation results/errors)\n            outcomes = extract_resources(self._fhir._bundle, \"OperationOutcome\")\n            if outcomes:\n                self._fhir._operation_outcomes = outcomes\n\n            # Extract Provenance resources (data lineage/origin)\n            provenances = extract_resources(self._fhir._bundle, \"Provenance\")\n            if provenances:\n                self._fhir._provenances = provenances\n\n            self.text = \"\"  # No text content for bundle-only documents\n        # Handle list of FHIR resources\n        elif (\n            isinstance(self.data, list)\n            and self.data\n            and isinstance(self.data[0], Resource)\n        ):\n            self._fhir._bundle = create_bundle()\n            for resource in self.data:\n                add_resource(self._fhir._bundle, resource)\n            self.text = \"\"  # No text content for resource-only documents\n        else:\n            # Handle text data\n            self.text = self.data if isinstance(self.data, str) else str(self.data)\n\n        if not self._nlp._tokens and self.text:\n            self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n\n    def word_count(self) -&gt; int:\n        \"\"\"\n        Return the number of word tokens in the document.\n\n        Returns:\n            int: The count of tokenized words in the document.\n        \"\"\"\n        return len(self._nlp._tokens)\n\n    def update_problem_list_from_nlp(\n        self,\n        patient_ref: str = \"Patient/123\",\n        coding_system: str = \"http://snomed.info/sct\",\n        code_attribute: str = \"cui\",\n    ):\n        \"\"\"\n        Populate or update the problem list using entities extracted via NLP.\n\n        This method looks for entities with associated medical codes and creates FHIR Condition\n        resources from them. It supports a two-step process:\n        1. NER: Extract entities from text (spaCy, HuggingFace, etc.)\n        2. Entity Linking: Add medical codes to those entities\n        3. Problem List Creation: Convert linked entities to FHIR conditions (this method)\n\n        The method extracts from:\n        1. spaCy entities with extension attributes (e.g., ent._.cui)\n        2. Generic entities in the NLP annotations container (framework-agnostic)\n\n        TODO: make this more generic and support other resource types\n\n        Args:\n            patient_ref: FHIR reference to the patient (default: \"Patient/123\")\n            coding_system: Coding system URI for the conditions (default: SNOMED CT)\n            code_attribute: Name of the attribute containing the medical code (default: \"cui\")\n\n        Notes:\n            - Preserves any existing problem list Conditions.\n            - Supports framework-agnostic extraction (spaCy and dict entities).\n            - For spaCy, looks for entity extension attribute (e.g. ent._.cui).\n            - For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).\n        \"\"\"\n        # Start with existing conditions to preserve them\n        existing_conditions = self.fhir.problem_list.copy()\n        new_conditions = []\n\n        # 1. Extract from spaCy entities (if available)\n        if self.nlp._spacy_doc and self.nlp._spacy_doc.ents:\n            for ent in self.nlp._spacy_doc.ents:\n                if not Span.has_extension(code_attribute):\n                    logger.debug(\n                        f\"Extension '{code_attribute}' not found for spaCy entity {ent.text}\"\n                    )\n                    continue\n\n                code_value = getattr(ent._, code_attribute, None)\n                if code_value is None:\n                    logger.debug(\n                        f\"No {code_attribute} found for spaCy entity {ent.text}\"\n                    )\n                    continue\n\n                condition = create_condition(\n                    subject=patient_ref,\n                    code=code_value,\n                    display=ent.text,\n                    system=coding_system,\n                )\n                set_condition_category(condition, \"problem-list-item\")\n                logger.debug(\n                    f\"Adding condition from spaCy: {condition.model_dump(exclude_none=True)}\"\n                )\n                new_conditions.append(condition)\n\n        # 2. Extract from generic NLP entities (framework-agnostic)\n        generic_entities = self.nlp.get_entities()\n        if generic_entities:\n            for ent_dict in generic_entities:\n                # Skip if no linked code\n                code_value = ent_dict.get(code_attribute)\n                if code_value is None:\n                    logger.debug(\n                        f\"No {code_attribute} found for entity {ent_dict.get('text', 'unknown')}\"\n                    )\n                    continue\n\n                entity_text = ent_dict.get(\"text\", \"unknown\")\n\n                condition = create_condition(\n                    subject=patient_ref,\n                    code=code_value,\n                    display=entity_text,\n                    system=coding_system,\n                )\n                set_condition_category(condition, \"problem-list-item\")\n                logger.debug(\n                    f\"Adding condition from entities: {condition.model_dump(exclude_none=True)}\"\n                )\n                new_conditions.append(condition)\n\n        # Update problem list with combined conditions (replace to avoid duplication)\n        if new_conditions:\n            all_conditions = existing_conditions + new_conditions\n            self.fhir.add_resources(all_conditions, \"Condition\", replace=True)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        \"\"\"\n        Iterate through the document's tokens.\n\n        Returns:\n            Iterator[str]: Iterator over the document tokens.\n        \"\"\"\n        return iter(self._nlp._tokens)\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Return the length of the document's text.\n\n        Returns:\n            int: Character length of the document text.\n        \"\"\"\n        return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate through the document's tokens.</p> RETURNS DESCRIPTION <code>Iterator[str]</code> <p>Iterator[str]: Iterator over the document tokens.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n    \"\"\"\n    Iterate through the document's tokens.\n\n    Returns:\n        Iterator[str]: Iterator over the document tokens.\n    \"\"\"\n    return iter(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the document's text.</p> RETURNS DESCRIPTION <code>int</code> <p>Character length of the document text.</p> <p> TYPE: <code>int</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Return the length of the document's text.\n\n    Returns:\n        int: Character length of the document text.\n    \"\"\"\n    return len(self.text)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization setup to process textual or FHIR data.</p> <ul> <li>If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.</li> <li>If input data is a list of FHIR resources, wraps them in a Bundle.</li> <li>For text input, sets .text field accordingly.</li> <li>Performs basic whitespace tokenization if necessary.</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization setup to process textual or FHIR data.\n\n    - If input data is a FHIR Bundle, stores it and extracts OperationOutcome and Provenance resources.\n    - If input data is a list of FHIR resources, wraps them in a Bundle.\n    - For text input, sets .text field accordingly.\n    - Performs basic whitespace tokenization if necessary.\n    \"\"\"\n    super().__post_init__()\n\n    # Handle FHIR Bundle data\n    if isinstance(self.data, Bundle):\n        self._fhir._bundle = self.data\n\n        # Extract OperationOutcome resources (operation results/errors)\n        outcomes = extract_resources(self._fhir._bundle, \"OperationOutcome\")\n        if outcomes:\n            self._fhir._operation_outcomes = outcomes\n\n        # Extract Provenance resources (data lineage/origin)\n        provenances = extract_resources(self._fhir._bundle, \"Provenance\")\n        if provenances:\n            self._fhir._provenances = provenances\n\n        self.text = \"\"  # No text content for bundle-only documents\n    # Handle list of FHIR resources\n    elif (\n        isinstance(self.data, list)\n        and self.data\n        and isinstance(self.data[0], Resource)\n    ):\n        self._fhir._bundle = create_bundle()\n        for resource in self.data:\n            add_resource(self._fhir._bundle, resource)\n        self.text = \"\"  # No text content for resource-only documents\n    else:\n        # Handle text data\n        self.text = self.data if isinstance(self.data, str) else str(self.data)\n\n    if not self._nlp._tokens and self.text:\n        self._nlp._tokens = self.text.split()  # Basic tokenization if not provided\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.update_problem_list_from_nlp","title":"<code>update_problem_list_from_nlp(patient_ref='Patient/123', coding_system='http://snomed.info/sct', code_attribute='cui')</code>","text":"<p>Populate or update the problem list using entities extracted via NLP.</p> <p>This method looks for entities with associated medical codes and creates FHIR Condition resources from them. It supports a two-step process: 1. NER: Extract entities from text (spaCy, HuggingFace, etc.) 2. Entity Linking: Add medical codes to those entities 3. Problem List Creation: Convert linked entities to FHIR conditions (this method)</p> <p>The method extracts from: 1. spaCy entities with extension attributes (e.g., ent._.cui) 2. Generic entities in the NLP annotations container (framework-agnostic)</p> <p>TODO: make this more generic and support other resource types</p> PARAMETER DESCRIPTION <code>patient_ref</code> <p>FHIR reference to the patient (default: \"Patient/123\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Patient/123'</code> </p> <code>coding_system</code> <p>Coding system URI for the conditions (default: SNOMED CT)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>code_attribute</code> <p>Name of the attribute containing the medical code (default: \"cui\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cui'</code> </p> Notes <ul> <li>Preserves any existing problem list Conditions.</li> <li>Supports framework-agnostic extraction (spaCy and dict entities).</li> <li>For spaCy, looks for entity extension attribute (e.g. ent._.cui).</li> <li>For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).</li> </ul> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def update_problem_list_from_nlp(\n    self,\n    patient_ref: str = \"Patient/123\",\n    coding_system: str = \"http://snomed.info/sct\",\n    code_attribute: str = \"cui\",\n):\n    \"\"\"\n    Populate or update the problem list using entities extracted via NLP.\n\n    This method looks for entities with associated medical codes and creates FHIR Condition\n    resources from them. It supports a two-step process:\n    1. NER: Extract entities from text (spaCy, HuggingFace, etc.)\n    2. Entity Linking: Add medical codes to those entities\n    3. Problem List Creation: Convert linked entities to FHIR conditions (this method)\n\n    The method extracts from:\n    1. spaCy entities with extension attributes (e.g., ent._.cui)\n    2. Generic entities in the NLP annotations container (framework-agnostic)\n\n    TODO: make this more generic and support other resource types\n\n    Args:\n        patient_ref: FHIR reference to the patient (default: \"Patient/123\")\n        coding_system: Coding system URI for the conditions (default: SNOMED CT)\n        code_attribute: Name of the attribute containing the medical code (default: \"cui\")\n\n    Notes:\n        - Preserves any existing problem list Conditions.\n        - Supports framework-agnostic extraction (spaCy and dict entities).\n        - For spaCy, looks for entity extension attribute (e.g. ent._.cui).\n        - For non-spaCy, expects codes as dict keys (ent[\"cui\"], etc.).\n    \"\"\"\n    # Start with existing conditions to preserve them\n    existing_conditions = self.fhir.problem_list.copy()\n    new_conditions = []\n\n    # 1. Extract from spaCy entities (if available)\n    if self.nlp._spacy_doc and self.nlp._spacy_doc.ents:\n        for ent in self.nlp._spacy_doc.ents:\n            if not Span.has_extension(code_attribute):\n                logger.debug(\n                    f\"Extension '{code_attribute}' not found for spaCy entity {ent.text}\"\n                )\n                continue\n\n            code_value = getattr(ent._, code_attribute, None)\n            if code_value is None:\n                logger.debug(\n                    f\"No {code_attribute} found for spaCy entity {ent.text}\"\n                )\n                continue\n\n            condition = create_condition(\n                subject=patient_ref,\n                code=code_value,\n                display=ent.text,\n                system=coding_system,\n            )\n            set_condition_category(condition, \"problem-list-item\")\n            logger.debug(\n                f\"Adding condition from spaCy: {condition.model_dump(exclude_none=True)}\"\n            )\n            new_conditions.append(condition)\n\n    # 2. Extract from generic NLP entities (framework-agnostic)\n    generic_entities = self.nlp.get_entities()\n    if generic_entities:\n        for ent_dict in generic_entities:\n            # Skip if no linked code\n            code_value = ent_dict.get(code_attribute)\n            if code_value is None:\n                logger.debug(\n                    f\"No {code_attribute} found for entity {ent_dict.get('text', 'unknown')}\"\n                )\n                continue\n\n            entity_text = ent_dict.get(\"text\", \"unknown\")\n\n            condition = create_condition(\n                subject=patient_ref,\n                code=code_value,\n                display=entity_text,\n                system=coding_system,\n            )\n            set_condition_category(condition, \"problem-list-item\")\n            logger.debug(\n                f\"Adding condition from entities: {condition.model_dump(exclude_none=True)}\"\n            )\n            new_conditions.append(condition)\n\n    # Update problem list with combined conditions (replace to avoid duplication)\n    if new_conditions:\n        all_conditions = existing_conditions + new_conditions\n        self.fhir.add_resources(all_conditions, \"Condition\", replace=True)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.Document.word_count","title":"<code>word_count()</code>","text":"<p>Return the number of word tokens in the document.</p> RETURNS DESCRIPTION <code>int</code> <p>The count of tokenized words in the document.</p> <p> TYPE: <code>int</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def word_count(self) -&gt; int:\n    \"\"\"\n    Return the number of word tokens in the document.\n\n    Returns:\n        int: The count of tokenized words in the document.\n    \"\"\"\n    return len(self._nlp._tokens)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData","title":"<code>FhirData</code>  <code>dataclass</code>","text":"<p>Container for FHIR resource data and its context.</p> <p>Stores and manages clinical data in FHIR format. Access document references within resources easily through convenience functions.</p> <p>Also allows you to set common continuity of care lists, such as a problem list, medication list, and allergy list. These collections are accessible as properties of the class instance.</p> <p>TODO: make problem, meds, allergy lists configurable</p> Properties <p>bundle: The FHIR bundle containing resources prefetch_resources: Dictionary of CDS Hooks prefetch resources problem_list: List of Condition resources medication_list: List of MedicationStatement resources allergy_list: List of AllergyIntolerance resources</p> Example <p>fhir = FhirData()</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass FhirData:\n    \"\"\"\n    Container for FHIR resource data and its context.\n\n    Stores and manages clinical data in FHIR format.\n    Access document references within resources easily through convenience functions.\n\n    Also allows you to set common continuity of care lists,\n    such as a problem list, medication list, and allergy list.\n    These collections are accessible as properties of the class instance.\n\n    TODO: make problem, meds, allergy lists configurable\n\n    Properties:\n        bundle: The FHIR bundle containing resources\n        prefetch_resources: Dictionary of CDS Hooks prefetch resources\n        problem_list: List of Condition resources\n        medication_list: List of MedicationStatement resources\n        allergy_list: List of AllergyIntolerance resources\n\n    Example:\n        &gt;&gt;&gt; fhir = FhirData()\n        &gt;&gt;&gt; # Add prefetch resources from CDS request\n        &gt;&gt;&gt; fhir.prefetch_resources = {\"patient\": patient_resource}\n        &gt;&gt;&gt; # Add document to bundle\n        &gt;&gt;&gt; doc_id = fhir.add_document_reference(document)\n        &gt;&gt;&gt; # Get document with relationships\n        &gt;&gt;&gt; doc_family = fhir.get_document_reference_family(doc_id)\n        &gt;&gt;&gt; # Access clinical lists\n        &gt;&gt;&gt; conditions = fhir.problem_list\n    \"\"\"\n\n    _prefetch_resources: Optional[Dict[str, Resource]] = None\n    _bundle: Optional[Bundle] = None\n    _operation_outcomes: List[OperationOutcome] = field(default_factory=list)\n    _provenances: List[Provenance] = field(default_factory=list)\n\n    @property\n    def bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"Returns the FHIR Bundle if it exists.\"\"\"\n        return self._bundle\n\n    @bundle.setter\n    def bundle(self, bundle: Bundle):\n        \"\"\"Sets the FHIR Bundle.\n        The bundle is a collection of FHIR resources.\n        See: https://www.hl7.org/fhir/bundle.html\n        \"\"\"\n        self._bundle = bundle\n\n    @property\n    def prefetch_resources(self) -&gt; Optional[Dict[str, Resource]]:\n        \"\"\"Returns the prefetch FHIR resources.\"\"\"\n        return self._prefetch_resources\n\n    @prefetch_resources.setter\n    def prefetch_resources(self, resources: Dict[str, Resource]):\n        \"\"\"Sets the prefetch FHIR resources from CDS service requests.\"\"\"\n        self._prefetch_resources = resources\n\n    @property\n    def operation_outcomes(self) -&gt; List[OperationOutcome]:\n        \"\"\"Get extracted OperationOutcome resources separated from the bundle.\"\"\"\n        return self._operation_outcomes\n\n    @operation_outcomes.setter\n    def operation_outcomes(self, outcomes: List[OperationOutcome]) -&gt; None:\n        self._operation_outcomes = outcomes or []\n\n    @property\n    def provenances(self) -&gt; List[Provenance]:\n        \"\"\"Get extracted Provenance resources separated from the bundle.\"\"\"\n        return self._provenances\n\n    @provenances.setter\n    def provenances(self, provenances: List[Provenance]) -&gt; None:\n        self._provenances = provenances or []\n\n    @property\n    def patient(self) -&gt; Optional[Patient]:\n        \"\"\"Get the first Patient resource from the bundle (convenience accessor).\n\n        Returns None if no Patient resources are present in the bundle.\n        For bundles with multiple patients, use the patients property instead.\n        \"\"\"\n        patients = self.get_resources(\"Patient\")\n        return patients[0] if patients else None\n\n    @property\n    def patients(self) -&gt; List[Patient]:\n        \"\"\"Get all Patient resources from the bundle.\n\n        Most bundles contain a single patient, but some queries (e.g., family history,\n        population queries) may return multiple patients. This property provides access\n        to all Patient resources without removing them from the bundle.\n        \"\"\"\n        return self.get_resources(\"Patient\")\n\n    @property\n    def problem_list(self) -&gt; List[Condition]:\n        \"\"\"Get problem list from the bundle.\n        Problem list items are stored as Condition resources in the bundle.\n        See: https://www.hl7.org/fhir/condition.html\n        \"\"\"\n        return self.get_resources(\"Condition\")\n\n    @problem_list.setter\n    def problem_list(self, value: Union[List[Condition], Dict[str, Any]]) -&gt; None:\n        \"\"\"\n        Set problem list in the bundle.\n\n        By default, this adds the provided conditions to any existing conditions in the bundle.\n        To replace existing conditions instead, pass a dictionary with 'resources' and 'replace' keys.\n\n        Args:\n            value: Either a list of Condition resources (adds by default) or a dict with:\n                - 'resources': List of Condition resources\n                - 'replace': bool, whether to replace existing resources (default: False)\n\n        Examples:\n            &gt;&gt;&gt; # Add to existing conditions (default behavior)\n            &gt;&gt;&gt; fhir.problem_list = [condition1, condition2]\n            &gt;&gt;&gt; # Replace existing conditions\n            &gt;&gt;&gt; fhir.problem_list = {'resources': [condition1], 'replace': True}\n        \"\"\"\n        if isinstance(value, dict):\n            resources = value.get(\"resources\", [])\n            replace = value.get(\"replace\", False)\n        else:\n            resources = value\n            replace = False\n\n        self.add_resources(resources, \"Condition\", replace=replace)\n\n    @property\n    def medication_list(self) -&gt; List[MedicationStatement]:\n        \"\"\"Get medication list from the bundle.\"\"\"\n        return self.get_resources(\"MedicationStatement\")\n\n    @medication_list.setter\n    def medication_list(\n        self, value: Union[List[MedicationStatement], Dict[str, Any]]\n    ) -&gt; None:\n        \"\"\"\n        Set medication list in the bundle.\n\n        By default, this adds the provided medications to any existing medications in the bundle.\n        To replace existing medications instead, pass a dictionary with 'resources' and 'replace' keys.\n\n        Args:\n            value: Either a list of MedicationStatement resources (adds by default) or a dict with:\n                - 'resources': List of MedicationStatement resources\n                - 'replace': bool, whether to replace existing resources (default: False)\n\n        Examples:\n            &gt;&gt;&gt; # Add to existing medications (default behavior)\n            &gt;&gt;&gt; fhir.medication_list = [medication1, medication2]\n            &gt;&gt;&gt; # Replace existing medications\n            &gt;&gt;&gt; fhir.medication_list = {'resources': [medication1], 'replace': True}\n        \"\"\"\n        if isinstance(value, dict):\n            resources = value.get(\"resources\", [])\n            replace = value.get(\"replace\", False)\n        else:\n            resources = value\n            replace = False\n\n        self.add_resources(resources, \"MedicationStatement\", replace=replace)\n\n    @property\n    def allergy_list(self) -&gt; List[AllergyIntolerance]:\n        \"\"\"Get allergy list from the bundle.\"\"\"\n        return self.get_resources(\"AllergyIntolerance\")\n\n    @allergy_list.setter\n    def allergy_list(\n        self, value: Union[List[AllergyIntolerance], Dict[str, Any]]\n    ) -&gt; None:\n        \"\"\"\n        Set allergy list in the bundle.\n\n        By default, this adds the provided allergies to any existing allergies in the bundle.\n        To replace existing allergies instead, pass a dictionary with 'resources' and 'replace' keys.\n\n        Args:\n            value: Either a list of AllergyIntolerance resources (adds by default) or a dict with:\n                - 'resources': List of AllergyIntolerance resources\n                - 'replace': bool, whether to replace existing resources (default: False)\n\n        Examples:\n            &gt;&gt;&gt; # Add to existing allergies (default behavior)\n            &gt;&gt;&gt; fhir.allergy_list = [allergy1, allergy2]\n            &gt;&gt;&gt; # Replace existing allergies\n            &gt;&gt;&gt; fhir.allergy_list = {'resources': [allergy1], 'replace': True}\n        \"\"\"\n        if isinstance(value, dict):\n            resources = value.get(\"resources\", [])\n            replace = value.get(\"replace\", False)\n        else:\n            resources = value\n            replace = False\n\n        self.add_resources(resources, \"AllergyIntolerance\", replace=replace)\n\n    def get_prefetch_resources(self, key: str) -&gt; List[Any]:\n        \"\"\"Get resources of a specific type from the prefetch bundle.\"\"\"\n        if not self._prefetch_resources:\n            return []\n        return self._prefetch_resources.get(key, [])\n\n    def get_resources(self, resource_type: str) -&gt; List[Any]:\n        \"\"\"Get resources of a specific type from the working bundle.\"\"\"\n        if not self._bundle:\n            return []\n        return get_resources(self._bundle, resource_type)\n\n    def add_resources(\n        self, resources: List[Any], resource_type: str, replace: bool = False\n    ):\n        \"\"\"Add resources to the working bundle.\"\"\"\n        if not self._bundle:\n            self._bundle = create_bundle()\n        set_resources(self._bundle, resources, resource_type, replace=replace)\n\n    def add_document_reference(\n        self,\n        document: DocumentReference,\n        parent_id: Optional[str] = None,\n        relationship_type: Optional[str] = \"transforms\",\n    ) -&gt; str:\n        \"\"\"\n        Adds a DocumentReference resource to the FHIR bundle and establishes\n        relationships between documents if a parent_id is provided. The relationship is\n        tracked using the FHIR relatesTo element with a specified relationship type.\n        See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n        Args:\n            document: The DocumentReference to add to the bundle\n            parent_id: Optional ID of the parent document. If provided, establishes a\n                relationship between this document and its parent.\n            relationship_type: The type of relationship to establish with the parent\n                document. Defaults to \"transforms\". This is used in the FHIR relatesTo\n                element's code. See: http://hl7.org/fhir/valueset-document-relationship-type\n\n        Returns:\n            str: The ID of the added document. If the document had no ID, a new UUID-based\n                ID is generated.\n        \"\"\"\n        # Generate a consistent ID if not present\n        if not document.id:\n            document.id = f\"doc-{uuid4()}\"\n\n        # Add relationship metadata if there's a parent\n        if parent_id:\n            if not hasattr(document, \"relatesTo\") or not document.relatesTo:\n                document.relatesTo = []\n            document.relatesTo.append(\n                DocumentReferenceRelatesTo(\n                    target=Reference(reference=f\"DocumentReference/{parent_id}\"),\n                    code=create_single_codeable_concept(\n                        code=relationship_type,\n                        display=relationship_type.capitalize(),\n                        system=\"http://hl7.org/fhir/ValueSet/document-relationship-type\",\n                    ),\n                )\n            )\n\n        self.add_resources([document], \"DocumentReference\", replace=False)\n\n        return document.id\n\n    def get_document_references_readable(\n        self, include_data: bool = True, include_relationships: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get DocumentReferences resources with their content and optional relationship data\n        in a human-readable dictionary format.\n\n        Args:\n            include_data: If True, decode and include the document data (default: True)\n            include_relationships: If True, include related document information (default: True)\n\n        Returns:\n            List of documents with metadata and optionally their content and relationships\n        \"\"\"\n        documents = []\n        for doc in self.get_resources(\"DocumentReference\"):\n            doc_data = {\n                \"id\": doc.id,\n                \"description\": doc.description,\n                \"status\": doc.status,\n            }\n\n            attachments = read_content_attachment(doc, include_data=include_data)\n            if attachments:\n                doc_data[\"attachments\"] = []\n                for attachment in attachments:\n                    if include_data:\n                        doc_data[\"attachments\"].append(\n                            {\n                                \"data\": attachment.get(\"data\"),\n                                \"metadata\": attachment.get(\"metadata\"),\n                            }\n                        )\n                    else:\n                        doc_data[\"attachments\"].append(\n                            {\"metadata\": attachment.get(\"metadata\")}\n                        )\n\n            if include_relationships:\n                family = self.get_document_reference_family(doc.id)\n                doc_data[\"relationships\"] = {\n                    \"parents\": [\n                        {\"id\": p.id, \"description\": p.description}\n                        for p in family[\"parents\"]\n                    ],\n                    \"children\": [\n                        {\"id\": c.id, \"description\": c.description}\n                        for c in family[\"children\"]\n                    ],\n                    \"siblings\": [\n                        {\"id\": s.id, \"description\": s.description}\n                        for s in family[\"siblings\"]\n                    ],\n                }\n\n            documents.append(doc_data)\n\n        return documents\n\n    def get_document_reference_family(self, document_id: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get a DocumentReference resource and all its related resources\n        based on the relatesTo element in the FHIR standard.\n        See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n        Args:\n            document_id: ID of the DocumentReference resource to find relationships for\n\n        Returns:\n            Dict containing:\n                'document': The requested DocumentReference resource\n                'parents': List of parent DocumentReference resources\n                'children': List of child DocumentReference resources\n                'siblings': List of DocumentReference resources sharing the same parent\n        \"\"\"\n        documents = self.get_resources(\"DocumentReference\")\n        family = {\"document\": None, \"parents\": [], \"children\": [], \"siblings\": []}\n\n        # Find the requested document\n        target_doc = next((doc for doc in documents if doc.id == document_id), None)\n        if not target_doc:\n            return family\n\n        family[\"document\"] = target_doc\n\n        # Find direct relationships\n        if hasattr(target_doc, \"relatesTo\") and target_doc.relatesTo:\n            # Find parents from target's relationships\n            for relation in target_doc.relatesTo:\n                parent_ref = relation.target.reference\n                parent_id = parent_ref.split(\"/\")[-1]\n                parent = next((doc for doc in documents if doc.id == parent_id), None)\n                if parent:\n                    family[\"parents\"].append(parent)\n\n        # Find children and siblings\n        for doc in documents:\n            if not hasattr(doc, \"relatesTo\") or not doc.relatesTo:\n                continue\n\n            for relation in doc.relatesTo:\n                target_ref = relation.target.reference\n                related_id = target_ref.split(\"/\")[-1]\n\n                # Check if this doc is a child of our target\n                if related_id == document_id:\n                    family[\"children\"].append(doc)\n\n                # For siblings, check if they share the same parent\n                elif family[\"parents\"] and related_id == family[\"parents\"][0].id:\n                    if doc.id != document_id:  # Don't include self as sibling\n                        family[\"siblings\"].append(doc)\n\n        return family\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--add-prefetch-resources-from-cds-request","title":"Add prefetch resources from CDS request","text":"<p>fhir.prefetch_resources = {\"patient\": patient_resource}</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--add-document-to-bundle","title":"Add document to bundle","text":"<p>doc_id = fhir.add_document_reference(document)</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--get-document-with-relationships","title":"Get document with relationships","text":"<p>doc_family = fhir.get_document_reference_family(doc_id)</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData--access-clinical-lists","title":"Access clinical lists","text":"<p>conditions = fhir.problem_list</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.allergy_list","title":"<code>allergy_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get allergy list from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.bundle","title":"<code>bundle</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the FHIR Bundle if it exists.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.medication_list","title":"<code>medication_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get medication list from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.operation_outcomes","title":"<code>operation_outcomes</code>  <code>property</code> <code>writable</code>","text":"<p>Get extracted OperationOutcome resources separated from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.patient","title":"<code>patient</code>  <code>property</code>","text":"<p>Get the first Patient resource from the bundle (convenience accessor).</p> <p>Returns None if no Patient resources are present in the bundle. For bundles with multiple patients, use the patients property instead.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.patients","title":"<code>patients</code>  <code>property</code>","text":"<p>Get all Patient resources from the bundle.</p> <p>Most bundles contain a single patient, but some queries (e.g., family history, population queries) may return multiple patients. This property provides access to all Patient resources without removing them from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.prefetch_resources","title":"<code>prefetch_resources</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the prefetch FHIR resources.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.problem_list","title":"<code>problem_list</code>  <code>property</code> <code>writable</code>","text":"<p>Get problem list from the bundle. Problem list items are stored as Condition resources in the bundle. See: https://www.hl7.org/fhir/condition.html</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.provenances","title":"<code>provenances</code>  <code>property</code> <code>writable</code>","text":"<p>Get extracted Provenance resources separated from the bundle.</p>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.add_document_reference","title":"<code>add_document_reference(document, parent_id=None, relationship_type='transforms')</code>","text":"<p>Adds a DocumentReference resource to the FHIR bundle and establishes relationships between documents if a parent_id is provided. The relationship is tracked using the FHIR relatesTo element with a specified relationship type. See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo</p> PARAMETER DESCRIPTION <code>document</code> <p>The DocumentReference to add to the bundle</p> <p> TYPE: <code>DocumentReference</code> </p> <code>parent_id</code> <p>Optional ID of the parent document. If provided, establishes a relationship between this document and its parent.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>relationship_type</code> <p>The type of relationship to establish with the parent document. Defaults to \"transforms\". This is used in the FHIR relatesTo element's code. See: http://hl7.org/fhir/valueset-document-relationship-type</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'transforms'</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The ID of the added document. If the document had no ID, a new UUID-based ID is generated.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def add_document_reference(\n    self,\n    document: DocumentReference,\n    parent_id: Optional[str] = None,\n    relationship_type: Optional[str] = \"transforms\",\n) -&gt; str:\n    \"\"\"\n    Adds a DocumentReference resource to the FHIR bundle and establishes\n    relationships between documents if a parent_id is provided. The relationship is\n    tracked using the FHIR relatesTo element with a specified relationship type.\n    See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n    Args:\n        document: The DocumentReference to add to the bundle\n        parent_id: Optional ID of the parent document. If provided, establishes a\n            relationship between this document and its parent.\n        relationship_type: The type of relationship to establish with the parent\n            document. Defaults to \"transforms\". This is used in the FHIR relatesTo\n            element's code. See: http://hl7.org/fhir/valueset-document-relationship-type\n\n    Returns:\n        str: The ID of the added document. If the document had no ID, a new UUID-based\n            ID is generated.\n    \"\"\"\n    # Generate a consistent ID if not present\n    if not document.id:\n        document.id = f\"doc-{uuid4()}\"\n\n    # Add relationship metadata if there's a parent\n    if parent_id:\n        if not hasattr(document, \"relatesTo\") or not document.relatesTo:\n            document.relatesTo = []\n        document.relatesTo.append(\n            DocumentReferenceRelatesTo(\n                target=Reference(reference=f\"DocumentReference/{parent_id}\"),\n                code=create_single_codeable_concept(\n                    code=relationship_type,\n                    display=relationship_type.capitalize(),\n                    system=\"http://hl7.org/fhir/ValueSet/document-relationship-type\",\n                ),\n            )\n        )\n\n    self.add_resources([document], \"DocumentReference\", replace=False)\n\n    return document.id\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.add_resources","title":"<code>add_resources(resources, resource_type, replace=False)</code>","text":"<p>Add resources to the working bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def add_resources(\n    self, resources: List[Any], resource_type: str, replace: bool = False\n):\n    \"\"\"Add resources to the working bundle.\"\"\"\n    if not self._bundle:\n        self._bundle = create_bundle()\n    set_resources(self._bundle, resources, resource_type, replace=replace)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_document_reference_family","title":"<code>get_document_reference_family(document_id)</code>","text":"<p>Get a DocumentReference resource and all its related resources based on the relatesTo element in the FHIR standard. See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo</p> PARAMETER DESCRIPTION <code>document_id</code> <p>ID of the DocumentReference resource to find relationships for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict containing: 'document': The requested DocumentReference resource 'parents': List of parent DocumentReference resources 'children': List of child DocumentReference resources 'siblings': List of DocumentReference resources sharing the same parent</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_document_reference_family(self, document_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get a DocumentReference resource and all its related resources\n    based on the relatesTo element in the FHIR standard.\n    See: https://build.fhir.org/documentreference-definitions.html#DocumentReference.relatesTo\n\n    Args:\n        document_id: ID of the DocumentReference resource to find relationships for\n\n    Returns:\n        Dict containing:\n            'document': The requested DocumentReference resource\n            'parents': List of parent DocumentReference resources\n            'children': List of child DocumentReference resources\n            'siblings': List of DocumentReference resources sharing the same parent\n    \"\"\"\n    documents = self.get_resources(\"DocumentReference\")\n    family = {\"document\": None, \"parents\": [], \"children\": [], \"siblings\": []}\n\n    # Find the requested document\n    target_doc = next((doc for doc in documents if doc.id == document_id), None)\n    if not target_doc:\n        return family\n\n    family[\"document\"] = target_doc\n\n    # Find direct relationships\n    if hasattr(target_doc, \"relatesTo\") and target_doc.relatesTo:\n        # Find parents from target's relationships\n        for relation in target_doc.relatesTo:\n            parent_ref = relation.target.reference\n            parent_id = parent_ref.split(\"/\")[-1]\n            parent = next((doc for doc in documents if doc.id == parent_id), None)\n            if parent:\n                family[\"parents\"].append(parent)\n\n    # Find children and siblings\n    for doc in documents:\n        if not hasattr(doc, \"relatesTo\") or not doc.relatesTo:\n            continue\n\n        for relation in doc.relatesTo:\n            target_ref = relation.target.reference\n            related_id = target_ref.split(\"/\")[-1]\n\n            # Check if this doc is a child of our target\n            if related_id == document_id:\n                family[\"children\"].append(doc)\n\n            # For siblings, check if they share the same parent\n            elif family[\"parents\"] and related_id == family[\"parents\"][0].id:\n                if doc.id != document_id:  # Don't include self as sibling\n                    family[\"siblings\"].append(doc)\n\n    return family\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_document_references_readable","title":"<code>get_document_references_readable(include_data=True, include_relationships=True)</code>","text":"<p>Get DocumentReferences resources with their content and optional relationship data in a human-readable dictionary format.</p> PARAMETER DESCRIPTION <code>include_data</code> <p>If True, decode and include the document data (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>include_relationships</code> <p>If True, include related document information (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List of documents with metadata and optionally their content and relationships</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_document_references_readable(\n    self, include_data: bool = True, include_relationships: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get DocumentReferences resources with their content and optional relationship data\n    in a human-readable dictionary format.\n\n    Args:\n        include_data: If True, decode and include the document data (default: True)\n        include_relationships: If True, include related document information (default: True)\n\n    Returns:\n        List of documents with metadata and optionally their content and relationships\n    \"\"\"\n    documents = []\n    for doc in self.get_resources(\"DocumentReference\"):\n        doc_data = {\n            \"id\": doc.id,\n            \"description\": doc.description,\n            \"status\": doc.status,\n        }\n\n        attachments = read_content_attachment(doc, include_data=include_data)\n        if attachments:\n            doc_data[\"attachments\"] = []\n            for attachment in attachments:\n                if include_data:\n                    doc_data[\"attachments\"].append(\n                        {\n                            \"data\": attachment.get(\"data\"),\n                            \"metadata\": attachment.get(\"metadata\"),\n                        }\n                    )\n                else:\n                    doc_data[\"attachments\"].append(\n                        {\"metadata\": attachment.get(\"metadata\")}\n                    )\n\n        if include_relationships:\n            family = self.get_document_reference_family(doc.id)\n            doc_data[\"relationships\"] = {\n                \"parents\": [\n                    {\"id\": p.id, \"description\": p.description}\n                    for p in family[\"parents\"]\n                ],\n                \"children\": [\n                    {\"id\": c.id, \"description\": c.description}\n                    for c in family[\"children\"]\n                ],\n                \"siblings\": [\n                    {\"id\": s.id, \"description\": s.description}\n                    for s in family[\"siblings\"]\n                ],\n            }\n\n        documents.append(doc_data)\n\n    return documents\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_prefetch_resources","title":"<code>get_prefetch_resources(key)</code>","text":"<p>Get resources of a specific type from the prefetch bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_prefetch_resources(self, key: str) -&gt; List[Any]:\n    \"\"\"Get resources of a specific type from the prefetch bundle.\"\"\"\n    if not self._prefetch_resources:\n        return []\n    return self._prefetch_resources.get(key, [])\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.FhirData.get_resources","title":"<code>get_resources(resource_type)</code>","text":"<p>Get resources of a specific type from the working bundle.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_resources(self, resource_type: str) -&gt; List[Any]:\n    \"\"\"Get resources of a specific type from the working bundle.\"\"\"\n    if not self._bundle:\n        return []\n    return get_resources(self._bundle, resource_type)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.ModelOutputs","title":"<code>ModelOutputs</code>  <code>dataclass</code>","text":"<p>Container for storing and managing third-party integration model outputs.</p> <p>This class stores outputs from different NLP/ML frameworks like Hugging Face and LangChain, organizing them by task type. It also maintains a list of generated text outputs across frameworks.</p> ATTRIBUTE DESCRIPTION <code>_huggingface_results</code> <p>Dictionary storing Hugging Face model outputs, keyed by task name.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>_langchain_results</code> <p>Dictionary storing LangChain outputs, keyed by task name.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> METHOD DESCRIPTION <code>add_output</code> <p>str, task: str, output: Any): Adds a model output for a specific source and task. For text generation tasks, also extracts and stores the generated text.</p> <code>get_output</code> <p>str, task: str, default: Any = None) -&gt; Any: Gets the model output for a specific source and task. Returns default if not found.</p> <code>get_generated_text</code> <p>Returns the list of generated text outputs</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass ModelOutputs:\n    \"\"\"\n    Container for storing and managing third-party integration model outputs.\n\n    This class stores outputs from different NLP/ML frameworks like Hugging Face\n    and LangChain, organizing them by task type. It also maintains a list of\n    generated text outputs across frameworks.\n\n    Attributes:\n        _huggingface_results (Dict[str, Any]): Dictionary storing Hugging Face model\n            outputs, keyed by task name.\n        _langchain_results (Dict[str, Any]): Dictionary storing LangChain outputs,\n            keyed by task name.\n\n    Methods:\n        add_output(source: str, task: str, output: Any): Adds a model output for a\n            specific source and task. For text generation tasks, also extracts and\n            stores the generated text.\n        get_output(source: str, task: str, default: Any = None) -&gt; Any: Gets the model\n            output for a specific source and task. Returns default if not found.\n        get_generated_text() -&gt; List[str]: Returns the list of generated text outputs\n    \"\"\"\n\n    _huggingface_results: Dict[str, Any] = field(default_factory=dict)\n    _langchain_results: Dict[str, Any] = field(default_factory=dict)\n\n    def add_output(self, source: str, task: str, output: Any):\n        if source == \"huggingface\":\n            self._huggingface_results[task] = output\n        elif source == \"langchain\":\n            self._langchain_results[task] = output\n        else:\n            raise ValueError(f\"Unknown source: {source}\")\n\n    def get_output(self, source: str, task: str) -&gt; Any:\n        if source == \"huggingface\":\n            return self._huggingface_results.get(task, {})\n        elif source == \"langchain\":\n            return self._langchain_results.get(task, {})\n        raise ValueError(f\"Unknown source: {source}\")\n\n    def get_generated_text(self, source: str, task: str) -&gt; List[str]:\n        \"\"\"\n        Returns generated text outputs for a given source and task.\n\n        Handles different output formats for Hugging Face and LangChain. For\n        Hugging Face, it extracts the last message content from chat-style\n        outputs and common keys like \"generated_text\", \"summary_text\", and\n        \"translation\". For LangChain, it converts JSON outputs to strings, and returns\n        the output as is if it is already a string.\n\n        Args:\n            source (str): Framework name (e.g., \"huggingface\", \"langchain\").\n            task (str): Task name for retrieving generated text.\n\n        Returns:\n            List[str]: List of generated text outputs, or an empty list if none.\n        \"\"\"\n        generated_text = []\n\n        if source == \"huggingface\":\n            # Handle chat-style output format\n            output = self._huggingface_results.get(task)\n            if isinstance(output, list):\n                for entry in output:\n                    text = entry.get(\"generated_text\")\n                    if isinstance(text, list):\n                        last_msg = text[-1]\n                        if isinstance(last_msg, dict) and \"content\" in last_msg:\n                            generated_text.append(last_msg[\"content\"])\n                    # Otherwise get common huggingface output keys\n                    elif any(\n                        key in entry\n                        for key in [\"generated_text\", \"summary_text\", \"translation\"]\n                    ):\n                        generated_text.append(\n                            text\n                            or entry.get(\"summary_text\")\n                            or entry.get(\"translation\")\n                        )\n            else:\n                logger.warning(\"HuggingFace output is not a list of dictionaries. \")\n        elif source == \"langchain\":\n            output = self._langchain_results.get(task)\n            # Check if output is a string\n            if isinstance(output, str):\n                generated_text.append(output)\n            # Try to convert JSON to string\n            elif isinstance(output, dict):\n                try:\n                    import json\n\n                    output_str = json.dumps(output)\n                    generated_text.append(output_str)\n                except Exception:\n                    logger.warning(\n                        \"LangChain output is not a string and could not be converted to JSON string. \"\n                        \"Chains should output either a string or a JSON object.\"\n                    )\n            else:\n                logger.warning(\n                    \"LangChain output is not a string. Chains should output either a string or a JSON object.\"\n                )\n\n        return generated_text\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.ModelOutputs.get_generated_text","title":"<code>get_generated_text(source, task)</code>","text":"<p>Returns generated text outputs for a given source and task.</p> <p>Handles different output formats for Hugging Face and LangChain. For Hugging Face, it extracts the last message content from chat-style outputs and common keys like \"generated_text\", \"summary_text\", and \"translation\". For LangChain, it converts JSON outputs to strings, and returns the output as is if it is already a string.</p> PARAMETER DESCRIPTION <code>source</code> <p>Framework name (e.g., \"huggingface\", \"langchain\").</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>Task name for retrieving generated text.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: List of generated text outputs, or an empty list if none.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>def get_generated_text(self, source: str, task: str) -&gt; List[str]:\n    \"\"\"\n    Returns generated text outputs for a given source and task.\n\n    Handles different output formats for Hugging Face and LangChain. For\n    Hugging Face, it extracts the last message content from chat-style\n    outputs and common keys like \"generated_text\", \"summary_text\", and\n    \"translation\". For LangChain, it converts JSON outputs to strings, and returns\n    the output as is if it is already a string.\n\n    Args:\n        source (str): Framework name (e.g., \"huggingface\", \"langchain\").\n        task (str): Task name for retrieving generated text.\n\n    Returns:\n        List[str]: List of generated text outputs, or an empty list if none.\n    \"\"\"\n    generated_text = []\n\n    if source == \"huggingface\":\n        # Handle chat-style output format\n        output = self._huggingface_results.get(task)\n        if isinstance(output, list):\n            for entry in output:\n                text = entry.get(\"generated_text\")\n                if isinstance(text, list):\n                    last_msg = text[-1]\n                    if isinstance(last_msg, dict) and \"content\" in last_msg:\n                        generated_text.append(last_msg[\"content\"])\n                # Otherwise get common huggingface output keys\n                elif any(\n                    key in entry\n                    for key in [\"generated_text\", \"summary_text\", \"translation\"]\n                ):\n                    generated_text.append(\n                        text\n                        or entry.get(\"summary_text\")\n                        or entry.get(\"translation\")\n                    )\n        else:\n            logger.warning(\"HuggingFace output is not a list of dictionaries. \")\n    elif source == \"langchain\":\n        output = self._langchain_results.get(task)\n        # Check if output is a string\n        if isinstance(output, str):\n            generated_text.append(output)\n        # Try to convert JSON to string\n        elif isinstance(output, dict):\n            try:\n                import json\n\n                output_str = json.dumps(output)\n                generated_text.append(output_str)\n            except Exception:\n                logger.warning(\n                    \"LangChain output is not a string and could not be converted to JSON string. \"\n                    \"Chains should output either a string or a JSON object.\"\n                )\n        else:\n            logger.warning(\n                \"LangChain output is not a string. Chains should output either a string or a JSON object.\"\n            )\n\n    return generated_text\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.document.NlpAnnotations","title":"<code>NlpAnnotations</code>  <code>dataclass</code>","text":"<p>Container for NLP-specific annotations and results.</p> <p>This class stores various NLP annotations and processing results from text analysis, including preprocessed text, tokens, named entities, embeddings and spaCy documents.</p> ATTRIBUTE DESCRIPTION <code>_preprocessed_text</code> <p>The preprocessed version of the input text.</p> <p> TYPE: <code>str</code> </p> <code>_tokens</code> <p>List of tokenized words from the text.</p> <p> TYPE: <code>List[str]</code> </p> <code>_entities</code> <p>Named entities extracted from the text, with their labels and positions.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>_embeddings</code> <p>Vector embeddings generated from the text.</p> <p> TYPE: <code>Optional[List[float]]</code> </p> <code>_spacy_doc</code> <p>The processed spaCy Doc object.</p> <p> TYPE: <code>Optional[Doc]</code> </p> METHOD DESCRIPTION <code>add_spacy_doc</code> <p>SpacyDoc): Processes a spaCy Doc to extract tokens and entities.</p> <code>get_spacy_doc</code> <p>Returns the stored spaCy Doc object.</p> <code>get_tokens</code> <p>Returns the list of tokens.</p> <code>set_tokens</code> <p>List[str]): Sets the token list.</p> <code>set_entities</code> <p>List[Dict[str, Any]]): Sets the named entities list.</p> <code>get_entities</code> <p>Returns the list of named entities.</p> <code>get_embeddings</code> <p>Returns the vector embeddings.</p> <code>set_embeddings</code> <p>List[float]): Sets the vector embeddings.</p> Source code in <code>healthchain/io/containers/document.py</code> <pre><code>@dataclass\nclass NlpAnnotations:\n    \"\"\"\n    Container for NLP-specific annotations and results.\n\n    This class stores various NLP annotations and processing results from text analysis,\n    including preprocessed text, tokens, named entities, embeddings and spaCy documents.\n\n    Attributes:\n        _preprocessed_text (str): The preprocessed version of the input text.\n        _tokens (List[str]): List of tokenized words from the text.\n        _entities (List[Dict[str, Any]]): Named entities extracted from the text, with their labels and positions.\n        _embeddings (Optional[List[float]]): Vector embeddings generated from the text.\n        _spacy_doc (Optional[SpacyDoc]): The processed spaCy Doc object.\n\n    Methods:\n        add_spacy_doc(doc: SpacyDoc): Processes a spaCy Doc to extract tokens and entities.\n        get_spacy_doc() -&gt; Optional[SpacyDoc]: Returns the stored spaCy Doc object.\n        get_tokens() -&gt; List[str]: Returns the list of tokens.\n        set_tokens(tokens: List[str]): Sets the token list.\n        set_entities(entities: List[Dict[str, Any]]): Sets the named entities list.\n        get_entities() -&gt; List[Dict[str, Any]]: Returns the list of named entities.\n        get_embeddings() -&gt; Optional[List[float]]: Returns the vector embeddings.\n        set_embeddings(embeddings: List[float]): Sets the vector embeddings.\n    \"\"\"\n\n    _preprocessed_text: str = \"\"\n    _tokens: List[str] = field(default_factory=list)\n    _entities: List[Dict[str, Any]] = field(default_factory=list)\n    _embeddings: Optional[List[float]] = None\n    _spacy_doc: Optional[SpacyDoc] = None\n\n    def add_spacy_doc(self, doc: SpacyDoc):\n        self._spacy_doc = doc\n        self._tokens = [token.text for token in doc]\n        self._entities = [\n            {\n                \"text\": ent.text,\n                \"label\": ent.label_,\n                \"start\": ent.start_char,\n                \"end\": ent.end_char,\n            }\n            for ent in doc.ents\n        ]\n\n    def get_spacy_doc(self) -&gt; Optional[SpacyDoc]:\n        return self._spacy_doc\n\n    def get_tokens(self) -&gt; List[str]:\n        return self._tokens\n\n    def set_tokens(self, tokens: List[str]):\n        self._tokens = tokens\n\n    def set_entities(self, entities: List[Dict[str, Any]]):\n        self._entities = entities\n\n    def get_entities(self) -&gt; List[Dict[str, Any]]:\n        return self._entities\n\n    def get_embeddings(self) -&gt; Optional[List[float]]:\n        return self._embeddings\n\n    def set_embeddings(self, embeddings: List[float]):\n        self._embeddings = embeddings\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema","title":"<code>featureschema</code>","text":"<p>Feature schema definitions for FHIR to Dataset data conversion.</p> <p>This module provides classes to define and manage feature schemas that map FHIR resources to pandas DataFrame columns for ML model deployment.</p>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureMapping","title":"<code>FeatureMapping</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Maps a single feature to its FHIR source.</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>class FeatureMapping(BaseModel):\n    \"\"\"Maps a single feature to its FHIR source.\"\"\"\n\n    name: str\n    fhir_resource: str\n    code: Optional[str] = None\n    code_system: Optional[str] = None\n    field: Optional[str] = None\n    transform: Optional[str] = None\n    dtype: str = \"float64\"\n    required: bool = True\n    unit: Optional[str] = None\n    display: Optional[str] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    @model_validator(mode=\"after\")\n    def validate_resource_requirements(self) -&gt; \"FeatureMapping\":\n        \"\"\"Validate the feature mapping configuration based on resource type.\"\"\"\n        if self.fhir_resource == \"Observation\":\n            if not self.code:\n                raise ValueError(\n                    f\"Feature '{self.name}': Observation resources require a 'code'\"\n                )\n            if not self.code_system:\n                raise ValueError(\n                    f\"Feature '{self.name}': Observation resources require a 'code_system'\"\n                )\n        elif self.fhir_resource == \"Patient\":\n            if not self.field:\n                raise ValueError(\n                    f\"Feature '{self.name}': Patient resources require a 'field'\"\n                )\n        return self\n\n    @classmethod\n    def from_dict(cls, name: str, data: Dict[str, Any]) -&gt; \"FeatureMapping\":\n        \"\"\"Create a FeatureMapping from a dictionary.\n\n        Args:\n            name: The feature name\n            data: Dictionary containing feature configuration\n\n        Returns:\n            FeatureMapping instance\n        \"\"\"\n        return cls(name=name, **data)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureMapping.from_dict","title":"<code>from_dict(name, data)</code>  <code>classmethod</code>","text":"<p>Create a FeatureMapping from a dictionary.</p> PARAMETER DESCRIPTION <code>name</code> <p>The feature name</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Dictionary containing feature configuration</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>FeatureMapping</code> <p>FeatureMapping instance</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>@classmethod\ndef from_dict(cls, name: str, data: Dict[str, Any]) -&gt; \"FeatureMapping\":\n    \"\"\"Create a FeatureMapping from a dictionary.\n\n    Args:\n        name: The feature name\n        data: Dictionary containing feature configuration\n\n    Returns:\n        FeatureMapping instance\n    \"\"\"\n    return cls(name=name, **data)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureMapping.validate_resource_requirements","title":"<code>validate_resource_requirements()</code>","text":"<p>Validate the feature mapping configuration based on resource type.</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_resource_requirements(self) -&gt; \"FeatureMapping\":\n    \"\"\"Validate the feature mapping configuration based on resource type.\"\"\"\n    if self.fhir_resource == \"Observation\":\n        if not self.code:\n            raise ValueError(\n                f\"Feature '{self.name}': Observation resources require a 'code'\"\n            )\n        if not self.code_system:\n            raise ValueError(\n                f\"Feature '{self.name}': Observation resources require a 'code_system'\"\n            )\n    elif self.fhir_resource == \"Patient\":\n        if not self.field:\n            raise ValueError(\n                f\"Feature '{self.name}': Patient resources require a 'field'\"\n            )\n    return self\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema","title":"<code>FeatureSchema</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema defining how to extract features from FHIR resources.</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>class FeatureSchema(BaseModel):\n    \"\"\"Schema defining how to extract features from FHIR resources.\"\"\"\n\n    name: str\n    version: str\n    features: Dict[str, FeatureMapping] = {}\n    description: Optional[str] = None\n    model_info: Optional[Dict[str, Any]] = None\n    metadata: Optional[Dict[str, Any]] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    @field_validator(\"features\", mode=\"before\")\n    @classmethod\n    def convert_feature_dicts(cls, v):\n        \"\"\"Convert feature dicts to FeatureMapping objects if needed.\"\"\"\n        if v and isinstance(v, dict):\n            # Check if values are dicts (need conversion) or already FeatureMapping\n            if v and isinstance(list(v.values())[0], dict):\n                return {\n                    name: FeatureMapping.from_dict(name, mapping)\n                    for name, mapping in v.items()\n                }\n        return v\n\n    @classmethod\n    def from_yaml(cls, path: Union[str, Path]) -&gt; \"FeatureSchema\":\n        \"\"\"Load schema from a YAML file.\n\n        Args:\n            path: Path to the YAML file\n\n        Returns:\n            FeatureSchema instance\n\n        Example:\n            &gt;&gt;&gt; schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")\n        \"\"\"\n        path = Path(path)\n        with open(path, \"r\") as f:\n            data = yaml.safe_load(f)\n\n        return cls.model_validate(data)\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"FeatureSchema\":\n        \"\"\"Create a FeatureSchema from a dictionary.\n\n        Args:\n            data: Dictionary containing schema configuration\n\n        Returns:\n            FeatureSchema instance\n        \"\"\"\n        return cls.model_validate(data)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert schema to dictionary format.\n\n        Returns:\n            Dictionary representation of the schema\n        \"\"\"\n        result = {\n            \"name\": self.name,\n            \"version\": self.version,\n            \"description\": self.description,\n            \"model_info\": self.model_info,\n            \"features\": {\n                name: {\n                    k: v\n                    for k, v in mapping.model_dump().items()\n                    if k != \"name\" and v is not None\n                }\n                for name, mapping in self.features.items()\n            },\n        }\n        if self.metadata:\n            result[\"metadata\"] = self.metadata\n        return result\n\n    def to_yaml(self, path: Union[str, Path]) -&gt; None:\n        \"\"\"Save schema to a YAML file.\n\n        Args:\n            path: Path where the YAML file will be saved\n        \"\"\"\n        path = Path(path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(path, \"w\") as f:\n            yaml.dump(self.to_dict(), f, default_flow_style=False, sort_keys=False)\n\n    def get_feature_names(self) -&gt; List[str]:\n        \"\"\"Get list of feature names in order.\n\n        Returns:\n            List of feature names\n        \"\"\"\n        return list(self.features.keys())\n\n    def get_required_features(self) -&gt; List[str]:\n        \"\"\"Get list of required feature names.\n\n        Returns:\n            List of required feature names\n        \"\"\"\n        return [name for name, mapping in self.features.items() if mapping.required]\n\n    def get_features_by_resource(self, resource_type: str) -&gt; Dict[str, FeatureMapping]:\n        \"\"\"Get all features mapped to a specific FHIR resource type.\n\n        Args:\n            resource_type: FHIR resource type (e.g., \"Observation\", \"Patient\")\n\n        Returns:\n            Dictionary of features for the specified resource type\n        \"\"\"\n        return {\n            name: mapping\n            for name, mapping in self.features.items()\n            if mapping.fhir_resource == resource_type\n        }\n\n    def get_observation_codes(self) -&gt; Dict[str, FeatureMapping]:\n        \"\"\"Get all Observation features with their codes.\n\n        Returns:\n            Dictionary mapping codes to feature mappings\n        \"\"\"\n        observations = self.get_features_by_resource(\"Observation\")\n        return {\n            mapping.code: mapping for mapping in observations.values() if mapping.code\n        }\n\n    def validate_dataframe_columns(self, columns: List[str]) -&gt; Dict[str, Any]:\n        \"\"\"Validate that a DataFrame has the expected columns.\n\n        Args:\n            columns: List of column names from a DataFrame\n\n        Returns:\n            Dictionary with validation results:\n                - valid: bool\n                - missing_required: List of missing required features\n                - unexpected: List of unexpected columns\n        \"\"\"\n        expected = set(self.get_feature_names())\n        actual = set(columns)\n        required = set(self.get_required_features())\n\n        missing_required = list(required - actual)\n        unexpected = list(actual - expected)\n\n        return {\n            \"valid\": len(missing_required) == 0,\n            \"missing_required\": missing_required,\n            \"unexpected\": unexpected,\n            \"missing_optional\": list((expected - required) - actual),\n        }\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.convert_feature_dicts","title":"<code>convert_feature_dicts(v)</code>  <code>classmethod</code>","text":"<p>Convert feature dicts to FeatureMapping objects if needed.</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>@field_validator(\"features\", mode=\"before\")\n@classmethod\ndef convert_feature_dicts(cls, v):\n    \"\"\"Convert feature dicts to FeatureMapping objects if needed.\"\"\"\n    if v and isinstance(v, dict):\n        # Check if values are dicts (need conversion) or already FeatureMapping\n        if v and isinstance(list(v.values())[0], dict):\n            return {\n                name: FeatureMapping.from_dict(name, mapping)\n                for name, mapping in v.items()\n            }\n    return v\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a FeatureSchema from a dictionary.</p> PARAMETER DESCRIPTION <code>data</code> <p>Dictionary containing schema configuration</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>FeatureSchema</code> <p>FeatureSchema instance</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; \"FeatureSchema\":\n    \"\"\"Create a FeatureSchema from a dictionary.\n\n    Args:\n        data: Dictionary containing schema configuration\n\n    Returns:\n        FeatureSchema instance\n    \"\"\"\n    return cls.model_validate(data)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.from_yaml","title":"<code>from_yaml(path)</code>  <code>classmethod</code>","text":"<p>Load schema from a YAML file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the YAML file</p> <p> TYPE: <code>Union[str, Path]</code> </p> RETURNS DESCRIPTION <code>FeatureSchema</code> <p>FeatureSchema instance</p> Example <p>schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>@classmethod\ndef from_yaml(cls, path: Union[str, Path]) -&gt; \"FeatureSchema\":\n    \"\"\"Load schema from a YAML file.\n\n    Args:\n        path: Path to the YAML file\n\n    Returns:\n        FeatureSchema instance\n\n    Example:\n        &gt;&gt;&gt; schema = FeatureSchema.from_yaml(\"configs/features/sepsis_vitals.yaml\")\n    \"\"\"\n    path = Path(path)\n    with open(path, \"r\") as f:\n        data = yaml.safe_load(f)\n\n    return cls.model_validate(data)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.get_feature_names","title":"<code>get_feature_names()</code>","text":"<p>Get list of feature names in order.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of feature names</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def get_feature_names(self) -&gt; List[str]:\n    \"\"\"Get list of feature names in order.\n\n    Returns:\n        List of feature names\n    \"\"\"\n    return list(self.features.keys())\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.get_features_by_resource","title":"<code>get_features_by_resource(resource_type)</code>","text":"<p>Get all features mapped to a specific FHIR resource type.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>FHIR resource type (e.g., \"Observation\", \"Patient\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, FeatureMapping]</code> <p>Dictionary of features for the specified resource type</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def get_features_by_resource(self, resource_type: str) -&gt; Dict[str, FeatureMapping]:\n    \"\"\"Get all features mapped to a specific FHIR resource type.\n\n    Args:\n        resource_type: FHIR resource type (e.g., \"Observation\", \"Patient\")\n\n    Returns:\n        Dictionary of features for the specified resource type\n    \"\"\"\n    return {\n        name: mapping\n        for name, mapping in self.features.items()\n        if mapping.fhir_resource == resource_type\n    }\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.get_observation_codes","title":"<code>get_observation_codes()</code>","text":"<p>Get all Observation features with their codes.</p> RETURNS DESCRIPTION <code>Dict[str, FeatureMapping]</code> <p>Dictionary mapping codes to feature mappings</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def get_observation_codes(self) -&gt; Dict[str, FeatureMapping]:\n    \"\"\"Get all Observation features with their codes.\n\n    Returns:\n        Dictionary mapping codes to feature mappings\n    \"\"\"\n    observations = self.get_features_by_resource(\"Observation\")\n    return {\n        mapping.code: mapping for mapping in observations.values() if mapping.code\n    }\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.get_required_features","title":"<code>get_required_features()</code>","text":"<p>Get list of required feature names.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of required feature names</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def get_required_features(self) -&gt; List[str]:\n    \"\"\"Get list of required feature names.\n\n    Returns:\n        List of required feature names\n    \"\"\"\n    return [name for name, mapping in self.features.items() if mapping.required]\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert schema to dictionary format.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary representation of the schema</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert schema to dictionary format.\n\n    Returns:\n        Dictionary representation of the schema\n    \"\"\"\n    result = {\n        \"name\": self.name,\n        \"version\": self.version,\n        \"description\": self.description,\n        \"model_info\": self.model_info,\n        \"features\": {\n            name: {\n                k: v\n                for k, v in mapping.model_dump().items()\n                if k != \"name\" and v is not None\n            }\n            for name, mapping in self.features.items()\n        },\n    }\n    if self.metadata:\n        result[\"metadata\"] = self.metadata\n    return result\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.to_yaml","title":"<code>to_yaml(path)</code>","text":"<p>Save schema to a YAML file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path where the YAML file will be saved</p> <p> TYPE: <code>Union[str, Path]</code> </p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def to_yaml(self, path: Union[str, Path]) -&gt; None:\n    \"\"\"Save schema to a YAML file.\n\n    Args:\n        path: Path where the YAML file will be saved\n    \"\"\"\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    with open(path, \"w\") as f:\n        yaml.dump(self.to_dict(), f, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"api/containers/#healthchain.io.containers.featureschema.FeatureSchema.validate_dataframe_columns","title":"<code>validate_dataframe_columns(columns)</code>","text":"<p>Validate that a DataFrame has the expected columns.</p> PARAMETER DESCRIPTION <code>columns</code> <p>List of column names from a DataFrame</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary with validation results: - valid: bool - missing_required: List of missing required features - unexpected: List of unexpected columns</p> Source code in <code>healthchain/io/containers/featureschema.py</code> <pre><code>def validate_dataframe_columns(self, columns: List[str]) -&gt; Dict[str, Any]:\n    \"\"\"Validate that a DataFrame has the expected columns.\n\n    Args:\n        columns: List of column names from a DataFrame\n\n    Returns:\n        Dictionary with validation results:\n            - valid: bool\n            - missing_required: List of missing required features\n            - unexpected: List of unexpected columns\n    \"\"\"\n    expected = set(self.get_feature_names())\n    actual = set(columns)\n    required = set(self.get_required_features())\n\n    missing_required = list(required - actual)\n    unexpected = list(actual - expected)\n\n    return {\n        \"valid\": len(missing_required) == 0,\n        \"missing_required\": missing_required,\n        \"unexpected\": unexpected,\n        \"missing_optional\": list((expected - required) - actual),\n    }\n</code></pre>"},{"location":"api/fhir_helpers/","title":"FHIR Helpers","text":"<p>FHIR utilities for HealthChain.</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.BundleConverterConfig","title":"<code>BundleConverterConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for FHIR Bundle to DataFrame conversion.</p> <p>This configuration object controls which FHIR resources are processed and how they are converted to DataFrame columns for ML model deployment.</p> ATTRIBUTE DESCRIPTION <code>resources</code> <p>List of FHIR resource types to include in the conversion</p> <p> TYPE: <code>List[str]</code> </p> <code>observation_aggregation</code> <p>How to aggregate multiple observation values</p> <p> TYPE: <code>Literal['mean', 'median', 'max', 'min', 'last']</code> </p> <code>age_calculation</code> <p>Method for calculating patient age</p> <p> TYPE: <code>Literal['current_date', 'event_date']</code> </p> <code>event_date_source</code> <p>Which resource to extract event date from</p> <p> TYPE: <code>Literal['Observation', 'Encounter']</code> </p> <code>event_date_strategy</code> <p>Which date to use when multiple dates exist</p> <p> TYPE: <code>Literal['earliest', 'latest', 'first']</code> </p> <code>resource_options</code> <p>Resource-specific configuration options (extensible)</p> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> Example <p>config = BundleConverterConfig( ...     resources=[\"Patient\", \"Observation\", \"Condition\"], ...     observation_aggregation=\"median\" ... ) df = bundle_to_dataframe(bundle, config=config)</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>class BundleConverterConfig(BaseModel):\n    \"\"\"Configuration for FHIR Bundle to DataFrame conversion.\n\n    This configuration object controls which FHIR resources are processed and how\n    they are converted to DataFrame columns for ML model deployment.\n\n    Attributes:\n        resources: List of FHIR resource types to include in the conversion\n        observation_aggregation: How to aggregate multiple observation values\n        age_calculation: Method for calculating patient age\n        event_date_source: Which resource to extract event date from\n        event_date_strategy: Which date to use when multiple dates exist\n        resource_options: Resource-specific configuration options (extensible)\n\n    Example:\n        &gt;&gt;&gt; config = BundleConverterConfig(\n        ...     resources=[\"Patient\", \"Observation\", \"Condition\"],\n        ...     observation_aggregation=\"median\"\n        ... )\n        &gt;&gt;&gt; df = bundle_to_dataframe(bundle, config=config)\n    \"\"\"\n\n    # Core resources to include\n    resources: List[str] = [\"Patient\", \"Observation\"]\n\n    # Observation-specific options\n    observation_aggregation: Literal[\"mean\", \"median\", \"max\", \"min\", \"last\"] = \"mean\"\n\n    # Patient age calculation\n    age_calculation: Literal[\"current_date\", \"event_date\"] = \"current_date\"\n    event_date_source: Literal[\"Observation\", \"Encounter\"] = \"Observation\"\n    event_date_strategy: Literal[\"earliest\", \"latest\", \"first\"] = \"earliest\"\n\n    # Resource-specific options (extensible for future use)\n    resource_options: Dict[str, Dict[str, Any]] = {}\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    @field_validator(\"resources\")\n    @classmethod\n    def validate_resources(cls, v):\n        \"\"\"Validate that requested resources are supported and warn about unsupported ones.\"\"\"\n        supported = get_supported_resources()\n        unsupported = [r for r in v if r not in supported]\n        if unsupported:\n            logger.warning(\n                f\"Unsupported resources will be skipped: {unsupported}. \"\n                f\"Supported resources: {supported}\"\n            )\n        return v\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.BundleConverterConfig.validate_resources","title":"<code>validate_resources(v)</code>  <code>classmethod</code>","text":"<p>Validate that requested resources are supported and warn about unsupported ones.</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>@field_validator(\"resources\")\n@classmethod\ndef validate_resources(cls, v):\n    \"\"\"Validate that requested resources are supported and warn about unsupported ones.\"\"\"\n    supported = get_supported_resources()\n    unsupported = [r for r in v if r not in supported]\n    if unsupported:\n        logger.warning(\n            f\"Unsupported resources will be skipped: {unsupported}. \"\n            f\"Supported resources: {supported}\"\n        )\n    return v\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.FHIRVersion","title":"<code>FHIRVersion</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported FHIR versions.</p> <p>R5 is the default version in fhir.resources library. R4B and STU3 are available via subpackages (e.g., fhir.resources.R4B).</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>class FHIRVersion(str, Enum):\n    \"\"\"Supported FHIR versions.\n\n    R5 is the default version in fhir.resources library.\n    R4B and STU3 are available via subpackages (e.g., fhir.resources.R4B).\n    \"\"\"\n\n    STU3 = \"STU3\"\n    R4B = \"R4B\"\n    R5 = \"R5\"\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_coding_to_codeable_concept","title":"<code>add_coding_to_codeable_concept(codeable_concept, code, system, display=None, version=None)</code>","text":"<p>Add a coding to an existing CodeableConcept.</p> <p>Useful for adding standardized codes (e.g., SNOMED CT) to resources that already have codes from other systems (e.g., ICD-10).</p> PARAMETER DESCRIPTION <code>codeable_concept</code> <p>The CodeableConcept to add coding to</p> <p> TYPE: <code>Any</code> </p> <code>code</code> <p>The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>system</code> <p>The code system URI</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>Optional display text for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use. If None, attempts to detect from the CodeableConcept.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>The updated CodeableConcept with the new coding added</p> <p> TYPE: <code>Any</code> </p> Example Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def add_coding_to_codeable_concept(\n    codeable_concept: Any,\n    code: str,\n    system: str,\n    display: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"Add a coding to an existing CodeableConcept.\n\n    Useful for adding standardized codes (e.g., SNOMED CT) to resources that already\n    have codes from other systems (e.g., ICD-10).\n\n    Args:\n        codeable_concept: The CodeableConcept to add coding to\n        code: The code value from the code system\n        system: The code system URI\n        display: Optional display text for the code\n        version: FHIR version to use. If None, attempts to detect from the CodeableConcept.\n\n    Returns:\n        CodeableConcept: The updated CodeableConcept with the new coding added\n\n    Example:\n        &gt;&gt;&gt; # Add SNOMED CT code to a condition that has ICD-10\n        &gt;&gt;&gt; condition_code = condition.code\n        &gt;&gt;&gt; condition_code = add_coding_to_codeable_concept(\n        ...     condition_code,\n        ...     code=\"44054006\",\n        ...     system=\"http://snomed.info/sct\",\n        ...     display=\"Type 2 diabetes mellitus\"\n        ... )\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource, get_resource_version\n\n    # Detect version from CodeableConcept if not provided\n    if version is None:\n        version = get_resource_version(codeable_concept)\n\n    Coding = get_fhir_resource(\"Coding\", version)\n\n    if not codeable_concept.coding:\n        codeable_concept.coding = []\n\n    codeable_concept.coding.append(Coding(system=system, code=code, display=display))\n\n    return codeable_concept\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_coding_to_codeable_concept--add-snomed-ct-code-to-a-condition-that-has-icd-10","title":"Add SNOMED CT code to a condition that has ICD-10","text":"<p>condition_code = condition.code condition_code = add_coding_to_codeable_concept( ...     condition_code, ...     code=\"44054006\", ...     system=\"http://snomed.info/sct\", ...     display=\"Type 2 diabetes mellitus\" ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_provenance_metadata","title":"<code>add_provenance_metadata(resource, source, tag_code=None, tag_display=None, version=None)</code>","text":"<p>Add provenance metadata to a FHIR resource.</p> <p>Adds source system identifier, timestamp, and optional processing tags to track data lineage and transformations for audit trails.</p> PARAMETER DESCRIPTION <code>resource</code> <p>The FHIR resource to annotate</p> <p> TYPE: <code>Any</code> </p> <code>source</code> <p>Name of the source system (e.g., \"epic\", \"cerner\")</p> <p> TYPE: <code>str</code> </p> <code>tag_code</code> <p>Optional tag code for processing operations (e.g., \"aggregated\", \"deduplicated\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>tag_display</code> <p>Optional display text for the tag</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use. If None, attempts to detect from the resource.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Resource</code> <p>The resource with added provenance metadata</p> <p> TYPE: <code>Any</code> </p> Example <p>condition = create_condition(subject=\"Patient/123\", code=\"E11.9\") condition = add_provenance_metadata(condition, \"epic\", \"aggregated\", \"Aggregated from source\")</p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def add_provenance_metadata(\n    resource: Any,\n    source: str,\n    tag_code: Optional[str] = None,\n    tag_display: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"Add provenance metadata to a FHIR resource.\n\n    Adds source system identifier, timestamp, and optional processing tags to track\n    data lineage and transformations for audit trails.\n\n    Args:\n        resource: The FHIR resource to annotate\n        source: Name of the source system (e.g., \"epic\", \"cerner\")\n        tag_code: Optional tag code for processing operations (e.g., \"aggregated\", \"deduplicated\")\n        tag_display: Optional display text for the tag\n        version: FHIR version to use. If None, attempts to detect from the resource.\n\n    Returns:\n        Resource: The resource with added provenance metadata\n\n    Example:\n        &gt;&gt;&gt; condition = create_condition(subject=\"Patient/123\", code=\"E11.9\")\n        &gt;&gt;&gt; condition = add_provenance_metadata(condition, \"epic\", \"aggregated\", \"Aggregated from source\")\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource, get_resource_version\n\n    # Detect version from resource if not provided\n    if version is None:\n        version = get_resource_version(resource)\n\n    Meta = get_fhir_resource(\"Meta\", version)\n    Coding = get_fhir_resource(\"Coding\", version)\n\n    if not resource.meta:\n        resource.meta = Meta()\n\n    # Add source system identifier\n    resource.meta.source = f\"urn:healthchain:source:{source}\"\n\n    # Update timestamp\n    resource.meta.lastUpdated = datetime.datetime.now(datetime.timezone.utc).isoformat()\n\n    # Add processing tag if provided\n    if tag_code:\n        if not resource.meta.tag:\n            resource.meta.tag = []\n\n        resource.meta.tag.append(\n            Coding(\n                system=\"https://dotimplement.github.io/HealthChain/fhir/tags\",\n                code=tag_code,\n                display=tag_display or tag_code,\n            )\n        )\n\n    return resource\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.add_resource","title":"<code>add_resource(bundle, resource, full_url=None)</code>","text":"<p>Add a resource to a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to add to</p> <p> TYPE: <code>Bundle</code> </p> <code>resource</code> <p>The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance</p> <p> TYPE: <code>Resource</code> </p> <code>full_url</code> <p>Optional full URL for the resource</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def add_resource(\n    bundle: Bundle, resource: Resource, full_url: Optional[str] = None\n) -&gt; None:\n    \"\"\"Add a resource to a bundle.\n\n    Args:\n        bundle: The bundle to add to\n        resource: The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance\n        full_url: Optional full URL for the resource\n    \"\"\"\n    entry = BundleEntry(resource=resource)\n    if full_url:\n        entry.fullUrl = full_url\n    bundle.entry = (bundle.entry or []) + [entry]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_to_dataframe","title":"<code>bundle_to_dataframe(bundle, config=None)</code>","text":"<p>Convert a FHIR Bundle to a pandas DataFrame.</p> <p>Converts FHIR resources to a tabular format with one row per patient. Uses a configuration object to control which resources are processed and how.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>FHIR Bundle resource (object or dict)</p> <p> TYPE: <code>Union[Bundle, Dict[str, Any]]</code> </p> <code>config</code> <p>BundleConverterConfig object specifying conversion behavior. If None, uses default config (Patient + Observation with mean aggregation)</p> <p> TYPE: <code>Optional[BundleConverterConfig]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with one row per patient and columns for each feature</p> Example <p>from healthchain.fhir.converters import BundleConverterConfig</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def bundle_to_dataframe(\n    bundle: Union[Bundle, Dict[str, Any]],\n    config: Optional[BundleConverterConfig] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Convert a FHIR Bundle to a pandas DataFrame.\n\n    Converts FHIR resources to a tabular format with one row per patient.\n    Uses a configuration object to control which resources are processed and how.\n\n    Args:\n        bundle: FHIR Bundle resource (object or dict)\n        config: BundleConverterConfig object specifying conversion behavior.\n            If None, uses default config (Patient + Observation with mean aggregation)\n\n    Returns:\n        DataFrame with one row per patient and columns for each feature\n\n    Example:\n        &gt;&gt;&gt; from healthchain.fhir.converters import BundleConverterConfig\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Default behavior\n        &gt;&gt;&gt; df = bundle_to_dataframe(bundle)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Custom config\n        &gt;&gt;&gt; config = BundleConverterConfig(\n        ...     resources=[\"Patient\", \"Observation\", \"Condition\"],\n        ...     observation_aggregation=\"median\",\n        ...     age_calculation=\"event_date\"\n        ... )\n        &gt;&gt;&gt; df = bundle_to_dataframe(bundle, config=config)\n    \"\"\"\n    # Use default config if not provided\n    if config is None:\n        config = BundleConverterConfig()\n\n    # Group resources by patient\n    patient_data = group_bundle_by_patient(bundle)\n\n    if not patient_data:\n        return pd.DataFrame()\n\n    # Build rows for each patient\n    rows = []\n    for patient_ref, resources in patient_data.items():\n        row = {\"patient_ref\": patient_ref}\n\n        # Process each requested resource type using registry\n        for resource_type in config.resources:\n            handler_info = SUPPORTED_RESOURCES.get(resource_type)\n\n            if not handler_info:\n                # Skip unsupported resources gracefully (already warned by validator)\n                continue\n\n            # Get handler function by name\n            handler_name = handler_info[\"handler\"]\n            handler = globals()[handler_name]\n\n            # Call handler with standardized signature\n            features = handler(resources, config)\n            if features:\n                row.update(features)\n\n        rows.append(row)\n\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_to_dataframe--default-behavior","title":"Default behavior","text":"<p>df = bundle_to_dataframe(bundle)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundle_to_dataframe--custom-config","title":"Custom config","text":"<p>config = BundleConverterConfig( ...     resources=[\"Patient\", \"Observation\", \"Condition\"], ...     observation_aggregation=\"median\", ...     age_calculation=\"event_date\" ... ) df = bundle_to_dataframe(bundle, config=config)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.calculate_age_from_birthdate","title":"<code>calculate_age_from_birthdate(birth_date)</code>","text":"<p>Calculate age in years from a birth date string.</p> PARAMETER DESCRIPTION <code>birth_date</code> <p>Birth date in ISO format (YYYY-MM-DD or full ISO datetime)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[int]</code> <p>Age in years, or None if birth date is invalid</p> Source code in <code>healthchain/fhir/utilities.py</code> <pre><code>def calculate_age_from_birthdate(birth_date: str) -&gt; Optional[int]:\n    \"\"\"Calculate age in years from a birth date string.\n\n    Args:\n        birth_date: Birth date in ISO format (YYYY-MM-DD or full ISO datetime)\n\n    Returns:\n        Age in years, or None if birth date is invalid\n    \"\"\"\n    if not birth_date:\n        return None\n\n    try:\n        if isinstance(birth_date, str):\n            # Remove timezone info for simpler parsing\n            birth_date_clean = birth_date.replace(\"Z\", \"\").split(\"T\")[0]\n            birth_dt = datetime.datetime.strptime(birth_date_clean, \"%Y-%m-%d\")\n        else:\n            birth_dt = birth_date\n\n        # Calculate age\n        today = datetime.datetime.now()\n        age = today.year - birth_dt.year\n\n        # Adjust if birthday hasn't occurred this year\n        if (today.month, today.day) &lt; (birth_dt.month, birth_dt.day):\n            age -= 1\n\n        return age\n    except (ValueError, AttributeError, TypeError):\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.calculate_age_from_event_date","title":"<code>calculate_age_from_event_date(birth_date, event_date)</code>","text":"<p>Calculate age in years from birth date and event date (MIMIC-IV style).</p> <p>Uses the formula: age = year(eventDate) - year(birthDate) This matches MIMIC-IV on FHIR de-identified age calculation.</p> PARAMETER DESCRIPTION <code>birth_date</code> <p>Birth date in ISO format (YYYY-MM-DD or full ISO datetime)</p> <p> TYPE: <code>str</code> </p> <code>event_date</code> <p>Event date in ISO format (YYYY-MM-DD or full ISO datetime)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[int]</code> <p>Age in years based on year difference, or None if dates are invalid</p> Example <p>calculate_age_from_event_date(\"1990-06-15\", \"2020-03-10\") 30</p> Source code in <code>healthchain/fhir/utilities.py</code> <pre><code>def calculate_age_from_event_date(birth_date: str, event_date: str) -&gt; Optional[int]:\n    \"\"\"Calculate age in years from birth date and event date (MIMIC-IV style).\n\n    Uses the formula: age = year(eventDate) - year(birthDate)\n    This matches MIMIC-IV on FHIR de-identified age calculation.\n\n    Args:\n        birth_date: Birth date in ISO format (YYYY-MM-DD or full ISO datetime)\n        event_date: Event date in ISO format (YYYY-MM-DD or full ISO datetime)\n\n    Returns:\n        Age in years based on year difference, or None if dates are invalid\n\n    Example:\n        &gt;&gt;&gt; calculate_age_from_event_date(\"1990-06-15\", \"2020-03-10\")\n        30\n    \"\"\"\n    if not birth_date or not event_date:\n        return None\n\n    try:\n        # Parse birth date\n        if isinstance(birth_date, str):\n            birth_date_clean = birth_date.replace(\"Z\", \"\").split(\"T\")[0]\n            birth_year = int(birth_date_clean.split(\"-\")[0])\n        else:\n            birth_year = birth_date.year\n\n        # Parse event date\n        if isinstance(event_date, str):\n            event_date_clean = event_date.replace(\"Z\", \"\").split(\"T\")[0]\n            event_year = int(event_date_clean.split(\"-\")[0])\n        else:\n            event_year = event_date.year\n\n        # MIMIC-IV style: simple year difference\n        age = event_year - birth_year\n\n        return age\n    except (ValueError, AttributeError, TypeError, IndexError):\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.convert_prefetch_to_fhir_objects","title":"<code>convert_prefetch_to_fhir_objects(prefetch_dict)</code>","text":"<p>Convert a dictionary of FHIR resource dicts to FHIR Resource objects.</p> <p>Takes a prefetch dictionary where values may be either dict representations of FHIR resources or already instantiated FHIR Resource objects, and ensures all values are FHIR Resource objects.</p> PARAMETER DESCRIPTION <code>prefetch_dict</code> <p>Dictionary mapping keys to FHIR resource dicts or objects</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Resource]</code> <p>Dict[str, Resource]: Dictionary with same keys but all values as FHIR Resource objects</p> Example <p>prefetch = { ...     \"patient\": {\"resourceType\": \"Patient\", \"id\": \"123\"}, ...     \"condition\": Condition(id=\"456\", ...) ... } fhir_objects = convert_prefetch_to_fhir_objects(prefetch) isinstance(fhir_objects[\"patient\"], Patient)  # True isinstance(fhir_objects[\"condition\"], Condition)  # True</p> Source code in <code>healthchain/fhir/readers.py</code> <pre><code>def convert_prefetch_to_fhir_objects(\n    prefetch_dict: Dict[str, Any],\n) -&gt; Dict[str, Resource]:\n    \"\"\"Convert a dictionary of FHIR resource dicts to FHIR Resource objects.\n\n    Takes a prefetch dictionary where values may be either dict representations of FHIR\n    resources or already instantiated FHIR Resource objects, and ensures all values are\n    FHIR Resource objects.\n\n    Args:\n        prefetch_dict: Dictionary mapping keys to FHIR resource dicts or objects\n\n    Returns:\n        Dict[str, Resource]: Dictionary with same keys but all values as FHIR Resource objects\n\n    Example:\n        &gt;&gt;&gt; prefetch = {\n        ...     \"patient\": {\"resourceType\": \"Patient\", \"id\": \"123\"},\n        ...     \"condition\": Condition(id=\"456\", ...)\n        ... }\n        &gt;&gt;&gt; fhir_objects = convert_prefetch_to_fhir_objects(prefetch)\n        &gt;&gt;&gt; isinstance(fhir_objects[\"patient\"], Patient)  # True\n        &gt;&gt;&gt; isinstance(fhir_objects[\"condition\"], Condition)  # True\n    \"\"\"\n    from fhir.resources import get_fhir_model_class\n\n    result: Dict[str, Resource] = {}\n\n    for key, resource_data in prefetch_dict.items():\n        if isinstance(resource_data, dict):\n            # Convert dict to FHIR Resource object\n            resource_type = resource_data.get(\"resourceType\")\n            if resource_type:\n                try:\n                    # Fix timezone-naive datetimes before validation\n                    fixed_data = _fix_timezone_naive_datetimes(resource_data)\n                    resource_class = get_fhir_model_class(resource_type)\n                    result[key] = resource_class(**fixed_data)\n                except Exception as e:\n                    logger.warning(\n                        f\"Failed to convert {resource_type} to FHIR object: {e}\"\n                    )\n                    result[key] = resource_data\n            else:\n                logger.warning(\n                    f\"No resourceType found for key '{key}', keeping as dict\"\n                )\n                result[key] = resource_data\n        elif isinstance(resource_data, Resource):\n            # Already a FHIR object\n            result[key] = resource_data\n        else:\n            logger.warning(f\"Unexpected type for key '{key}': {type(resource_data)}\")\n            result[key] = resource_data\n\n    return result\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.convert_resource","title":"<code>convert_resource(resource, target_version)</code>","text":"<p>Convert a FHIR resource to a different version.</p> <p>Converts by serializing the resource to a dictionary and deserializing with the target version's resource class. This approach works for resources with compatible field structures.</p> Note <p>Field mappings between FHIR versions may not be 1:1. Some fields may be added, removed, or renamed between versions. This function performs a best-effort conversion and may raise validation errors if the resource data is incompatible with the target version.</p> PARAMETER DESCRIPTION <code>resource</code> <p>The FHIR resource to convert</p> <p> TYPE: <code>Any</code> </p> <code>target_version</code> <p>The target FHIR version</p> <p> TYPE: <code>Union[FHIRVersion, str]</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>A new resource instance of the target version</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the resource type cannot be determined or imported</p> <code>ValidationError</code> <p>If the resource data is incompatible with target version</p> Example <p>from fhir.resources.patient import Patient patient_r5 = Patient(id=\"123\", gender=\"male\") patient_r4b = convert_resource(patient_r5, \"R4B\") print(patient_r4b.class.module) fhir.resources.R4B.patient</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def convert_resource(resource: Any, target_version: Union[FHIRVersion, str]) -&gt; Any:\n    \"\"\"Convert a FHIR resource to a different version.\n\n    Converts by serializing the resource to a dictionary and deserializing\n    with the target version's resource class. This approach works for\n    resources with compatible field structures.\n\n    Note:\n        Field mappings between FHIR versions may not be 1:1. Some fields\n        may be added, removed, or renamed between versions. This function\n        performs a best-effort conversion and may raise validation errors\n        if the resource data is incompatible with the target version.\n\n    Args:\n        resource: The FHIR resource to convert\n        target_version: The target FHIR version\n\n    Returns:\n        A new resource instance of the target version\n\n    Raises:\n        ValueError: If the resource type cannot be determined or imported\n        ValidationError: If the resource data is incompatible with target version\n\n    Example:\n        &gt;&gt;&gt; from fhir.resources.patient import Patient\n        &gt;&gt;&gt; patient_r5 = Patient(id=\"123\", gender=\"male\")\n        &gt;&gt;&gt; patient_r4b = convert_resource(patient_r5, \"R4B\")\n        &gt;&gt;&gt; print(patient_r4b.__class__.__module__)\n        fhir.resources.R4B.patient\n    \"\"\"\n    # Get the resource type name from the class\n    resource_type = resource.__class__.__name__\n\n    # Get the target version's resource class\n    target_class = get_fhir_resource(resource_type, target_version)\n\n    # Serialize to dict and deserialize with target class\n    data = resource.model_dump(exclude_none=True)\n\n    logger.debug(\n        f\"Converting {resource_type} from {resource.__class__.__module__} \"\n        f\"to {target_class.__module__}\"\n    )\n\n    return target_class.model_validate(data)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.count_resources","title":"<code>count_resources(bundle)</code>","text":"<p>Count resources by type in a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The FHIR Bundle to analyze</p> <p> TYPE: <code>Bundle</code> </p> RETURNS DESCRIPTION <code>dict[str, int]</code> <p>Dictionary mapping resource type names to their counts.</p> <code>Example</code> <p>{\"Condition\": 2, \"MedicationStatement\": 1, \"Patient\": 1}</p> <p> TYPE: <code>dict[str, int]</code> </p> Example <p>bundle = create_bundle() add_resource(bundle, create_condition(...)) add_resource(bundle, create_condition(...)) add_resource(bundle, create_medication_statement(...)) counts = count_resources(bundle) print(counts)</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def count_resources(bundle: Bundle) -&gt; dict[str, int]:\n    \"\"\"Count resources by type in a bundle.\n\n    Args:\n        bundle: The FHIR Bundle to analyze\n\n    Returns:\n        Dictionary mapping resource type names to their counts.\n        Example: {\"Condition\": 2, \"MedicationStatement\": 1, \"Patient\": 1}\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; add_resource(bundle, create_condition(...))\n        &gt;&gt;&gt; add_resource(bundle, create_condition(...))\n        &gt;&gt;&gt; add_resource(bundle, create_medication_statement(...))\n        &gt;&gt;&gt; counts = count_resources(bundle)\n        &gt;&gt;&gt; print(counts)\n        {'Condition': 2, 'MedicationStatement': 1}\n    \"\"\"\n    if not bundle or not bundle.entry:\n        return {}\n\n    counts: dict[str, int] = {}\n    for entry in bundle.entry:\n        if entry.resource:\n            # Get the resource type from the class name\n            resource_type = entry.resource.__resource_type__\n            counts[resource_type] = counts.get(resource_type, 0) + 1\n\n    return counts\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_allergy_intolerance","title":"<code>create_allergy_intolerance(patient, code=None, display=None, system='http://snomed.info/sct', version=None)</code>","text":"<p>Create a minimal active FHIR AllergyIntolerance. If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly. https://build.fhir.org/allergyintolerance.html</p> PARAMETER DESCRIPTION <code>patient</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>code</code> <p>The allergen code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the allergen</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AllergyIntolerance</code> <p>A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_allergy_intolerance(\n    patient: str,\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal active FHIR AllergyIntolerance.\n    If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly.\n    https://build.fhir.org/allergyintolerance.html\n\n    Args:\n        patient: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        code: The allergen code\n        display: The display name for the allergen\n        system: The code system (default: SNOMED CT)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        AllergyIntolerance: A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    AllergyIntolerance = get_fhir_resource(\"AllergyIntolerance\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n\n    if code:\n        allergy_code = create_single_codeable_concept(code, display, system, version)\n    else:\n        allergy_code = None\n\n    allergy = AllergyIntolerance(\n        id=_generate_id(),\n        patient=ReferenceClass(reference=patient),\n        code=allergy_code,\n    )\n\n    return allergy\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_bundle","title":"<code>create_bundle(bundle_type='collection')</code>","text":"<p>Create an empty FHIR Bundle. https://www.hl7.org/fhir/bundle.html</p> PARAMETER DESCRIPTION <code>bundle_type</code> <p>The type of bundle (default: collection) Valid types: document, message, transaction, transaction-response, batch, batch-response, history, searchset, collection</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def create_bundle(bundle_type: str = \"collection\") -&gt; Bundle:\n    \"\"\"Create an empty FHIR Bundle.\n    https://www.hl7.org/fhir/bundle.html\n\n    Args:\n        bundle_type: The type of bundle (default: collection)\n            Valid types: document, message, transaction, transaction-response,\n            batch, batch-response, history, searchset, collection\n    \"\"\"\n    return Bundle(type=bundle_type, entry=[])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_condition","title":"<code>create_condition(subject, clinical_status='active', code=None, display=None, system='http://snomed.info/sct', version=None)</code>","text":"<p>Create a minimal active FHIR Condition. If you need to create a more complex condition, use the FHIR Condition resource directly. https://build.fhir.org/condition.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>clinical_status</code> <p>REQUIRED. Clinical status (default: active)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'active'</code> </p> <code>code</code> <p>The condition code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the condition</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_condition(\n    subject: str,\n    clinical_status: str = \"active\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal active FHIR Condition.\n    If you need to create a more complex condition, use the FHIR Condition resource directly.\n    https://build.fhir.org/condition.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        clinical_status: REQUIRED. Clinical status (default: active)\n        code: The condition code\n        display: The display name for the condition\n        system: The code system (default: SNOMED CT)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        Condition: A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    Condition = get_fhir_resource(\"Condition\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n\n    if code:\n        condition_code = create_single_codeable_concept(code, display, system, version)\n    else:\n        condition_code = None\n\n    condition = Condition(\n        id=_generate_id(),\n        subject=ReferenceClass(reference=subject),\n        clinicalStatus=create_single_codeable_concept(\n            code=clinical_status,\n            display=clinical_status.capitalize(),\n            system=\"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            version=version,\n        ),\n        code=condition_code,\n    )\n\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_document_reference","title":"<code>create_document_reference(data=None, url=None, content_type=None, status='current', description='DocumentReference created by HealthChain', attachment_title='Attachment created by HealthChain', version=None)</code>","text":"<p>Create a minimal FHIR DocumentReference. If you need to create a more complex document reference, use the FHIR DocumentReference resource directly. https://build.fhir.org/documentreference.html</p> PARAMETER DESCRIPTION <code>data</code> <p>The data content of the document attachment</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>URL where the document can be accessed</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content_type</code> <p>MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>REQUIRED. Status of the document reference (default: current)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>description</code> <p>Description of the document reference</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'DocumentReference created by HealthChain'</code> </p> <code>attachment_title</code> <p>Title for the document attachment</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DocumentReference</code> <p>A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_document_reference(\n    data: Optional[Any] = None,\n    url: Optional[str] = None,\n    content_type: Optional[str] = None,\n    status: str = \"current\",\n    description: Optional[str] = \"DocumentReference created by HealthChain\",\n    attachment_title: Optional[str] = \"Attachment created by HealthChain\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal FHIR DocumentReference.\n    If you need to create a more complex document reference, use the FHIR DocumentReference resource directly.\n    https://build.fhir.org/documentreference.html\n\n    Args:\n        data: The data content of the document attachment\n        url: URL where the document can be accessed\n        content_type: MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")\n        status: REQUIRED. Status of the document reference (default: current)\n        description: Description of the document reference\n        attachment_title: Title for the document attachment\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        DocumentReference: A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    DocumentReference = get_fhir_resource(\"DocumentReference\", version)\n\n    document_reference = DocumentReference(\n        id=_generate_id(),\n        status=status,\n        date=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n        description=description,\n        content=[\n            {\n                \"attachment\": create_single_attachment(\n                    content_type=content_type,\n                    data=data,\n                    url=url,\n                    title=attachment_title,\n                    version=version,\n                )\n            }\n        ],\n    )\n\n    return document_reference\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_document_reference_content","title":"<code>create_document_reference_content(attachment_data=None, url=None, content_type='text/plain', language='en-US', title=None, version=None, **kwargs)</code>","text":"<p>Create a FHIR DocumentReferenceContent object.</p> <p>Creates a DocumentReferenceContent structure that can be added to a DocumentReference. Either attachment_data or url must be provided. If attachment_data is provided, it will be base64 encoded automatically.</p> PARAMETER DESCRIPTION <code>attachment_data</code> <p>The content data (text that will be base64 encoded)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>URL where the content can be accessed</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content_type</code> <p>MIME type (e.g., 'text/plain', 'text/html', 'application/pdf') (default: text/plain)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'text/plain'</code> </p> <code>language</code> <p>Language code (default: en-US)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'en-US'</code> </p> <code>title</code> <p>Optional title for the content (default: \"Attachment created by HealthChain\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional DocumentReferenceContent fields (e.g., format, profile)</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A FHIR DocumentReferenceContent dictionary with attachment and optional language</p> Example Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_document_reference_content(\n    attachment_data: Optional[str] = None,\n    url: Optional[str] = None,\n    content_type: str = \"text/plain\",\n    language: Optional[str] = \"en-US\",\n    title: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n    **kwargs,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a FHIR DocumentReferenceContent object.\n\n    Creates a DocumentReferenceContent structure that can be added to a DocumentReference.\n    Either attachment_data or url must be provided. If attachment_data is provided, it will\n    be base64 encoded automatically.\n\n    Args:\n        attachment_data: The content data (text that will be base64 encoded)\n        url: URL where the content can be accessed\n        content_type: MIME type (e.g., 'text/plain', 'text/html', 'application/pdf') (default: text/plain)\n        language: Language code (default: en-US)\n        title: Optional title for the content (default: \"Attachment created by HealthChain\")\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n        **kwargs: Additional DocumentReferenceContent fields (e.g., format, profile)\n\n    Returns:\n        Dict[str, Any]: A FHIR DocumentReferenceContent dictionary with attachment and optional language\n\n    Example:\n        &gt;&gt;&gt; # Create content with inline data\n        &gt;&gt;&gt; content = create_document_reference_content(\n        ...     attachment_data=\"Patient presents with fever...\",\n        ...     content_type=\"text/plain\",\n        ...     title=\"Clinical Note\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create content with URL reference\n        &gt;&gt;&gt; content = create_document_reference_content(\n        ...     url=\"https://example.com/document.pdf\",\n        ...     content_type=\"application/pdf\",\n        ...     title=\"Lab Report\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Add content to a DocumentReference\n        &gt;&gt;&gt; doc_ref = DocumentReference(\n        ...     id=\"doc-1\",\n        ...     status=\"current\",\n        ...     content=[content]\n        ... )\n    \"\"\"\n    if not attachment_data and not url:\n        logger.warning(\n            \"No attachment_data or url provided for DocumentReferenceContent\"\n        )\n\n    if title is None:\n        title = \"Attachment created by HealthChain\"\n\n    attachment = create_single_attachment(\n        content_type=content_type,\n        data=attachment_data,\n        url=url,\n        title=title,\n        version=version,\n    )\n\n    content: Dict[str, Any] = {\n        \"attachment\": attachment,\n    }\n\n    if language:\n        content[\"language\"] = language\n\n    content.update(kwargs)\n\n    return content\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_document_reference_content--create-content-with-inline-data","title":"Create content with inline data","text":"<p>content = create_document_reference_content( ...     attachment_data=\"Patient presents with fever...\", ...     content_type=\"text/plain\", ...     title=\"Clinical Note\" ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_document_reference_content--create-content-with-url-reference","title":"Create content with URL reference","text":"<p>content = create_document_reference_content( ...     url=\"https://example.com/document.pdf\", ...     content_type=\"application/pdf\", ...     title=\"Lab Report\" ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_document_reference_content--add-content-to-a-documentreference","title":"Add content to a DocumentReference","text":"<p>doc_ref = DocumentReference( ...     id=\"doc-1\", ...     status=\"current\", ...     content=[content] ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_medication_statement","title":"<code>create_medication_statement(subject, status='recorded', code=None, display=None, system='http://snomed.info/sct', version=None)</code>","text":"<p>Create a minimal recorded FHIR MedicationStatement. If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly. https://build.fhir.org/medicationstatement.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>status</code> <p>REQUIRED. Status of the medication (default: recorded)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'recorded'</code> </p> <code>code</code> <p>The medication code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the medication</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>MedicationStatement</code> <p>A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_medication_statement(\n    subject: str,\n    status: Optional[str] = \"recorded\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal recorded FHIR MedicationStatement.\n    If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly.\n    https://build.fhir.org/medicationstatement.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        status: REQUIRED. Status of the medication (default: recorded)\n        code: The medication code\n        display: The display name for the medication\n        system: The code system (default: SNOMED CT)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        MedicationStatement: A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    MedicationStatement = get_fhir_resource(\"MedicationStatement\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n\n    if code:\n        medication_concept = create_single_codeable_concept(\n            code, display, system, version\n        )\n    else:\n        medication_concept = None\n\n    medication = MedicationStatement(\n        id=_generate_id(),\n        subject=ReferenceClass(reference=subject),\n        status=status,\n        medication={\"concept\": medication_concept},\n    )\n\n    return medication\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_patient","title":"<code>create_patient(gender=None, birth_date=None, identifier=None, identifier_system='http://hospital.example.org', version=None)</code>","text":"<p>Create a minimal FHIR Patient resource with basic gender and birthdate If you need to create a more complex patient, use the FHIR Patient resource directly https://hl7.org/fhir/patient.html (No required fields).</p> PARAMETER DESCRIPTION <code>gender</code> <p>Administrative gender (male, female, other, unknown)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>birth_date</code> <p>Birth date in YYYY-MM-DD format</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>identifier</code> <p>Optional identifier value for the patient (e.g., MRN)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>identifier_system</code> <p>The system for the identifier (default: \"http://hospital.example.org\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://hospital.example.org'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Patient</code> <p>A FHIR Patient resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_patient(\n    gender: Optional[str] = None,\n    birth_date: Optional[str] = None,\n    identifier: Optional[str] = None,\n    identifier_system: Optional[str] = \"http://hospital.example.org\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal FHIR Patient resource with basic gender and birthdate\n    If you need to create a more complex patient, use the FHIR Patient resource directly\n    https://hl7.org/fhir/patient.html (No required fields).\n\n    Args:\n        gender: Administrative gender (male, female, other, unknown)\n        birth_date: Birth date in YYYY-MM-DD format\n        identifier: Optional identifier value for the patient (e.g., MRN)\n        identifier_system: The system for the identifier (default: \"http://hospital.example.org\")\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        Patient: A FHIR Patient resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    Patient = get_fhir_resource(\"Patient\", version)\n    Identifier = get_fhir_resource(\"Identifier\", version)\n\n    patient_id = _generate_id()\n\n    patient_data: Dict[str, Any] = {\"id\": patient_id}\n\n    if birth_date:\n        patient_data[\"birthDate\"] = birth_date\n\n    if gender:\n        patient_data[\"gender\"] = gender.lower()\n\n    if identifier:\n        patient_data[\"identifier\"] = [\n            Identifier(\n                system=identifier_system,\n                value=identifier,\n            )\n        ]\n\n    patient = Patient(**patient_data)\n    return patient\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_resource_from_dict","title":"<code>create_resource_from_dict(resource_dict, resource_type)</code>","text":"<p>Create a FHIR resource instance from a dictionary</p> PARAMETER DESCRIPTION <code>resource_dict</code> <p>Dictionary representation of the resource</p> <p> TYPE: <code>Dict</code> </p> <code>resource_type</code> <p>Type of FHIR resource to create</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Resource]</code> <p>Optional[Resource]: FHIR resource instance or None if creation failed</p> Source code in <code>healthchain/fhir/readers.py</code> <pre><code>def create_resource_from_dict(\n    resource_dict: Dict, resource_type: str\n) -&gt; Optional[Resource]:\n    \"\"\"Create a FHIR resource instance from a dictionary\n\n    Args:\n        resource_dict: Dictionary representation of the resource\n        resource_type: Type of FHIR resource to create\n\n    Returns:\n        Optional[Resource]: FHIR resource instance or None if creation failed\n    \"\"\"\n    try:\n        resource_module = importlib.import_module(\n            f\"fhir.resources.{resource_type.lower()}\"\n        )\n        resource_class = getattr(resource_module, resource_type)\n        return resource_class(**resource_dict)\n    except Exception as e:\n        logger.error(f\"Failed to create FHIR resource: {str(e)}\")\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_risk_assessment_from_prediction","title":"<code>create_risk_assessment_from_prediction(subject, prediction, status='final', method=None, basis=None, comment=None, occurrence_datetime=None, version=None)</code>","text":"<p>Create a FHIR RiskAssessment from ML model prediction output. If you need to create a more complex risk assessment, use the FHIR RiskAssessment resource directly. https://hl7.org/fhir/riskassessment.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>prediction</code> <p>Dictionary containing prediction details with keys: - outcome: CodeableConcept or dict with code, display, system for the predicted outcome - probability: float between 0 and 1 representing the risk probability - qualitative_risk: Optional str indicating risk level (e.g., \"high\", \"moderate\", \"low\")</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>status</code> <p>REQUIRED. The status of the assessment (default: \"final\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'final'</code> </p> <code>method</code> <p>Optional CodeableConcept describing the assessment method/model used</p> <p> TYPE: <code>Optional[CodeableConcept]</code> DEFAULT: <code>None</code> </p> <code>basis</code> <p>Optional list of References to observations or other resources used as input</p> <p> TYPE: <code>Optional[List[Reference]]</code> DEFAULT: <code>None</code> </p> <code>comment</code> <p>Optional text comment about the assessment</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>occurrence_datetime</code> <p>When the assessment was made (ISO format). Uses current time if not provided.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>RiskAssessment</code> <p>A FHIR RiskAssessment resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Example <p>prediction = { ...     \"outcome\": {\"code\": \"A41.9\", \"display\": \"Sepsis\", \"system\": \"http://hl7.org/fhir/sid/icd-10\"}, ...     \"probability\": 0.85, ...     \"qualitative_risk\": \"high\" ... } risk = create_risk_assessment(\"Patient/123\", prediction)</p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_risk_assessment_from_prediction(\n    subject: str,\n    prediction: Dict[str, Any],\n    status: str = \"final\",\n    method: Optional[CodeableConcept] = None,\n    basis: Optional[List[Reference]] = None,\n    comment: Optional[str] = None,\n    occurrence_datetime: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a FHIR RiskAssessment from ML model prediction output.\n    If you need to create a more complex risk assessment, use the FHIR RiskAssessment resource directly.\n    https://hl7.org/fhir/riskassessment.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        prediction: Dictionary containing prediction details with keys:\n            - outcome: CodeableConcept or dict with code, display, system for the predicted outcome\n            - probability: float between 0 and 1 representing the risk probability\n            - qualitative_risk: Optional str indicating risk level (e.g., \"high\", \"moderate\", \"low\")\n        status: REQUIRED. The status of the assessment (default: \"final\")\n        method: Optional CodeableConcept describing the assessment method/model used\n        basis: Optional list of References to observations or other resources used as input\n        comment: Optional text comment about the assessment\n        occurrence_datetime: When the assessment was made (ISO format). Uses current time if not provided.\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        RiskAssessment: A FHIR RiskAssessment resource with an auto-generated ID prefixed with 'hc-'\n\n    Example:\n        &gt;&gt;&gt; prediction = {\n        ...     \"outcome\": {\"code\": \"A41.9\", \"display\": \"Sepsis\", \"system\": \"http://hl7.org/fhir/sid/icd-10\"},\n        ...     \"probability\": 0.85,\n        ...     \"qualitative_risk\": \"high\"\n        ... }\n        &gt;&gt;&gt; risk = create_risk_assessment(\"Patient/123\", prediction)\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    RiskAssessment = get_fhir_resource(\"RiskAssessment\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n\n    if not occurrence_datetime:\n        occurrence_datetime = datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        )\n\n    outcome = prediction.get(\"outcome\")\n    if isinstance(outcome, dict):\n        outcome_concept = create_single_codeable_concept(\n            code=outcome[\"code\"],\n            display=outcome.get(\"display\"),\n            system=outcome.get(\"system\", \"http://snomed.info/sct\"),\n            version=version,\n        )\n    else:\n        outcome_concept = outcome\n\n    prediction_data: Dict[str, Any] = {\n        \"outcome\": outcome_concept,\n    }\n\n    if \"probability\" in prediction:\n        prediction_data[\"probabilityDecimal\"] = prediction[\"probability\"]\n\n    if \"qualitative_risk\" in prediction:\n        prediction_data[\"qualitativeRisk\"] = create_single_codeable_concept(\n            code=prediction[\"qualitative_risk\"],\n            display=prediction[\"qualitative_risk\"].capitalize(),\n            system=\"http://terminology.hl7.org/CodeSystem/risk-probability\",\n            version=version,\n        )\n\n    risk_assessment_data: Dict[str, Any] = {\n        \"id\": _generate_id(),\n        \"status\": status,\n        \"subject\": ReferenceClass(reference=subject),\n        \"occurrenceDateTime\": occurrence_datetime,\n        \"prediction\": [prediction_data],\n    }\n\n    if method:\n        risk_assessment_data[\"method\"] = method\n\n    if basis:\n        risk_assessment_data[\"basis\"] = basis\n\n    if comment:\n        risk_assessment_data[\"note\"] = [{\"text\": comment}]\n\n    risk_assessment = RiskAssessment(**risk_assessment_data)\n\n    return risk_assessment\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_attachment","title":"<code>create_single_attachment(content_type=None, data=None, url=None, title='Attachment created by HealthChain', version=None)</code>","text":"<p>Create a minimal FHIR Attachment.</p> <p>Creates a FHIR Attachment resource with basic fields. Either data or url should be provided. If data is provided, it will be base64 encoded.</p> PARAMETER DESCRIPTION <code>content_type</code> <p>The MIME type of the content</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>data</code> <p>The actual data content to be base64 encoded</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>The URL where the data can be found</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>A title for the attachment (default: \"Attachment created by HealthChain\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Attachment</code> <p>A FHIR Attachment resource with basic metadata and content</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/elementhelpers.py</code> <pre><code>def create_single_attachment(\n    content_type: Optional[str] = None,\n    data: Optional[str] = None,\n    url: Optional[str] = None,\n    title: Optional[str] = \"Attachment created by HealthChain\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"Create a minimal FHIR Attachment.\n\n    Creates a FHIR Attachment resource with basic fields. Either data or url should be provided.\n    If data is provided, it will be base64 encoded.\n\n    Args:\n        content_type: The MIME type of the content\n        data: The actual data content to be base64 encoded\n        url: The URL where the data can be found\n        title: A title for the attachment (default: \"Attachment created by HealthChain\")\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        Attachment: A FHIR Attachment resource with basic metadata and content\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    Attachment = get_fhir_resource(\"Attachment\", version)\n\n    if not data and not url:\n        logger.warning(\"No data or url provided for attachment\")\n\n    if data:\n        data = base64.b64encode(data.encode(\"utf-8\")).decode(\"utf-8\")\n\n    return Attachment(\n        contentType=content_type,\n        data=data,\n        url=url,\n        title=title,\n        creation=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n    )\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_codeable_concept","title":"<code>create_single_codeable_concept(code, display=None, system='http://snomed.info/sct', version=None)</code>","text":"<p>Create a minimal FHIR CodeableConcept with a single coding.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>A FHIR CodeableConcept resource with a single coding</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/elementhelpers.py</code> <pre><code>def create_single_codeable_concept(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal FHIR CodeableConcept with a single coding.\n\n    Args:\n        code: REQUIRED. The code value from the code system\n        display: The display name for the code\n        system: The code system (default: SNOMED CT)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        CodeableConcept: A FHIR CodeableConcept resource with a single coding\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    CodeableConcept = get_fhir_resource(\"CodeableConcept\", version)\n    Coding = get_fhir_resource(\"Coding\", version)\n\n    return CodeableConcept(coding=[Coding(system=system, code=code, display=display)])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_single_reaction","title":"<code>create_single_reaction(code, display=None, system='http://snomed.info/sct', severity=None, version=None)</code>","text":"<p>Create a minimal FHIR Reaction with a single coding.</p> <p>Creates a FHIR Reaction object with a single manifestation coding. The manifestation describes the clinical reaction that was observed. The severity indicates how severe the reaction was.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system representing the reaction manifestation</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the manifestation code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system for the manifestation code (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>severity</code> <p>The severity of the reaction (mild, moderate, severe)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>A list containing a single FHIR Reaction dictionary with manifestation and severity fields</p> Source code in <code>healthchain/fhir/elementhelpers.py</code> <pre><code>def create_single_reaction(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    severity: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create a minimal FHIR Reaction with a single coding.\n\n    Creates a FHIR Reaction object with a single manifestation coding. The manifestation\n    describes the clinical reaction that was observed. The severity indicates how severe\n    the reaction was.\n\n    Args:\n        code: REQUIRED. The code value from the code system representing the reaction manifestation\n        display: The display name for the manifestation code\n        system: The code system for the manifestation code (default: SNOMED CT)\n        severity: The severity of the reaction (mild, moderate, severe)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        A list containing a single FHIR Reaction dictionary with manifestation and severity fields\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    CodeableConcept = get_fhir_resource(\"CodeableConcept\", version)\n    CodeableReference = get_fhir_resource(\"CodeableReference\", version)\n    Coding = get_fhir_resource(\"Coding\", version)\n\n    return [\n        {\n            \"manifestation\": [\n                CodeableReference(\n                    concept=CodeableConcept(\n                        coding=[Coding(system=system, code=code, display=display)]\n                    )\n                )\n            ],\n            \"severity\": severity,\n        }\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.create_value_quantity_observation","title":"<code>create_value_quantity_observation(code, value, unit, status='final', subject=None, system='http://loinc.org', display=None, effective_datetime=None, version=None)</code>","text":"<p>Create a minimal FHIR Observation for vital signs or laboratory values. If you need to create a more complex observation, use the FHIR Observation resource directly. https://hl7.org/fhir/observation.html</p> PARAMETER DESCRIPTION <code>status</code> <p>REQUIRED. The status of the observation (default: \"final\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'final'</code> </p> <code>code</code> <p>REQUIRED. The observation code (e.g., LOINC code for the measurement)</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The numeric value of the observation</p> <p> TYPE: <code>float</code> </p> <code>unit</code> <p>The unit of measure (e.g., \"beats/min\", \"mg/dL\")</p> <p> TYPE: <code>str</code> </p> <code>system</code> <p>The code system for the observation code (default: LOINC)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://loinc.org'</code> </p> <code>display</code> <p>The display name for the observation code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>effective_datetime</code> <p>When the observation was made (ISO format). Uses current time if not provided.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>subject</code> <p>Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Observation</code> <p>A FHIR Observation resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_value_quantity_observation(\n    code: str,\n    value: float,\n    unit: str,\n    status: str = \"final\",\n    subject: Optional[str] = None,\n    system: str = \"http://loinc.org\",\n    display: Optional[str] = None,\n    effective_datetime: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal FHIR Observation for vital signs or laboratory values.\n    If you need to create a more complex observation, use the FHIR Observation resource directly.\n    https://hl7.org/fhir/observation.html\n\n    Args:\n        status: REQUIRED. The status of the observation (default: \"final\")\n        code: REQUIRED. The observation code (e.g., LOINC code for the measurement)\n        value: The numeric value of the observation\n        unit: The unit of measure (e.g., \"beats/min\", \"mg/dL\")\n        system: The code system for the observation code (default: LOINC)\n        display: The display name for the observation code\n        effective_datetime: When the observation was made (ISO format). Uses current time if not provided.\n        subject: Reference to the patient (e.g. \"Patient/123\")\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        Observation: A FHIR Observation resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    Observation = get_fhir_resource(\"Observation\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n    Quantity = get_fhir_resource(\"Quantity\", version)\n\n    if not effective_datetime:\n        effective_datetime = datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        )\n    subject_ref = None\n    if subject is not None:\n        subject_ref = ReferenceClass(reference=subject)\n\n    observation = Observation(\n        id=_generate_id(),\n        status=status,\n        code=create_single_codeable_concept(code, display, system, version),\n        subject=subject_ref,\n        effectiveDateTime=effective_datetime,\n        valueQuantity=Quantity(\n            value=value, unit=unit, system=\"http://unitsofmeasure.org\", code=unit\n        ),\n    )\n\n    return observation\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.encode_gender","title":"<code>encode_gender(gender)</code>","text":"<p>Encode gender as integer for ML models.</p> <p>Standard encoding: Male=1, Female=0, Other/Unknown=None</p> PARAMETER DESCRIPTION <code>gender</code> <p>Gender string (case-insensitive)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[int]</code> <p>Encoded gender (1 for male, 0 for female, None for other/unknown)</p> Source code in <code>healthchain/fhir/utilities.py</code> <pre><code>def encode_gender(gender: str) -&gt; Optional[int]:\n    \"\"\"Encode gender as integer for ML models.\n\n    Standard encoding: Male=1, Female=0, Other/Unknown=None\n\n    Args:\n        gender: Gender string (case-insensitive)\n\n    Returns:\n        Encoded gender (1 for male, 0 for female, None for other/unknown)\n    \"\"\"\n    if not gender:\n        return None\n\n    gender_lower = gender.lower()\n    if gender_lower in [\"male\", \"m\"]:\n        return 1\n    elif gender_lower in [\"female\", \"f\"]:\n        return 0\n    else:\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.extract_resources","title":"<code>extract_resources(bundle, resource_type)</code>","text":"<p>Remove resources of a given type from a bundle and return them.</p> <p>Useful for extracting and separating specific resource types (e.g., OperationOutcome) from a FHIR Bundle, modifying the bundle in place.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The FHIR Bundle to process (modified in place)</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>The FHIR resource class or string name to extract (e.g., OperationOutcome or \"OperationOutcome\")</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List[Resource]: All resources of the specified type that were in the bundle</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def extract_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Remove resources of a given type from a bundle and return them.\n\n    Useful for extracting and separating specific resource types (e.g., OperationOutcome)\n    from a FHIR Bundle, modifying the bundle in place.\n\n    Args:\n        bundle: The FHIR Bundle to process (modified in place)\n        resource_type: The FHIR resource class or string name to extract (e.g., OperationOutcome or \"OperationOutcome\")\n\n    Returns:\n        List[Resource]: All resources of the specified type that were in the bundle\n    \"\"\"\n    if not bundle or not bundle.entry:\n        return []\n\n    type_class = get_resource_type(resource_type)\n\n    extracted: List[Resource] = []\n    remaining_entries: List[BundleEntry] = []\n\n    for entry in bundle.entry:\n        resource = entry.resource\n        if isinstance(resource, type_class):\n            extracted.append(resource)\n            continue\n        remaining_entries.append(entry)\n\n    bundle.entry = remaining_entries\n    return extracted\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.fhir_version_context","title":"<code>fhir_version_context(version)</code>","text":"<p>Context manager for temporarily changing the default FHIR version.</p> PARAMETER DESCRIPTION <code>version</code> <p>The FHIR version to use within the context</p> <p> TYPE: <code>Union[FHIRVersion, str]</code> </p> YIELDS DESCRIPTION <code>FHIRVersion</code> <p>The resolved FHIRVersion being used</p> Example <p>with fhir_version_context(\"R4B\") as v: ...     patient = get_fhir_resource(\"Patient\")  # R4B Patient ...     print(f\"Using {v}\")</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>@contextmanager\ndef fhir_version_context(\n    version: Union[FHIRVersion, str],\n) -&gt; Generator[FHIRVersion, None, None]:\n    \"\"\"Context manager for temporarily changing the default FHIR version.\n\n    Args:\n        version: The FHIR version to use within the context\n\n    Yields:\n        The resolved FHIRVersion being used\n\n    Example:\n        &gt;&gt;&gt; with fhir_version_context(\"R4B\") as v:\n        ...     patient = get_fhir_resource(\"Patient\")  # R4B Patient\n        ...     print(f\"Using {v}\")\n        &gt;&gt;&gt; # After context, default is restored\n    \"\"\"\n    global _default_version\n    previous_version = _default_version\n    resolved = _resolve_version(version)\n    _default_version = resolved\n    try:\n        yield resolved\n    finally:\n        _default_version = previous_version\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.fhir_version_context--after-context-default-is-restored","title":"After context, default is restored","text":""},{"location":"api/fhir_helpers/#healthchain.fhir.get_default_version","title":"<code>get_default_version()</code>","text":"<p>Get the current default FHIR version.</p> RETURNS DESCRIPTION <code>FHIRVersion</code> <p>The current default FHIRVersion (R5 if not explicitly set)</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def get_default_version() -&gt; FHIRVersion:\n    \"\"\"Get the current default FHIR version.\n\n    Returns:\n        The current default FHIRVersion (R5 if not explicitly set)\n    \"\"\"\n    return _default_version or FHIRVersion.R5\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_fhir_resource","title":"<code>get_fhir_resource(resource_name, version=None)</code>","text":"<p>Dynamically import a FHIR resource class based on version.</p> PARAMETER DESCRIPTION <code>resource_name</code> <p>Name of the FHIR resource (e.g., \"Patient\", \"Condition\")</p> <p> TYPE: <code>str</code> </p> <code>version</code> <p>FHIR version (None for default, or FHIRVersion enum/string)</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Type[Any]</code> <p>The FHIR resource class for the specified version</p> RAISES DESCRIPTION <code>ValueError</code> <p>If version is invalid or resource cannot be imported</p> Example <p>Patient_R5 = get_fhir_resource(\"Patient\") Patient_R4B = get_fhir_resource(\"Patient\", \"R4B\") Patient_STU3 = get_fhir_resource(\"Patient\", FHIRVersion.STU3)</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def get_fhir_resource(\n    resource_name: str, version: Optional[Union[FHIRVersion, str]] = None\n) -&gt; Type[Any]:\n    \"\"\"Dynamically import a FHIR resource class based on version.\n\n    Args:\n        resource_name: Name of the FHIR resource (e.g., \"Patient\", \"Condition\")\n        version: FHIR version (None for default, or FHIRVersion enum/string)\n\n    Returns:\n        The FHIR resource class for the specified version\n\n    Raises:\n        ValueError: If version is invalid or resource cannot be imported\n\n    Example:\n        &gt;&gt;&gt; Patient_R5 = get_fhir_resource(\"Patient\")\n        &gt;&gt;&gt; Patient_R4B = get_fhir_resource(\"Patient\", \"R4B\")\n        &gt;&gt;&gt; Patient_STU3 = get_fhir_resource(\"Patient\", FHIRVersion.STU3)\n    \"\"\"\n    resolved_version = _resolve_version(version)\n\n    # Build module path based on version\n    # R5 is the default (no subpackage), R4B and STU3 use subpackages\n    if resolved_version == FHIRVersion.R5:\n        module_path = f\"fhir.resources.{resource_name.lower()}\"\n    else:\n        module_path = f\"fhir.resources.{resolved_version.value}.{resource_name.lower()}\"\n\n    try:\n        module = importlib.import_module(module_path)\n        resource_class = getattr(module, resource_name)\n        logger.debug(f\"Loaded {resource_name} from {module_path}\")\n        return resource_class\n    except ImportError as e:\n        raise ValueError(\n            f\"Could not import resource type: {resource_name}. \"\n            f\"Make sure it is a valid FHIR resource type for version '{resolved_version.value}'.\"\n        ) from e\n    except AttributeError as e:\n        raise ValueError(\n            f\"Module '{module_path}' does not contain resource '{resource_name}'.\"\n        ) from e\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resource_info","title":"<code>get_resource_info(resource_type)</code>","text":"<p>Get detailed information about a supported resource type.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>FHIR resource type name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary with resource handler information, or empty dict if unsupported</p> Example <p>info = get_resource_info(\"Observation\") print(info[\"description\"]) 'Clinical observations (vitals, labs)'</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def get_resource_info(resource_type: str) -&gt; Dict[str, Any]:\n    \"\"\"Get detailed information about a supported resource type.\n\n    Args:\n        resource_type: FHIR resource type name\n\n    Returns:\n        Dictionary with resource handler information, or empty dict if unsupported\n\n    Example:\n        &gt;&gt;&gt; info = get_resource_info(\"Observation\")\n        &gt;&gt;&gt; print(info[\"description\"])\n        'Clinical observations (vitals, labs)'\n    \"\"\"\n    return SUPPORTED_RESOURCES.get(resource_type, {})\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resource_type","title":"<code>get_resource_type(resource_type, version=None)</code>","text":"<p>Get the resource type class from string or type.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> <code>version</code> <p>Optional FHIR version (e.g., \"R4B\", \"STU3\", or FHIRVersion enum).      If None, uses the current default version.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Type[Resource]</code> <p>The resource type class for the specified version</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the resource type is not supported or cannot be imported</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def get_resource_type(\n    resource_type: Union[str, Type[Resource]],\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Type[Resource]:\n    \"\"\"Get the resource type class from string or type.\n\n    Args:\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n        version: Optional FHIR version (e.g., \"R4B\", \"STU3\", or FHIRVersion enum).\n                 If None, uses the current default version.\n\n    Returns:\n        The resource type class for the specified version\n\n    Raises:\n        ValueError: If the resource type is not supported or cannot be imported\n    \"\"\"\n    if isinstance(resource_type, type) and issubclass(resource_type, Resource):\n        return resource_type\n\n    if not isinstance(resource_type, str):\n        raise ValueError(\n            f\"Resource type must be a string or Resource class, got {type(resource_type)}\"\n        )\n\n    # Use version manager for dynamic import with version support\n    from healthchain.fhir.version import get_fhir_resource\n\n    return get_fhir_resource(resource_type, version)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resource_version","title":"<code>get_resource_version(resource)</code>","text":"<p>Detect the FHIR version of a resource based on its module path.</p> PARAMETER DESCRIPTION <code>resource</code> <p>A FHIR resource instance</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Optional[FHIRVersion]</code> <p>The FHIRVersion if detectable, None otherwise</p> Example <p>from fhir.resources.R4B.patient import Patient patient = Patient(id=\"123\") version = get_resource_version(patient) print(version) FHIRVersion.R4B</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def get_resource_version(resource: Any) -&gt; Optional[FHIRVersion]:\n    \"\"\"Detect the FHIR version of a resource based on its module path.\n\n    Args:\n        resource: A FHIR resource instance\n\n    Returns:\n        The FHIRVersion if detectable, None otherwise\n\n    Example:\n        &gt;&gt;&gt; from fhir.resources.R4B.patient import Patient\n        &gt;&gt;&gt; patient = Patient(id=\"123\")\n        &gt;&gt;&gt; version = get_resource_version(patient)\n        &gt;&gt;&gt; print(version)\n        FHIRVersion.R4B\n    \"\"\"\n    module = resource.__class__.__module__\n\n    if \".R4B.\" in module:\n        return FHIRVersion.R4B\n    elif \".STU3.\" in module:\n        return FHIRVersion.STU3\n    elif module.startswith(\"fhir.resources.\"):\n        return FHIRVersion.R5\n\n    return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources","title":"<code>get_resources(bundle, resource_type)</code>","text":"<p>Get all resources of a specific type from a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to search</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List of resources of the specified type</p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def get_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Get all resources of a specific type from a bundle.\n\n    Args:\n        bundle: The bundle to search\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n\n    Returns:\n        List of resources of the specified type\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Using string identifier\n        &gt;&gt;&gt; conditions = get_resources(bundle, \"Condition\")\n        &gt;&gt;&gt; medications = get_resources(bundle, \"MedicationStatement\")\n        &gt;&gt;&gt; allergies = get_resources(bundle, \"AllergyIntolerance\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; conditions = get_resources(bundle, Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n    return [\n        entry.resource\n        for entry in (bundle.entry or [])\n        if isinstance(entry.resource, type_class)\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources--using-string-identifier","title":"Using string identifier","text":"<p>conditions = get_resources(bundle, \"Condition\") medications = get_resources(bundle, \"MedicationStatement\") allergies = get_resources(bundle, \"AllergyIntolerance\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition conditions = get_resources(bundle, Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.get_supported_resources","title":"<code>get_supported_resources()</code>","text":"<p>Get list of supported FHIR resource types.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of resource type names that can be converted to DataFrame columns</p> Example <p>resources = get_supported_resources() print(resources) ['Patient', 'Observation', 'Condition', 'MedicationStatement']</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def get_supported_resources() -&gt; List[str]:\n    \"\"\"Get list of supported FHIR resource types.\n\n    Returns:\n        List of resource type names that can be converted to DataFrame columns\n\n    Example:\n        &gt;&gt;&gt; resources = get_supported_resources()\n        &gt;&gt;&gt; print(resources)\n        ['Patient', 'Observation', 'Condition', 'MedicationStatement']\n    \"\"\"\n    return list(SUPPORTED_RESOURCES.keys())\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.merge_bundles","title":"<code>merge_bundles(bundles, bundle_type='collection', deduplicate=False, dedupe_key='id')</code>","text":"<p>Merge multiple FHIR bundles into a single bundle.</p> <p>Combines entries from multiple bundles while preserving resource metadata. Useful for aggregating search results from multiple FHIR sources.</p> PARAMETER DESCRIPTION <code>bundles</code> <p>List of bundles to merge</p> <p> TYPE: <code>List[Bundle]</code> </p> <code>bundle_type</code> <p>Type for the merged bundle (default: \"collection\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> <code>deduplicate</code> <p>If True, remove duplicate resources based on dedupe_key</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>dedupe_key</code> <p>Resource attribute to use for deduplication (default: \"id\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'id'</code> </p> RETURNS DESCRIPTION <code>Bundle</code> <p>A new bundle containing all entries from input bundles</p> Example Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def merge_bundles(\n    bundles: List[Bundle],\n    bundle_type: str = \"collection\",\n    deduplicate: bool = False,\n    dedupe_key: str = \"id\",\n) -&gt; Bundle:\n    \"\"\"Merge multiple FHIR bundles into a single bundle.\n\n    Combines entries from multiple bundles while preserving resource metadata.\n    Useful for aggregating search results from multiple FHIR sources.\n\n    Args:\n        bundles: List of bundles to merge\n        bundle_type: Type for the merged bundle (default: \"collection\")\n        deduplicate: If True, remove duplicate resources based on dedupe_key\n        dedupe_key: Resource attribute to use for deduplication (default: \"id\")\n\n    Returns:\n        A new bundle containing all entries from input bundles\n\n    Example:\n        &gt;&gt;&gt; # Merge search results from multiple sources\n        &gt;&gt;&gt; epic_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"epic\")\n        &gt;&gt;&gt; cerner_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"cerner\")\n        &gt;&gt;&gt; merged = merge_bundles([epic_bundle, cerner_bundle], deduplicate=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Use in Document workflow\n        &gt;&gt;&gt; doc = Document(data=merged)\n        &gt;&gt;&gt; doc.fhir.bundle  # Contains all conditions from both sources\n    \"\"\"\n    merged = create_bundle(bundle_type=bundle_type)\n\n    if deduplicate:\n        # Track seen resources by dedupe_key to avoid duplicates\n        seen_keys = set()\n\n        for bundle in bundles:\n            if not bundle or not bundle.entry:\n                continue\n\n            for entry in bundle.entry:\n                if not entry.resource:\n                    continue\n\n                # Get the deduplication key value\n                key_value = getattr(entry.resource, dedupe_key, None)\n\n                # Skip if we've seen this key before\n                if key_value and key_value in seen_keys:\n                    continue\n\n                # Add to merged bundle and track the key\n                add_resource(merged, entry.resource, entry.fullUrl)\n                if key_value:\n                    seen_keys.add(key_value)\n    else:\n        # No deduplication - just merge all entries\n        for bundle in bundles:\n            if not bundle or not bundle.entry:\n                continue\n\n            for entry in bundle.entry:\n                if entry.resource:\n                    add_resource(merged, entry.resource, entry.fullUrl)\n\n    return merged\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.merge_bundles--merge-search-results-from-multiple-sources","title":"Merge search results from multiple sources","text":"<p>epic_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"epic\") cerner_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"cerner\") merged = merge_bundles([epic_bundle, cerner_bundle], deduplicate=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.merge_bundles--use-in-document-workflow","title":"Use in Document workflow","text":"<p>doc = Document(data=merged) doc.fhir.bundle  # Contains all conditions from both sources</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.prefetch_to_bundle","title":"<code>prefetch_to_bundle(prefetch)</code>","text":"<p>Flatten CDS Hooks prefetch into a collection Bundle dict.</p> <p>Converts the keyed prefetch format (used in CDS Hooks) into a flat bundle suitable for Dataset.from_fhir_bundle().</p> PARAMETER DESCRIPTION <code>prefetch</code> <p>CDS Hooks prefetch dict with format: {\"patient\": {...}, \"observations\": {\"entry\": [...]}, ...}</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Bundle dict with type \"collection\" and flattened entries</p> Example <p>prefetch = request.prefetch bundle = prefetch_to_bundle(prefetch) dataset = Dataset.from_fhir_bundle(bundle, schema=schema)</p> Source code in <code>healthchain/fhir/readers.py</code> <pre><code>def prefetch_to_bundle(prefetch: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Flatten CDS Hooks prefetch into a collection Bundle dict.\n\n    Converts the keyed prefetch format (used in CDS Hooks) into a flat bundle\n    suitable for Dataset.from_fhir_bundle().\n\n    Args:\n        prefetch: CDS Hooks prefetch dict with format:\n            {\"patient\": {...}, \"observations\": {\"entry\": [...]}, ...}\n\n    Returns:\n        Bundle dict with type \"collection\" and flattened entries\n\n    Example:\n        &gt;&gt;&gt; prefetch = request.prefetch\n        &gt;&gt;&gt; bundle = prefetch_to_bundle(prefetch)\n        &gt;&gt;&gt; dataset = Dataset.from_fhir_bundle(bundle, schema=schema)\n    \"\"\"\n    entries = []\n    for key, value in prefetch.items():\n        if isinstance(value, dict):\n            if \"entry\" in value:  # Searchset bundle\n                entries.extend(value[\"entry\"])\n            elif \"resourceType\" in value:  # Single resource\n                entries.append({\"resource\": value})\n    return {\"type\": \"collection\", \"entry\": entries}\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.print_supported_resources","title":"<code>print_supported_resources()</code>","text":"<p>Print user-friendly list of supported FHIR resources for conversion.</p> Example <p>from healthchain.fhir.converters import print_supported_resources print_supported_resources() Supported FHIR Resources for ML Dataset Conversion:</p> <p>\u2713 Patient     Patient demographics (age, gender)     Columns: age, gender ...</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def print_supported_resources() -&gt; None:\n    \"\"\"Print user-friendly list of supported FHIR resources for conversion.\n\n    Example:\n        &gt;&gt;&gt; from healthchain.fhir.converters import print_supported_resources\n        &gt;&gt;&gt; print_supported_resources()\n        Supported FHIR Resources for ML Dataset Conversion:\n\n          \u2713 Patient\n            Patient demographics (age, gender)\n            Columns: age, gender\n        ...\n    \"\"\"\n    print(\"Supported FHIR Resources for ML Dataset Conversion:\\n\")\n    for resource, info in SUPPORTED_RESOURCES.items():\n        print(f\"  \u2713 {resource}\")\n        print(f\"    {info['description']}\")\n        if isinstance(info[\"output_columns\"], list):\n            print(f\"    Columns: {', '.join(info['output_columns'])}\")\n        else:\n            print(f\"    Columns: {info['output_columns']}\")\n        if info.get(\"options\"):\n            print(f\"    Options: {', '.join(info['options'])}\")\n        print()\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.read_content_attachment","title":"<code>read_content_attachment(document_reference, include_data=True)</code>","text":"<p>Read the attachments in a human readable format from a FHIR DocumentReference content field.</p> PARAMETER DESCRIPTION <code>document_reference</code> <p>The FHIR DocumentReference resource</p> <p> TYPE: <code>DocumentReference</code> </p> <code>include_data</code> <p>Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[List[Dict[str, Any]]]</code> <p>Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata, or None if no attachments are found: [     {         \"data\": str,         \"metadata\": Dict[str, Any]     } ]</p> Source code in <code>healthchain/fhir/readers.py</code> <pre><code>def read_content_attachment(\n    document_reference: DocumentReference,\n    include_data: bool = True,\n) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"Read the attachments in a human readable format from a FHIR DocumentReference content field.\n\n    Args:\n        document_reference: The FHIR DocumentReference resource\n        include_data: Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)\n\n    Returns:\n        Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata,\n            or None if no attachments are found:\n            [\n                {\n                    \"data\": str,\n                    \"metadata\": Dict[str, Any]\n                }\n            ]\n    \"\"\"\n    if not document_reference.content:\n        return None\n\n    attachments = []\n    for content in document_reference.content:\n        attachment = content.attachment\n        result = {}\n\n        if include_data:\n            result[\"data\"] = (\n                attachment.url if attachment.url else attachment.data.decode(\"utf-8\")\n            )\n\n        result[\"metadata\"] = {\n            \"content_type\": attachment.contentType,\n            \"title\": attachment.title,\n            \"creation\": attachment.creation,\n        }\n\n        attachments.append(result)\n\n    return attachments\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.reset_default_version","title":"<code>reset_default_version()</code>","text":"<p>Reset the default FHIR version to library default (R5).</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def reset_default_version() -&gt; None:\n    \"\"\"Reset the default FHIR version to library default (R5).\"\"\"\n    global _default_version\n    _default_version = None\n    logger.debug(\"Default FHIR version reset to R5\")\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_condition_category","title":"<code>set_condition_category(condition, category, version=None)</code>","text":"<p>Set the category of a FHIR Condition to either 'problem-list-item' or 'encounter-diagnosis'.</p> PARAMETER DESCRIPTION <code>condition</code> <p>The FHIR Condition resource to modify</p> <p> TYPE: <code>Any</code> </p> <code>category</code> <p>The category to set. Must be 'problem-list-item' or 'encounter-diagnosis'.</p> <p> TYPE: <code>str</code> </p> <code>version</code> <p>FHIR version to use. If None, attempts to detect from the condition resource.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>The modified FHIR Condition resource with the specified category set</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the category is not one of the allowed values.</p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def set_condition_category(\n    condition: Any,\n    category: str,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Set the category of a FHIR Condition to either 'problem-list-item' or 'encounter-diagnosis'.\n\n    Args:\n        condition: The FHIR Condition resource to modify\n        category: The category to set. Must be 'problem-list-item' or 'encounter-diagnosis'.\n        version: FHIR version to use. If None, attempts to detect from the condition resource.\n\n    Returns:\n        Condition: The modified FHIR Condition resource with the specified category set\n\n    Raises:\n        ValueError: If the category is not one of the allowed values.\n    \"\"\"\n    from healthchain.fhir.version import get_resource_version\n\n    # Detect version from resource if not provided\n    if version is None:\n        version = get_resource_version(condition)\n\n    allowed_categories = {\n        \"problem-list-item\": {\n            \"code\": \"problem-list-item\",\n            \"display\": \"Problem List Item\",\n        },\n        \"encounter-diagnosis\": {\n            \"code\": \"encounter-diagnosis\",\n            \"display\": \"Encounter Diagnosis\",\n        },\n    }\n    if category not in allowed_categories:\n        raise ValueError(\n            f\"Invalid category '{category}'. Must be one of: {list(allowed_categories.keys())}\"\n        )\n\n    cat_info = allowed_categories[category]\n    condition.category = [\n        create_single_codeable_concept(\n            code=cat_info[\"code\"],\n            display=cat_info[\"display\"],\n            system=\"http://terminology.hl7.org/CodeSystem/condition-category\",\n            version=version,\n        )\n    ]\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_default_version","title":"<code>set_default_version(version)</code>","text":"<p>Set the global default FHIR version.</p> PARAMETER DESCRIPTION <code>version</code> <p>The FHIR version to use as default</p> <p> TYPE: <code>Union[FHIRVersion, str]</code> </p> Example <p>set_default_version(\"R4B\") patient = get_fhir_resource(\"Patient\")  # Returns R4B Patient</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def set_default_version(version: Union[FHIRVersion, str]) -&gt; None:\n    \"\"\"Set the global default FHIR version.\n\n    Args:\n        version: The FHIR version to use as default\n\n    Example:\n        &gt;&gt;&gt; set_default_version(\"R4B\")\n        &gt;&gt;&gt; patient = get_fhir_resource(\"Patient\")  # Returns R4B Patient\n    \"\"\"\n    global _default_version\n    _default_version = _resolve_version(version)\n    logger.info(f\"Default FHIR version set to {_default_version.value}\")\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources","title":"<code>set_resources(bundle, resources, resource_type, replace=True)</code>","text":"<p>Set resources of a specific type in the bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to modify</p> <p> TYPE: <code>Bundle</code> </p> <code>resources</code> <p>The new resources to add</p> <p> TYPE: <code>List[Resource]</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> <code>replace</code> <p>If True, remove existing resources of this type before adding new ones.     If False, append new resources to existing ones. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def set_resources(\n    bundle: Bundle,\n    resources: List[Resource],\n    resource_type: Union[str, Type[Resource]],\n    replace: bool = True,\n) -&gt; None:\n    \"\"\"Set resources of a specific type in the bundle.\n\n    Args:\n        bundle: The bundle to modify\n        resources: The new resources to add\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n        replace: If True, remove existing resources of this type before adding new ones.\n                If False, append new resources to existing ones. Defaults to True.\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Append to existing resources (default behavior)\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], \"Condition\")\n        &gt;&gt;&gt; set_resources(bundle, [medication1], \"MedicationStatement\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Replace existing resources\n        &gt;&gt;&gt; set_resources(bundle, [condition3], \"Condition\", replace=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n\n    # Remove existing resources of this type if replace=True\n    if replace:\n        bundle.entry = [\n            entry\n            for entry in (bundle.entry or [])\n            if not isinstance(entry.resource, type_class)\n        ]\n\n    # Add new resources\n    for resource in resources:\n        if not isinstance(resource, type_class):\n            raise ValueError(\n                f\"Resource must be of type {type_class.__name__}, \"\n                f\"got {type(resource).__name__}\"\n            )\n        add_resource(bundle, resource)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--append-to-existing-resources-default-behavior","title":"Append to existing resources (default behavior)","text":"<p>set_resources(bundle, [condition1, condition2], \"Condition\") set_resources(bundle, [medication1], \"MedicationStatement\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--replace-existing-resources","title":"Replace existing resources","text":"<p>set_resources(bundle, [condition3], \"Condition\", replace=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.set_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition set_resources(bundle, [condition1, condition2], Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers","title":"<code>bundlehelpers</code>","text":"<p>Helper functions for working with FHIR Bundles. Patterns: - create_(): create a new FHIR bundle - add_(): add a resource to a bundle - get_(): get resources from a bundle - set_(): set resources in a bundle - merge_(): merge multiple bundles into a single bundle - extract_(): extract resources from a bundle</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.add_resource","title":"<code>add_resource(bundle, resource, full_url=None)</code>","text":"<p>Add a resource to a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to add to</p> <p> TYPE: <code>Bundle</code> </p> <code>resource</code> <p>The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance</p> <p> TYPE: <code>Resource</code> </p> <code>full_url</code> <p>Optional full URL for the resource</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def add_resource(\n    bundle: Bundle, resource: Resource, full_url: Optional[str] = None\n) -&gt; None:\n    \"\"\"Add a resource to a bundle.\n\n    Args:\n        bundle: The bundle to add to\n        resource: The resource to add, e.g. Condition, MedicationStatement, AllergyIntolerance\n        full_url: Optional full URL for the resource\n    \"\"\"\n    entry = BundleEntry(resource=resource)\n    if full_url:\n        entry.fullUrl = full_url\n    bundle.entry = (bundle.entry or []) + [entry]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.count_resources","title":"<code>count_resources(bundle)</code>","text":"<p>Count resources by type in a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The FHIR Bundle to analyze</p> <p> TYPE: <code>Bundle</code> </p> RETURNS DESCRIPTION <code>dict[str, int]</code> <p>Dictionary mapping resource type names to their counts.</p> <code>Example</code> <p>{\"Condition\": 2, \"MedicationStatement\": 1, \"Patient\": 1}</p> <p> TYPE: <code>dict[str, int]</code> </p> Example <p>bundle = create_bundle() add_resource(bundle, create_condition(...)) add_resource(bundle, create_condition(...)) add_resource(bundle, create_medication_statement(...)) counts = count_resources(bundle) print(counts)</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def count_resources(bundle: Bundle) -&gt; dict[str, int]:\n    \"\"\"Count resources by type in a bundle.\n\n    Args:\n        bundle: The FHIR Bundle to analyze\n\n    Returns:\n        Dictionary mapping resource type names to their counts.\n        Example: {\"Condition\": 2, \"MedicationStatement\": 1, \"Patient\": 1}\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; add_resource(bundle, create_condition(...))\n        &gt;&gt;&gt; add_resource(bundle, create_condition(...))\n        &gt;&gt;&gt; add_resource(bundle, create_medication_statement(...))\n        &gt;&gt;&gt; counts = count_resources(bundle)\n        &gt;&gt;&gt; print(counts)\n        {'Condition': 2, 'MedicationStatement': 1}\n    \"\"\"\n    if not bundle or not bundle.entry:\n        return {}\n\n    counts: dict[str, int] = {}\n    for entry in bundle.entry:\n        if entry.resource:\n            # Get the resource type from the class name\n            resource_type = entry.resource.__resource_type__\n            counts[resource_type] = counts.get(resource_type, 0) + 1\n\n    return counts\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.create_bundle","title":"<code>create_bundle(bundle_type='collection')</code>","text":"<p>Create an empty FHIR Bundle. https://www.hl7.org/fhir/bundle.html</p> PARAMETER DESCRIPTION <code>bundle_type</code> <p>The type of bundle (default: collection) Valid types: document, message, transaction, transaction-response, batch, batch-response, history, searchset, collection</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def create_bundle(bundle_type: str = \"collection\") -&gt; Bundle:\n    \"\"\"Create an empty FHIR Bundle.\n    https://www.hl7.org/fhir/bundle.html\n\n    Args:\n        bundle_type: The type of bundle (default: collection)\n            Valid types: document, message, transaction, transaction-response,\n            batch, batch-response, history, searchset, collection\n    \"\"\"\n    return Bundle(type=bundle_type, entry=[])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.extract_resources","title":"<code>extract_resources(bundle, resource_type)</code>","text":"<p>Remove resources of a given type from a bundle and return them.</p> <p>Useful for extracting and separating specific resource types (e.g., OperationOutcome) from a FHIR Bundle, modifying the bundle in place.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The FHIR Bundle to process (modified in place)</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>The FHIR resource class or string name to extract (e.g., OperationOutcome or \"OperationOutcome\")</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List[Resource]: All resources of the specified type that were in the bundle</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def extract_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Remove resources of a given type from a bundle and return them.\n\n    Useful for extracting and separating specific resource types (e.g., OperationOutcome)\n    from a FHIR Bundle, modifying the bundle in place.\n\n    Args:\n        bundle: The FHIR Bundle to process (modified in place)\n        resource_type: The FHIR resource class or string name to extract (e.g., OperationOutcome or \"OperationOutcome\")\n\n    Returns:\n        List[Resource]: All resources of the specified type that were in the bundle\n    \"\"\"\n    if not bundle or not bundle.entry:\n        return []\n\n    type_class = get_resource_type(resource_type)\n\n    extracted: List[Resource] = []\n    remaining_entries: List[BundleEntry] = []\n\n    for entry in bundle.entry:\n        resource = entry.resource\n        if isinstance(resource, type_class):\n            extracted.append(resource)\n            continue\n        remaining_entries.append(entry)\n\n    bundle.entry = remaining_entries\n    return extracted\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.get_resource_type","title":"<code>get_resource_type(resource_type, version=None)</code>","text":"<p>Get the resource type class from string or type.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> <code>version</code> <p>Optional FHIR version (e.g., \"R4B\", \"STU3\", or FHIRVersion enum).      If None, uses the current default version.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Type[Resource]</code> <p>The resource type class for the specified version</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the resource type is not supported or cannot be imported</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def get_resource_type(\n    resource_type: Union[str, Type[Resource]],\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Type[Resource]:\n    \"\"\"Get the resource type class from string or type.\n\n    Args:\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n        version: Optional FHIR version (e.g., \"R4B\", \"STU3\", or FHIRVersion enum).\n                 If None, uses the current default version.\n\n    Returns:\n        The resource type class for the specified version\n\n    Raises:\n        ValueError: If the resource type is not supported or cannot be imported\n    \"\"\"\n    if isinstance(resource_type, type) and issubclass(resource_type, Resource):\n        return resource_type\n\n    if not isinstance(resource_type, str):\n        raise ValueError(\n            f\"Resource type must be a string or Resource class, got {type(resource_type)}\"\n        )\n\n    # Use version manager for dynamic import with version support\n    from healthchain.fhir.version import get_fhir_resource\n\n    return get_fhir_resource(resource_type, version)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.get_resources","title":"<code>get_resources(bundle, resource_type)</code>","text":"<p>Get all resources of a specific type from a bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to search</p> <p> TYPE: <code>Bundle</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List of resources of the specified type</p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def get_resources(\n    bundle: Bundle, resource_type: Union[str, Type[Resource]]\n) -&gt; List[Resource]:\n    \"\"\"Get all resources of a specific type from a bundle.\n\n    Args:\n        bundle: The bundle to search\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n\n    Returns:\n        List of resources of the specified type\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Using string identifier\n        &gt;&gt;&gt; conditions = get_resources(bundle, \"Condition\")\n        &gt;&gt;&gt; medications = get_resources(bundle, \"MedicationStatement\")\n        &gt;&gt;&gt; allergies = get_resources(bundle, \"AllergyIntolerance\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; conditions = get_resources(bundle, Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n    return [\n        entry.resource\n        for entry in (bundle.entry or [])\n        if isinstance(entry.resource, type_class)\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.get_resources--using-string-identifier","title":"Using string identifier","text":"<p>conditions = get_resources(bundle, \"Condition\") medications = get_resources(bundle, \"MedicationStatement\") allergies = get_resources(bundle, \"AllergyIntolerance\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.get_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition conditions = get_resources(bundle, Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.merge_bundles","title":"<code>merge_bundles(bundles, bundle_type='collection', deduplicate=False, dedupe_key='id')</code>","text":"<p>Merge multiple FHIR bundles into a single bundle.</p> <p>Combines entries from multiple bundles while preserving resource metadata. Useful for aggregating search results from multiple FHIR sources.</p> PARAMETER DESCRIPTION <code>bundles</code> <p>List of bundles to merge</p> <p> TYPE: <code>List[Bundle]</code> </p> <code>bundle_type</code> <p>Type for the merged bundle (default: \"collection\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'collection'</code> </p> <code>deduplicate</code> <p>If True, remove duplicate resources based on dedupe_key</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>dedupe_key</code> <p>Resource attribute to use for deduplication (default: \"id\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'id'</code> </p> RETURNS DESCRIPTION <code>Bundle</code> <p>A new bundle containing all entries from input bundles</p> Example Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def merge_bundles(\n    bundles: List[Bundle],\n    bundle_type: str = \"collection\",\n    deduplicate: bool = False,\n    dedupe_key: str = \"id\",\n) -&gt; Bundle:\n    \"\"\"Merge multiple FHIR bundles into a single bundle.\n\n    Combines entries from multiple bundles while preserving resource metadata.\n    Useful for aggregating search results from multiple FHIR sources.\n\n    Args:\n        bundles: List of bundles to merge\n        bundle_type: Type for the merged bundle (default: \"collection\")\n        deduplicate: If True, remove duplicate resources based on dedupe_key\n        dedupe_key: Resource attribute to use for deduplication (default: \"id\")\n\n    Returns:\n        A new bundle containing all entries from input bundles\n\n    Example:\n        &gt;&gt;&gt; # Merge search results from multiple sources\n        &gt;&gt;&gt; epic_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"epic\")\n        &gt;&gt;&gt; cerner_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"cerner\")\n        &gt;&gt;&gt; merged = merge_bundles([epic_bundle, cerner_bundle], deduplicate=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Use in Document workflow\n        &gt;&gt;&gt; doc = Document(data=merged)\n        &gt;&gt;&gt; doc.fhir.bundle  # Contains all conditions from both sources\n    \"\"\"\n    merged = create_bundle(bundle_type=bundle_type)\n\n    if deduplicate:\n        # Track seen resources by dedupe_key to avoid duplicates\n        seen_keys = set()\n\n        for bundle in bundles:\n            if not bundle or not bundle.entry:\n                continue\n\n            for entry in bundle.entry:\n                if not entry.resource:\n                    continue\n\n                # Get the deduplication key value\n                key_value = getattr(entry.resource, dedupe_key, None)\n\n                # Skip if we've seen this key before\n                if key_value and key_value in seen_keys:\n                    continue\n\n                # Add to merged bundle and track the key\n                add_resource(merged, entry.resource, entry.fullUrl)\n                if key_value:\n                    seen_keys.add(key_value)\n    else:\n        # No deduplication - just merge all entries\n        for bundle in bundles:\n            if not bundle or not bundle.entry:\n                continue\n\n            for entry in bundle.entry:\n                if entry.resource:\n                    add_resource(merged, entry.resource, entry.fullUrl)\n\n    return merged\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.merge_bundles--merge-search-results-from-multiple-sources","title":"Merge search results from multiple sources","text":"<p>epic_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"epic\") cerner_bundle = gateway.search(Condition, {\"patient\": \"123\"}, \"cerner\") merged = merge_bundles([epic_bundle, cerner_bundle], deduplicate=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.merge_bundles--use-in-document-workflow","title":"Use in Document workflow","text":"<p>doc = Document(data=merged) doc.fhir.bundle  # Contains all conditions from both sources</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.set_resources","title":"<code>set_resources(bundle, resources, resource_type, replace=True)</code>","text":"<p>Set resources of a specific type in the bundle.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>The bundle to modify</p> <p> TYPE: <code>Bundle</code> </p> <code>resources</code> <p>The new resources to add</p> <p> TYPE: <code>List[Resource]</code> </p> <code>resource_type</code> <p>String name of the resource type (e.g. \"Condition\") or the type itself</p> <p> TYPE: <code>Union[str, Type[Resource]]</code> </p> <code>replace</code> <p>If True, remove existing resources of this type before adding new ones.     If False, append new resources to existing ones. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Example <p>bundle = create_bundle()</p> Source code in <code>healthchain/fhir/bundlehelpers.py</code> <pre><code>def set_resources(\n    bundle: Bundle,\n    resources: List[Resource],\n    resource_type: Union[str, Type[Resource]],\n    replace: bool = True,\n) -&gt; None:\n    \"\"\"Set resources of a specific type in the bundle.\n\n    Args:\n        bundle: The bundle to modify\n        resources: The new resources to add\n        resource_type: String name of the resource type (e.g. \"Condition\") or the type itself\n        replace: If True, remove existing resources of this type before adding new ones.\n                If False, append new resources to existing ones. Defaults to True.\n\n    Example:\n        &gt;&gt;&gt; bundle = create_bundle()\n        &gt;&gt;&gt; # Append to existing resources (default behavior)\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], \"Condition\")\n        &gt;&gt;&gt; set_resources(bundle, [medication1], \"MedicationStatement\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Replace existing resources\n        &gt;&gt;&gt; set_resources(bundle, [condition3], \"Condition\", replace=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Or using type directly\n        &gt;&gt;&gt; from fhir.resources.condition import Condition\n        &gt;&gt;&gt; set_resources(bundle, [condition1, condition2], Condition)\n    \"\"\"\n    type_class = get_resource_type(resource_type)\n\n    # Remove existing resources of this type if replace=True\n    if replace:\n        bundle.entry = [\n            entry\n            for entry in (bundle.entry or [])\n            if not isinstance(entry.resource, type_class)\n        ]\n\n    # Add new resources\n    for resource in resources:\n        if not isinstance(resource, type_class):\n            raise ValueError(\n                f\"Resource must be of type {type_class.__name__}, \"\n                f\"got {type(resource).__name__}\"\n            )\n        add_resource(bundle, resource)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.set_resources--append-to-existing-resources-default-behavior","title":"Append to existing resources (default behavior)","text":"<p>set_resources(bundle, [condition1, condition2], \"Condition\") set_resources(bundle, [medication1], \"MedicationStatement\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.set_resources--replace-existing-resources","title":"Replace existing resources","text":"<p>set_resources(bundle, [condition3], \"Condition\", replace=True)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.bundlehelpers.set_resources--or-using-type-directly","title":"Or using type directly","text":"<p>from fhir.resources.condition import Condition set_resources(bundle, [condition1, condition2], Condition)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe","title":"<code>dataframe</code>","text":"<p>FHIR to DataFrame converters.</p> <p>This module provides generic functions to convert FHIR Bundles to pandas DataFrames for analysis and ML model deployment.</p> <p>In instances where there are multiple codes present for a single resource, the first code is used as the primary code.</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.BundleConverterConfig","title":"<code>BundleConverterConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for FHIR Bundle to DataFrame conversion.</p> <p>This configuration object controls which FHIR resources are processed and how they are converted to DataFrame columns for ML model deployment.</p> ATTRIBUTE DESCRIPTION <code>resources</code> <p>List of FHIR resource types to include in the conversion</p> <p> TYPE: <code>List[str]</code> </p> <code>observation_aggregation</code> <p>How to aggregate multiple observation values</p> <p> TYPE: <code>Literal['mean', 'median', 'max', 'min', 'last']</code> </p> <code>age_calculation</code> <p>Method for calculating patient age</p> <p> TYPE: <code>Literal['current_date', 'event_date']</code> </p> <code>event_date_source</code> <p>Which resource to extract event date from</p> <p> TYPE: <code>Literal['Observation', 'Encounter']</code> </p> <code>event_date_strategy</code> <p>Which date to use when multiple dates exist</p> <p> TYPE: <code>Literal['earliest', 'latest', 'first']</code> </p> <code>resource_options</code> <p>Resource-specific configuration options (extensible)</p> <p> TYPE: <code>Dict[str, Dict[str, Any]]</code> </p> Example <p>config = BundleConverterConfig( ...     resources=[\"Patient\", \"Observation\", \"Condition\"], ...     observation_aggregation=\"median\" ... ) df = bundle_to_dataframe(bundle, config=config)</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>class BundleConverterConfig(BaseModel):\n    \"\"\"Configuration for FHIR Bundle to DataFrame conversion.\n\n    This configuration object controls which FHIR resources are processed and how\n    they are converted to DataFrame columns for ML model deployment.\n\n    Attributes:\n        resources: List of FHIR resource types to include in the conversion\n        observation_aggregation: How to aggregate multiple observation values\n        age_calculation: Method for calculating patient age\n        event_date_source: Which resource to extract event date from\n        event_date_strategy: Which date to use when multiple dates exist\n        resource_options: Resource-specific configuration options (extensible)\n\n    Example:\n        &gt;&gt;&gt; config = BundleConverterConfig(\n        ...     resources=[\"Patient\", \"Observation\", \"Condition\"],\n        ...     observation_aggregation=\"median\"\n        ... )\n        &gt;&gt;&gt; df = bundle_to_dataframe(bundle, config=config)\n    \"\"\"\n\n    # Core resources to include\n    resources: List[str] = [\"Patient\", \"Observation\"]\n\n    # Observation-specific options\n    observation_aggregation: Literal[\"mean\", \"median\", \"max\", \"min\", \"last\"] = \"mean\"\n\n    # Patient age calculation\n    age_calculation: Literal[\"current_date\", \"event_date\"] = \"current_date\"\n    event_date_source: Literal[\"Observation\", \"Encounter\"] = \"Observation\"\n    event_date_strategy: Literal[\"earliest\", \"latest\", \"first\"] = \"earliest\"\n\n    # Resource-specific options (extensible for future use)\n    resource_options: Dict[str, Dict[str, Any]] = {}\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    @field_validator(\"resources\")\n    @classmethod\n    def validate_resources(cls, v):\n        \"\"\"Validate that requested resources are supported and warn about unsupported ones.\"\"\"\n        supported = get_supported_resources()\n        unsupported = [r for r in v if r not in supported]\n        if unsupported:\n            logger.warning(\n                f\"Unsupported resources will be skipped: {unsupported}. \"\n                f\"Supported resources: {supported}\"\n            )\n        return v\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.BundleConverterConfig.validate_resources","title":"<code>validate_resources(v)</code>  <code>classmethod</code>","text":"<p>Validate that requested resources are supported and warn about unsupported ones.</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>@field_validator(\"resources\")\n@classmethod\ndef validate_resources(cls, v):\n    \"\"\"Validate that requested resources are supported and warn about unsupported ones.\"\"\"\n    supported = get_supported_resources()\n    unsupported = [r for r in v if r not in supported]\n    if unsupported:\n        logger.warning(\n            f\"Unsupported resources will be skipped: {unsupported}. \"\n            f\"Supported resources: {supported}\"\n        )\n    return v\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.bundle_to_dataframe","title":"<code>bundle_to_dataframe(bundle, config=None)</code>","text":"<p>Convert a FHIR Bundle to a pandas DataFrame.</p> <p>Converts FHIR resources to a tabular format with one row per patient. Uses a configuration object to control which resources are processed and how.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>FHIR Bundle resource (object or dict)</p> <p> TYPE: <code>Union[Bundle, Dict[str, Any]]</code> </p> <code>config</code> <p>BundleConverterConfig object specifying conversion behavior. If None, uses default config (Patient + Observation with mean aggregation)</p> <p> TYPE: <code>Optional[BundleConverterConfig]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with one row per patient and columns for each feature</p> Example <p>from healthchain.fhir.converters import BundleConverterConfig</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def bundle_to_dataframe(\n    bundle: Union[Bundle, Dict[str, Any]],\n    config: Optional[BundleConverterConfig] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Convert a FHIR Bundle to a pandas DataFrame.\n\n    Converts FHIR resources to a tabular format with one row per patient.\n    Uses a configuration object to control which resources are processed and how.\n\n    Args:\n        bundle: FHIR Bundle resource (object or dict)\n        config: BundleConverterConfig object specifying conversion behavior.\n            If None, uses default config (Patient + Observation with mean aggregation)\n\n    Returns:\n        DataFrame with one row per patient and columns for each feature\n\n    Example:\n        &gt;&gt;&gt; from healthchain.fhir.converters import BundleConverterConfig\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Default behavior\n        &gt;&gt;&gt; df = bundle_to_dataframe(bundle)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Custom config\n        &gt;&gt;&gt; config = BundleConverterConfig(\n        ...     resources=[\"Patient\", \"Observation\", \"Condition\"],\n        ...     observation_aggregation=\"median\",\n        ...     age_calculation=\"event_date\"\n        ... )\n        &gt;&gt;&gt; df = bundle_to_dataframe(bundle, config=config)\n    \"\"\"\n    # Use default config if not provided\n    if config is None:\n        config = BundleConverterConfig()\n\n    # Group resources by patient\n    patient_data = group_bundle_by_patient(bundle)\n\n    if not patient_data:\n        return pd.DataFrame()\n\n    # Build rows for each patient\n    rows = []\n    for patient_ref, resources in patient_data.items():\n        row = {\"patient_ref\": patient_ref}\n\n        # Process each requested resource type using registry\n        for resource_type in config.resources:\n            handler_info = SUPPORTED_RESOURCES.get(resource_type)\n\n            if not handler_info:\n                # Skip unsupported resources gracefully (already warned by validator)\n                continue\n\n            # Get handler function by name\n            handler_name = handler_info[\"handler\"]\n            handler = globals()[handler_name]\n\n            # Call handler with standardized signature\n            features = handler(resources, config)\n            if features:\n                row.update(features)\n\n        rows.append(row)\n\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.bundle_to_dataframe--default-behavior","title":"Default behavior","text":"<p>df = bundle_to_dataframe(bundle)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.bundle_to_dataframe--custom-config","title":"Custom config","text":"<p>config = BundleConverterConfig( ...     resources=[\"Patient\", \"Observation\", \"Condition\"], ...     observation_aggregation=\"median\", ...     age_calculation=\"event_date\" ... ) df = bundle_to_dataframe(bundle, config=config)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.extract_event_date","title":"<code>extract_event_date(resources, source='Observation', strategy='earliest')</code>","text":"<p>Extract event date from patient resources for age calculation.</p> <p>Used primarily for MIMIC-IV on FHIR datasets where age is calculated based on event dates rather than current date.</p> PARAMETER DESCRIPTION <code>resources</code> <p>Dictionary of patient resources (from group_bundle_by_patient)</p> <p> TYPE: <code>Dict[str, List[Any]]</code> </p> <code>source</code> <p>Which resource type to extract date from (\"Observation\" or \"Encounter\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Observation'</code> </p> <code>strategy</code> <p>Which date to use (\"earliest\", \"latest\", \"first\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'earliest'</code> </p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>Event date in ISO format, or None if no suitable date found</p> Example <p>resources = {\"observations\": [obs1, obs2], \"encounters\": [enc1]} event_date = extract_event_date(resources, source=\"Observation\", strategy=\"earliest\")</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def extract_event_date(\n    resources: Dict[str, List[Any]],\n    source: str = \"Observation\",\n    strategy: str = \"earliest\",\n) -&gt; Optional[str]:\n    \"\"\"Extract event date from patient resources for age calculation.\n\n    Used primarily for MIMIC-IV on FHIR datasets where age is calculated\n    based on event dates rather than current date.\n\n    Args:\n        resources: Dictionary of patient resources (from group_bundle_by_patient)\n        source: Which resource type to extract date from (\"Observation\" or \"Encounter\")\n        strategy: Which date to use (\"earliest\", \"latest\", \"first\")\n\n    Returns:\n        Event date in ISO format, or None if no suitable date found\n\n    Example:\n        &gt;&gt;&gt; resources = {\"observations\": [obs1, obs2], \"encounters\": [enc1]}\n        &gt;&gt;&gt; event_date = extract_event_date(resources, source=\"Observation\", strategy=\"earliest\")\n    \"\"\"\n    if source == \"Observation\":\n        items = resources.get(\"observations\", [])\n        date_field = \"effectiveDateTime\"\n    elif source == \"Encounter\":\n        items = resources.get(\"encounters\", [])\n        date_field = \"period\"\n    else:\n        return None\n\n    if not items:\n        return None\n\n    dates = []\n    for item in items:\n        if source == \"Encounter\":\n            # Extract start date from period\n            period = _get_field(item, date_field)\n            if period:\n                start = _get_field(period, \"start\")\n                if start:\n                    dates.append(start)\n        else:\n            # Direct date field\n            date_value = _get_field(item, date_field)\n            if date_value:\n                dates.append(date_value)\n\n    if not dates:\n        return None\n\n    # Apply strategy\n    if strategy == \"earliest\":\n        return min(dates)\n    elif strategy == \"latest\":\n        return max(dates)\n    elif strategy == \"first\":\n        return dates[0]\n    else:\n        return min(dates)  # Default to earliest\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.extract_observation_value","title":"<code>extract_observation_value(observation)</code>","text":"<p>Extract numeric value from an Observation dict.</p> <p>Handles different value types (valueQuantity, valueInteger, valueString) and attempts to convert to float.</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def extract_observation_value(observation: Dict) -&gt; Optional[float]:\n    \"\"\"Extract numeric value from an Observation dict.\n\n    Handles different value types (valueQuantity, valueInteger, valueString) and\n    attempts to convert to float.\n    \"\"\"\n\n    try:\n        value_quantity = _get_field(observation, \"valueQuantity\")\n        if value_quantity:\n            value = _get_field(value_quantity, \"value\")\n            if value is not None:\n                return float(value)\n\n        value_int = _get_field(observation, \"valueInteger\")\n        if value_int is not None:\n            return float(value_int)\n\n        value_str = _get_field(observation, \"valueString\")\n        if value_str:\n            return float(value_str)\n\n    except (ValueError, TypeError):\n        pass\n\n    return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.get_resource_info","title":"<code>get_resource_info(resource_type)</code>","text":"<p>Get detailed information about a supported resource type.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>FHIR resource type name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary with resource handler information, or empty dict if unsupported</p> Example <p>info = get_resource_info(\"Observation\") print(info[\"description\"]) 'Clinical observations (vitals, labs)'</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def get_resource_info(resource_type: str) -&gt; Dict[str, Any]:\n    \"\"\"Get detailed information about a supported resource type.\n\n    Args:\n        resource_type: FHIR resource type name\n\n    Returns:\n        Dictionary with resource handler information, or empty dict if unsupported\n\n    Example:\n        &gt;&gt;&gt; info = get_resource_info(\"Observation\")\n        &gt;&gt;&gt; print(info[\"description\"])\n        'Clinical observations (vitals, labs)'\n    \"\"\"\n    return SUPPORTED_RESOURCES.get(resource_type, {})\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.get_supported_resources","title":"<code>get_supported_resources()</code>","text":"<p>Get list of supported FHIR resource types.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of resource type names that can be converted to DataFrame columns</p> Example <p>resources = get_supported_resources() print(resources) ['Patient', 'Observation', 'Condition', 'MedicationStatement']</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def get_supported_resources() -&gt; List[str]:\n    \"\"\"Get list of supported FHIR resource types.\n\n    Returns:\n        List of resource type names that can be converted to DataFrame columns\n\n    Example:\n        &gt;&gt;&gt; resources = get_supported_resources()\n        &gt;&gt;&gt; print(resources)\n        ['Patient', 'Observation', 'Condition', 'MedicationStatement']\n    \"\"\"\n    return list(SUPPORTED_RESOURCES.keys())\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.group_bundle_by_patient","title":"<code>group_bundle_by_patient(bundle)</code>","text":"<p>Group Bundle resources by patient reference.</p> <p>Organizes FHIR resources in a Bundle by their associated patient, making it easier to process patient-centric data. Accepts both Pydantic Bundle objects and dicts, converts to dict internally for performance.</p> PARAMETER DESCRIPTION <code>bundle</code> <p>FHIR Bundle resource (Pydantic object or dict)</p> <p> TYPE: <code>Union[Bundle, Dict[str, Any]]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, List[Any]]]</code> <p>Dictionary mapping patient references to their resources:</p> <code>Dict[str, Dict[str, List[Any]]]</code> <p>{ \"Patient/123\": {     \"patient\": Patient resource dict,     \"observations\": [Observation dict, ...],     \"conditions\": [Condition dict, ...],     ... }</p> <code>Dict[str, Dict[str, List[Any]]]</code> <p>}</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def group_bundle_by_patient(\n    bundle: Union[Bundle, Dict[str, Any]],\n) -&gt; Dict[str, Dict[str, List[Any]]]:\n    \"\"\"Group Bundle resources by patient reference.\n\n    Organizes FHIR resources in a Bundle by their associated patient, making it easier\n    to process patient-centric data. Accepts both Pydantic Bundle objects and dicts,\n    converts to dict internally for performance.\n\n    Args:\n        bundle: FHIR Bundle resource (Pydantic object or dict)\n\n    Returns:\n        Dictionary mapping patient references to their resources:\n        {\n            \"Patient/123\": {\n                \"patient\": Patient resource dict,\n                \"observations\": [Observation dict, ...],\n                \"conditions\": [Condition dict, ...],\n                ...\n            }\n        }\n    \"\"\"\n    if not isinstance(bundle, dict):\n        bundle = bundle.model_dump()\n\n    patient_data = defaultdict(\n        lambda: {\n            \"patient\": None,\n            \"observations\": [],\n            \"conditions\": [],\n            \"medications\": [],\n            \"allergies\": [],\n            \"procedures\": [],\n            \"encounters\": [],\n            \"other\": [],\n        }\n    )\n\n    # Get bundle entries\n    entries = _get_field(bundle, \"entry\")\n    if not entries:\n        return dict(patient_data)\n\n    for entry in entries:\n        # Get resource from entry\n        resource = _get_field(entry, \"resource\")\n        if not resource:\n            continue\n\n        resource_type = _get_field(resource, \"resourceType\")\n        resource_id = _get_field(resource, \"id\")\n\n        if resource_type == \"Patient\":\n            patient_ref = f\"Patient/{resource_id}\"\n            patient_data[patient_ref][\"patient\"] = resource\n\n        else:\n            # Get patient reference from resource\n            subject = _get_field(resource, \"subject\")\n            patient_field = _get_field(resource, \"patient\")\n\n            patient_ref = _get_reference(subject) or _get_reference(patient_field)\n\n            if patient_ref:\n                # Add to appropriate list based on resource type\n                if resource_type == \"Observation\":\n                    patient_data[patient_ref][\"observations\"].append(resource)\n                elif resource_type == \"Condition\":\n                    patient_data[patient_ref][\"conditions\"].append(resource)\n                elif resource_type == \"MedicationStatement\":\n                    patient_data[patient_ref][\"medications\"].append(resource)\n                elif resource_type == \"AllergyIntolerance\":\n                    patient_data[patient_ref][\"allergies\"].append(resource)\n                elif resource_type == \"Procedure\":\n                    patient_data[patient_ref][\"procedures\"].append(resource)\n                elif resource_type == \"Encounter\":\n                    patient_data[patient_ref][\"encounters\"].append(resource)\n                else:\n                    patient_data[patient_ref][\"other\"].append(resource)\n\n    return dict(patient_data)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.dataframe.print_supported_resources","title":"<code>print_supported_resources()</code>","text":"<p>Print user-friendly list of supported FHIR resources for conversion.</p> Example <p>from healthchain.fhir.converters import print_supported_resources print_supported_resources() Supported FHIR Resources for ML Dataset Conversion:</p> <p>\u2713 Patient     Patient demographics (age, gender)     Columns: age, gender ...</p> Source code in <code>healthchain/fhir/dataframe.py</code> <pre><code>def print_supported_resources() -&gt; None:\n    \"\"\"Print user-friendly list of supported FHIR resources for conversion.\n\n    Example:\n        &gt;&gt;&gt; from healthchain.fhir.converters import print_supported_resources\n        &gt;&gt;&gt; print_supported_resources()\n        Supported FHIR Resources for ML Dataset Conversion:\n\n          \u2713 Patient\n            Patient demographics (age, gender)\n            Columns: age, gender\n        ...\n    \"\"\"\n    print(\"Supported FHIR Resources for ML Dataset Conversion:\\n\")\n    for resource, info in SUPPORTED_RESOURCES.items():\n        print(f\"  \u2713 {resource}\")\n        print(f\"    {info['description']}\")\n        if isinstance(info[\"output_columns\"], list):\n            print(f\"    Columns: {', '.join(info['output_columns'])}\")\n        else:\n            print(f\"    Columns: {info['output_columns']}\")\n        if info.get(\"options\"):\n            print(f\"    Options: {', '.join(info['options'])}\")\n        print()\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.elementhelpers","title":"<code>elementhelpers</code>","text":"<p>FHIR element creation functions.</p> <p>This module provides convenience functions for creating FHIR elements that are used as building blocks within FHIR resources (e.g., CodeableConcept, Attachment, Coding).</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.elementhelpers.create_single_attachment","title":"<code>create_single_attachment(content_type=None, data=None, url=None, title='Attachment created by HealthChain', version=None)</code>","text":"<p>Create a minimal FHIR Attachment.</p> <p>Creates a FHIR Attachment resource with basic fields. Either data or url should be provided. If data is provided, it will be base64 encoded.</p> PARAMETER DESCRIPTION <code>content_type</code> <p>The MIME type of the content</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>data</code> <p>The actual data content to be base64 encoded</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>The URL where the data can be found</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>A title for the attachment (default: \"Attachment created by HealthChain\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Attachment</code> <p>A FHIR Attachment resource with basic metadata and content</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/elementhelpers.py</code> <pre><code>def create_single_attachment(\n    content_type: Optional[str] = None,\n    data: Optional[str] = None,\n    url: Optional[str] = None,\n    title: Optional[str] = \"Attachment created by HealthChain\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"Create a minimal FHIR Attachment.\n\n    Creates a FHIR Attachment resource with basic fields. Either data or url should be provided.\n    If data is provided, it will be base64 encoded.\n\n    Args:\n        content_type: The MIME type of the content\n        data: The actual data content to be base64 encoded\n        url: The URL where the data can be found\n        title: A title for the attachment (default: \"Attachment created by HealthChain\")\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        Attachment: A FHIR Attachment resource with basic metadata and content\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    Attachment = get_fhir_resource(\"Attachment\", version)\n\n    if not data and not url:\n        logger.warning(\"No data or url provided for attachment\")\n\n    if data:\n        data = base64.b64encode(data.encode(\"utf-8\")).decode(\"utf-8\")\n\n    return Attachment(\n        contentType=content_type,\n        data=data,\n        url=url,\n        title=title,\n        creation=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n    )\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.elementhelpers.create_single_codeable_concept","title":"<code>create_single_codeable_concept(code, display=None, system='http://snomed.info/sct', version=None)</code>","text":"<p>Create a minimal FHIR CodeableConcept with a single coding.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>A FHIR CodeableConcept resource with a single coding</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/elementhelpers.py</code> <pre><code>def create_single_codeable_concept(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal FHIR CodeableConcept with a single coding.\n\n    Args:\n        code: REQUIRED. The code value from the code system\n        display: The display name for the code\n        system: The code system (default: SNOMED CT)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        CodeableConcept: A FHIR CodeableConcept resource with a single coding\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    CodeableConcept = get_fhir_resource(\"CodeableConcept\", version)\n    Coding = get_fhir_resource(\"Coding\", version)\n\n    return CodeableConcept(coding=[Coding(system=system, code=code, display=display)])\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.elementhelpers.create_single_reaction","title":"<code>create_single_reaction(code, display=None, system='http://snomed.info/sct', severity=None, version=None)</code>","text":"<p>Create a minimal FHIR Reaction with a single coding.</p> <p>Creates a FHIR Reaction object with a single manifestation coding. The manifestation describes the clinical reaction that was observed. The severity indicates how severe the reaction was.</p> PARAMETER DESCRIPTION <code>code</code> <p>REQUIRED. The code value from the code system representing the reaction manifestation</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>The display name for the manifestation code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system for the manifestation code (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>severity</code> <p>The severity of the reaction (mild, moderate, severe)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>A list containing a single FHIR Reaction dictionary with manifestation and severity fields</p> Source code in <code>healthchain/fhir/elementhelpers.py</code> <pre><code>def create_single_reaction(\n    code: str,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    severity: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Create a minimal FHIR Reaction with a single coding.\n\n    Creates a FHIR Reaction object with a single manifestation coding. The manifestation\n    describes the clinical reaction that was observed. The severity indicates how severe\n    the reaction was.\n\n    Args:\n        code: REQUIRED. The code value from the code system representing the reaction manifestation\n        display: The display name for the manifestation code\n        system: The code system for the manifestation code (default: SNOMED CT)\n        severity: The severity of the reaction (mild, moderate, severe)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        A list containing a single FHIR Reaction dictionary with manifestation and severity fields\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    CodeableConcept = get_fhir_resource(\"CodeableConcept\", version)\n    CodeableReference = get_fhir_resource(\"CodeableReference\", version)\n    Coding = get_fhir_resource(\"Coding\", version)\n\n    return [\n        {\n            \"manifestation\": [\n                CodeableReference(\n                    concept=CodeableConcept(\n                        coding=[Coding(system=system, code=code, display=display)]\n                    )\n                )\n            ],\n            \"severity\": severity,\n        }\n    ]\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.readers","title":"<code>readers</code>","text":"<p>FHIR conversion and reading functions.</p> <p>This module provides functions for converting between different FHIR representations and reading data from FHIR resources.</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.readers.convert_prefetch_to_fhir_objects","title":"<code>convert_prefetch_to_fhir_objects(prefetch_dict)</code>","text":"<p>Convert a dictionary of FHIR resource dicts to FHIR Resource objects.</p> <p>Takes a prefetch dictionary where values may be either dict representations of FHIR resources or already instantiated FHIR Resource objects, and ensures all values are FHIR Resource objects.</p> PARAMETER DESCRIPTION <code>prefetch_dict</code> <p>Dictionary mapping keys to FHIR resource dicts or objects</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Resource]</code> <p>Dict[str, Resource]: Dictionary with same keys but all values as FHIR Resource objects</p> Example <p>prefetch = { ...     \"patient\": {\"resourceType\": \"Patient\", \"id\": \"123\"}, ...     \"condition\": Condition(id=\"456\", ...) ... } fhir_objects = convert_prefetch_to_fhir_objects(prefetch) isinstance(fhir_objects[\"patient\"], Patient)  # True isinstance(fhir_objects[\"condition\"], Condition)  # True</p> Source code in <code>healthchain/fhir/readers.py</code> <pre><code>def convert_prefetch_to_fhir_objects(\n    prefetch_dict: Dict[str, Any],\n) -&gt; Dict[str, Resource]:\n    \"\"\"Convert a dictionary of FHIR resource dicts to FHIR Resource objects.\n\n    Takes a prefetch dictionary where values may be either dict representations of FHIR\n    resources or already instantiated FHIR Resource objects, and ensures all values are\n    FHIR Resource objects.\n\n    Args:\n        prefetch_dict: Dictionary mapping keys to FHIR resource dicts or objects\n\n    Returns:\n        Dict[str, Resource]: Dictionary with same keys but all values as FHIR Resource objects\n\n    Example:\n        &gt;&gt;&gt; prefetch = {\n        ...     \"patient\": {\"resourceType\": \"Patient\", \"id\": \"123\"},\n        ...     \"condition\": Condition(id=\"456\", ...)\n        ... }\n        &gt;&gt;&gt; fhir_objects = convert_prefetch_to_fhir_objects(prefetch)\n        &gt;&gt;&gt; isinstance(fhir_objects[\"patient\"], Patient)  # True\n        &gt;&gt;&gt; isinstance(fhir_objects[\"condition\"], Condition)  # True\n    \"\"\"\n    from fhir.resources import get_fhir_model_class\n\n    result: Dict[str, Resource] = {}\n\n    for key, resource_data in prefetch_dict.items():\n        if isinstance(resource_data, dict):\n            # Convert dict to FHIR Resource object\n            resource_type = resource_data.get(\"resourceType\")\n            if resource_type:\n                try:\n                    # Fix timezone-naive datetimes before validation\n                    fixed_data = _fix_timezone_naive_datetimes(resource_data)\n                    resource_class = get_fhir_model_class(resource_type)\n                    result[key] = resource_class(**fixed_data)\n                except Exception as e:\n                    logger.warning(\n                        f\"Failed to convert {resource_type} to FHIR object: {e}\"\n                    )\n                    result[key] = resource_data\n            else:\n                logger.warning(\n                    f\"No resourceType found for key '{key}', keeping as dict\"\n                )\n                result[key] = resource_data\n        elif isinstance(resource_data, Resource):\n            # Already a FHIR object\n            result[key] = resource_data\n        else:\n            logger.warning(f\"Unexpected type for key '{key}': {type(resource_data)}\")\n            result[key] = resource_data\n\n    return result\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.readers.create_resource_from_dict","title":"<code>create_resource_from_dict(resource_dict, resource_type)</code>","text":"<p>Create a FHIR resource instance from a dictionary</p> PARAMETER DESCRIPTION <code>resource_dict</code> <p>Dictionary representation of the resource</p> <p> TYPE: <code>Dict</code> </p> <code>resource_type</code> <p>Type of FHIR resource to create</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Resource]</code> <p>Optional[Resource]: FHIR resource instance or None if creation failed</p> Source code in <code>healthchain/fhir/readers.py</code> <pre><code>def create_resource_from_dict(\n    resource_dict: Dict, resource_type: str\n) -&gt; Optional[Resource]:\n    \"\"\"Create a FHIR resource instance from a dictionary\n\n    Args:\n        resource_dict: Dictionary representation of the resource\n        resource_type: Type of FHIR resource to create\n\n    Returns:\n        Optional[Resource]: FHIR resource instance or None if creation failed\n    \"\"\"\n    try:\n        resource_module = importlib.import_module(\n            f\"fhir.resources.{resource_type.lower()}\"\n        )\n        resource_class = getattr(resource_module, resource_type)\n        return resource_class(**resource_dict)\n    except Exception as e:\n        logger.error(f\"Failed to create FHIR resource: {str(e)}\")\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.readers.prefetch_to_bundle","title":"<code>prefetch_to_bundle(prefetch)</code>","text":"<p>Flatten CDS Hooks prefetch into a collection Bundle dict.</p> <p>Converts the keyed prefetch format (used in CDS Hooks) into a flat bundle suitable for Dataset.from_fhir_bundle().</p> PARAMETER DESCRIPTION <code>prefetch</code> <p>CDS Hooks prefetch dict with format: {\"patient\": {...}, \"observations\": {\"entry\": [...]}, ...}</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Bundle dict with type \"collection\" and flattened entries</p> Example <p>prefetch = request.prefetch bundle = prefetch_to_bundle(prefetch) dataset = Dataset.from_fhir_bundle(bundle, schema=schema)</p> Source code in <code>healthchain/fhir/readers.py</code> <pre><code>def prefetch_to_bundle(prefetch: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Flatten CDS Hooks prefetch into a collection Bundle dict.\n\n    Converts the keyed prefetch format (used in CDS Hooks) into a flat bundle\n    suitable for Dataset.from_fhir_bundle().\n\n    Args:\n        prefetch: CDS Hooks prefetch dict with format:\n            {\"patient\": {...}, \"observations\": {\"entry\": [...]}, ...}\n\n    Returns:\n        Bundle dict with type \"collection\" and flattened entries\n\n    Example:\n        &gt;&gt;&gt; prefetch = request.prefetch\n        &gt;&gt;&gt; bundle = prefetch_to_bundle(prefetch)\n        &gt;&gt;&gt; dataset = Dataset.from_fhir_bundle(bundle, schema=schema)\n    \"\"\"\n    entries = []\n    for key, value in prefetch.items():\n        if isinstance(value, dict):\n            if \"entry\" in value:  # Searchset bundle\n                entries.extend(value[\"entry\"])\n            elif \"resourceType\" in value:  # Single resource\n                entries.append({\"resource\": value})\n    return {\"type\": \"collection\", \"entry\": entries}\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.readers.read_content_attachment","title":"<code>read_content_attachment(document_reference, include_data=True)</code>","text":"<p>Read the attachments in a human readable format from a FHIR DocumentReference content field.</p> PARAMETER DESCRIPTION <code>document_reference</code> <p>The FHIR DocumentReference resource</p> <p> TYPE: <code>DocumentReference</code> </p> <code>include_data</code> <p>Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[List[Dict[str, Any]]]</code> <p>Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata, or None if no attachments are found: [     {         \"data\": str,         \"metadata\": Dict[str, Any]     } ]</p> Source code in <code>healthchain/fhir/readers.py</code> <pre><code>def read_content_attachment(\n    document_reference: DocumentReference,\n    include_data: bool = True,\n) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"Read the attachments in a human readable format from a FHIR DocumentReference content field.\n\n    Args:\n        document_reference: The FHIR DocumentReference resource\n        include_data: Whether to include the data of the attachments. If true, the data will be also be decoded (default: True)\n\n    Returns:\n        Optional[List[Dict[str, Any]]]: List of dictionaries containing attachment data and metadata,\n            or None if no attachments are found:\n            [\n                {\n                    \"data\": str,\n                    \"metadata\": Dict[str, Any]\n                }\n            ]\n    \"\"\"\n    if not document_reference.content:\n        return None\n\n    attachments = []\n    for content in document_reference.content:\n        attachment = content.attachment\n        result = {}\n\n        if include_data:\n            result[\"data\"] = (\n                attachment.url if attachment.url else attachment.data.decode(\"utf-8\")\n            )\n\n        result[\"metadata\"] = {\n            \"content_type\": attachment.contentType,\n            \"title\": attachment.title,\n            \"creation\": attachment.creation,\n        }\n\n        attachments.append(result)\n\n    return attachments\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers","title":"<code>resourcehelpers</code>","text":"<p>FHIR resource creation and modification functions.</p> <p>This module provides convenience functions for creating and modifying FHIR resources.</p> <p>Patterns: - create_(): create a new FHIR resource with sensible defaults - set_(): set specific fields of resources with soft validation - add_*(): add data to resources safely</p> <p>Parameters marked REQUIRED are required by FHIR specification.</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.add_coding_to_codeable_concept","title":"<code>add_coding_to_codeable_concept(codeable_concept, code, system, display=None, version=None)</code>","text":"<p>Add a coding to an existing CodeableConcept.</p> <p>Useful for adding standardized codes (e.g., SNOMED CT) to resources that already have codes from other systems (e.g., ICD-10).</p> PARAMETER DESCRIPTION <code>codeable_concept</code> <p>The CodeableConcept to add coding to</p> <p> TYPE: <code>Any</code> </p> <code>code</code> <p>The code value from the code system</p> <p> TYPE: <code>str</code> </p> <code>system</code> <p>The code system URI</p> <p> TYPE: <code>str</code> </p> <code>display</code> <p>Optional display text for the code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use. If None, attempts to detect from the CodeableConcept.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CodeableConcept</code> <p>The updated CodeableConcept with the new coding added</p> <p> TYPE: <code>Any</code> </p> Example Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def add_coding_to_codeable_concept(\n    codeable_concept: Any,\n    code: str,\n    system: str,\n    display: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"Add a coding to an existing CodeableConcept.\n\n    Useful for adding standardized codes (e.g., SNOMED CT) to resources that already\n    have codes from other systems (e.g., ICD-10).\n\n    Args:\n        codeable_concept: The CodeableConcept to add coding to\n        code: The code value from the code system\n        system: The code system URI\n        display: Optional display text for the code\n        version: FHIR version to use. If None, attempts to detect from the CodeableConcept.\n\n    Returns:\n        CodeableConcept: The updated CodeableConcept with the new coding added\n\n    Example:\n        &gt;&gt;&gt; # Add SNOMED CT code to a condition that has ICD-10\n        &gt;&gt;&gt; condition_code = condition.code\n        &gt;&gt;&gt; condition_code = add_coding_to_codeable_concept(\n        ...     condition_code,\n        ...     code=\"44054006\",\n        ...     system=\"http://snomed.info/sct\",\n        ...     display=\"Type 2 diabetes mellitus\"\n        ... )\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource, get_resource_version\n\n    # Detect version from CodeableConcept if not provided\n    if version is None:\n        version = get_resource_version(codeable_concept)\n\n    Coding = get_fhir_resource(\"Coding\", version)\n\n    if not codeable_concept.coding:\n        codeable_concept.coding = []\n\n    codeable_concept.coding.append(Coding(system=system, code=code, display=display))\n\n    return codeable_concept\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.add_coding_to_codeable_concept--add-snomed-ct-code-to-a-condition-that-has-icd-10","title":"Add SNOMED CT code to a condition that has ICD-10","text":"<p>condition_code = condition.code condition_code = add_coding_to_codeable_concept( ...     condition_code, ...     code=\"44054006\", ...     system=\"http://snomed.info/sct\", ...     display=\"Type 2 diabetes mellitus\" ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.add_provenance_metadata","title":"<code>add_provenance_metadata(resource, source, tag_code=None, tag_display=None, version=None)</code>","text":"<p>Add provenance metadata to a FHIR resource.</p> <p>Adds source system identifier, timestamp, and optional processing tags to track data lineage and transformations for audit trails.</p> PARAMETER DESCRIPTION <code>resource</code> <p>The FHIR resource to annotate</p> <p> TYPE: <code>Any</code> </p> <code>source</code> <p>Name of the source system (e.g., \"epic\", \"cerner\")</p> <p> TYPE: <code>str</code> </p> <code>tag_code</code> <p>Optional tag code for processing operations (e.g., \"aggregated\", \"deduplicated\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>tag_display</code> <p>Optional display text for the tag</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use. If None, attempts to detect from the resource.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Resource</code> <p>The resource with added provenance metadata</p> <p> TYPE: <code>Any</code> </p> Example <p>condition = create_condition(subject=\"Patient/123\", code=\"E11.9\") condition = add_provenance_metadata(condition, \"epic\", \"aggregated\", \"Aggregated from source\")</p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def add_provenance_metadata(\n    resource: Any,\n    source: str,\n    tag_code: Optional[str] = None,\n    tag_display: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"Add provenance metadata to a FHIR resource.\n\n    Adds source system identifier, timestamp, and optional processing tags to track\n    data lineage and transformations for audit trails.\n\n    Args:\n        resource: The FHIR resource to annotate\n        source: Name of the source system (e.g., \"epic\", \"cerner\")\n        tag_code: Optional tag code for processing operations (e.g., \"aggregated\", \"deduplicated\")\n        tag_display: Optional display text for the tag\n        version: FHIR version to use. If None, attempts to detect from the resource.\n\n    Returns:\n        Resource: The resource with added provenance metadata\n\n    Example:\n        &gt;&gt;&gt; condition = create_condition(subject=\"Patient/123\", code=\"E11.9\")\n        &gt;&gt;&gt; condition = add_provenance_metadata(condition, \"epic\", \"aggregated\", \"Aggregated from source\")\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource, get_resource_version\n\n    # Detect version from resource if not provided\n    if version is None:\n        version = get_resource_version(resource)\n\n    Meta = get_fhir_resource(\"Meta\", version)\n    Coding = get_fhir_resource(\"Coding\", version)\n\n    if not resource.meta:\n        resource.meta = Meta()\n\n    # Add source system identifier\n    resource.meta.source = f\"urn:healthchain:source:{source}\"\n\n    # Update timestamp\n    resource.meta.lastUpdated = datetime.datetime.now(datetime.timezone.utc).isoformat()\n\n    # Add processing tag if provided\n    if tag_code:\n        if not resource.meta.tag:\n            resource.meta.tag = []\n\n        resource.meta.tag.append(\n            Coding(\n                system=\"https://dotimplement.github.io/HealthChain/fhir/tags\",\n                code=tag_code,\n                display=tag_display or tag_code,\n            )\n        )\n\n    return resource\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_allergy_intolerance","title":"<code>create_allergy_intolerance(patient, code=None, display=None, system='http://snomed.info/sct', version=None)</code>","text":"<p>Create a minimal active FHIR AllergyIntolerance. If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly. https://build.fhir.org/allergyintolerance.html</p> PARAMETER DESCRIPTION <code>patient</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>code</code> <p>The allergen code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the allergen</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AllergyIntolerance</code> <p>A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_allergy_intolerance(\n    patient: str,\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal active FHIR AllergyIntolerance.\n    If you need to create a more complex allergy intolerance, use the FHIR AllergyIntolerance resource directly.\n    https://build.fhir.org/allergyintolerance.html\n\n    Args:\n        patient: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        code: The allergen code\n        display: The display name for the allergen\n        system: The code system (default: SNOMED CT)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        AllergyIntolerance: A FHIR AllergyIntolerance resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    AllergyIntolerance = get_fhir_resource(\"AllergyIntolerance\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n\n    if code:\n        allergy_code = create_single_codeable_concept(code, display, system, version)\n    else:\n        allergy_code = None\n\n    allergy = AllergyIntolerance(\n        id=_generate_id(),\n        patient=ReferenceClass(reference=patient),\n        code=allergy_code,\n    )\n\n    return allergy\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_condition","title":"<code>create_condition(subject, clinical_status='active', code=None, display=None, system='http://snomed.info/sct', version=None)</code>","text":"<p>Create a minimal active FHIR Condition. If you need to create a more complex condition, use the FHIR Condition resource directly. https://build.fhir.org/condition.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>clinical_status</code> <p>REQUIRED. Clinical status (default: active)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'active'</code> </p> <code>code</code> <p>The condition code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the condition</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_condition(\n    subject: str,\n    clinical_status: str = \"active\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal active FHIR Condition.\n    If you need to create a more complex condition, use the FHIR Condition resource directly.\n    https://build.fhir.org/condition.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        clinical_status: REQUIRED. Clinical status (default: active)\n        code: The condition code\n        display: The display name for the condition\n        system: The code system (default: SNOMED CT)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        Condition: A FHIR Condition resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    Condition = get_fhir_resource(\"Condition\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n\n    if code:\n        condition_code = create_single_codeable_concept(code, display, system, version)\n    else:\n        condition_code = None\n\n    condition = Condition(\n        id=_generate_id(),\n        subject=ReferenceClass(reference=subject),\n        clinicalStatus=create_single_codeable_concept(\n            code=clinical_status,\n            display=clinical_status.capitalize(),\n            system=\"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            version=version,\n        ),\n        code=condition_code,\n    )\n\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_document_reference","title":"<code>create_document_reference(data=None, url=None, content_type=None, status='current', description='DocumentReference created by HealthChain', attachment_title='Attachment created by HealthChain', version=None)</code>","text":"<p>Create a minimal FHIR DocumentReference. If you need to create a more complex document reference, use the FHIR DocumentReference resource directly. https://build.fhir.org/documentreference.html</p> PARAMETER DESCRIPTION <code>data</code> <p>The data content of the document attachment</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>URL where the document can be accessed</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content_type</code> <p>MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>REQUIRED. Status of the document reference (default: current)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'current'</code> </p> <code>description</code> <p>Description of the document reference</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'DocumentReference created by HealthChain'</code> </p> <code>attachment_title</code> <p>Title for the document attachment</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'Attachment created by HealthChain'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DocumentReference</code> <p>A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_document_reference(\n    data: Optional[Any] = None,\n    url: Optional[str] = None,\n    content_type: Optional[str] = None,\n    status: str = \"current\",\n    description: Optional[str] = \"DocumentReference created by HealthChain\",\n    attachment_title: Optional[str] = \"Attachment created by HealthChain\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal FHIR DocumentReference.\n    If you need to create a more complex document reference, use the FHIR DocumentReference resource directly.\n    https://build.fhir.org/documentreference.html\n\n    Args:\n        data: The data content of the document attachment\n        url: URL where the document can be accessed\n        content_type: MIME type of the document (e.g. \"application/pdf\", \"text/xml\", \"image/png\")\n        status: REQUIRED. Status of the document reference (default: current)\n        description: Description of the document reference\n        attachment_title: Title for the document attachment\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        DocumentReference: A FHIR DocumentReference resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    DocumentReference = get_fhir_resource(\"DocumentReference\", version)\n\n    document_reference = DocumentReference(\n        id=_generate_id(),\n        status=status,\n        date=datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        ),\n        description=description,\n        content=[\n            {\n                \"attachment\": create_single_attachment(\n                    content_type=content_type,\n                    data=data,\n                    url=url,\n                    title=attachment_title,\n                    version=version,\n                )\n            }\n        ],\n    )\n\n    return document_reference\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_document_reference_content","title":"<code>create_document_reference_content(attachment_data=None, url=None, content_type='text/plain', language='en-US', title=None, version=None, **kwargs)</code>","text":"<p>Create a FHIR DocumentReferenceContent object.</p> <p>Creates a DocumentReferenceContent structure that can be added to a DocumentReference. Either attachment_data or url must be provided. If attachment_data is provided, it will be base64 encoded automatically.</p> PARAMETER DESCRIPTION <code>attachment_data</code> <p>The content data (text that will be base64 encoded)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>URL where the content can be accessed</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content_type</code> <p>MIME type (e.g., 'text/plain', 'text/html', 'application/pdf') (default: text/plain)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'text/plain'</code> </p> <code>language</code> <p>Language code (default: en-US)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'en-US'</code> </p> <code>title</code> <p>Optional title for the content (default: \"Attachment created by HealthChain\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional DocumentReferenceContent fields (e.g., format, profile)</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dict[str, Any]: A FHIR DocumentReferenceContent dictionary with attachment and optional language</p> Example Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_document_reference_content(\n    attachment_data: Optional[str] = None,\n    url: Optional[str] = None,\n    content_type: str = \"text/plain\",\n    language: Optional[str] = \"en-US\",\n    title: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n    **kwargs,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a FHIR DocumentReferenceContent object.\n\n    Creates a DocumentReferenceContent structure that can be added to a DocumentReference.\n    Either attachment_data or url must be provided. If attachment_data is provided, it will\n    be base64 encoded automatically.\n\n    Args:\n        attachment_data: The content data (text that will be base64 encoded)\n        url: URL where the content can be accessed\n        content_type: MIME type (e.g., 'text/plain', 'text/html', 'application/pdf') (default: text/plain)\n        language: Language code (default: en-US)\n        title: Optional title for the content (default: \"Attachment created by HealthChain\")\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n        **kwargs: Additional DocumentReferenceContent fields (e.g., format, profile)\n\n    Returns:\n        Dict[str, Any]: A FHIR DocumentReferenceContent dictionary with attachment and optional language\n\n    Example:\n        &gt;&gt;&gt; # Create content with inline data\n        &gt;&gt;&gt; content = create_document_reference_content(\n        ...     attachment_data=\"Patient presents with fever...\",\n        ...     content_type=\"text/plain\",\n        ...     title=\"Clinical Note\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create content with URL reference\n        &gt;&gt;&gt; content = create_document_reference_content(\n        ...     url=\"https://example.com/document.pdf\",\n        ...     content_type=\"application/pdf\",\n        ...     title=\"Lab Report\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Add content to a DocumentReference\n        &gt;&gt;&gt; doc_ref = DocumentReference(\n        ...     id=\"doc-1\",\n        ...     status=\"current\",\n        ...     content=[content]\n        ... )\n    \"\"\"\n    if not attachment_data and not url:\n        logger.warning(\n            \"No attachment_data or url provided for DocumentReferenceContent\"\n        )\n\n    if title is None:\n        title = \"Attachment created by HealthChain\"\n\n    attachment = create_single_attachment(\n        content_type=content_type,\n        data=attachment_data,\n        url=url,\n        title=title,\n        version=version,\n    )\n\n    content: Dict[str, Any] = {\n        \"attachment\": attachment,\n    }\n\n    if language:\n        content[\"language\"] = language\n\n    content.update(kwargs)\n\n    return content\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_document_reference_content--create-content-with-inline-data","title":"Create content with inline data","text":"<p>content = create_document_reference_content( ...     attachment_data=\"Patient presents with fever...\", ...     content_type=\"text/plain\", ...     title=\"Clinical Note\" ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_document_reference_content--create-content-with-url-reference","title":"Create content with URL reference","text":"<p>content = create_document_reference_content( ...     url=\"https://example.com/document.pdf\", ...     content_type=\"application/pdf\", ...     title=\"Lab Report\" ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_document_reference_content--add-content-to-a-documentreference","title":"Add content to a DocumentReference","text":"<p>doc_ref = DocumentReference( ...     id=\"doc-1\", ...     status=\"current\", ...     content=[content] ... )</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_medication_statement","title":"<code>create_medication_statement(subject, status='recorded', code=None, display=None, system='http://snomed.info/sct', version=None)</code>","text":"<p>Create a minimal recorded FHIR MedicationStatement. If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly. https://build.fhir.org/medicationstatement.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>status</code> <p>REQUIRED. Status of the medication (default: recorded)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'recorded'</code> </p> <code>code</code> <p>The medication code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>display</code> <p>The display name for the medication</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>system</code> <p>The code system (default: SNOMED CT)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://snomed.info/sct'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>MedicationStatement</code> <p>A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_medication_statement(\n    subject: str,\n    status: Optional[str] = \"recorded\",\n    code: Optional[str] = None,\n    display: Optional[str] = None,\n    system: Optional[str] = \"http://snomed.info/sct\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal recorded FHIR MedicationStatement.\n    If you need to create a more complex medication statement, use the FHIR MedicationStatement resource directly.\n    https://build.fhir.org/medicationstatement.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        status: REQUIRED. Status of the medication (default: recorded)\n        code: The medication code\n        display: The display name for the medication\n        system: The code system (default: SNOMED CT)\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        MedicationStatement: A FHIR MedicationStatement resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    MedicationStatement = get_fhir_resource(\"MedicationStatement\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n\n    if code:\n        medication_concept = create_single_codeable_concept(\n            code, display, system, version\n        )\n    else:\n        medication_concept = None\n\n    medication = MedicationStatement(\n        id=_generate_id(),\n        subject=ReferenceClass(reference=subject),\n        status=status,\n        medication={\"concept\": medication_concept},\n    )\n\n    return medication\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_patient","title":"<code>create_patient(gender=None, birth_date=None, identifier=None, identifier_system='http://hospital.example.org', version=None)</code>","text":"<p>Create a minimal FHIR Patient resource with basic gender and birthdate If you need to create a more complex patient, use the FHIR Patient resource directly https://hl7.org/fhir/patient.html (No required fields).</p> PARAMETER DESCRIPTION <code>gender</code> <p>Administrative gender (male, female, other, unknown)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>birth_date</code> <p>Birth date in YYYY-MM-DD format</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>identifier</code> <p>Optional identifier value for the patient (e.g., MRN)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>identifier_system</code> <p>The system for the identifier (default: \"http://hospital.example.org\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'http://hospital.example.org'</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Patient</code> <p>A FHIR Patient resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_patient(\n    gender: Optional[str] = None,\n    birth_date: Optional[str] = None,\n    identifier: Optional[str] = None,\n    identifier_system: Optional[str] = \"http://hospital.example.org\",\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal FHIR Patient resource with basic gender and birthdate\n    If you need to create a more complex patient, use the FHIR Patient resource directly\n    https://hl7.org/fhir/patient.html (No required fields).\n\n    Args:\n        gender: Administrative gender (male, female, other, unknown)\n        birth_date: Birth date in YYYY-MM-DD format\n        identifier: Optional identifier value for the patient (e.g., MRN)\n        identifier_system: The system for the identifier (default: \"http://hospital.example.org\")\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        Patient: A FHIR Patient resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    Patient = get_fhir_resource(\"Patient\", version)\n    Identifier = get_fhir_resource(\"Identifier\", version)\n\n    patient_id = _generate_id()\n\n    patient_data: Dict[str, Any] = {\"id\": patient_id}\n\n    if birth_date:\n        patient_data[\"birthDate\"] = birth_date\n\n    if gender:\n        patient_data[\"gender\"] = gender.lower()\n\n    if identifier:\n        patient_data[\"identifier\"] = [\n            Identifier(\n                system=identifier_system,\n                value=identifier,\n            )\n        ]\n\n    patient = Patient(**patient_data)\n    return patient\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_risk_assessment_from_prediction","title":"<code>create_risk_assessment_from_prediction(subject, prediction, status='final', method=None, basis=None, comment=None, occurrence_datetime=None, version=None)</code>","text":"<p>Create a FHIR RiskAssessment from ML model prediction output. If you need to create a more complex risk assessment, use the FHIR RiskAssessment resource directly. https://hl7.org/fhir/riskassessment.html</p> PARAMETER DESCRIPTION <code>subject</code> <p>REQUIRED. Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>str</code> </p> <code>prediction</code> <p>Dictionary containing prediction details with keys: - outcome: CodeableConcept or dict with code, display, system for the predicted outcome - probability: float between 0 and 1 representing the risk probability - qualitative_risk: Optional str indicating risk level (e.g., \"high\", \"moderate\", \"low\")</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>status</code> <p>REQUIRED. The status of the assessment (default: \"final\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'final'</code> </p> <code>method</code> <p>Optional CodeableConcept describing the assessment method/model used</p> <p> TYPE: <code>Optional[CodeableConcept]</code> DEFAULT: <code>None</code> </p> <code>basis</code> <p>Optional list of References to observations or other resources used as input</p> <p> TYPE: <code>Optional[List[Reference]]</code> DEFAULT: <code>None</code> </p> <code>comment</code> <p>Optional text comment about the assessment</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>occurrence_datetime</code> <p>When the assessment was made (ISO format). Uses current time if not provided.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>RiskAssessment</code> <p>A FHIR RiskAssessment resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Example <p>prediction = { ...     \"outcome\": {\"code\": \"A41.9\", \"display\": \"Sepsis\", \"system\": \"http://hl7.org/fhir/sid/icd-10\"}, ...     \"probability\": 0.85, ...     \"qualitative_risk\": \"high\" ... } risk = create_risk_assessment(\"Patient/123\", prediction)</p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_risk_assessment_from_prediction(\n    subject: str,\n    prediction: Dict[str, Any],\n    status: str = \"final\",\n    method: Optional[CodeableConcept] = None,\n    basis: Optional[List[Reference]] = None,\n    comment: Optional[str] = None,\n    occurrence_datetime: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a FHIR RiskAssessment from ML model prediction output.\n    If you need to create a more complex risk assessment, use the FHIR RiskAssessment resource directly.\n    https://hl7.org/fhir/riskassessment.html\n\n    Args:\n        subject: REQUIRED. Reference to the patient (e.g. \"Patient/123\")\n        prediction: Dictionary containing prediction details with keys:\n            - outcome: CodeableConcept or dict with code, display, system for the predicted outcome\n            - probability: float between 0 and 1 representing the risk probability\n            - qualitative_risk: Optional str indicating risk level (e.g., \"high\", \"moderate\", \"low\")\n        status: REQUIRED. The status of the assessment (default: \"final\")\n        method: Optional CodeableConcept describing the assessment method/model used\n        basis: Optional list of References to observations or other resources used as input\n        comment: Optional text comment about the assessment\n        occurrence_datetime: When the assessment was made (ISO format). Uses current time if not provided.\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        RiskAssessment: A FHIR RiskAssessment resource with an auto-generated ID prefixed with 'hc-'\n\n    Example:\n        &gt;&gt;&gt; prediction = {\n        ...     \"outcome\": {\"code\": \"A41.9\", \"display\": \"Sepsis\", \"system\": \"http://hl7.org/fhir/sid/icd-10\"},\n        ...     \"probability\": 0.85,\n        ...     \"qualitative_risk\": \"high\"\n        ... }\n        &gt;&gt;&gt; risk = create_risk_assessment(\"Patient/123\", prediction)\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    RiskAssessment = get_fhir_resource(\"RiskAssessment\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n\n    if not occurrence_datetime:\n        occurrence_datetime = datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        )\n\n    outcome = prediction.get(\"outcome\")\n    if isinstance(outcome, dict):\n        outcome_concept = create_single_codeable_concept(\n            code=outcome[\"code\"],\n            display=outcome.get(\"display\"),\n            system=outcome.get(\"system\", \"http://snomed.info/sct\"),\n            version=version,\n        )\n    else:\n        outcome_concept = outcome\n\n    prediction_data: Dict[str, Any] = {\n        \"outcome\": outcome_concept,\n    }\n\n    if \"probability\" in prediction:\n        prediction_data[\"probabilityDecimal\"] = prediction[\"probability\"]\n\n    if \"qualitative_risk\" in prediction:\n        prediction_data[\"qualitativeRisk\"] = create_single_codeable_concept(\n            code=prediction[\"qualitative_risk\"],\n            display=prediction[\"qualitative_risk\"].capitalize(),\n            system=\"http://terminology.hl7.org/CodeSystem/risk-probability\",\n            version=version,\n        )\n\n    risk_assessment_data: Dict[str, Any] = {\n        \"id\": _generate_id(),\n        \"status\": status,\n        \"subject\": ReferenceClass(reference=subject),\n        \"occurrenceDateTime\": occurrence_datetime,\n        \"prediction\": [prediction_data],\n    }\n\n    if method:\n        risk_assessment_data[\"method\"] = method\n\n    if basis:\n        risk_assessment_data[\"basis\"] = basis\n\n    if comment:\n        risk_assessment_data[\"note\"] = [{\"text\": comment}]\n\n    risk_assessment = RiskAssessment(**risk_assessment_data)\n\n    return risk_assessment\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.create_value_quantity_observation","title":"<code>create_value_quantity_observation(code, value, unit, status='final', subject=None, system='http://loinc.org', display=None, effective_datetime=None, version=None)</code>","text":"<p>Create a minimal FHIR Observation for vital signs or laboratory values. If you need to create a more complex observation, use the FHIR Observation resource directly. https://hl7.org/fhir/observation.html</p> PARAMETER DESCRIPTION <code>status</code> <p>REQUIRED. The status of the observation (default: \"final\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'final'</code> </p> <code>code</code> <p>REQUIRED. The observation code (e.g., LOINC code for the measurement)</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The numeric value of the observation</p> <p> TYPE: <code>float</code> </p> <code>unit</code> <p>The unit of measure (e.g., \"beats/min\", \"mg/dL\")</p> <p> TYPE: <code>str</code> </p> <code>system</code> <p>The code system for the observation code (default: LOINC)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://loinc.org'</code> </p> <code>display</code> <p>The display name for the observation code</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>effective_datetime</code> <p>When the observation was made (ISO format). Uses current time if not provided.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>subject</code> <p>Reference to the patient (e.g. \"Patient/123\")</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>version</code> <p>FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Observation</code> <p>A FHIR Observation resource with an auto-generated ID prefixed with 'hc-'</p> <p> TYPE: <code>Any</code> </p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def create_value_quantity_observation(\n    code: str,\n    value: float,\n    unit: str,\n    status: str = \"final\",\n    subject: Optional[str] = None,\n    system: str = \"http://loinc.org\",\n    display: Optional[str] = None,\n    effective_datetime: Optional[str] = None,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Create a minimal FHIR Observation for vital signs or laboratory values.\n    If you need to create a more complex observation, use the FHIR Observation resource directly.\n    https://hl7.org/fhir/observation.html\n\n    Args:\n        status: REQUIRED. The status of the observation (default: \"final\")\n        code: REQUIRED. The observation code (e.g., LOINC code for the measurement)\n        value: The numeric value of the observation\n        unit: The unit of measure (e.g., \"beats/min\", \"mg/dL\")\n        system: The code system for the observation code (default: LOINC)\n        display: The display name for the observation code\n        effective_datetime: When the observation was made (ISO format). Uses current time if not provided.\n        subject: Reference to the patient (e.g. \"Patient/123\")\n        version: FHIR version to use (e.g., \"R4B\", \"STU3\"). Defaults to current default.\n\n    Returns:\n        Observation: A FHIR Observation resource with an auto-generated ID prefixed with 'hc-'\n    \"\"\"\n    from healthchain.fhir.version import get_fhir_resource\n\n    Observation = get_fhir_resource(\"Observation\", version)\n    ReferenceClass = get_fhir_resource(\"Reference\", version)\n    Quantity = get_fhir_resource(\"Quantity\", version)\n\n    if not effective_datetime:\n        effective_datetime = datetime.datetime.now(datetime.timezone.utc).strftime(\n            \"%Y-%m-%dT%H:%M:%S%z\"\n        )\n    subject_ref = None\n    if subject is not None:\n        subject_ref = ReferenceClass(reference=subject)\n\n    observation = Observation(\n        id=_generate_id(),\n        status=status,\n        code=create_single_codeable_concept(code, display, system, version),\n        subject=subject_ref,\n        effectiveDateTime=effective_datetime,\n        valueQuantity=Quantity(\n            value=value, unit=unit, system=\"http://unitsofmeasure.org\", code=unit\n        ),\n    )\n\n    return observation\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.resourcehelpers.set_condition_category","title":"<code>set_condition_category(condition, category, version=None)</code>","text":"<p>Set the category of a FHIR Condition to either 'problem-list-item' or 'encounter-diagnosis'.</p> PARAMETER DESCRIPTION <code>condition</code> <p>The FHIR Condition resource to modify</p> <p> TYPE: <code>Any</code> </p> <code>category</code> <p>The category to set. Must be 'problem-list-item' or 'encounter-diagnosis'.</p> <p> TYPE: <code>str</code> </p> <code>version</code> <p>FHIR version to use. If None, attempts to detect from the condition resource.</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Condition</code> <p>The modified FHIR Condition resource with the specified category set</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the category is not one of the allowed values.</p> Source code in <code>healthchain/fhir/resourcehelpers.py</code> <pre><code>def set_condition_category(\n    condition: Any,\n    category: str,\n    version: Optional[Union[\"FHIRVersion\", str]] = None,\n) -&gt; Any:\n    \"\"\"\n    Set the category of a FHIR Condition to either 'problem-list-item' or 'encounter-diagnosis'.\n\n    Args:\n        condition: The FHIR Condition resource to modify\n        category: The category to set. Must be 'problem-list-item' or 'encounter-diagnosis'.\n        version: FHIR version to use. If None, attempts to detect from the condition resource.\n\n    Returns:\n        Condition: The modified FHIR Condition resource with the specified category set\n\n    Raises:\n        ValueError: If the category is not one of the allowed values.\n    \"\"\"\n    from healthchain.fhir.version import get_resource_version\n\n    # Detect version from resource if not provided\n    if version is None:\n        version = get_resource_version(condition)\n\n    allowed_categories = {\n        \"problem-list-item\": {\n            \"code\": \"problem-list-item\",\n            \"display\": \"Problem List Item\",\n        },\n        \"encounter-diagnosis\": {\n            \"code\": \"encounter-diagnosis\",\n            \"display\": \"Encounter Diagnosis\",\n        },\n    }\n    if category not in allowed_categories:\n        raise ValueError(\n            f\"Invalid category '{category}'. Must be one of: {list(allowed_categories.keys())}\"\n        )\n\n    cat_info = allowed_categories[category]\n    condition.category = [\n        create_single_codeable_concept(\n            code=cat_info[\"code\"],\n            display=cat_info[\"display\"],\n            system=\"http://terminology.hl7.org/CodeSystem/condition-category\",\n            version=version,\n        )\n    ]\n    return condition\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.utilities","title":"<code>utilities</code>","text":"<p>FHIR utility functions.</p> <p>This module provides utility functions for common operations like ID generation, age calculation, and gender encoding.</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.utilities.calculate_age_from_birthdate","title":"<code>calculate_age_from_birthdate(birth_date)</code>","text":"<p>Calculate age in years from a birth date string.</p> PARAMETER DESCRIPTION <code>birth_date</code> <p>Birth date in ISO format (YYYY-MM-DD or full ISO datetime)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[int]</code> <p>Age in years, or None if birth date is invalid</p> Source code in <code>healthchain/fhir/utilities.py</code> <pre><code>def calculate_age_from_birthdate(birth_date: str) -&gt; Optional[int]:\n    \"\"\"Calculate age in years from a birth date string.\n\n    Args:\n        birth_date: Birth date in ISO format (YYYY-MM-DD or full ISO datetime)\n\n    Returns:\n        Age in years, or None if birth date is invalid\n    \"\"\"\n    if not birth_date:\n        return None\n\n    try:\n        if isinstance(birth_date, str):\n            # Remove timezone info for simpler parsing\n            birth_date_clean = birth_date.replace(\"Z\", \"\").split(\"T\")[0]\n            birth_dt = datetime.datetime.strptime(birth_date_clean, \"%Y-%m-%d\")\n        else:\n            birth_dt = birth_date\n\n        # Calculate age\n        today = datetime.datetime.now()\n        age = today.year - birth_dt.year\n\n        # Adjust if birthday hasn't occurred this year\n        if (today.month, today.day) &lt; (birth_dt.month, birth_dt.day):\n            age -= 1\n\n        return age\n    except (ValueError, AttributeError, TypeError):\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.utilities.calculate_age_from_event_date","title":"<code>calculate_age_from_event_date(birth_date, event_date)</code>","text":"<p>Calculate age in years from birth date and event date (MIMIC-IV style).</p> <p>Uses the formula: age = year(eventDate) - year(birthDate) This matches MIMIC-IV on FHIR de-identified age calculation.</p> PARAMETER DESCRIPTION <code>birth_date</code> <p>Birth date in ISO format (YYYY-MM-DD or full ISO datetime)</p> <p> TYPE: <code>str</code> </p> <code>event_date</code> <p>Event date in ISO format (YYYY-MM-DD or full ISO datetime)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[int]</code> <p>Age in years based on year difference, or None if dates are invalid</p> Example <p>calculate_age_from_event_date(\"1990-06-15\", \"2020-03-10\") 30</p> Source code in <code>healthchain/fhir/utilities.py</code> <pre><code>def calculate_age_from_event_date(birth_date: str, event_date: str) -&gt; Optional[int]:\n    \"\"\"Calculate age in years from birth date and event date (MIMIC-IV style).\n\n    Uses the formula: age = year(eventDate) - year(birthDate)\n    This matches MIMIC-IV on FHIR de-identified age calculation.\n\n    Args:\n        birth_date: Birth date in ISO format (YYYY-MM-DD or full ISO datetime)\n        event_date: Event date in ISO format (YYYY-MM-DD or full ISO datetime)\n\n    Returns:\n        Age in years based on year difference, or None if dates are invalid\n\n    Example:\n        &gt;&gt;&gt; calculate_age_from_event_date(\"1990-06-15\", \"2020-03-10\")\n        30\n    \"\"\"\n    if not birth_date or not event_date:\n        return None\n\n    try:\n        # Parse birth date\n        if isinstance(birth_date, str):\n            birth_date_clean = birth_date.replace(\"Z\", \"\").split(\"T\")[0]\n            birth_year = int(birth_date_clean.split(\"-\")[0])\n        else:\n            birth_year = birth_date.year\n\n        # Parse event date\n        if isinstance(event_date, str):\n            event_date_clean = event_date.replace(\"Z\", \"\").split(\"T\")[0]\n            event_year = int(event_date_clean.split(\"-\")[0])\n        else:\n            event_year = event_date.year\n\n        # MIMIC-IV style: simple year difference\n        age = event_year - birth_year\n\n        return age\n    except (ValueError, AttributeError, TypeError, IndexError):\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.utilities.encode_gender","title":"<code>encode_gender(gender)</code>","text":"<p>Encode gender as integer for ML models.</p> <p>Standard encoding: Male=1, Female=0, Other/Unknown=None</p> PARAMETER DESCRIPTION <code>gender</code> <p>Gender string (case-insensitive)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[int]</code> <p>Encoded gender (1 for male, 0 for female, None for other/unknown)</p> Source code in <code>healthchain/fhir/utilities.py</code> <pre><code>def encode_gender(gender: str) -&gt; Optional[int]:\n    \"\"\"Encode gender as integer for ML models.\n\n    Standard encoding: Male=1, Female=0, Other/Unknown=None\n\n    Args:\n        gender: Gender string (case-insensitive)\n\n    Returns:\n        Encoded gender (1 for male, 0 for female, None for other/unknown)\n    \"\"\"\n    if not gender:\n        return None\n\n    gender_lower = gender.lower()\n    if gender_lower in [\"male\", \"m\"]:\n        return 1\n    elif gender_lower in [\"female\", \"f\"]:\n        return 0\n    else:\n        return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.version","title":"<code>version</code>","text":"<p>FHIR version management for multi-version support.</p> <p>This module provides utilities for working with different FHIR versions (STU3, R4B, R5). It enables dynamic resource loading, version context management, and basic resource conversion.</p> Usage <p>from healthchain.fhir.version import get_fhir_resource, FHIRVersion</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.version--get-a-resource-class-for-a-specific-version","title":"Get a resource class for a specific version","text":"<p>Patient_R4B = get_fhir_resource(\"Patient\", \"R4B\") Patient_R5 = get_fhir_resource(\"Patient\", FHIRVersion.R5)</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.version--set-the-default-version-for-the-session","title":"Set the default version for the session","text":"<p>set_default_version(\"R4B\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.version--use-context-manager-for-temporary-version-changes","title":"Use context manager for temporary version changes","text":"<p>with fhir_version_context(\"STU3\"):     patient = get_fhir_resource(\"Patient\")  # Returns STU3 Patient</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.version--convert-resources-between-versions","title":"Convert resources between versions","text":"<p>patient_r5 = Patient(id=\"123\", gender=\"male\") patient_r4b = convert_resource(patient_r5, \"R4B\")</p>"},{"location":"api/fhir_helpers/#healthchain.fhir.version.FHIRVersion","title":"<code>FHIRVersion</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported FHIR versions.</p> <p>R5 is the default version in fhir.resources library. R4B and STU3 are available via subpackages (e.g., fhir.resources.R4B).</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>class FHIRVersion(str, Enum):\n    \"\"\"Supported FHIR versions.\n\n    R5 is the default version in fhir.resources library.\n    R4B and STU3 are available via subpackages (e.g., fhir.resources.R4B).\n    \"\"\"\n\n    STU3 = \"STU3\"\n    R4B = \"R4B\"\n    R5 = \"R5\"\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.version.convert_resource","title":"<code>convert_resource(resource, target_version)</code>","text":"<p>Convert a FHIR resource to a different version.</p> <p>Converts by serializing the resource to a dictionary and deserializing with the target version's resource class. This approach works for resources with compatible field structures.</p> Note <p>Field mappings between FHIR versions may not be 1:1. Some fields may be added, removed, or renamed between versions. This function performs a best-effort conversion and may raise validation errors if the resource data is incompatible with the target version.</p> PARAMETER DESCRIPTION <code>resource</code> <p>The FHIR resource to convert</p> <p> TYPE: <code>Any</code> </p> <code>target_version</code> <p>The target FHIR version</p> <p> TYPE: <code>Union[FHIRVersion, str]</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>A new resource instance of the target version</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the resource type cannot be determined or imported</p> <code>ValidationError</code> <p>If the resource data is incompatible with target version</p> Example <p>from fhir.resources.patient import Patient patient_r5 = Patient(id=\"123\", gender=\"male\") patient_r4b = convert_resource(patient_r5, \"R4B\") print(patient_r4b.class.module) fhir.resources.R4B.patient</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def convert_resource(resource: Any, target_version: Union[FHIRVersion, str]) -&gt; Any:\n    \"\"\"Convert a FHIR resource to a different version.\n\n    Converts by serializing the resource to a dictionary and deserializing\n    with the target version's resource class. This approach works for\n    resources with compatible field structures.\n\n    Note:\n        Field mappings between FHIR versions may not be 1:1. Some fields\n        may be added, removed, or renamed between versions. This function\n        performs a best-effort conversion and may raise validation errors\n        if the resource data is incompatible with the target version.\n\n    Args:\n        resource: The FHIR resource to convert\n        target_version: The target FHIR version\n\n    Returns:\n        A new resource instance of the target version\n\n    Raises:\n        ValueError: If the resource type cannot be determined or imported\n        ValidationError: If the resource data is incompatible with target version\n\n    Example:\n        &gt;&gt;&gt; from fhir.resources.patient import Patient\n        &gt;&gt;&gt; patient_r5 = Patient(id=\"123\", gender=\"male\")\n        &gt;&gt;&gt; patient_r4b = convert_resource(patient_r5, \"R4B\")\n        &gt;&gt;&gt; print(patient_r4b.__class__.__module__)\n        fhir.resources.R4B.patient\n    \"\"\"\n    # Get the resource type name from the class\n    resource_type = resource.__class__.__name__\n\n    # Get the target version's resource class\n    target_class = get_fhir_resource(resource_type, target_version)\n\n    # Serialize to dict and deserialize with target class\n    data = resource.model_dump(exclude_none=True)\n\n    logger.debug(\n        f\"Converting {resource_type} from {resource.__class__.__module__} \"\n        f\"to {target_class.__module__}\"\n    )\n\n    return target_class.model_validate(data)\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.version.fhir_version_context","title":"<code>fhir_version_context(version)</code>","text":"<p>Context manager for temporarily changing the default FHIR version.</p> PARAMETER DESCRIPTION <code>version</code> <p>The FHIR version to use within the context</p> <p> TYPE: <code>Union[FHIRVersion, str]</code> </p> YIELDS DESCRIPTION <code>FHIRVersion</code> <p>The resolved FHIRVersion being used</p> Example <p>with fhir_version_context(\"R4B\") as v: ...     patient = get_fhir_resource(\"Patient\")  # R4B Patient ...     print(f\"Using {v}\")</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>@contextmanager\ndef fhir_version_context(\n    version: Union[FHIRVersion, str],\n) -&gt; Generator[FHIRVersion, None, None]:\n    \"\"\"Context manager for temporarily changing the default FHIR version.\n\n    Args:\n        version: The FHIR version to use within the context\n\n    Yields:\n        The resolved FHIRVersion being used\n\n    Example:\n        &gt;&gt;&gt; with fhir_version_context(\"R4B\") as v:\n        ...     patient = get_fhir_resource(\"Patient\")  # R4B Patient\n        ...     print(f\"Using {v}\")\n        &gt;&gt;&gt; # After context, default is restored\n    \"\"\"\n    global _default_version\n    previous_version = _default_version\n    resolved = _resolve_version(version)\n    _default_version = resolved\n    try:\n        yield resolved\n    finally:\n        _default_version = previous_version\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.version.fhir_version_context--after-context-default-is-restored","title":"After context, default is restored","text":""},{"location":"api/fhir_helpers/#healthchain.fhir.version.get_default_version","title":"<code>get_default_version()</code>","text":"<p>Get the current default FHIR version.</p> RETURNS DESCRIPTION <code>FHIRVersion</code> <p>The current default FHIRVersion (R5 if not explicitly set)</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def get_default_version() -&gt; FHIRVersion:\n    \"\"\"Get the current default FHIR version.\n\n    Returns:\n        The current default FHIRVersion (R5 if not explicitly set)\n    \"\"\"\n    return _default_version or FHIRVersion.R5\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.version.get_fhir_resource","title":"<code>get_fhir_resource(resource_name, version=None)</code>","text":"<p>Dynamically import a FHIR resource class based on version.</p> PARAMETER DESCRIPTION <code>resource_name</code> <p>Name of the FHIR resource (e.g., \"Patient\", \"Condition\")</p> <p> TYPE: <code>str</code> </p> <code>version</code> <p>FHIR version (None for default, or FHIRVersion enum/string)</p> <p> TYPE: <code>Optional[Union[FHIRVersion, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Type[Any]</code> <p>The FHIR resource class for the specified version</p> RAISES DESCRIPTION <code>ValueError</code> <p>If version is invalid or resource cannot be imported</p> Example <p>Patient_R5 = get_fhir_resource(\"Patient\") Patient_R4B = get_fhir_resource(\"Patient\", \"R4B\") Patient_STU3 = get_fhir_resource(\"Patient\", FHIRVersion.STU3)</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def get_fhir_resource(\n    resource_name: str, version: Optional[Union[FHIRVersion, str]] = None\n) -&gt; Type[Any]:\n    \"\"\"Dynamically import a FHIR resource class based on version.\n\n    Args:\n        resource_name: Name of the FHIR resource (e.g., \"Patient\", \"Condition\")\n        version: FHIR version (None for default, or FHIRVersion enum/string)\n\n    Returns:\n        The FHIR resource class for the specified version\n\n    Raises:\n        ValueError: If version is invalid or resource cannot be imported\n\n    Example:\n        &gt;&gt;&gt; Patient_R5 = get_fhir_resource(\"Patient\")\n        &gt;&gt;&gt; Patient_R4B = get_fhir_resource(\"Patient\", \"R4B\")\n        &gt;&gt;&gt; Patient_STU3 = get_fhir_resource(\"Patient\", FHIRVersion.STU3)\n    \"\"\"\n    resolved_version = _resolve_version(version)\n\n    # Build module path based on version\n    # R5 is the default (no subpackage), R4B and STU3 use subpackages\n    if resolved_version == FHIRVersion.R5:\n        module_path = f\"fhir.resources.{resource_name.lower()}\"\n    else:\n        module_path = f\"fhir.resources.{resolved_version.value}.{resource_name.lower()}\"\n\n    try:\n        module = importlib.import_module(module_path)\n        resource_class = getattr(module, resource_name)\n        logger.debug(f\"Loaded {resource_name} from {module_path}\")\n        return resource_class\n    except ImportError as e:\n        raise ValueError(\n            f\"Could not import resource type: {resource_name}. \"\n            f\"Make sure it is a valid FHIR resource type for version '{resolved_version.value}'.\"\n        ) from e\n    except AttributeError as e:\n        raise ValueError(\n            f\"Module '{module_path}' does not contain resource '{resource_name}'.\"\n        ) from e\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.version.get_resource_version","title":"<code>get_resource_version(resource)</code>","text":"<p>Detect the FHIR version of a resource based on its module path.</p> PARAMETER DESCRIPTION <code>resource</code> <p>A FHIR resource instance</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Optional[FHIRVersion]</code> <p>The FHIRVersion if detectable, None otherwise</p> Example <p>from fhir.resources.R4B.patient import Patient patient = Patient(id=\"123\") version = get_resource_version(patient) print(version) FHIRVersion.R4B</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def get_resource_version(resource: Any) -&gt; Optional[FHIRVersion]:\n    \"\"\"Detect the FHIR version of a resource based on its module path.\n\n    Args:\n        resource: A FHIR resource instance\n\n    Returns:\n        The FHIRVersion if detectable, None otherwise\n\n    Example:\n        &gt;&gt;&gt; from fhir.resources.R4B.patient import Patient\n        &gt;&gt;&gt; patient = Patient(id=\"123\")\n        &gt;&gt;&gt; version = get_resource_version(patient)\n        &gt;&gt;&gt; print(version)\n        FHIRVersion.R4B\n    \"\"\"\n    module = resource.__class__.__module__\n\n    if \".R4B.\" in module:\n        return FHIRVersion.R4B\n    elif \".STU3.\" in module:\n        return FHIRVersion.STU3\n    elif module.startswith(\"fhir.resources.\"):\n        return FHIRVersion.R5\n\n    return None\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.version.reset_default_version","title":"<code>reset_default_version()</code>","text":"<p>Reset the default FHIR version to library default (R5).</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def reset_default_version() -&gt; None:\n    \"\"\"Reset the default FHIR version to library default (R5).\"\"\"\n    global _default_version\n    _default_version = None\n    logger.debug(\"Default FHIR version reset to R5\")\n</code></pre>"},{"location":"api/fhir_helpers/#healthchain.fhir.version.set_default_version","title":"<code>set_default_version(version)</code>","text":"<p>Set the global default FHIR version.</p> PARAMETER DESCRIPTION <code>version</code> <p>The FHIR version to use as default</p> <p> TYPE: <code>Union[FHIRVersion, str]</code> </p> Example <p>set_default_version(\"R4B\") patient = get_fhir_resource(\"Patient\")  # Returns R4B Patient</p> Source code in <code>healthchain/fhir/version.py</code> <pre><code>def set_default_version(version: Union[FHIRVersion, str]) -&gt; None:\n    \"\"\"Set the global default FHIR version.\n\n    Args:\n        version: The FHIR version to use as default\n\n    Example:\n        &gt;&gt;&gt; set_default_version(\"R4B\")\n        &gt;&gt;&gt; patient = get_fhir_resource(\"Patient\")  # Returns R4B Patient\n    \"\"\"\n    global _default_version\n    _default_version = _resolve_version(version)\n    logger.info(f\"Default FHIR version set to {_default_version.value}\")\n</code></pre>"},{"location":"api/interop/","title":"Interoperability Engine","text":"<p>InteropConfigManager for HealthChain Interoperability Engine</p> <p>This module provides specialized configuration management for interoperability.</p> <p>CDA Parser for HealthChain Interoperability Engine</p> <p>This module provides functionality for parsing CDA XML documents.</p> <p>CDA Generator for HealthChain Interoperability Engine</p> <p>This module provides functionality for generating CDA documents.</p> <p>FHIR Generator for HealthChain Interoperability Engine</p> <p>This module provides functionality for generating FHIR resources from templates.</p> <p>Configuration validators for HealthChain</p> <p>This module provides validation models and utilities for configuration files.</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine","title":"<code>InteropEngine</code>","text":"<p>Generic interoperability engine for converting between healthcare formats</p> <p>The InteropEngine provides capabilities for converting between different healthcare data format standards, such as HL7 FHIR, CDA, and HL7v2.</p> <p>The engine uses a template-based approach for transformations, with templates stored in the configured template directory. Transformations are handled by format-specific parsers and generators that are lazily loaded as needed.</p> <p>Configuration is handled through the <code>config</code> property, which provides direct access to the underlying ConfigManager instance. This allows for setting validation levels, changing environments, and accessing configuration values.</p> <p>The engine supports registering custom parsers, generators, and validators to extend or override the default functionality.</p> Example <p>engine = InteropEngine()</p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>class InteropEngine:\n    \"\"\"Generic interoperability engine for converting between healthcare formats\n\n    The InteropEngine provides capabilities for converting between different\n    healthcare data format standards, such as HL7 FHIR, CDA, and HL7v2.\n\n    The engine uses a template-based approach for transformations, with templates\n    stored in the configured template directory. Transformations are handled by\n    format-specific parsers and generators that are lazily loaded as needed.\n\n    Configuration is handled through the `config` property, which provides\n    direct access to the underlying ConfigManager instance. This allows\n    for setting validation levels, changing environments, and accessing\n    configuration values.\n\n    The engine supports registering custom parsers, generators, and validators\n    to extend or override the default functionality.\n\n    Example:\n        engine = InteropEngine()\n\n        # Convert CDA to FHIR\n        fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")\n\n        # Convert FHIR to CDA\n        cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")\n\n        # Access config directly:\n        engine.config.set_environment(\"production\")\n        engine.config.set_validation_level(\"warn\")\n        value = engine.config.get_config_value(\"cda.sections.problems.resource\")\n\n        # Access the template registry:\n        template = engine.template_registry.get_template(\"cda_fhir/condition\")\n        engine.template_registry.add_filter()\n\n        # Register custom components:\n        engine.register_parser(FormatType.CDA, custom_parser)\n        engine.register_generator(FormatType.FHIR, custom_generator)\n\n        # Register custom configuration validators:\n        engine.register_cda_section_config_validator(\"Procedure\", ProcedureSectionConfig)\n        engine.register_cda_document_config_validator(\"CCD\", CCDDocumentConfig)\n    \"\"\"\n\n    def __init__(\n        self,\n        config_dir: Optional[Path] = None,\n        validation_level: str = ValidationLevel.STRICT,\n        environment: Optional[str] = None,\n    ):\n        \"\"\"Initialize the InteropEngine\n\n        Args:\n            config_dir: Base directory containing configuration files. If None, will search standard locations.\n            validation_level: Level of configuration validation (strict, warn, ignore)\n            environment: Optional environment to use (development, testing, production)\n        \"\"\"\n        # Initialize configuration manager\n        self.config = InteropConfigManager(config_dir, validation_level, environment)\n\n        # Initialize template registry\n        template_dir = config_dir / \"templates\"\n        self.template_registry = TemplateRegistry(template_dir)\n\n        # Create and register default filters\n        # Get required configuration for filters\n        mappings_dir = self.config.get_config_value(\"defaults.mappings_dir\")\n        if not mappings_dir:\n            log.warning(\"No mappings directory configured, using default mappings\")\n            mappings_dir = \"cda_default\"\n        mappings = self.config.get_mappings(mappings_dir)\n        id_prefix = self.config.get_config_value(\"defaults.common.id_prefix\")\n\n        # Get default filters from the filters module\n        default_filters = create_default_filters(mappings, id_prefix)\n        self.template_registry.initialize(default_filters)\n\n        # Component registries for lazy loading\n        self._parsers = {}\n        self._generators = {}\n\n    # Lazy-loaded parsers\n    @cached_property\n    def cda_parser(self):\n        \"\"\"Lazily load the CDA parser\"\"\"\n        return self._get_parser(FormatType.CDA)\n\n    @cached_property\n    def hl7v2_parser(self):\n        \"\"\"Lazily load the HL7v2 parser\"\"\"\n        return self._get_parser(FormatType.HL7V2)\n\n    # Lazy-loaded generators\n    @cached_property\n    def cda_generator(self):\n        \"\"\"Lazily load the CDA generator\"\"\"\n        return self._get_generator(FormatType.CDA)\n\n    @cached_property\n    def fhir_generator(self):\n        \"\"\"Lazily load the FHIR generator\"\"\"\n        return self._get_generator(FormatType.FHIR)\n\n    @cached_property\n    def hl7v2_generator(self):\n        \"\"\"Lazily load the HL7v2 generator\"\"\"\n        return self._get_generator(FormatType.HL7V2)\n\n    def _get_parser(self, format_type: FormatType):\n        \"\"\"Get or create a parser for the specified format\n\n        Args:\n            format_type: The format type to get a parser for (CDA or HL7v2)\n\n        Returns:\n            The parser instance for the specified format\n\n        Raises:\n            ValueError: If an unsupported format type is provided\n        \"\"\"\n        if format_type not in self._parsers:\n            if format_type == FormatType.CDA:\n                parser = CDAParser(self.config)\n                self._parsers[format_type] = parser\n            elif format_type == FormatType.HL7V2:\n                raise NotImplementedError(\"HL7v2 parser not implemented\")\n            else:\n                raise ValueError(f\"Unsupported parser format: {format_type}\")\n\n        return self._parsers[format_type]\n\n    def _get_generator(self, format_type: FormatType):\n        \"\"\"Get or create a generator for the specified format\n\n        Args:\n            format_type: The format type to get a generator for (CDA, HL7v2, or FHIR)\n\n        Returns:\n            The generator instance for the specified format\n\n        Raises:\n            ValueError: If an unsupported format type is provided\n        \"\"\"\n        if format_type not in self._generators:\n            if format_type == FormatType.CDA:\n                generator = CDAGenerator(self.config, self.template_registry)\n                self._generators[format_type] = generator\n            elif format_type == FormatType.HL7V2:\n                raise NotImplementedError(\"HL7v2 generator not implemented\")\n            elif format_type == FormatType.FHIR:\n                generator = FHIRGenerator(self.config, self.template_registry)\n                self._generators[format_type] = generator\n            else:\n                raise ValueError(f\"Unsupported generator format: {format_type}\")\n\n        return self._generators[format_type]\n\n    def register_parser(\n        self, format_type: FormatType, parser_instance: BaseParser\n    ) -&gt; \"InteropEngine\":\n        \"\"\"Register a custom parser for a format type. This will replace the default parser for the format type.\n\n        Args:\n            format_type: The format type (CDA, HL7v2) to register the parser for\n            parser_instance: The parser instance that implements the parsing logic\n\n        Returns:\n            InteropEngine: Returns self for method chaining\n\n        Example:\n            engine.register_parser(FormatType.CDA, CustomCDAParser())\n        \"\"\"\n        self._parsers[format_type] = parser_instance\n        return self\n\n    def register_generator(\n        self, format_type: FormatType, generator_instance: BaseGenerator\n    ) -&gt; \"InteropEngine\":\n        \"\"\"Register a custom generator for a format type. This will replace the default generator for the format type.\n\n        Args:\n            format_type: The format type (CDA, HL7v2, FHIR) to register the generator for\n            generator_instance: The generator instance that implements the generation logic\n\n        Returns:\n            InteropEngine: Returns self for method chaining\n\n        Example:\n            engine.register_generator(FormatType.CDA, CustomCDAGenerator())\n        \"\"\"\n        self._generators[format_type] = generator_instance\n        return self\n\n    # TODO: make the config validator functions more generic\n    def register_cda_section_config_validator(\n        self, resource_type: str, template_model: BaseModel\n    ) -&gt; \"InteropEngine\":\n        \"\"\"Register a custom section config validator model for a resource type\n\n        Args:\n            resource_type: FHIR resource type (e.g., \"Condition\", \"MedicationStatement\") which converts to the CDA section\n            template_model: Pydantic model for CDA section config validation\n\n        Returns:\n            Self for method chaining\n\n        Example:\n            # Register a config validator for the Problem section, which is converted from the Condition resource\n            engine.register_cda_section_config_validator(\n                \"Condition\", ProblemSectionConfig\n            )\n        \"\"\"\n        self.config.register_cda_section_config(resource_type, template_model)\n        return self\n\n    def register_cda_document_config_validator(\n        self, document_type: str, document_model: BaseModel\n    ) -&gt; \"InteropEngine\":\n        \"\"\"Register a custom document validator model for a document type\n\n        Args:\n            document_type: Document type (e.g., \"ccd\", \"discharge\")\n            document_model: Pydantic model for document validation\n\n        Returns:\n            Self for method chaining\n\n        Example:\n            # Register a config validator for the CCD document type\n            engine.register_cda_document_validator(\n                \"ccd\", CCDDocumentConfig\n            )\n        \"\"\"\n        self.config.register_cda_document_config(document_type, document_model)\n        return self\n\n    def to_fhir(\n        self, src_data: str, src_format: Union[str, FormatType]\n    ) -&gt; List[Resource]:\n        \"\"\"Convert source data to FHIR resources\n\n        Args:\n            src_data: Input data as string (CDA XML or HL7v2 message)\n            src_format: Source format type, either as string (\"cda\", \"hl7v2\")\n                         or FormatType enum\n\n        Returns:\n            List[Resource]: List of FHIR resources generated from the source data\n\n        Raises:\n            ValueError: If src_format is not supported\n\n        Example:\n            # Convert CDA XML to FHIR resources\n            fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")\n        \"\"\"\n        src_format = validate_format(src_format)\n\n        if src_format == FormatType.CDA:\n            return self._cda_to_fhir(src_data)\n        elif src_format == FormatType.HL7V2:\n            return self._hl7v2_to_fhir(src_data)\n        else:\n            raise ValueError(f\"Unsupported format: {src_format}\")\n\n    def from_fhir(\n        self,\n        resources: Union[List[Resource], Bundle],\n        dest_format: Union[str, FormatType],\n        **kwargs: Any,\n    ) -&gt; str:\n        \"\"\"Convert FHIR resources to a target format\n\n        Args:\n            resources: List of FHIR resources to convert or a FHIR Bundle\n            dest_format: Destination format type, either as string (\"cda\", \"hl7v2\")\n                        or FormatType enum\n            **kwargs: Additional arguments to pass to generator.\n                     For CDA: document_type (str) - Type of CDA document (e.g. \"ccd\", \"discharge\")\n\n        Returns:\n            str: Converted data as string (CDA XML or HL7v2 message)\n\n        Raises:\n            ValueError: If dest_format is not supported\n\n        Example:\n            # Convert FHIR resources to CDA XML\n            cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")\n        \"\"\"\n        dest_format = validate_format(dest_format)\n        resources = normalize_resource_list(resources)\n\n        if dest_format == FormatType.HL7V2:\n            return self._fhir_to_hl7v2(resources, **kwargs)\n        elif dest_format == FormatType.CDA:\n            return self._fhir_to_cda(resources, **kwargs)\n        else:\n            raise ValueError(f\"Unsupported format: {dest_format}\")\n\n    def _cda_to_fhir(self, xml: str, **kwargs) -&gt; List[Resource]:\n        \"\"\"Convert CDA XML to FHIR resources\n\n        Args:\n            xml: CDA document as XML string\n            **kwargs: Additional arguments to pass to parser and generator.\n\n        Returns:\n            List[Resource]: List of FHIR resources\n\n        Raises:\n            ValueError: If required mappings are missing or if sections are unsupported\n        \"\"\"\n        # Get parser and generator (lazy loaded)\n        parser = self.cda_parser\n        generator = self.fhir_generator\n\n        # Parse sections from CDA XML using the parser\n        section_entries = parser.from_string(xml)\n\n        # Process each section and convert entries to FHIR resources\n        resources = []\n        for section_key, entries in section_entries.items():\n            section_resources = generator.transform(\n                entries, src_format=FormatType.CDA, section_key=section_key\n            )\n            resources.extend(section_resources)\n\n        return resources\n\n    def _fhir_to_cda(self, resources: List[Resource], **kwargs) -&gt; str:\n        \"\"\"Convert FHIR resources to CDA XML\n\n        Args:\n            resources: A list of FHIR resources\n            **kwargs: Additional arguments to pass to generator.\n                     Supported arguments:\n                     - document_type: Type of CDA document (e.g. \"CCD\", \"Discharge Summary\")\n\n        Returns:\n            str: CDA document as XML string\n\n        Raises:\n            ValueError: If required mappings are missing or if resource types are unsupported\n        \"\"\"\n        # Get generators (lazy loaded)\n        cda_generator = self.cda_generator\n\n        # Check for document type\n        document_type = kwargs.get(\"document_type\", \"ccd\")\n        if document_type:\n            log.info(f\"Processing CDA document of type: {document_type}\")\n\n        # Get document configuration for this specific document type\n        doc_config = self.config.get_cda_document_config(document_type)\n        if not doc_config:\n            raise ValueError(\n                f\"Invalid or missing document configuration for type: {document_type}\"\n            )\n\n        return cda_generator.transform(resources, document_type=document_type)\n\n    def _hl7v2_to_fhir(self, source_data: str) -&gt; List[Resource]:\n        \"\"\"Convert HL7v2 to FHIR resources\"\"\"\n        parser = self.hl7v2_parser\n        generator = self.fhir_generator\n\n        # Parse HL7v2 message using the parser\n        message_entries = parser.from_string(source_data)\n\n        # Process each message entry and convert to FHIR resources\n        resources = []\n        for message_key, entries in message_entries.items():\n            resource_entries = generator.transform(\n                entries, src_format=FormatType.HL7V2, message_key=message_key\n            )\n            resources.extend(resource_entries)\n\n        return resources\n\n    def _fhir_to_hl7v2(self, resources: List[Resource]) -&gt; str:\n        \"\"\"Convert FHIR resources to HL7v2\"\"\"\n        generator = self.hl7v2_generator\n\n        # Process each resource and convert to HL7v2 message\n        messages = []\n        for resource in resources:\n            message = generator.transform(resource)\n            messages.append(message)\n\n        return messages\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--convert-cda-to-fhir","title":"Convert CDA to FHIR","text":"<p>fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--convert-fhir-to-cda","title":"Convert FHIR to CDA","text":"<p>cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--access-config-directly","title":"Access config directly:","text":"<p>engine.config.set_environment(\"production\") engine.config.set_validation_level(\"warn\") value = engine.config.get_config_value(\"cda.sections.problems.resource\")</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--access-the-template-registry","title":"Access the template registry:","text":"<p>template = engine.template_registry.get_template(\"cda_fhir/condition\") engine.template_registry.add_filter()</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--register-custom-components","title":"Register custom components:","text":"<p>engine.register_parser(FormatType.CDA, custom_parser) engine.register_generator(FormatType.FHIR, custom_generator)</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine--register-custom-configuration-validators","title":"Register custom configuration validators:","text":"<p>engine.register_cda_section_config_validator(\"Procedure\", ProcedureSectionConfig) engine.register_cda_document_config_validator(\"CCD\", CCDDocumentConfig)</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.cda_generator","title":"<code>cda_generator</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the CDA generator</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.cda_parser","title":"<code>cda_parser</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the CDA parser</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.fhir_generator","title":"<code>fhir_generator</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the FHIR generator</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.hl7v2_generator","title":"<code>hl7v2_generator</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the HL7v2 generator</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.hl7v2_parser","title":"<code>hl7v2_parser</code>  <code>cached</code> <code>property</code>","text":"<p>Lazily load the HL7v2 parser</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.__init__","title":"<code>__init__(config_dir=None, validation_level=ValidationLevel.STRICT, environment=None)</code>","text":"<p>Initialize the InteropEngine</p> PARAMETER DESCRIPTION <code>config_dir</code> <p>Base directory containing configuration files. If None, will search standard locations.</p> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>validation_level</code> <p>Level of configuration validation (strict, warn, ignore)</p> <p> TYPE: <code>str</code> DEFAULT: <code>STRICT</code> </p> <code>environment</code> <p>Optional environment to use (development, testing, production)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>def __init__(\n    self,\n    config_dir: Optional[Path] = None,\n    validation_level: str = ValidationLevel.STRICT,\n    environment: Optional[str] = None,\n):\n    \"\"\"Initialize the InteropEngine\n\n    Args:\n        config_dir: Base directory containing configuration files. If None, will search standard locations.\n        validation_level: Level of configuration validation (strict, warn, ignore)\n        environment: Optional environment to use (development, testing, production)\n    \"\"\"\n    # Initialize configuration manager\n    self.config = InteropConfigManager(config_dir, validation_level, environment)\n\n    # Initialize template registry\n    template_dir = config_dir / \"templates\"\n    self.template_registry = TemplateRegistry(template_dir)\n\n    # Create and register default filters\n    # Get required configuration for filters\n    mappings_dir = self.config.get_config_value(\"defaults.mappings_dir\")\n    if not mappings_dir:\n        log.warning(\"No mappings directory configured, using default mappings\")\n        mappings_dir = \"cda_default\"\n    mappings = self.config.get_mappings(mappings_dir)\n    id_prefix = self.config.get_config_value(\"defaults.common.id_prefix\")\n\n    # Get default filters from the filters module\n    default_filters = create_default_filters(mappings, id_prefix)\n    self.template_registry.initialize(default_filters)\n\n    # Component registries for lazy loading\n    self._parsers = {}\n    self._generators = {}\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.from_fhir","title":"<code>from_fhir(resources, dest_format, **kwargs)</code>","text":"<p>Convert FHIR resources to a target format</p> PARAMETER DESCRIPTION <code>resources</code> <p>List of FHIR resources to convert or a FHIR Bundle</p> <p> TYPE: <code>Union[List[Resource], Bundle]</code> </p> <code>dest_format</code> <p>Destination format type, either as string (\"cda\", \"hl7v2\")         or FormatType enum</p> <p> TYPE: <code>Union[str, FormatType]</code> </p> <code>**kwargs</code> <p>Additional arguments to pass to generator.      For CDA: document_type (str) - Type of CDA document (e.g. \"ccd\", \"discharge\")</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Converted data as string (CDA XML or HL7v2 message)</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If dest_format is not supported</p> Example Source code in <code>healthchain/interop/engine.py</code> <pre><code>def from_fhir(\n    self,\n    resources: Union[List[Resource], Bundle],\n    dest_format: Union[str, FormatType],\n    **kwargs: Any,\n) -&gt; str:\n    \"\"\"Convert FHIR resources to a target format\n\n    Args:\n        resources: List of FHIR resources to convert or a FHIR Bundle\n        dest_format: Destination format type, either as string (\"cda\", \"hl7v2\")\n                    or FormatType enum\n        **kwargs: Additional arguments to pass to generator.\n                 For CDA: document_type (str) - Type of CDA document (e.g. \"ccd\", \"discharge\")\n\n    Returns:\n        str: Converted data as string (CDA XML or HL7v2 message)\n\n    Raises:\n        ValueError: If dest_format is not supported\n\n    Example:\n        # Convert FHIR resources to CDA XML\n        cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")\n    \"\"\"\n    dest_format = validate_format(dest_format)\n    resources = normalize_resource_list(resources)\n\n    if dest_format == FormatType.HL7V2:\n        return self._fhir_to_hl7v2(resources, **kwargs)\n    elif dest_format == FormatType.CDA:\n        return self._fhir_to_cda(resources, **kwargs)\n    else:\n        raise ValueError(f\"Unsupported format: {dest_format}\")\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.from_fhir--convert-fhir-resources-to-cda-xml","title":"Convert FHIR resources to CDA XML","text":"<p>cda_xml = engine.from_fhir(fhir_resources, dest_format=\"cda\")</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_cda_document_config_validator","title":"<code>register_cda_document_config_validator(document_type, document_model)</code>","text":"<p>Register a custom document validator model for a document type</p> PARAMETER DESCRIPTION <code>document_type</code> <p>Document type (e.g., \"ccd\", \"discharge\")</p> <p> TYPE: <code>str</code> </p> <code>document_model</code> <p>Pydantic model for document validation</p> <p> TYPE: <code>BaseModel</code> </p> RETURNS DESCRIPTION <code>InteropEngine</code> <p>Self for method chaining</p> Example Source code in <code>healthchain/interop/engine.py</code> <pre><code>def register_cda_document_config_validator(\n    self, document_type: str, document_model: BaseModel\n) -&gt; \"InteropEngine\":\n    \"\"\"Register a custom document validator model for a document type\n\n    Args:\n        document_type: Document type (e.g., \"ccd\", \"discharge\")\n        document_model: Pydantic model for document validation\n\n    Returns:\n        Self for method chaining\n\n    Example:\n        # Register a config validator for the CCD document type\n        engine.register_cda_document_validator(\n            \"ccd\", CCDDocumentConfig\n        )\n    \"\"\"\n    self.config.register_cda_document_config(document_type, document_model)\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_cda_document_config_validator--register-a-config-validator-for-the-ccd-document-type","title":"Register a config validator for the CCD document type","text":"<p>engine.register_cda_document_validator(     \"ccd\", CCDDocumentConfig )</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_cda_section_config_validator","title":"<code>register_cda_section_config_validator(resource_type, template_model)</code>","text":"<p>Register a custom section config validator model for a resource type</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>FHIR resource type (e.g., \"Condition\", \"MedicationStatement\") which converts to the CDA section</p> <p> TYPE: <code>str</code> </p> <code>template_model</code> <p>Pydantic model for CDA section config validation</p> <p> TYPE: <code>BaseModel</code> </p> RETURNS DESCRIPTION <code>InteropEngine</code> <p>Self for method chaining</p> Example Source code in <code>healthchain/interop/engine.py</code> <pre><code>def register_cda_section_config_validator(\n    self, resource_type: str, template_model: BaseModel\n) -&gt; \"InteropEngine\":\n    \"\"\"Register a custom section config validator model for a resource type\n\n    Args:\n        resource_type: FHIR resource type (e.g., \"Condition\", \"MedicationStatement\") which converts to the CDA section\n        template_model: Pydantic model for CDA section config validation\n\n    Returns:\n        Self for method chaining\n\n    Example:\n        # Register a config validator for the Problem section, which is converted from the Condition resource\n        engine.register_cda_section_config_validator(\n            \"Condition\", ProblemSectionConfig\n        )\n    \"\"\"\n    self.config.register_cda_section_config(resource_type, template_model)\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_cda_section_config_validator--register-a-config-validator-for-the-problem-section-which-is-converted-from-the-condition-resource","title":"Register a config validator for the Problem section, which is converted from the Condition resource","text":"<p>engine.register_cda_section_config_validator(     \"Condition\", ProblemSectionConfig )</p>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_generator","title":"<code>register_generator(format_type, generator_instance)</code>","text":"<p>Register a custom generator for a format type. This will replace the default generator for the format type.</p> PARAMETER DESCRIPTION <code>format_type</code> <p>The format type (CDA, HL7v2, FHIR) to register the generator for</p> <p> TYPE: <code>FormatType</code> </p> <code>generator_instance</code> <p>The generator instance that implements the generation logic</p> <p> TYPE: <code>BaseGenerator</code> </p> RETURNS DESCRIPTION <code>InteropEngine</code> <p>Returns self for method chaining</p> <p> TYPE: <code>InteropEngine</code> </p> Example <p>engine.register_generator(FormatType.CDA, CustomCDAGenerator())</p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>def register_generator(\n    self, format_type: FormatType, generator_instance: BaseGenerator\n) -&gt; \"InteropEngine\":\n    \"\"\"Register a custom generator for a format type. This will replace the default generator for the format type.\n\n    Args:\n        format_type: The format type (CDA, HL7v2, FHIR) to register the generator for\n        generator_instance: The generator instance that implements the generation logic\n\n    Returns:\n        InteropEngine: Returns self for method chaining\n\n    Example:\n        engine.register_generator(FormatType.CDA, CustomCDAGenerator())\n    \"\"\"\n    self._generators[format_type] = generator_instance\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.register_parser","title":"<code>register_parser(format_type, parser_instance)</code>","text":"<p>Register a custom parser for a format type. This will replace the default parser for the format type.</p> PARAMETER DESCRIPTION <code>format_type</code> <p>The format type (CDA, HL7v2) to register the parser for</p> <p> TYPE: <code>FormatType</code> </p> <code>parser_instance</code> <p>The parser instance that implements the parsing logic</p> <p> TYPE: <code>BaseParser</code> </p> RETURNS DESCRIPTION <code>InteropEngine</code> <p>Returns self for method chaining</p> <p> TYPE: <code>InteropEngine</code> </p> Example <p>engine.register_parser(FormatType.CDA, CustomCDAParser())</p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>def register_parser(\n    self, format_type: FormatType, parser_instance: BaseParser\n) -&gt; \"InteropEngine\":\n    \"\"\"Register a custom parser for a format type. This will replace the default parser for the format type.\n\n    Args:\n        format_type: The format type (CDA, HL7v2) to register the parser for\n        parser_instance: The parser instance that implements the parsing logic\n\n    Returns:\n        InteropEngine: Returns self for method chaining\n\n    Example:\n        engine.register_parser(FormatType.CDA, CustomCDAParser())\n    \"\"\"\n    self._parsers[format_type] = parser_instance\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.to_fhir","title":"<code>to_fhir(src_data, src_format)</code>","text":"<p>Convert source data to FHIR resources</p> PARAMETER DESCRIPTION <code>src_data</code> <p>Input data as string (CDA XML or HL7v2 message)</p> <p> TYPE: <code>str</code> </p> <code>src_format</code> <p>Source format type, either as string (\"cda\", \"hl7v2\")          or FormatType enum</p> <p> TYPE: <code>Union[str, FormatType]</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List[Resource]: List of FHIR resources generated from the source data</p> RAISES DESCRIPTION <code>ValueError</code> <p>If src_format is not supported</p> Example Source code in <code>healthchain/interop/engine.py</code> <pre><code>def to_fhir(\n    self, src_data: str, src_format: Union[str, FormatType]\n) -&gt; List[Resource]:\n    \"\"\"Convert source data to FHIR resources\n\n    Args:\n        src_data: Input data as string (CDA XML or HL7v2 message)\n        src_format: Source format type, either as string (\"cda\", \"hl7v2\")\n                     or FormatType enum\n\n    Returns:\n        List[Resource]: List of FHIR resources generated from the source data\n\n    Raises:\n        ValueError: If src_format is not supported\n\n    Example:\n        # Convert CDA XML to FHIR resources\n        fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")\n    \"\"\"\n    src_format = validate_format(src_format)\n\n    if src_format == FormatType.CDA:\n        return self._cda_to_fhir(src_data)\n    elif src_format == FormatType.HL7V2:\n        return self._hl7v2_to_fhir(src_data)\n    else:\n        raise ValueError(f\"Unsupported format: {src_format}\")\n</code></pre>"},{"location":"api/interop/#healthchain.interop.engine.InteropEngine.to_fhir--convert-cda-xml-to-fhir-resources","title":"Convert CDA XML to FHIR resources","text":"<p>fhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")</p>"},{"location":"api/interop/#healthchain.interop.engine.normalize_resource_list","title":"<code>normalize_resource_list(resources)</code>","text":"<p>Convert input resources to a normalized list format</p> Source code in <code>healthchain/interop/engine.py</code> <pre><code>def normalize_resource_list(\n    resources: Union[Resource, List[Resource], Bundle],\n) -&gt; List[Resource]:\n    \"\"\"Convert input resources to a normalized list format\"\"\"\n    if isinstance(resources, Bundle):\n        return [entry.resource for entry in resources.entry if entry.resource]\n    elif isinstance(resources, list):\n        return resources\n    else:\n        return [resources]\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager","title":"<code>InteropConfigManager</code>","text":"<p>               Bases: <code>ConfigManager</code></p> <p>Specialized configuration manager for the interoperability module</p> <p>Extends ConfigManager to handle CDA document and section template configurations. Provides functionality for:</p> <ul> <li>Loading and validating interop configurations</li> <li>Managing document and section templates</li> <li>Registering custom validation models</li> </ul> <p>Configuration structure: - Document templates (under \"document\") - Section templates (under \"sections\") - Default values and settings</p> <p>Validation levels: - STRICT: Full validation (default) - WARN: Warning-only - IGNORE: No validation</p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>class InteropConfigManager(ConfigManager):\n    \"\"\"Specialized configuration manager for the interoperability module\n\n    Extends ConfigManager to handle CDA document and section template configurations.\n    Provides functionality for:\n\n    - Loading and validating interop configurations\n    - Managing document and section templates\n    - Registering custom validation models\n\n    Configuration structure:\n    - Document templates (under \"document\")\n    - Section templates (under \"sections\")\n    - Default values and settings\n\n    Validation levels:\n    - STRICT: Full validation (default)\n    - WARN: Warning-only\n    - IGNORE: No validation\n    \"\"\"\n\n    def __init__(\n        self,\n        config_dir: Path,\n        validation_level: str = ValidationLevel.STRICT,\n        environment: Optional[str] = None,\n    ):\n        \"\"\"Initialize the InteropConfigManager.\n\n        Initializes the configuration manager with the interop module and validates\n        the configuration. The interop module configuration must exist in the\n        specified config directory.\n\n        Args:\n            config_dir: Base directory containing configuration files\n            validation_level: Level of validation to perform. Default is STRICT.\n                Can be STRICT, WARN, or IGNORE.\n            environment: Optional environment name to load environment-specific configs.\n                If provided, will load and merge environment-specific configuration.\n\n        Raises:\n            ValueError: If the interop module configuration is not found in config_dir.\n        \"\"\"\n        # Initialize with \"interop\" as the fixed module\n        super().__init__(config_dir, validation_level, module=\"interop\")\n        self.load(environment, skip_validation=True)\n\n        if \"interop\" not in self._module_configs:\n            raise ValueError(\n                f\"Interop module not found in configuration directory {config_dir}\"\n            )\n\n        self.validate()\n\n    def _find_cda_document_types(self) -&gt; List[str]:\n        \"\"\"Find available CDA document types in the configs\n\n        Returns:\n            List of CDA document type strings\n        \"\"\"\n        # Get document types from cda/document path\n        doc_section = self._find_config_section(\n            module_name=\"interop\", section_path=\"cda/document\"\n        )\n\n        # If no document section exists, return empty list\n        if not doc_section:\n            return []\n\n        # Return the keys from the document section\n        return list(doc_section.keys())\n\n    def get_cda_section_configs(self, section_key: Optional[str] = None) -&gt; Dict:\n        \"\"\"Get CDA section configuration(s).\n\n        Retrieves section configurations from the loaded configs. When section_key is provided,\n        retrieves configuration for a specific section; otherwise, returns all section configurations.\n        Section configurations define how different CDA sections should be processed and mapped to\n        FHIR resources.\n\n        Args:\n            section_key: Optional section identifier (e.g., \"problems\", \"medications\").\n                         If provided, returns only that specific section's configuration.\n\n        Returns:\n            Dict: Dictionary mapping section keys to their configurations if section_key is None.\n                  Single section configuration dict if section_key is provided.\n\n        Raises:\n            ValueError: If section_key is provided but not found in configurations\n                       or if no sections are configured\n        \"\"\"\n        # Get all sections\n        sections = self._find_config_section(\n            module_name=\"interop\", section_path=\"cda/sections\"\n        )\n\n        if not sections:\n            raise ValueError(\"No CDA section configurations found\")\n\n        # If section_key is provided, return just that section\n        if section_key is not None:\n            if section_key not in sections:\n                raise ValueError(f\"Section configuration not found: {section_key}\")\n\n            # Basic validation that required fields exist\n            section_config = sections[section_key]\n            if \"resource\" not in section_config:\n                raise ValueError(\n                    f\"Invalid section configuration for {section_key}: missing 'resource' field\"\n                )\n\n            return section_config\n\n        return sections\n\n    def get_cda_document_config(self, document_type: str) -&gt; Dict:\n        \"\"\"Get CDA document configuration for a specific document type.\n\n        Retrieves the configuration for a CDA document type from the loaded configs.\n        The configuration contains template settings and other document-specific parameters.\n\n        Args:\n            document_type: Type of document (e.g., \"ccd\", \"discharge\") to get config for\n\n        Returns:\n            Dict containing the document configuration\n\n        Raises:\n            ValueError: If document_type is not found or the configuration is invalid\n        \"\"\"\n        document_config = self._find_config_section(\n            module_name=\"interop\", section_path=f\"cda/document/{document_type}\"\n        )\n\n        if not document_config:\n            raise ValueError(\n                f\"Document configuration not found for type: {document_type}\"\n            )\n\n        # Basic validation that required sections exist\n        if \"templates\" not in document_config:\n            raise ValueError(\n                f\"Invalid document configuration for {document_type}: missing 'templates' section\"\n            )\n\n        # Return the validated config\n        return document_config\n\n    def validate(self) -&gt; bool:\n        \"\"\"Validate that all required configurations are present for the interop module.\n\n        Validates both section and document configurations according to their registered\n        validation models. Section configs are required and will cause validation to fail\n        if missing or invalid. Document configs are optional but will be validated if present.\n\n        The validation behavior depends on the validation_level setting:\n        - IGNORE: Always returns True without validating\n        - WARN: Logs warnings for validation failures but returns True\n        - ERROR: Returns False if any validation fails\n\n        Returns:\n            bool: True if validation passes or is ignored, False if validation fails\n                 when validation_level is ERROR\n        \"\"\"\n        if self._validation_level == ValidationLevel.IGNORE:\n            return True\n\n        is_valid = super().validate()\n\n        # Validate section configs\n        try:\n            section_configs = self._find_config_section(\n                module_name=\"interop\", section_path=\"cda/sections\"\n            )\n            if not section_configs:\n                is_valid = self._handle_validation_error(\"No section configs found\")\n            else:\n                # Validate each section config\n                for section_key, section_config in section_configs.items():\n                    result = validate_cda_section_config_model(\n                        section_key, section_config\n                    )\n                    if not result:\n                        is_valid = self._handle_validation_error(\n                            f\"Section config validation failed for key: {section_key}\"\n                        )\n        except Exception as e:\n            is_valid = self._handle_validation_error(\n                f\"Error validating section configs: {str(e)}\"\n            )\n\n        # Validate document configs - but don't fail if no documents are configured\n        # since some use cases might not require documents\n        document_types = self._find_cda_document_types()\n        for doc_type in document_types:\n            try:\n                doc_config = self._find_config_section(\n                    module_name=\"interop\", section_path=f\"cda/document/{doc_type}\"\n                )\n                if doc_config:\n                    result = validate_cda_document_config_model(doc_type, doc_config)\n                    if not result:\n                        is_valid = self._handle_validation_error(\n                            f\"Document config validation failed for type: {doc_type}\"\n                        )\n            except Exception as e:\n                is_valid = self._handle_validation_error(\n                    f\"Error validating document config for {doc_type}: {str(e)}\"\n                )\n\n        return is_valid\n\n    def register_cda_section_config(\n        self, resource_type: str, config_model: Type[BaseModel]\n    ) -&gt; None:\n        \"\"\"Register a validation model for a CDA section configuration.\n\n        Registers a Pydantic model that will be used to validate configuration for a CDA section\n        that maps to a specific FHIR resource type. The model defines the required and optional\n        fields that should be present in the section configuration.\n\n        Args:\n            resource_type: FHIR resource type that the section maps to (e.g. \"Condition\")\n            config_model: Pydantic model class that defines the validation schema for the section config\n        \"\"\"\n        register_cda_section_template_config_model(resource_type, config_model)\n\n    def register_cda_document_config(\n        self, document_type: str, config_model: Type[BaseModel]\n    ) -&gt; None:\n        \"\"\"Register a validation model for a CDA document configuration.\n\n        Registers a Pydantic model that will be used to validate configuration for a CDA document\n        type. The model defines the required and optional fields that should be present in the\n        document configuration.\n\n        Args:\n            document_type: Document type identifier (e.g., \"ccd\", \"discharge\")\n            config_model: Pydantic model class that defines the validation schema for the document config\n        \"\"\"\n        register_cda_document_template_config_model(document_type, config_model)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.__init__","title":"<code>__init__(config_dir, validation_level=ValidationLevel.STRICT, environment=None)</code>","text":"<p>Initialize the InteropConfigManager.</p> <p>Initializes the configuration manager with the interop module and validates the configuration. The interop module configuration must exist in the specified config directory.</p> PARAMETER DESCRIPTION <code>config_dir</code> <p>Base directory containing configuration files</p> <p> TYPE: <code>Path</code> </p> <code>validation_level</code> <p>Level of validation to perform. Default is STRICT. Can be STRICT, WARN, or IGNORE.</p> <p> TYPE: <code>str</code> DEFAULT: <code>STRICT</code> </p> <code>environment</code> <p>Optional environment name to load environment-specific configs. If provided, will load and merge environment-specific configuration.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the interop module configuration is not found in config_dir.</p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def __init__(\n    self,\n    config_dir: Path,\n    validation_level: str = ValidationLevel.STRICT,\n    environment: Optional[str] = None,\n):\n    \"\"\"Initialize the InteropConfigManager.\n\n    Initializes the configuration manager with the interop module and validates\n    the configuration. The interop module configuration must exist in the\n    specified config directory.\n\n    Args:\n        config_dir: Base directory containing configuration files\n        validation_level: Level of validation to perform. Default is STRICT.\n            Can be STRICT, WARN, or IGNORE.\n        environment: Optional environment name to load environment-specific configs.\n            If provided, will load and merge environment-specific configuration.\n\n    Raises:\n        ValueError: If the interop module configuration is not found in config_dir.\n    \"\"\"\n    # Initialize with \"interop\" as the fixed module\n    super().__init__(config_dir, validation_level, module=\"interop\")\n    self.load(environment, skip_validation=True)\n\n    if \"interop\" not in self._module_configs:\n        raise ValueError(\n            f\"Interop module not found in configuration directory {config_dir}\"\n        )\n\n    self.validate()\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.get_cda_document_config","title":"<code>get_cda_document_config(document_type)</code>","text":"<p>Get CDA document configuration for a specific document type.</p> <p>Retrieves the configuration for a CDA document type from the loaded configs. The configuration contains template settings and other document-specific parameters.</p> PARAMETER DESCRIPTION <code>document_type</code> <p>Type of document (e.g., \"ccd\", \"discharge\") to get config for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict</code> <p>Dict containing the document configuration</p> RAISES DESCRIPTION <code>ValueError</code> <p>If document_type is not found or the configuration is invalid</p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def get_cda_document_config(self, document_type: str) -&gt; Dict:\n    \"\"\"Get CDA document configuration for a specific document type.\n\n    Retrieves the configuration for a CDA document type from the loaded configs.\n    The configuration contains template settings and other document-specific parameters.\n\n    Args:\n        document_type: Type of document (e.g., \"ccd\", \"discharge\") to get config for\n\n    Returns:\n        Dict containing the document configuration\n\n    Raises:\n        ValueError: If document_type is not found or the configuration is invalid\n    \"\"\"\n    document_config = self._find_config_section(\n        module_name=\"interop\", section_path=f\"cda/document/{document_type}\"\n    )\n\n    if not document_config:\n        raise ValueError(\n            f\"Document configuration not found for type: {document_type}\"\n        )\n\n    # Basic validation that required sections exist\n    if \"templates\" not in document_config:\n        raise ValueError(\n            f\"Invalid document configuration for {document_type}: missing 'templates' section\"\n        )\n\n    # Return the validated config\n    return document_config\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.get_cda_section_configs","title":"<code>get_cda_section_configs(section_key=None)</code>","text":"<p>Get CDA section configuration(s).</p> <p>Retrieves section configurations from the loaded configs. When section_key is provided, retrieves configuration for a specific section; otherwise, returns all section configurations. Section configurations define how different CDA sections should be processed and mapped to FHIR resources.</p> PARAMETER DESCRIPTION <code>section_key</code> <p>Optional section identifier (e.g., \"problems\", \"medications\").          If provided, returns only that specific section's configuration.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dict</code> <p>Dictionary mapping section keys to their configurations if section_key is None.   Single section configuration dict if section_key is provided.</p> <p> TYPE: <code>Dict</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If section_key is provided but not found in configurations        or if no sections are configured</p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def get_cda_section_configs(self, section_key: Optional[str] = None) -&gt; Dict:\n    \"\"\"Get CDA section configuration(s).\n\n    Retrieves section configurations from the loaded configs. When section_key is provided,\n    retrieves configuration for a specific section; otherwise, returns all section configurations.\n    Section configurations define how different CDA sections should be processed and mapped to\n    FHIR resources.\n\n    Args:\n        section_key: Optional section identifier (e.g., \"problems\", \"medications\").\n                     If provided, returns only that specific section's configuration.\n\n    Returns:\n        Dict: Dictionary mapping section keys to their configurations if section_key is None.\n              Single section configuration dict if section_key is provided.\n\n    Raises:\n        ValueError: If section_key is provided but not found in configurations\n                   or if no sections are configured\n    \"\"\"\n    # Get all sections\n    sections = self._find_config_section(\n        module_name=\"interop\", section_path=\"cda/sections\"\n    )\n\n    if not sections:\n        raise ValueError(\"No CDA section configurations found\")\n\n    # If section_key is provided, return just that section\n    if section_key is not None:\n        if section_key not in sections:\n            raise ValueError(f\"Section configuration not found: {section_key}\")\n\n        # Basic validation that required fields exist\n        section_config = sections[section_key]\n        if \"resource\" not in section_config:\n            raise ValueError(\n                f\"Invalid section configuration for {section_key}: missing 'resource' field\"\n            )\n\n        return section_config\n\n    return sections\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.register_cda_document_config","title":"<code>register_cda_document_config(document_type, config_model)</code>","text":"<p>Register a validation model for a CDA document configuration.</p> <p>Registers a Pydantic model that will be used to validate configuration for a CDA document type. The model defines the required and optional fields that should be present in the document configuration.</p> PARAMETER DESCRIPTION <code>document_type</code> <p>Document type identifier (e.g., \"ccd\", \"discharge\")</p> <p> TYPE: <code>str</code> </p> <code>config_model</code> <p>Pydantic model class that defines the validation schema for the document config</p> <p> TYPE: <code>Type[BaseModel]</code> </p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def register_cda_document_config(\n    self, document_type: str, config_model: Type[BaseModel]\n) -&gt; None:\n    \"\"\"Register a validation model for a CDA document configuration.\n\n    Registers a Pydantic model that will be used to validate configuration for a CDA document\n    type. The model defines the required and optional fields that should be present in the\n    document configuration.\n\n    Args:\n        document_type: Document type identifier (e.g., \"ccd\", \"discharge\")\n        config_model: Pydantic model class that defines the validation schema for the document config\n    \"\"\"\n    register_cda_document_template_config_model(document_type, config_model)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.register_cda_section_config","title":"<code>register_cda_section_config(resource_type, config_model)</code>","text":"<p>Register a validation model for a CDA section configuration.</p> <p>Registers a Pydantic model that will be used to validate configuration for a CDA section that maps to a specific FHIR resource type. The model defines the required and optional fields that should be present in the section configuration.</p> PARAMETER DESCRIPTION <code>resource_type</code> <p>FHIR resource type that the section maps to (e.g. \"Condition\")</p> <p> TYPE: <code>str</code> </p> <code>config_model</code> <p>Pydantic model class that defines the validation schema for the section config</p> <p> TYPE: <code>Type[BaseModel]</code> </p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def register_cda_section_config(\n    self, resource_type: str, config_model: Type[BaseModel]\n) -&gt; None:\n    \"\"\"Register a validation model for a CDA section configuration.\n\n    Registers a Pydantic model that will be used to validate configuration for a CDA section\n    that maps to a specific FHIR resource type. The model defines the required and optional\n    fields that should be present in the section configuration.\n\n    Args:\n        resource_type: FHIR resource type that the section maps to (e.g. \"Condition\")\n        config_model: Pydantic model class that defines the validation schema for the section config\n    \"\"\"\n    register_cda_section_template_config_model(resource_type, config_model)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.config_manager.InteropConfigManager.validate","title":"<code>validate()</code>","text":"<p>Validate that all required configurations are present for the interop module.</p> <p>Validates both section and document configurations according to their registered validation models. Section configs are required and will cause validation to fail if missing or invalid. Document configs are optional but will be validated if present.</p> <p>The validation behavior depends on the validation_level setting: - IGNORE: Always returns True without validating - WARN: Logs warnings for validation failures but returns True - ERROR: Returns False if any validation fails</p> RETURNS DESCRIPTION <code>bool</code> <p>True if validation passes or is ignored, False if validation fails  when validation_level is ERROR</p> <p> TYPE: <code>bool</code> </p> Source code in <code>healthchain/interop/config_manager.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"Validate that all required configurations are present for the interop module.\n\n    Validates both section and document configurations according to their registered\n    validation models. Section configs are required and will cause validation to fail\n    if missing or invalid. Document configs are optional but will be validated if present.\n\n    The validation behavior depends on the validation_level setting:\n    - IGNORE: Always returns True without validating\n    - WARN: Logs warnings for validation failures but returns True\n    - ERROR: Returns False if any validation fails\n\n    Returns:\n        bool: True if validation passes or is ignored, False if validation fails\n             when validation_level is ERROR\n    \"\"\"\n    if self._validation_level == ValidationLevel.IGNORE:\n        return True\n\n    is_valid = super().validate()\n\n    # Validate section configs\n    try:\n        section_configs = self._find_config_section(\n            module_name=\"interop\", section_path=\"cda/sections\"\n        )\n        if not section_configs:\n            is_valid = self._handle_validation_error(\"No section configs found\")\n        else:\n            # Validate each section config\n            for section_key, section_config in section_configs.items():\n                result = validate_cda_section_config_model(\n                    section_key, section_config\n                )\n                if not result:\n                    is_valid = self._handle_validation_error(\n                        f\"Section config validation failed for key: {section_key}\"\n                    )\n    except Exception as e:\n        is_valid = self._handle_validation_error(\n            f\"Error validating section configs: {str(e)}\"\n        )\n\n    # Validate document configs - but don't fail if no documents are configured\n    # since some use cases might not require documents\n    document_types = self._find_cda_document_types()\n    for doc_type in document_types:\n        try:\n            doc_config = self._find_config_section(\n                module_name=\"interop\", section_path=f\"cda/document/{doc_type}\"\n            )\n            if doc_config:\n                result = validate_cda_document_config_model(doc_type, doc_config)\n                if not result:\n                    is_valid = self._handle_validation_error(\n                        f\"Document config validation failed for type: {doc_type}\"\n                    )\n        except Exception as e:\n            is_valid = self._handle_validation_error(\n                f\"Error validating document config for {doc_type}: {str(e)}\"\n            )\n\n    return is_valid\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry","title":"<code>TemplateRegistry</code>","text":"<p>Manages loading and accessing Liquid templates for the InteropEngine.</p> <p>The TemplateRegistry handles loading Liquid template files from a directory and making them available for rendering. It supports custom filter functions that can be used within templates.</p> <p>Key features: - Loads .liquid template files recursively from a directory - Supports adding custom filter functions - Provides template lookup by name - Validates template existence</p> Example <p>registry = TemplateRegistry(Path(\"templates\")) registry.initialize({     \"uppercase\": str.upper,     \"lowercase\": str.lower }) template = registry.get_template(\"cda_fhir/condition\")</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>class TemplateRegistry:\n    \"\"\"Manages loading and accessing Liquid templates for the InteropEngine.\n\n    The TemplateRegistry handles loading Liquid template files from a directory and making them\n    available for rendering. It supports custom filter functions that can be used within templates.\n\n    Key features:\n    - Loads .liquid template files recursively from a directory\n    - Supports adding custom filter functions\n    - Provides template lookup by name\n    - Validates template existence\n\n    Example:\n        registry = TemplateRegistry(Path(\"templates\"))\n        registry.initialize({\n            \"uppercase\": str.upper,\n            \"lowercase\": str.lower\n        })\n        template = registry.get_template(\"cda_fhir/condition\")\n    \"\"\"\n\n    def __init__(self, template_dir: Path):\n        \"\"\"Initialize the TemplateRegistry\n\n        Args:\n            template_dir: Directory containing template files\n        \"\"\"\n        self.template_dir = template_dir\n        self._templates = {}\n        self._env = None\n        self._filters = {}\n\n        if not template_dir.exists():\n            raise ValueError(f\"Template directory not found: {template_dir}\")\n\n    def initialize(self, filters: Dict[str, Callable] = None) -&gt; \"TemplateRegistry\":\n        \"\"\"Initialize the Liquid environment and load templates.\n\n        This method sets up the Liquid template environment by:\n        1. Storing any provided filter functions\n        2. Creating the Liquid environment with the template directory\n        3. Loading all template files from the directory\n\n        The environment must be initialized before templates can be loaded or rendered.\n\n        Args:\n            filters: Optional dictionary mapping filter names to filter functions that can be used\n                    in templates. For example: {\"uppercase\": str.upper}\n\n        Returns:\n            TemplateRegistry: Returns self for method chaining\n\n        Raises:\n            ValueError: If template directory does not exist or environment initialization fails\n        \"\"\"\n        # Store initial filters\n        if filters:\n            self._filters.update(filters)\n\n        self._create_environment()\n        self._load_templates()\n        return self\n\n    def _create_environment(self) -&gt; None:\n        \"\"\"Create and configure the Liquid environment with registered filters\"\"\"\n        self._env = Environment(loader=FileSystemLoader(str(self.template_dir)))\n\n        # Register all filters\n        for name, func in self._filters.items():\n            self._env.filters[name] = func\n\n    def add_filter(self, name: str, filter_func: Callable) -&gt; \"TemplateRegistry\":\n        \"\"\"Add a custom filter function\n\n        Args:\n            name: Name of the filter to use in templates\n            filter_func: Filter function to register\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        # Add to internal filter registry\n        self._filters[name] = filter_func\n\n        # If environment is already initialized, register the filter\n        if self._env:\n            self._env.filters[name] = filter_func\n\n        return self\n\n    def add_filters(self, filters: Dict[str, Callable]) -&gt; \"TemplateRegistry\":\n        \"\"\"Add multiple custom filter functions\n\n        Args:\n            filters: Dictionary of filter names to filter functions\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        for name, func in filters.items():\n            self.add_filter(name, func)\n\n        return self\n\n    def _load_templates(self) -&gt; None:\n        \"\"\"Load all Liquid template files from the template directory.\n\n        This method recursively walks through the template directory and its subdirectories\n        to find all .liquid template files. Each template is loaded into the environment\n        and stored in the internal template registry using its full relative path (without extension)\n        as the key (e.g., \"cda_fhir/document\"). This is not required but recommended for clarity.\n        \"\"\"\n        if not self._env:\n            raise ValueError(\"Environment not initialized. Call initialize() first.\")\n\n        # Walk through all subdirectories to find template files\n        for template_file in self.template_dir.rglob(\"*.liquid\"):\n            rel_path = template_file.relative_to(self.template_dir)\n            # Use full path without extension as the key (e.g., \"cda_fhir/document\")\n            template_key = str(rel_path.with_suffix(\"\"))\n\n            try:\n                template = self._env.get_template(str(rel_path))\n                self._templates[template_key] = template\n                log.debug(f\"Loaded template: {template_key}\")\n            except Exception as e:\n                log.error(f\"Failed to load template {template_file}: {str(e)}\")\n                continue\n\n        if not self._templates:\n            raise ValueError(f\"No templates found in {self.template_dir}\")\n\n        log.info(f\"Loaded {len(self._templates)} templates\")\n\n    def get_template(self, template_key: str) -&gt; Template:\n        \"\"\"Get a template by key\n\n        Args:\n            template_key: Template identifier. Can be a full path (e.g., 'cda_fhir/document')\n                or just a filename (e.g., 'document').\n\n        Returns:\n            The template object\n\n        Raises:\n            KeyError: If template not found\n        \"\"\"\n        if template_key not in self._templates:\n            raise KeyError(f\"Template not found: {template_key}\")\n\n        return self._templates[template_key]\n\n    def has_template(self, template_key: str) -&gt; bool:\n        \"\"\"Check if a template exists\n\n        Args:\n            template_key: Template identifier. Can be a full path (e.g., 'cda_fhir/document')\n                or just a filename (e.g., 'document').\n\n        Returns:\n            True if template exists, False otherwise\n        \"\"\"\n        return template_key in self._templates\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.__init__","title":"<code>__init__(template_dir)</code>","text":"<p>Initialize the TemplateRegistry</p> PARAMETER DESCRIPTION <code>template_dir</code> <p>Directory containing template files</p> <p> TYPE: <code>Path</code> </p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def __init__(self, template_dir: Path):\n    \"\"\"Initialize the TemplateRegistry\n\n    Args:\n        template_dir: Directory containing template files\n    \"\"\"\n    self.template_dir = template_dir\n    self._templates = {}\n    self._env = None\n    self._filters = {}\n\n    if not template_dir.exists():\n        raise ValueError(f\"Template directory not found: {template_dir}\")\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.add_filter","title":"<code>add_filter(name, filter_func)</code>","text":"<p>Add a custom filter function</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the filter to use in templates</p> <p> TYPE: <code>str</code> </p> <code>filter_func</code> <p>Filter function to register</p> <p> TYPE: <code>Callable</code> </p> RETURNS DESCRIPTION <code>TemplateRegistry</code> <p>Self for method chaining</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def add_filter(self, name: str, filter_func: Callable) -&gt; \"TemplateRegistry\":\n    \"\"\"Add a custom filter function\n\n    Args:\n        name: Name of the filter to use in templates\n        filter_func: Filter function to register\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    # Add to internal filter registry\n    self._filters[name] = filter_func\n\n    # If environment is already initialized, register the filter\n    if self._env:\n        self._env.filters[name] = filter_func\n\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.add_filters","title":"<code>add_filters(filters)</code>","text":"<p>Add multiple custom filter functions</p> PARAMETER DESCRIPTION <code>filters</code> <p>Dictionary of filter names to filter functions</p> <p> TYPE: <code>Dict[str, Callable]</code> </p> RETURNS DESCRIPTION <code>TemplateRegistry</code> <p>Self for method chaining</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def add_filters(self, filters: Dict[str, Callable]) -&gt; \"TemplateRegistry\":\n    \"\"\"Add multiple custom filter functions\n\n    Args:\n        filters: Dictionary of filter names to filter functions\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    for name, func in filters.items():\n        self.add_filter(name, func)\n\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.get_template","title":"<code>get_template(template_key)</code>","text":"<p>Get a template by key</p> PARAMETER DESCRIPTION <code>template_key</code> <p>Template identifier. Can be a full path (e.g., 'cda_fhir/document') or just a filename (e.g., 'document').</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Template</code> <p>The template object</p> RAISES DESCRIPTION <code>KeyError</code> <p>If template not found</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def get_template(self, template_key: str) -&gt; Template:\n    \"\"\"Get a template by key\n\n    Args:\n        template_key: Template identifier. Can be a full path (e.g., 'cda_fhir/document')\n            or just a filename (e.g., 'document').\n\n    Returns:\n        The template object\n\n    Raises:\n        KeyError: If template not found\n    \"\"\"\n    if template_key not in self._templates:\n        raise KeyError(f\"Template not found: {template_key}\")\n\n    return self._templates[template_key]\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.has_template","title":"<code>has_template(template_key)</code>","text":"<p>Check if a template exists</p> PARAMETER DESCRIPTION <code>template_key</code> <p>Template identifier. Can be a full path (e.g., 'cda_fhir/document') or just a filename (e.g., 'document').</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if template exists, False otherwise</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def has_template(self, template_key: str) -&gt; bool:\n    \"\"\"Check if a template exists\n\n    Args:\n        template_key: Template identifier. Can be a full path (e.g., 'cda_fhir/document')\n            or just a filename (e.g., 'document').\n\n    Returns:\n        True if template exists, False otherwise\n    \"\"\"\n    return template_key in self._templates\n</code></pre>"},{"location":"api/interop/#healthchain.interop.template_registry.TemplateRegistry.initialize","title":"<code>initialize(filters=None)</code>","text":"<p>Initialize the Liquid environment and load templates.</p> <p>This method sets up the Liquid template environment by: 1. Storing any provided filter functions 2. Creating the Liquid environment with the template directory 3. Loading all template files from the directory</p> <p>The environment must be initialized before templates can be loaded or rendered.</p> PARAMETER DESCRIPTION <code>filters</code> <p>Optional dictionary mapping filter names to filter functions that can be used     in templates. For example: {\"uppercase\": str.upper}</p> <p> TYPE: <code>Dict[str, Callable]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>TemplateRegistry</code> <p>Returns self for method chaining</p> <p> TYPE: <code>TemplateRegistry</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If template directory does not exist or environment initialization fails</p> Source code in <code>healthchain/interop/template_registry.py</code> <pre><code>def initialize(self, filters: Dict[str, Callable] = None) -&gt; \"TemplateRegistry\":\n    \"\"\"Initialize the Liquid environment and load templates.\n\n    This method sets up the Liquid template environment by:\n    1. Storing any provided filter functions\n    2. Creating the Liquid environment with the template directory\n    3. Loading all template files from the directory\n\n    The environment must be initialized before templates can be loaded or rendered.\n\n    Args:\n        filters: Optional dictionary mapping filter names to filter functions that can be used\n                in templates. For example: {\"uppercase\": str.upper}\n\n    Returns:\n        TemplateRegistry: Returns self for method chaining\n\n    Raises:\n        ValueError: If template directory does not exist or environment initialization fails\n    \"\"\"\n    # Store initial filters\n    if filters:\n        self._filters.update(filters)\n\n    self._create_environment()\n    self._load_templates()\n    return self\n</code></pre>"},{"location":"api/interop/#healthchain.interop.parsers.cda.CDAParser","title":"<code>CDAParser</code>","text":"<p>               Bases: <code>BaseParser</code></p> <p>Parser for CDA XML documents.</p> <p>The CDAParser class provides functionality to parse Clinical Document Architecture (CDA) XML documents and extract structured data from their sections. It works in conjunction with the InteropConfigManager to identify and process sections based on configuration.</p> <p>Key capabilities: - Parse complete CDA XML documents - Extract entries from configured sections based on template IDs or codes - Convert and validate section entries into structured dictionaries (xmltodict)</p> <p>The parser uses configuration from InteropConfigManager to: - Identify sections by template ID or code - Map section contents to the appropriate data structures - Apply any configured transformations</p> ATTRIBUTE DESCRIPTION <code>config</code> <p>Configuration manager instance</p> <p> TYPE: <code>InteropConfigManager</code> </p> <code>clinical_document</code> <p>Currently loaded CDA document</p> <p> TYPE: <code>ClinicalDocument</code> </p> Source code in <code>healthchain/interop/parsers/cda.py</code> <pre><code>class CDAParser(BaseParser):\n    \"\"\"Parser for CDA XML documents.\n\n    The CDAParser class provides functionality to parse Clinical Document Architecture (CDA)\n    XML documents and extract structured data from their sections. It works in conjunction with\n    the InteropConfigManager to identify and process sections based on configuration.\n\n    Key capabilities:\n    - Parse complete CDA XML documents\n    - Extract entries from configured sections based on template IDs or codes\n    - Convert and validate section entries into structured dictionaries (xmltodict)\n\n    The parser uses configuration from InteropConfigManager to:\n    - Identify sections by template ID or code\n    - Map section contents to the appropriate data structures\n    - Apply any configured transformations\n\n    Attributes:\n        config (InteropConfigManager): Configuration manager instance\n        clinical_document (ClinicalDocument): Currently loaded CDA document\n    \"\"\"\n\n    def __init__(self, config: InteropConfigManager):\n        \"\"\"Initialize the CDA parser.\n\n        Args:\n            config: InteropConfigManager instance containing section configurations,\n                   templates, and mapping rules for CDA document parsing\n        \"\"\"\n        super().__init__(config)\n        self.clinical_document = None\n\n    def from_string(self, data: str) -&gt; dict:\n        \"\"\"\n        Parse input data and convert it to a structured format.\n\n        Args:\n            data: The CDA XML document string to parse\n\n        Returns:\n            A dictionary containing the parsed data structure with sections\n        \"\"\"\n        return self.parse_document(data)\n\n    def parse_document(self, xml: str) -&gt; Dict[str, List[Dict]]:\n        \"\"\"Parse a complete CDA document and extract entries from all configured sections.\n\n        This method parses a CDA XML document and extracts entries from each section that is\n        defined in the configuration. It uses xmltodict to parse the XML into a dictionary\n        and then processes each configured section to extract its entries.\n\n        Args:\n            xml: The CDA XML document string to parse\n\n        Returns:\n            Dict[str, List[Dict]]: Dictionary mapping section keys (e.g. \"problems\",\n                \"medications\") to lists of entry dictionaries containing the parsed data\n                from that section (xmltodict format).\n\n        Raises:\n            ValueError: If the XML string is empty or invalid\n            Exception: If there is an error parsing the document or any section\n\n        Example:\n            &gt;&gt;&gt; parser = CDAParser(config)\n            &gt;&gt;&gt; sections = parser.from_string(cda_xml)\n            &gt;&gt;&gt; problems = sections.get(\"problems\", [])\n        \"\"\"\n        section_entries = {}\n\n        # Parse the document once\n        try:\n            doc_dict = xmltodict.parse(xml)\n            self.clinical_document = ClinicalDocument(**doc_dict[\"ClinicalDocument\"])\n        except Exception as e:\n            log.error(f\"Error parsing CDA document: {str(e)}\")\n            return section_entries\n\n        # Get section configurations\n        sections = self.config.get_cda_section_configs()\n        if not sections:\n            log.warning(\"No sections found in configuration\")\n            return section_entries\n\n        # Process each section from the configuration\n        for section_key in sections.keys():\n            try:\n                entries = self._parse_section_entries_from_document(section_key)\n                if entries:\n                    section_entries[section_key] = entries\n            except Exception as e:\n                log.error(f\"Failed to parse section {section_key}: {str(e)}\")\n                continue\n\n        return section_entries\n\n    def _parse_section_entries_from_document(self, section_key: str) -&gt; List[Dict]:\n        \"\"\"Extract entries from a CDA section using an already parsed document.\n\n        Args:\n            section_key: Key identifying the section in the configuration (e.g. \"problems\",\n                \"medications\"). Must match a section defined in the configuration.\n\n        Returns:\n            List[Dict]: List of entry dictionaries from the matched section. Each dictionary\n                contains the parsed data from a single entry in the section. Returns an empty\n                list if no entries are found or if an error occurs.\n\n        Raises:\n            ValueError: If no template_id or code is configured for the section_key, or if\n                no matching section is found in the document.\n            Exception: If there is an error parsing the section or its entries.\n        \"\"\"\n        entries_dicts = []\n        if not self.clinical_document:\n            log.error(\"No document loaded. Call parse_document first.\")\n            return entries_dicts\n\n        try:\n            # Get all components\n            components = self.clinical_document.component.structuredBody.component\n            if not isinstance(components, list):\n                components = [components]\n\n            # Find matching section\n            section = None\n            for component in components:\n                curr_section = component.section\n\n                # Get template_id and code from config_manager\n                template_id = self.config.get_config_value(\n                    f\"cda.sections.{section_key}.identifiers.template_id\"\n                )\n                code = self.config.get_config_value(\n                    f\"cda.sections.{section_key}.identifiers.code\"\n                )\n\n                if not template_id and not code:\n                    raise ValueError(\n                        f\"No template_id or code found for section {section_key}: \\\n                            configure one of the following: \\\n                            cda.sections.{section_key}.identifiers.template_id \\\n                            or cda.sections.{section_key}.identifiers.code\"\n                    )\n\n                if template_id and self._find_section_by_template_id(\n                    curr_section, template_id\n                ):\n                    section = curr_section\n                    break\n\n                if code and self._find_section_by_code(curr_section, code):\n                    section = curr_section\n                    break\n\n            if not section:\n                log.warning(\n                    f\"Section with template_id: {template_id} or code: {code} not found in CDA document for key: {section_key}\"\n                )\n                return entries_dicts\n\n            # Check if this is a notes section (which doesn't have entries but has text) - temporary workaround\n            if section_key == \"notes\":\n                # For notes section, create a synthetic entry with the section's text content\n                section_dict = section.model_dump(exclude_none=True, by_alias=True)\n                log.debug(\n                    f\"Created synthetic entry for notes section with text: {type(section.text)}\"\n                )\n                # Return the entire section as the entry for DocumentReference\n                return [section_dict]\n\n            # Get entries from section (normal case for other sections)\n            if section.entry:\n                entries_dicts = (\n                    section.entry\n                    if isinstance(section.entry, list)\n                    else [section.entry]\n                )\n            else:\n                log.warning(f\"No entries found for section {section_key}\")\n                return entries_dicts\n\n            # Convert entries to dictionaries\n            entry_dicts = [\n                entry.model_dump(exclude_none=True, by_alias=True)\n                for entry in entries_dicts\n                if entry\n            ]\n\n            log.debug(f\"Found {len(entry_dicts)} entries in section {section_key}\")\n\n            return entry_dicts\n\n        except Exception as e:\n            log.error(f\"Error parsing section {section_key}: {str(e)}\")\n            return entries_dicts\n\n    def _find_section_by_template_id(self, section: Section, template_id: str) -&gt; bool:\n        \"\"\"Returns True if section has matching template ID\"\"\"\n        if not section.templateId:\n            return False\n\n        template_ids = (\n            section.templateId\n            if isinstance(section.templateId, list)\n            else [section.templateId]\n        )\n        return any(tid.root == template_id for tid in template_ids)\n\n    def _find_section_by_code(self, section: Section, code: str) -&gt; bool:\n        \"\"\"Returns True if section has matching code\"\"\"\n        return bool(section.code and section.code.code == code)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.parsers.cda.CDAParser.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the CDA parser.</p> PARAMETER DESCRIPTION <code>config</code> <p>InteropConfigManager instance containing section configurations,    templates, and mapping rules for CDA document parsing</p> <p> TYPE: <code>InteropConfigManager</code> </p> Source code in <code>healthchain/interop/parsers/cda.py</code> <pre><code>def __init__(self, config: InteropConfigManager):\n    \"\"\"Initialize the CDA parser.\n\n    Args:\n        config: InteropConfigManager instance containing section configurations,\n               templates, and mapping rules for CDA document parsing\n    \"\"\"\n    super().__init__(config)\n    self.clinical_document = None\n</code></pre>"},{"location":"api/interop/#healthchain.interop.parsers.cda.CDAParser.from_string","title":"<code>from_string(data)</code>","text":"<p>Parse input data and convert it to a structured format.</p> PARAMETER DESCRIPTION <code>data</code> <p>The CDA XML document string to parse</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the parsed data structure with sections</p> Source code in <code>healthchain/interop/parsers/cda.py</code> <pre><code>def from_string(self, data: str) -&gt; dict:\n    \"\"\"\n    Parse input data and convert it to a structured format.\n\n    Args:\n        data: The CDA XML document string to parse\n\n    Returns:\n        A dictionary containing the parsed data structure with sections\n    \"\"\"\n    return self.parse_document(data)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.parsers.cda.CDAParser.parse_document","title":"<code>parse_document(xml)</code>","text":"<p>Parse a complete CDA document and extract entries from all configured sections.</p> <p>This method parses a CDA XML document and extracts entries from each section that is defined in the configuration. It uses xmltodict to parse the XML into a dictionary and then processes each configured section to extract its entries.</p> PARAMETER DESCRIPTION <code>xml</code> <p>The CDA XML document string to parse</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, List[Dict]]</code> <p>Dict[str, List[Dict]]: Dictionary mapping section keys (e.g. \"problems\", \"medications\") to lists of entry dictionaries containing the parsed data from that section (xmltodict format).</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the XML string is empty or invalid</p> <code>Exception</code> <p>If there is an error parsing the document or any section</p> Example <p>parser = CDAParser(config) sections = parser.from_string(cda_xml) problems = sections.get(\"problems\", [])</p> Source code in <code>healthchain/interop/parsers/cda.py</code> <pre><code>def parse_document(self, xml: str) -&gt; Dict[str, List[Dict]]:\n    \"\"\"Parse a complete CDA document and extract entries from all configured sections.\n\n    This method parses a CDA XML document and extracts entries from each section that is\n    defined in the configuration. It uses xmltodict to parse the XML into a dictionary\n    and then processes each configured section to extract its entries.\n\n    Args:\n        xml: The CDA XML document string to parse\n\n    Returns:\n        Dict[str, List[Dict]]: Dictionary mapping section keys (e.g. \"problems\",\n            \"medications\") to lists of entry dictionaries containing the parsed data\n            from that section (xmltodict format).\n\n    Raises:\n        ValueError: If the XML string is empty or invalid\n        Exception: If there is an error parsing the document or any section\n\n    Example:\n        &gt;&gt;&gt; parser = CDAParser(config)\n        &gt;&gt;&gt; sections = parser.from_string(cda_xml)\n        &gt;&gt;&gt; problems = sections.get(\"problems\", [])\n    \"\"\"\n    section_entries = {}\n\n    # Parse the document once\n    try:\n        doc_dict = xmltodict.parse(xml)\n        self.clinical_document = ClinicalDocument(**doc_dict[\"ClinicalDocument\"])\n    except Exception as e:\n        log.error(f\"Error parsing CDA document: {str(e)}\")\n        return section_entries\n\n    # Get section configurations\n    sections = self.config.get_cda_section_configs()\n    if not sections:\n        log.warning(\"No sections found in configuration\")\n        return section_entries\n\n    # Process each section from the configuration\n    for section_key in sections.keys():\n        try:\n            entries = self._parse_section_entries_from_document(section_key)\n            if entries:\n                section_entries[section_key] = entries\n        except Exception as e:\n            log.error(f\"Failed to parse section {section_key}: {str(e)}\")\n            continue\n\n    return section_entries\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.cda.CDAGenerator","title":"<code>CDAGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>Handles generation of CDA documents from FHIR resources.</p> <p>This class provides functionality to convert FHIR resources into CDA (Clinical Document Architecture) documents using configurable templates. It handles the mapping of resources to appropriate CDA sections, rendering of entries and sections, and generation of the final XML document.</p> Example <p>generator = CDAGenerator(config_manager, template_registry)</p> Source code in <code>healthchain/interop/generators/cda.py</code> <pre><code>class CDAGenerator(BaseGenerator):\n    \"\"\"Handles generation of CDA documents from FHIR resources.\n\n    This class provides functionality to convert FHIR resources into CDA (Clinical Document Architecture)\n    documents using configurable templates. It handles the mapping of resources to appropriate CDA sections,\n    rendering of entries and sections, and generation of the final XML document.\n\n    Example:\n        generator = CDAGenerator(config_manager, template_registry)\n\n        # Convert FHIR resources to CDA XML document\n        cda_xml = generator.transform(\n            resources=fhir_resources,\n            document_type=\"ccd\"\n        )\n    \"\"\"\n\n    def transform(self, resources: List[Resource], **kwargs: Any) -&gt; str:\n        \"\"\"Transform FHIR resources to CDA format.\n\n        Args:\n            resources: List of FHIR resources\n            **kwargs:\n                document_type: Type of CDA document\n\n        Returns:\n            str: CDA document as XML string\n        \"\"\"\n        # TODO: add validation\n        document_type = kwargs.get(\"document_type\", \"ccd\")\n        return self.generate_document_from_fhir_resources(resources, document_type)\n\n    def generate_document_from_fhir_resources(\n        self,\n        resources: List[Resource],\n        document_type: str,\n        validate: bool = True,\n    ) -&gt; str:\n        \"\"\"Generate a complete CDA document from FHIR resources\n\n        This method handles the entire process of generating a CDA document:\n        1. Mapping FHIR resources to CDA sections (config)\n        2. Rendering sections (template)\n        3. Generating the final document (template)\n\n        Args:\n            resources: FHIR resources to include in the document\n            document_type: Type of document to generate\n            validate: Whether to validate the CDA document (default: True)\n\n        Returns:\n            CDA document as XML string\n        \"\"\"\n        mapped_entries = self._get_mapped_entries(resources, document_type)\n        sections = self._render_sections(mapped_entries, document_type)\n\n        # Generate final CDA document\n        return self._render_document(sections, document_type, validate=validate)\n\n    def _render_entry(\n        self,\n        resource: Resource,\n        config_key: str,\n    ) -&gt; Optional[Dict]:\n        \"\"\"Render a single entry for a resource\n\n        Args:\n            resource: FHIR resource\n            config_key: Key identifying the section\n\n        Returns:\n            Dictionary representation of the rendered entry (xmltodict)\n        \"\"\"\n        try:\n            # Get validated section configuration\n            section_config = self.config.get_cda_section_configs(config_key)\n\n            timestamp_format = self.config.get_config_value(\n                \"defaults.common.timestamp\", \"%Y%m%d\"\n            )\n            timestamp = datetime.now().strftime(format=timestamp_format)\n\n            id_format = self.config.get_config_value(\n                \"defaults.common.reference_name\", \"#{uuid}name\"\n            )\n            reference_name = id_format.replace(\"{uuid}\", str(uuid.uuid4())[:8])\n\n            # Create context\n            context = {\n                \"timestamp\": timestamp,\n                \"text_reference_name\": reference_name,\n                \"resource\": resource.model_dump(exclude_none=True),\n                \"config\": section_config,\n            }\n\n            # Get template and render\n            template = self.get_template_from_section_config(config_key, \"entry\")\n            if template is None:\n                log.error(f\"Required entry template for '{config_key}' not found\")\n                return None\n\n            return self.render_template(template, context)\n\n        except Exception as e:\n            log.error(f\"Failed to render {config_key} entry: {str(e)}\")\n            return None\n\n    def _get_mapped_entries(\n        self, resources: List[Resource], document_type: str = None\n    ) -&gt; Dict:\n        \"\"\"Map FHIR resources to CDA section entries by resource type.\n\n        Args:\n            resources: List of FHIR resources to map to CDA entries\n            document_type: Optional document type to determine which sections to include\n\n        Returns:\n            Dictionary mapping section keys (e.g. 'problems', 'medications') to lists of\n            their rendered CDA entries. For example:\n            {\n                'problems': [&lt;rendered condition entry&gt;, ...],\n                'medications': [&lt;rendered medication entry&gt;, ...]\n            }\n        \"\"\"\n        # Get included sections from document config if document_type is provided\n        include_sections = None\n        if document_type:\n            include_sections = self.config.get_config_value(\n                f\"cda.document.{document_type}.structure.body.include_sections\"\n            )\n            if include_sections:\n                log.debug(\n                    f\"Generating sections: {include_sections} for document type {document_type}\"\n                )\n\n        section_entries = {}\n        for resource in resources:\n            # Find matching section for resource type\n            resource_type = resource.__class__.__name__\n            all_configs = self.config.get_cda_section_configs()\n            section_key = _find_section_key_for_resource_type(\n                resource_type, all_configs\n            )\n            if not section_key:\n                log.error(f\"No section config found for resource type: {resource_type}\")\n                continue\n\n            # Skip if section is not included in the document config\n            if include_sections and section_key not in include_sections:\n                log.info(\n                    f\"Skipping section {section_key} as it's not in include_sections\"\n                )\n                continue\n\n            entry = self._render_entry(resource, section_key)\n            if entry:\n                section_entries.setdefault(section_key, []).append(entry)\n\n        return section_entries\n\n    def _render_sections(self, mapped_entries: Dict, document_type: str) -&gt; List[Dict]:\n        \"\"\"Render all sections with their entries\n\n        Args:\n            mapped_entries: Dictionary mapping section keys to their entries\n            document_type: Type of document to generate\n\n        Returns:\n            List of formatted section dictionaries\n\n        Raises:\n            ValueError: If section configurations or templates are not found\n        \"\"\"\n        sections = []\n\n        try:\n            # Get validated section configurations\n            section_configs = self.config.get_cda_section_configs()\n        except ValueError as e:\n            log.error(f\"Error getting section configs: {str(e)}\")\n            raise ValueError(f\"Failed to load section configurations: {str(e)}\")\n\n        # Get section template name from config\n        section_template_name = self.config.get_config_value(\n            f\"cda.document.{document_type}.templates.section\"\n        )\n        if not section_template_name:\n            raise ValueError(\n                f\"No section template found for document type: {document_type}\"\n            )\n\n        # Get the section template\n        section_template = self.get_template(section_template_name)\n        if not section_template:\n            raise ValueError(f\"Required template '{section_template_name}' not found\")\n\n        # Render each section that has entries\n        for section_key, section_config in section_configs.items():\n            entries = mapped_entries.get(section_key, [])\n            if entries:\n                try:\n                    # Special handling for notes section, bit of a hack for now\n                    if section_key == \"notes\":\n                        # For DocumentReference, the generated entries already contain the full\n                        # section structure, so we need to extract the section directly\n                        if (\n                            len(entries) &gt; 0\n                            and \"component\" in entries[0]\n                            and \"section\" in entries[0][\"component\"]\n                        ):\n                            # Just extract the first section (we don't support multiple notes sections yet)\n                            section_data = entries[0][\"component\"][\"section\"]\n                            sections.append({\"section\": section_data})\n                            continue\n\n                    # Regular handling for other resource types\n                    context = {\n                        \"entries\": entries,\n                        \"config\": section_config,\n                    }\n                    rendered = self.render_template(section_template, context)\n                    if rendered:\n                        sections.append(rendered)\n                except Exception as e:\n                    log.error(f\"Failed to render section {section_key}: {str(e)}\")\n\n        return sections\n\n    def _render_document(\n        self,\n        sections: List[Dict],\n        document_type: str,\n        validate: bool = True,\n    ) -&gt; str:\n        \"\"\"Generate the final CDA document\n\n        Args:\n            sections: List of formatted section dictionaries\n            document_type: Type of document to generate\n            validate: Whether to validate the CDA document\n\n        Returns:\n            CDA document as XML string\n\n        Raises:\n            ValueError: If document configuration or template is not found\n        \"\"\"\n        try:\n            # Get validated document configuration\n            config = self.config.get_cda_document_config(document_type)\n        except ValueError as e:\n            log.error(f\"Error getting document config: {str(e)}\")\n            raise ValueError(f\"Failed to load document configuration: {str(e)}\")\n\n        # Get document template name from config\n        document_template_name = self.config.get_config_value(\n            f\"cda.document.{document_type}.templates.document\"\n        )\n        if not document_template_name:\n            raise ValueError(\n                f\"No document template found for document type: {document_type}\"\n            )\n\n        # Get the document template\n        document_template = self.get_template(document_template_name)\n        if not document_template:\n            raise ValueError(f\"Required template '{document_template_name}' not found\")\n\n        # Create document context\n        # TODO: modify this as bundle metadata is not extracted\n        context = {\n            \"config\": config,\n            \"sections\": sections,\n        }\n\n        rendered = self.render_template(document_template, context)\n        if validate:\n            if \"ClinicalDocument\" not in rendered:\n                log.error(\n                    \"Unable to validate document structure: missing ClinicalDocument\"\n                )\n                out_dict = rendered\n            else:\n                validated = ClinicalDocument(**rendered[\"ClinicalDocument\"])\n                out_dict = {\n                    \"ClinicalDocument\": validated.model_dump(\n                        exclude_none=True, exclude_unset=True, by_alias=True\n                    )\n                }\n        else:\n            out_dict = rendered\n\n        # Get XML formatting options\n        pretty_print = self.config.get_config_value(\n            f\"cda.document.{document_type}.rendering.xml.pretty_print\", True\n        )\n        encoding = self.config.get_config_value(\n            f\"cda.document.{document_type}.rendering.xml.encoding\", \"UTF-8\"\n        )\n\n        # Generate XML without preprocessor\n        xml_string = xmltodict.unparse(out_dict, pretty=pretty_print, encoding=encoding)\n\n        # Replace text elements containing &lt; or &gt; with CDATA sections\n        # This regex matches &lt;text&gt;...&lt;/text&gt; tags where content has HTML entities\n        def replace_with_cdata(match):\n            content = match.group(1)\n            # Only process if it contains HTML entities\n            if \"&amp;lt;\" in content or \"&amp;gt;\" in content:\n                # Convert HTML entities back to characters\n                import html\n\n                decoded = html.unescape(content)\n                return f\"&lt;text&gt;&lt;![CDATA[{decoded}]]&gt;&lt;/text&gt;\"\n            return f\"&lt;text&gt;{content}&lt;/text&gt;\"\n\n        xml_string = re.sub(\n            r\"&lt;text&gt;(.*?)&lt;/text&gt;\", replace_with_cdata, xml_string, flags=re.DOTALL\n        )\n\n        # Fix self-closing tags\n        return re.sub(r\"(&lt;(\\w+)(\\s+[^&gt;]*?)?)&gt;&lt;/\\2&gt;\", r\"\\1/&gt;\", xml_string)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.cda.CDAGenerator--convert-fhir-resources-to-cda-xml-document","title":"Convert FHIR resources to CDA XML document","text":"<p>cda_xml = generator.transform(     resources=fhir_resources,     document_type=\"ccd\" )</p>"},{"location":"api/interop/#healthchain.interop.generators.cda.CDAGenerator.generate_document_from_fhir_resources","title":"<code>generate_document_from_fhir_resources(resources, document_type, validate=True)</code>","text":"<p>Generate a complete CDA document from FHIR resources</p> <p>This method handles the entire process of generating a CDA document: 1. Mapping FHIR resources to CDA sections (config) 2. Rendering sections (template) 3. Generating the final document (template)</p> PARAMETER DESCRIPTION <code>resources</code> <p>FHIR resources to include in the document</p> <p> TYPE: <code>List[Resource]</code> </p> <code>document_type</code> <p>Type of document to generate</p> <p> TYPE: <code>str</code> </p> <code>validate</code> <p>Whether to validate the CDA document (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>CDA document as XML string</p> Source code in <code>healthchain/interop/generators/cda.py</code> <pre><code>def generate_document_from_fhir_resources(\n    self,\n    resources: List[Resource],\n    document_type: str,\n    validate: bool = True,\n) -&gt; str:\n    \"\"\"Generate a complete CDA document from FHIR resources\n\n    This method handles the entire process of generating a CDA document:\n    1. Mapping FHIR resources to CDA sections (config)\n    2. Rendering sections (template)\n    3. Generating the final document (template)\n\n    Args:\n        resources: FHIR resources to include in the document\n        document_type: Type of document to generate\n        validate: Whether to validate the CDA document (default: True)\n\n    Returns:\n        CDA document as XML string\n    \"\"\"\n    mapped_entries = self._get_mapped_entries(resources, document_type)\n    sections = self._render_sections(mapped_entries, document_type)\n\n    # Generate final CDA document\n    return self._render_document(sections, document_type, validate=validate)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.cda.CDAGenerator.transform","title":"<code>transform(resources, **kwargs)</code>","text":"<p>Transform FHIR resources to CDA format.</p> PARAMETER DESCRIPTION <code>resources</code> <p>List of FHIR resources</p> <p> TYPE: <code>List[Resource]</code> </p> <code>**kwargs</code> <p>document_type: Type of CDA document</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>str</code> <p>CDA document as XML string</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/interop/generators/cda.py</code> <pre><code>def transform(self, resources: List[Resource], **kwargs: Any) -&gt; str:\n    \"\"\"Transform FHIR resources to CDA format.\n\n    Args:\n        resources: List of FHIR resources\n        **kwargs:\n            document_type: Type of CDA document\n\n    Returns:\n        str: CDA document as XML string\n    \"\"\"\n    # TODO: add validation\n    document_type = kwargs.get(\"document_type\", \"ccd\")\n    return self.generate_document_from_fhir_resources(resources, document_type)\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator","title":"<code>FHIRGenerator</code>","text":"<p>               Bases: <code>BaseGenerator</code></p> <p>Handles generation of FHIR resources from templates.</p> <p>This class provides functionality to convert CDA section entries into FHIR resources using configurable templates. It handles validation, required field population, and error handling during the conversion process.</p> <p>Key features: - Template-based conversion of CDA entries (xmltodict format) to FHIR resources - Automatic population of required FHIR fields based on configuration for     common resource types like Condition, MedicationStatement, AllergyIntolerance - Validation of generated FHIR resources</p> Example <p>generator = FHIRGenerator(config_manager, template_registry)</p> Source code in <code>healthchain/interop/generators/fhir.py</code> <pre><code>class FHIRGenerator(BaseGenerator):\n    \"\"\"Handles generation of FHIR resources from templates.\n\n    This class provides functionality to convert CDA section entries into FHIR resources\n    using configurable templates. It handles validation, required field population, and\n    error handling during the conversion process.\n\n    Key features:\n    - Template-based conversion of CDA entries (xmltodict format) to FHIR resources\n    - Automatic population of required FHIR fields based on configuration for\n        common resource types like Condition, MedicationStatement, AllergyIntolerance\n    - Validation of generated FHIR resources\n\n    Example:\n        generator = FHIRGenerator(config_manager, template_registry)\n\n        # Convert CDA problem entries to FHIR Condition resources\n        problems = generator.generate_resources_from_cda_section_entries(\n            entries=problem_entries,\n            section_key=\"problems\"  # from configs\n        )\n    \"\"\"\n\n    def transform(self, data: List[Dict], **kwargs: Any) -&gt; List[Resource]:\n        \"\"\"Transform input data to FHIR resources.\n\n        Args:\n            data: List of entries from source format\n            **kwargs:\n                src_format: The source format type (FormatType.CDA or FormatType.HL7V2)\n                section_key: For CDA, the section key\n                message_key: For HL7v2, the message key\n\n        Returns:\n            List[Resource]: FHIR resources\n        \"\"\"\n        src_format = kwargs.get(\"src_format\")\n        if src_format == FormatType.CDA:\n            return self.generate_resources_from_cda_section_entries(\n                data, kwargs.get(\"section_key\")\n            )\n        elif src_format == FormatType.HL7V2:\n            return self.generate_resources_from_hl7v2_entries(\n                data, kwargs.get(\"message_key\")\n            )\n        else:\n            raise ValueError(f\"Unsupported source format: {src_format}\")\n\n    def generate_resources_from_cda_section_entries(\n        self, entries: List[Dict], section_key: str\n    ) -&gt; List[Dict]:\n        \"\"\"\n        Convert CDA section entries into FHIR resources using configured templates.\n\n        This method processes entries from a CDA section and generates corresponding FHIR\n        resources based on templates and configuration. It handles validation and error\n        checking during the conversion process.\n\n        Args:\n            entries: List of CDA section entries in xmltodict format to convert\n            section_key: Configuration key identifying the section (e.g. \"problems\", \"medications\")\n                Used to look up templates and resource type mappings\n\n        Returns:\n            List of validated FHIR resource dictionaries. Empty list if conversion fails.\n\n        Example:\n            # Convert problem list entries to FHIR Condition resources\n            conditions = generator.generate_resources_from_cda_section_entries(\n                problem_entries, \"problems\"\n            )\n        \"\"\"\n        if not section_key:\n            log.error(\n                \"No section key provided for CDA section entries: data needs to be in the format \\\n                      '{&lt;section_key&gt;}: {&lt;section_entries&gt;}'\"\n            )\n            return []\n\n        resources = []\n        template = self.get_template_from_section_config(section_key, \"resource\")\n\n        if not template:\n            log.error(f\"No resource template found for section {section_key}\")\n            return resources\n\n        resource_type = self.config.get_config_value(\n            f\"cda.sections.{section_key}.resource\"\n        )\n        if not resource_type:\n            log.error(f\"No resource type specified for section {section_key}\")\n            return resources\n\n        for entry in entries:\n            try:\n                # Convert entry to FHIR resource dictionary\n                resource_dict = self._render_resource_from_entry(\n                    entry, section_key, template\n                )\n                if not resource_dict:\n                    continue\n\n                log.debug(f\"Rendered FHIR resource: {resource_dict}\")\n\n                resource = self._validate_fhir_resource(resource_dict, resource_type)\n\n                if resource:\n                    resources.append(resource)\n\n            except Exception as e:\n                log.error(f\"Failed to convert entry in section {section_key}: {str(e)}\")\n                continue\n\n        return resources\n\n    def _render_resource_from_entry(\n        self, entry: Dict, section_key: str, template: Type[Template]\n    ) -&gt; Optional[Dict]:\n        \"\"\"Renders a FHIR resource dictionary from a CDA entry using templates.\n\n        Args:\n            entry: CDA entry dictionary\n            section_key: Section identifier (e.g. \"problems\")\n            template: Template to use for rendering\n\n        Returns:\n            FHIR resource dictionary or None if rendering fails\n        \"\"\"\n        try:\n            # Get validated section configuration\n            try:\n                section_config = self.config.get_cda_section_configs(section_key)\n            except ValueError as e:\n                log.error(\n                    f\"Failed to get CDA section config for {section_key}: {str(e)}\"\n                )\n                return None\n\n            # Create context with entry data and config\n            context = {\"entry\": entry, \"config\": section_config}\n\n            # Render template with context\n            return self.render_template(template, context)\n\n        except Exception as e:\n            log.error(f\"Failed to render resource for section {section_key}: {str(e)}\")\n            return None\n\n    def _validate_fhir_resource(\n        self, resource_dict: Dict, resource_type: str\n    ) -&gt; Optional[Resource]:\n        \"\"\"Validates and creates a FHIR resource from a dictionary.\n        Adds required fields.\n\n        Args:\n            resource_dict: FHIR resource dictionary\n            resource_type: FHIR resource type\n\n        Returns:\n            FHIR resource or None if validation fails\n        \"\"\"\n\n        try:\n            resource_dict = self._add_required_fields(resource_dict, resource_type)\n            resource = create_resource_from_dict(resource_dict, resource_type)\n            if resource:\n                return resource\n        except Exception as e:\n            log.error(f\"Failed to validate FHIR resource: {str(e)}\")\n            return None\n\n    def _add_required_fields(self, resource_dict: Dict, resource_type: str) -&gt; Dict:\n        \"\"\"Add required fields to FHIR resource dictionary based on resource type.\n        Currently only supports Condition, MedicationStatement, and AllergyIntolerance.\n\n        Args:\n            resource_dict: Dictionary representation of the resource\n            resource_type: Type of FHIR resource\n\n        Returns:\n            Dict: Resource dictionary with required fields added\n        \"\"\"\n        # Add common fields\n        id_prefix = self.config.get_config_value(\"defaults.common.id_prefix\", \"hc-\")\n        if \"id\" not in resource_dict:\n            resource_dict[\"id\"] = f\"{id_prefix}{str(uuid.uuid4())}\"\n\n        # Get default values from configuration if available\n        default_subject = self.config.get_config_value(\"defaults.common.subject\")\n\n        # Add resource-specific required fields\n        if resource_type == \"Condition\":\n            if \"subject\" not in resource_dict:\n                resource_dict[\"subject\"] = default_subject\n\n            if \"clinicalStatus\" not in resource_dict:\n                default_status = self.config.get_config_value(\n                    \"defaults.resources.Condition.clinicalStatus\"\n                )\n                resource_dict[\"clinicalStatus\"] = default_status\n        elif resource_type == \"MedicationStatement\":\n            if \"subject\" not in resource_dict:\n                resource_dict[\"subject\"] = default_subject\n            if \"status\" not in resource_dict:\n                default_status = self.config.get_config_value(\n                    \"defaults.resources.MedicationStatement.status\"\n                )\n                resource_dict[\"status\"] = default_status\n        elif resource_type == \"AllergyIntolerance\":\n            if \"patient\" not in resource_dict:\n                resource_dict[\"patient\"] = default_subject\n            if \"clinicalStatus\" not in resource_dict:\n                default_status = self.config.get_config_value(\n                    \"defaults.resources.AllergyIntolerance.clinicalStatus\"\n                )\n                resource_dict[\"clinicalStatus\"] = default_status\n\n        return resource_dict\n\n    def generate_resources_from_hl7v2_entries(\n        self, entries: List[Dict], message_key: str\n    ) -&gt; List[Dict]:\n        \"\"\"\n        Convert HL7v2 message entries into FHIR resources.\n        This is a placeholder implementation.\n\n        Args:\n            entries: List of HL7v2 message entries to convert\n            message_key: Key identifying the message type\n\n        Returns:\n            List of FHIR resources\n        \"\"\"\n        log.warning(\n            \"FHIR resource generation from HL7v2 is a placeholder implementation\"\n        )\n        return []\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator--convert-cda-problem-entries-to-fhir-condition-resources","title":"Convert CDA problem entries to FHIR Condition resources","text":"<p>problems = generator.generate_resources_from_cda_section_entries(     entries=problem_entries,     section_key=\"problems\"  # from configs )</p>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator.generate_resources_from_cda_section_entries","title":"<code>generate_resources_from_cda_section_entries(entries, section_key)</code>","text":"<p>Convert CDA section entries into FHIR resources using configured templates.</p> <p>This method processes entries from a CDA section and generates corresponding FHIR resources based on templates and configuration. It handles validation and error checking during the conversion process.</p> PARAMETER DESCRIPTION <code>entries</code> <p>List of CDA section entries in xmltodict format to convert</p> <p> TYPE: <code>List[Dict]</code> </p> <code>section_key</code> <p>Configuration key identifying the section (e.g. \"problems\", \"medications\") Used to look up templates and resource type mappings</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[Dict]</code> <p>List of validated FHIR resource dictionaries. Empty list if conversion fails.</p> Example Source code in <code>healthchain/interop/generators/fhir.py</code> <pre><code>def generate_resources_from_cda_section_entries(\n    self, entries: List[Dict], section_key: str\n) -&gt; List[Dict]:\n    \"\"\"\n    Convert CDA section entries into FHIR resources using configured templates.\n\n    This method processes entries from a CDA section and generates corresponding FHIR\n    resources based on templates and configuration. It handles validation and error\n    checking during the conversion process.\n\n    Args:\n        entries: List of CDA section entries in xmltodict format to convert\n        section_key: Configuration key identifying the section (e.g. \"problems\", \"medications\")\n            Used to look up templates and resource type mappings\n\n    Returns:\n        List of validated FHIR resource dictionaries. Empty list if conversion fails.\n\n    Example:\n        # Convert problem list entries to FHIR Condition resources\n        conditions = generator.generate_resources_from_cda_section_entries(\n            problem_entries, \"problems\"\n        )\n    \"\"\"\n    if not section_key:\n        log.error(\n            \"No section key provided for CDA section entries: data needs to be in the format \\\n                  '{&lt;section_key&gt;}: {&lt;section_entries&gt;}'\"\n        )\n        return []\n\n    resources = []\n    template = self.get_template_from_section_config(section_key, \"resource\")\n\n    if not template:\n        log.error(f\"No resource template found for section {section_key}\")\n        return resources\n\n    resource_type = self.config.get_config_value(\n        f\"cda.sections.{section_key}.resource\"\n    )\n    if not resource_type:\n        log.error(f\"No resource type specified for section {section_key}\")\n        return resources\n\n    for entry in entries:\n        try:\n            # Convert entry to FHIR resource dictionary\n            resource_dict = self._render_resource_from_entry(\n                entry, section_key, template\n            )\n            if not resource_dict:\n                continue\n\n            log.debug(f\"Rendered FHIR resource: {resource_dict}\")\n\n            resource = self._validate_fhir_resource(resource_dict, resource_type)\n\n            if resource:\n                resources.append(resource)\n\n        except Exception as e:\n            log.error(f\"Failed to convert entry in section {section_key}: {str(e)}\")\n            continue\n\n    return resources\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator.generate_resources_from_cda_section_entries--convert-problem-list-entries-to-fhir-condition-resources","title":"Convert problem list entries to FHIR Condition resources","text":"<p>conditions = generator.generate_resources_from_cda_section_entries(     problem_entries, \"problems\" )</p>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator.generate_resources_from_hl7v2_entries","title":"<code>generate_resources_from_hl7v2_entries(entries, message_key)</code>","text":"<p>Convert HL7v2 message entries into FHIR resources. This is a placeholder implementation.</p> PARAMETER DESCRIPTION <code>entries</code> <p>List of HL7v2 message entries to convert</p> <p> TYPE: <code>List[Dict]</code> </p> <code>message_key</code> <p>Key identifying the message type</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[Dict]</code> <p>List of FHIR resources</p> Source code in <code>healthchain/interop/generators/fhir.py</code> <pre><code>def generate_resources_from_hl7v2_entries(\n    self, entries: List[Dict], message_key: str\n) -&gt; List[Dict]:\n    \"\"\"\n    Convert HL7v2 message entries into FHIR resources.\n    This is a placeholder implementation.\n\n    Args:\n        entries: List of HL7v2 message entries to convert\n        message_key: Key identifying the message type\n\n    Returns:\n        List of FHIR resources\n    \"\"\"\n    log.warning(\n        \"FHIR resource generation from HL7v2 is a placeholder implementation\"\n    )\n    return []\n</code></pre>"},{"location":"api/interop/#healthchain.interop.generators.fhir.FHIRGenerator.transform","title":"<code>transform(data, **kwargs)</code>","text":"<p>Transform input data to FHIR resources.</p> PARAMETER DESCRIPTION <code>data</code> <p>List of entries from source format</p> <p> TYPE: <code>List[Dict]</code> </p> <code>**kwargs</code> <p>src_format: The source format type (FormatType.CDA or FormatType.HL7V2) section_key: For CDA, the section key message_key: For HL7v2, the message key</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>List[Resource]</code> <p>List[Resource]: FHIR resources</p> Source code in <code>healthchain/interop/generators/fhir.py</code> <pre><code>def transform(self, data: List[Dict], **kwargs: Any) -&gt; List[Resource]:\n    \"\"\"Transform input data to FHIR resources.\n\n    Args:\n        data: List of entries from source format\n        **kwargs:\n            src_format: The source format type (FormatType.CDA or FormatType.HL7V2)\n            section_key: For CDA, the section key\n            message_key: For HL7v2, the message key\n\n    Returns:\n        List[Resource]: FHIR resources\n    \"\"\"\n    src_format = kwargs.get(\"src_format\")\n    if src_format == FormatType.CDA:\n        return self.generate_resources_from_cda_section_entries(\n            data, kwargs.get(\"section_key\")\n        )\n    elif src_format == FormatType.HL7V2:\n        return self.generate_resources_from_hl7v2_entries(\n            data, kwargs.get(\"message_key\")\n        )\n    else:\n        raise ValueError(f\"Unsupported source format: {src_format}\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.AllergySectionTemplateConfig","title":"<code>AllergySectionTemplateConfig</code>","text":"<p>               Bases: <code>SectionTemplateConfigBase</code></p> <p>Template configuration for Allergy Section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class AllergySectionTemplateConfig(SectionTemplateConfigBase):\n    \"\"\"Template configuration for Allergy Section\"\"\"\n\n    act: ComponentTemplateConfig\n    allergy_obs: ComponentTemplateConfig\n    reaction_obs: Optional[ComponentTemplateConfig] = None\n    severity_obs: Optional[ComponentTemplateConfig] = None\n    clinical_status_obs: ComponentTemplateConfig\n\n    @field_validator(\"allergy_obs\")\n    @classmethod\n    def validate_allergy_obs(cls, v):\n        required_fields = {\"code\", \"code_system\", \"status_code\"}\n        missing = required_fields - set(v.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(f\"allergy_obs missing required fields: {missing}\")\n        return v\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.CcdDocumentConfig","title":"<code>CcdDocumentConfig</code>","text":"<p>               Bases: <code>DocumentConfigBase</code></p> <p>Configuration model specific to CCD documents</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class CcdDocumentConfig(DocumentConfigBase):\n    \"\"\"Configuration model specific to CCD documents\"\"\"\n\n    allowed_sections: List[str] = [\"problems\", \"medications\", \"notes\"]\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.ComponentTemplateConfig","title":"<code>ComponentTemplateConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic template for CDA/FHIR component configuration</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class ComponentTemplateConfig(BaseModel):\n    \"\"\"Generic template for CDA/FHIR component configuration\"\"\"\n\n    template_id: Union[List[str], str]\n    code: Optional[str] = None\n    code_system: Optional[str] = \"2.16.840.1.113883.6.1\"\n    code_system_name: Optional[str] = \"LOINC\"\n    display_name: Optional[str] = None\n    status_code: Optional[str] = \"active\"\n    class_code: Optional[str] = None\n    mood_code: Optional[str] = None\n    type_code: Optional[str] = None\n    inversion_ind: Optional[bool] = None\n    value: Optional[Dict[str, Any]] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.DocumentConfigBase","title":"<code>DocumentConfigBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic document configuration model</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class DocumentConfigBase(BaseModel):\n    \"\"\"Generic document configuration model\"\"\"\n\n    type_id: Dict[str, Any]\n    code: Dict[str, Any]\n    confidentiality_code: Dict[str, Any]\n    language_code: Optional[str] = \"en-US\"\n    templates: Optional[Dict[str, Any]] = None\n    structure: Optional[Dict[str, Any]] = None\n    defaults: Optional[Dict[str, Any]] = None\n    rendering: Optional[Dict[str, Any]] = None\n\n    @field_validator(\"type_id\")\n    @classmethod\n    def validate_type_id(cls, v):\n        if not isinstance(v, dict) or \"root\" not in v:\n            raise ValueError(\"type_id must contain 'root' field\")\n        return v\n\n    @field_validator(\"code\")\n    @classmethod\n    def validate_code(cls, v):\n        if not isinstance(v, dict) or \"code\" not in v or \"code_system\" not in v:\n            raise ValueError(\"code must contain 'code' and 'code_system' fields\")\n        return v\n\n    @field_validator(\"confidentiality_code\")\n    @classmethod\n    def validate_confidentiality_code(cls, v):\n        if not isinstance(v, dict) or \"code\" not in v:\n            raise ValueError(\"confidentiality_code must contain 'code' field\")\n        return v\n\n    @field_validator(\"templates\")\n    @classmethod\n    def validate_templates(cls, v):\n        if not isinstance(v, dict) or \"section\" not in v or \"document\" not in v:\n            raise ValueError(\"templates must contain 'section' and 'document' fields\")\n        return v\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.MedicationSectionTemplateConfig","title":"<code>MedicationSectionTemplateConfig</code>","text":"<p>               Bases: <code>SectionTemplateConfigBase</code></p> <p>Template configuration for SubstanceAdministration Section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class MedicationSectionTemplateConfig(SectionTemplateConfigBase):\n    \"\"\"Template configuration for SubstanceAdministration Section\"\"\"\n\n    substance_admin: ComponentTemplateConfig\n    manufactured_product: ComponentTemplateConfig\n    clinical_status_obs: ComponentTemplateConfig\n\n    @field_validator(\"substance_admin\")\n    @classmethod\n    def validate_substance_admin(cls, v):\n        if not v.status_code:\n            raise ValueError(\"substance_admin requires status_code\")\n        return v\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.NoteSectionTemplateConfig","title":"<code>NoteSectionTemplateConfig</code>","text":"<p>               Bases: <code>SectionTemplateConfigBase</code></p> <p>Template configuration for Notes Section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class NoteSectionTemplateConfig(SectionTemplateConfigBase):\n    \"\"\"Template configuration for Notes Section\"\"\"\n\n    note_section: ComponentTemplateConfig\n\n    @field_validator(\"note_section\")\n    @classmethod\n    def validate_note_section(cls, v):\n        required_fields = {\"template_id\", \"code\", \"code_system\", \"status_code\"}\n        missing = required_fields - set(v.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(f\"note_section missing required fields: {missing}\")\n        return v\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.ProblemSectionTemplateConfig","title":"<code>ProblemSectionTemplateConfig</code>","text":"<p>               Bases: <code>SectionTemplateConfigBase</code></p> <p>Template configuration for Problem Section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class ProblemSectionTemplateConfig(SectionTemplateConfigBase):\n    \"\"\"Template configuration for Problem Section\"\"\"\n\n    act: ComponentTemplateConfig\n    problem_obs: ComponentTemplateConfig\n    clinical_status_obs: ComponentTemplateConfig\n\n    @field_validator(\"problem_obs\")\n    @classmethod\n    def validate_problem_obs(cls, v):\n        required_fields = {\"code\", \"code_system\", \"status_code\"}\n        missing = required_fields - set(v.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(f\"problem_obs missing required fields: {missing}\")\n        return v\n\n    @field_validator(\"clinical_status_obs\")\n    @classmethod\n    def validate_clinical_status(cls, v):\n        required_fields = {\"code\", \"code_system\", \"status_code\"}\n        missing = required_fields - set(v.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(f\"clinical_status_obs missing required fields: {missing}\")\n        return v\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.RenderingConfig","title":"<code>RenderingConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for section rendering</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class RenderingConfig(BaseModel):\n    \"\"\"Configuration for section rendering\"\"\"\n\n    narrative: Optional[Dict[str, Any]] = None\n    entry: Optional[Dict[str, Any]] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.SectionBaseConfig","title":"<code>SectionBaseConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for all section configurations</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class SectionBaseConfig(BaseModel):\n    \"\"\"Base model for all section configurations\"\"\"\n\n    resource: str\n    resource_template: str\n    entry_template: str\n    identifiers: SectionIdentifiersConfig\n    rendering: Optional[RenderingConfig] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.SectionIdentifiersConfig","title":"<code>SectionIdentifiersConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Section identifiers validation</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class SectionIdentifiersConfig(BaseModel):\n    \"\"\"Section identifiers validation\"\"\"\n\n    template_id: str\n    code: str\n    code_system: Optional[str] = \"2.16.840.1.113883.6.1\"\n    code_system_name: Optional[str] = \"LOINC\"\n    display: str\n    clinical_status: Optional[Dict[str, str]] = None\n    reaction: Optional[Dict[str, str]] = None\n    severity: Optional[Dict[str, str]] = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.SectionTemplateConfigBase","title":"<code>SectionTemplateConfigBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for section template configurations</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>class SectionTemplateConfigBase(BaseModel):\n    \"\"\"Base class for section template configurations\"\"\"\n\n    def validate_component_fields(self, component, required_fields):\n        \"\"\"Helper method to validate required fields in a component\"\"\"\n        missing = required_fields - set(component.model_dump(exclude_unset=True).keys())\n        if missing:\n            raise ValueError(\n                f\"{component.__class__.__name__} missing required fields: {missing}\"\n            )\n        return component\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.SectionTemplateConfigBase.validate_component_fields","title":"<code>validate_component_fields(component, required_fields)</code>","text":"<p>Helper method to validate required fields in a component</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def validate_component_fields(self, component, required_fields):\n    \"\"\"Helper method to validate required fields in a component\"\"\"\n    missing = required_fields - set(component.model_dump(exclude_unset=True).keys())\n    if missing:\n        raise ValueError(\n            f\"{component.__class__.__name__} missing required fields: {missing}\"\n        )\n    return component\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.create_cda_section_validator","title":"<code>create_cda_section_validator(resource_type, template_model)</code>","text":"<p>Create a section validator for a specific resource type</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def create_cda_section_validator(\n    resource_type: str, template_model: Type[BaseModel]\n) -&gt; Type[BaseModel]:\n    \"\"\"Create a section validator for a specific resource type\"\"\"\n\n    class DynamicSectionConfig(SectionBaseConfig):\n        template: Dict[str, Any]\n\n        @field_validator(\"template\")\n        @classmethod\n        def validate_template(cls, v):\n            try:\n                template_model(**v)\n            except ValidationError as e:\n                raise ValueError(f\"Template validation failed: {str(e)}\")\n            return v\n\n    DynamicSectionConfig.__name__ = f\"{resource_type}SectionConfig\"\n    return DynamicSectionConfig\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.register_cda_document_template_config_model","title":"<code>register_cda_document_template_config_model(document_type, document_model)</code>","text":"<p>Register a custom document model</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def register_cda_document_template_config_model(\n    document_type: str, document_model: Type[BaseModel]\n) -&gt; None:\n    \"\"\"Register a custom document model\"\"\"\n    CDA_DOCUMENT_CONFIG_REGISTRY[document_type.lower()] = document_model\n    logger.info(f\"Registered custom document model for {document_type}\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.register_cda_section_template_config_model","title":"<code>register_cda_section_template_config_model(resource_type, template_model)</code>","text":"<p>Register a custom template model for a section</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def register_cda_section_template_config_model(\n    resource_type: str, template_model: Type[BaseModel]\n) -&gt; None:\n    \"\"\"Register a custom template model for a section\"\"\"\n    CDA_SECTION_CONFIG_REGISTRY[resource_type] = template_model\n    SECTION_VALIDATORS[resource_type] = create_cda_section_validator(\n        resource_type, template_model\n    )\n    logger.info(f\"Registered custom template model for {resource_type}\")\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.validate_cda_document_config_model","title":"<code>validate_cda_document_config_model(document_type, document_config)</code>","text":"<p>Validate a document configuration</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def validate_cda_document_config_model(\n    document_type: str, document_config: Dict[str, Any]\n) -&gt; bool:\n    \"\"\"Validate a document configuration\"\"\"\n    validator = CDA_DOCUMENT_CONFIG_REGISTRY.get(document_type.lower())\n    if not validator:\n        logger.warning(f\"No specific validator for document type: {document_type}\")\n        return True\n\n    try:\n        validator(**document_config)\n        return True\n    except ValidationError as e:\n        logger.error(f\"Document validation failed for {document_type}: {str(e)}\")\n        return False\n</code></pre>"},{"location":"api/interop/#healthchain.config.validators.validate_cda_section_config_model","title":"<code>validate_cda_section_config_model(section_key, section_config)</code>","text":"<p>Validate a section configuration</p> Source code in <code>healthchain/config/validators.py</code> <pre><code>def validate_cda_section_config_model(\n    section_key: str, section_config: Dict[str, Any]\n) -&gt; bool:\n    \"\"\"Validate a section configuration\"\"\"\n    resource_type = section_config.get(\"resource\")\n    if not resource_type:\n        logger.error(f\"Section '{section_key}' is missing 'resource' field\")\n        return False\n\n    validator = SECTION_VALIDATORS.get(resource_type)\n    if not validator:\n        # TODO: Pass validation level to this\n        logger.warning(f\"No specific validator for resource type: {resource_type}\")\n        return True\n\n    try:\n        validator(**section_config)\n        return True\n    except ValidationError as e:\n        logger.error(f\"Section validation failed for {resource_type}: {str(e)}\")\n        return False\n</code></pre>"},{"location":"api/pipeline/","title":"Pipeline","text":""},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline","title":"<code>BasePipeline</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for creating and managing data processing pipelines.</p> <p>The BasePipeline class provides a framework for building modular data processing pipelines by allowing users to add, remove, and configure components with defined dependencies and execution order. Components can be added at specific positions and grouped into stages.</p> <p>This is an abstract base class that should be subclassed to create specific pipeline implementations.</p> ATTRIBUTE DESCRIPTION <code>_components</code> <p>Ordered list of pipeline components</p> <p> TYPE: <code>List[PipelineNode[T]]</code> </p> <code>_stages</code> <p>Components grouped by processing stage</p> <p> TYPE: <code>Dict[str, List[Callable]]</code> </p> <code>_built_pipeline</code> <p>Compiled pipeline function</p> <p> TYPE: <code>Optional[Callable]</code> </p> <code>_output_template</code> <p>Template string for formatting pipeline outputs</p> <p> TYPE: <code>Optional[str]</code> </p> <code>_output_template_path</code> <p>Path to template file for formatting pipeline outputs</p> <p> TYPE: <code>Optional[Path]</code> </p> Example <p>class MyPipeline(BasePipeline[Document]): ...     def configure_pipeline(self, config: ModelConfig) -&gt; None: ...         self.add_node(preprocess, stage=\"preprocessing\") ...         self.add_node(process, stage=\"processing\") ...         self.add_node(postprocess, stage=\"postprocessing\") ... pipeline = MyPipeline() result = pipeline(document)  # Document \u2192 Document</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class BasePipeline(Generic[T], ABC):\n    \"\"\"\n    Abstract base class for creating and managing data processing pipelines.\n\n    The BasePipeline class provides a framework for building modular data processing pipelines\n    by allowing users to add, remove, and configure components with defined dependencies and\n    execution order. Components can be added at specific positions and grouped into stages.\n\n    This is an abstract base class that should be subclassed to create specific pipeline\n    implementations.\n\n    Attributes:\n        _components (List[PipelineNode[T]]): Ordered list of pipeline components\n        _stages (Dict[str, List[Callable]]): Components grouped by processing stage\n        _built_pipeline (Optional[Callable]): Compiled pipeline function\n        _output_template (Optional[str]): Template string for formatting pipeline outputs\n        _output_template_path (Optional[Path]): Path to template file for formatting pipeline outputs\n\n    Example:\n        &gt;&gt;&gt; class MyPipeline(BasePipeline[Document]):\n        ...     def configure_pipeline(self, config: ModelConfig) -&gt; None:\n        ...         self.add_node(preprocess, stage=\"preprocessing\")\n        ...         self.add_node(process, stage=\"processing\")\n        ...         self.add_node(postprocess, stage=\"postprocessing\")\n        ...\n        &gt;&gt;&gt; pipeline = MyPipeline()\n        &gt;&gt;&gt; result = pipeline(document)  # Document \u2192 Document\n    \"\"\"\n\n    def __init__(self):\n        self._components: List[PipelineNode[T]] = []\n        self._stages: Dict[str, List[Callable]] = {}\n        self._built_pipeline: Optional[Callable] = None\n        self._output_template: Optional[str] = None\n        self._output_template_path: Optional[Path] = None\n\n    def __repr__(self) -&gt; str:\n        components_repr = \", \".join(\n            [f'\"{component.name}\"' for component in self._components]\n        )\n        return f\"[{components_repr}]\"\n\n    def _configure_output_templates(\n        self,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Configure template settings for the pipeline.\n\n        Args:\n            template (Optional[str]): Template string for formatting outputs.\n                Defaults to None.\n            template_path (Optional[Union[str, Path]]): Path to template file.\n                Defaults to None.\n        \"\"\"\n        self._output_template = template\n        self._output_template_path = Path(template_path) if template_path else None\n\n    @classmethod\n    def load(\n        cls,\n        pipeline: Callable,\n        source: str,\n        task: Optional[str] = \"text-generation\",\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"\n        Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).\n\n        Args:\n            pipeline (Callable): A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)\n            source (str): Source of the pipeline. Can be \"langchain\" or \"huggingface\".\n            task (Optional[str]): Task identifier used to retrieve model outputs.\n                Defaults to \"text-generation\".\n            template (Optional[str]): Template string for formatting outputs.\n                Defaults to None.\n            template_path (Optional[Union[str, Path]]): Path to template file.\n                Defaults to None.\n            **kwargs: Additional configuration options passed to the pipeline.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If pipeline is not callable or source is invalid.\n\n        Examples:\n            &gt;&gt;&gt; # Load LangChain pipeline\n            &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n            &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n            &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n            &gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load HuggingFace pipeline\n            &gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n            &gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n            &gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n            &gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n            &gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n        \"\"\"\n        if not (hasattr(pipeline, \"__call__\") or hasattr(pipeline, \"invoke\")):\n            raise ValueError(\"Pipeline must be a callable object\")\n\n        # Validate source\n        source = source.lower()\n        if source not in [\"langchain\", \"huggingface\"]:\n            raise ValueError(\n                \"Source must be either 'langchain' or 'huggingface' for direct pipeline loading\"\n            )\n\n        # For HuggingFace pipelines, try to infer task if not provided\n        if source == \"huggingface\" and hasattr(pipeline, \"task\") and not task:\n            task = pipeline.task\n\n        instance = cls()\n        instance._configure_output_templates(template, template_path)\n\n        config = ModelConfig(\n            source=ModelSource(source),\n            pipeline_object=pipeline,\n            task=task,\n            kwargs=kwargs,\n        )\n\n        instance._model_config = config\n        instance.configure_pipeline(config)\n\n        return instance\n\n    @classmethod\n    def from_model_id(\n        cls,\n        model_id: str,\n        source: Union[str, ModelSource] = \"huggingface\",\n        task: Optional[str] = \"text-generation\",\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"\n        Load pipeline from a model identifier.\n\n        Args:\n            model_id (str): Model identifier (e.g. HuggingFace model ID, SpaCy model name)\n            source (Union[str, ModelSource]): Model source. Defaults to \"huggingface\".\n                Can be \"huggingface\", \"spacy\".\n            task (Optional[str]): Task identifier for the model. Defaults to \"text-generation\".\n            template (Optional[str]): Optional template string for formatting model output.\n            template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n            **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If source is not a valid ModelSource.\n\n        Examples:\n            &gt;&gt;&gt; # Load HuggingFace model\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"facebook/bart-large-cnn\",\n            ...     task=\"summarization\",\n            ...     temperature=0.7\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load SpaCy model\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"en_core_sci_md\",\n            ...     source=\"spacy\",\n            ...     disable=[\"parser\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load with output template\n            &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n            &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n            ...     \"gpt-3.5-turbo\",\n            ...     source=\"huggingface\",\n            ...     template=template\n            ... )\n        \"\"\"\n        pipeline = cls()\n        pipeline._configure_output_templates(template, template_path)\n\n        config = ModelConfig(\n            source=ModelSource(source.lower()),\n            model_id=model_id,\n            task=task,\n            kwargs=kwargs,\n        )\n        pipeline._model_config = config\n        pipeline.configure_pipeline(config)\n\n        return pipeline\n\n    @classmethod\n    def from_local_model(\n        cls,\n        path: Union[str, Path],\n        source: Union[str, ModelSource],\n        task: Optional[str] = None,\n        template: Optional[str] = None,\n        template_path: Optional[Union[str, Path]] = None,\n        **kwargs: Any,\n    ) -&gt; \"BasePipeline\":\n        \"\"\"Load pipeline from a local model path.\n\n        Args:\n            path (Union[str, Path]): Path to local model files/directory\n            source (Union[str, ModelSource]): Model source (e.g. \"huggingface\", \"spacy\")\n            task (Optional[str]): Task identifier for the model. Defaults to None.\n            template (Optional[str]): Optional template string for formatting model output.\n            template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n            **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n        Returns:\n            BasePipeline: Configured pipeline instance.\n\n        Raises:\n            ValueError: If source is not a valid ModelSource.\n\n        Examples:\n            &gt;&gt;&gt; # Load local HuggingFace model\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/my_summarizer\",\n            ...     source=\"huggingface\",\n            ...     task=\"summarization\",\n            ...     temperature=0.7\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load local SpaCy model\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/en_core_sci_md\",\n            ...     source=\"spacy\",\n            ...     disable=[\"parser\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load with output template\n            &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n            &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n            ...     \"models/gpt_model\",\n            ...     source=\"huggingface\",\n            ...     template=template\n            ... )\n        \"\"\"\n        pipeline = cls()\n        pipeline._configure_output_templates(template, template_path)\n\n        path = Path(path)\n        config = ModelConfig(\n            source=ModelSource(source.lower()),\n            model_id=path.name,\n            path=path,\n            task=task,\n            kwargs=kwargs,\n        )\n        pipeline._model_config = config\n        pipeline.configure_pipeline(config)\n\n        return pipeline\n\n    @abstractmethod\n    def configure_pipeline(self, model_config: ModelConfig) -&gt; None:\n        \"\"\"\n        Configure the pipeline based on the provided model configuration.\n\n        This method should be implemented by subclasses to add specific components\n        and configure the pipeline according to the given model configuration.\n        The configuration typically involves:\n        1. Adding model components based on the model source\n        2. Adding any additional processing nodes\n        3. Configuring the pipeline stages and execution order\n\n        Args:\n            model_config (ModelConfig): Configuration object containing:\n                - source: Model source (e.g. huggingface, spacy, langchain)\n                - model: Model identifier or path\n                - task: Optional task name (e.g. summarization, ner)\n                - path: Optional local path to model files\n                - kwargs: Additional model configuration parameters\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented by a subclass.\n\n        Example:\n            &gt;&gt;&gt; def configure_pipeline(self, config: ModelConfig):\n            ...     # Add model component\n            ...     model = self.get_model_component(config)\n            ...     self.add_node(model, stage=\"processing\")\n            ...\n            ...     # Add output formatting\n            ...     self.add_node(OutputFormatter(), stage=\"formatting\")\n        \"\"\"\n        raise NotImplementedError(\"This method must be implemented by subclasses.\")\n\n    @property\n    def stages(self):\n        \"\"\"\n        Returns a human-readable representation of the pipeline stages.\n        \"\"\"\n        output = [\"Pipeline Stages:\"]\n        for stage, components in self._stages.items():\n            output.append(f\"  {stage}:\")\n            for component in components:\n                component_name = (\n                    component.__name__\n                    if hasattr(component, \"__name__\")\n                    else (\n                        component.__class__.__name__\n                        if hasattr(component, \"__class__\")\n                        else str(component)\n                    )\n                )\n                output.append(f\"    - {component_name}\")\n        if not self._stages:\n            output.append(\"  No stages defined.\")\n        return \"\\n\".join(output)\n\n    @stages.setter\n    def stages(self, new_stages: Dict[str, List[Callable]]):\n        \"\"\"\n        Sets the stages of the pipeline.\n\n        Args:\n            new_stages (Dict[str, List[Callable]]): A dictionary where keys are stage names\n                                                    and values are lists of callable components.\n        \"\"\"\n        self._stages = new_stages\n\n    def add_node(\n        self,\n        component: Union[\n            BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n        ] = None,\n        *,\n        position: PositionType = \"default\",\n        reference: str = None,\n        stage: str = None,\n        name: str = None,\n        input_model: Type[BaseModel] = None,\n        output_model: Type[BaseModel] = None,\n        dependencies: List[str] = [],\n    ) -&gt; None:\n        \"\"\"\n        Adds a component node to the pipeline.\n\n        Args:\n            component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]], optional):\n                The component to be added. It can be either a BaseComponent object or a callable function.\n                Defaults to None.\n            position (PositionType, optional):\n                The position at which the component should be added in the pipeline.\n                Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\".\n                Defaults to \"default\".\n            reference (str, optional):\n                The name of the component after or before which the new component should be added.\n                Only applicable when position is \"after\" or \"before\".\n                Defaults to None.\n            stage (str, optional):\n                The stage to which the component belongs.\n                Defaults to None.\n            name (str, optional):\n                The name of the component.\n                Defaults to None, in which case the name of the function will be used.\n            input_model (Type[BaseModel], optional):\n                The input Pydantic model class for validating the input data.\n                Defaults to None.\n            output_model (Type[BaseModel], optional):\n                The output Pydantic model class for validating the output data.\n                Defaults to None.\n            dependencies (List[str], optional):\n                The list of component names that this component depends on.\n                Defaults to an empty list.\n\n        Returns:\n            The original component if component is None, otherwise the wrapper function.\n\n        \"\"\"\n\n        def wrapper(func):\n            def validated_component(data: DataContainer[T]) -&gt; DataContainer[T]:\n                # Validate input if input_model is provided\n                if input_model:\n                    input_model(**data.__dict__)\n\n                # Run the component\n                result = func(data)\n\n                # Validate output if output_model is provided\n                if output_model:\n                    output_model(**result.__dict__)\n\n                return result\n\n            component_func = (\n                validated_component if input_model or output_model else func\n            )\n            new_component = PipelineNode(\n                func=component_func,\n                position=position,\n                reference=reference,\n                stage=stage,\n                name=name\n                if name is not None\n                else (\n                    component_func.__name__\n                    if hasattr(component_func, \"__name__\")\n                    else (\n                        component_func.__class__.__name__\n                        if hasattr(component_func, \"__class__\")\n                        else str(component_func)\n                    )\n                ),\n                dependencies=dependencies,\n            )\n            try:\n                self._add_component_at_position(new_component, position, reference)\n            except Exception as e:\n                raise ValueError(f\"Error adding component: {str(e)}\")\n\n            if stage:\n                if stage not in self._stages:\n                    self._stages[stage] = []\n                self._stages[stage].append(func)\n                logger.debug(\n                    f\"Successfully added component '{new_component.name}' to stage '{stage}'.\"\n                )\n\n            return func\n\n        if component is None:\n            return wrapper\n        if callable(component):\n            return wrapper(component)\n        else:\n            raise ValueError(\"Component must be callable\")\n\n    def _add_component_at_position(self, new_component, position, reference):\n        \"\"\"\n        Add a new component to the pipeline at a specified position.\n\n        Args:\n            new_component (PipelineNode): The new component to be added to the pipeline.\n            position (str): The position where the component should be added.\n                            Valid values are 'first', 'last', 'after', 'before', or 'default'.\n            reference (str, optional): The name of the reference component when using 'after' or 'before' positions.\n\n        Raises:\n            ValueError: If an invalid position is provided or if a reference is required but not provided.\n\n        This method handles the insertion of a new component into the pipeline based on the specified position:\n        - 'first': Inserts the component at the beginning of the pipeline.\n        - 'last' or 'default': Appends the component to the end of the pipeline.\n        - 'after' or 'before': Inserts the component relative to a reference component.\n\n        For 'after' and 'before' positions, a reference component name must be provided.\n        \"\"\"\n        if position == \"first\":\n            self._components.insert(0, new_component)\n        elif position in [\"last\", \"default\"]:\n            self._components.append(new_component)\n        elif position in [\"after\", \"before\"]:\n            if not reference:\n                raise ValueError(\n                    f\"Reference must be provided for position '{position}'.\"\n                )\n            offset = 1 if position == \"after\" else 0\n            self._insert_relative_position(new_component, reference, offset)\n        else:\n            raise ValueError(\n                f\"Invalid position '{position}'. Must be 'first', 'last', 'after', 'before', or 'default'.\"\n            )\n\n    def _insert_relative_position(self, component, reference, offset):\n        \"\"\"\n        Insert a component relative to a reference component in the pipeline.\n\n        Args:\n            component (PipelineNode): The component to be inserted.\n            reference (str): The name of the reference component.\n            offset (int): The offset from the reference component (0 for before, 1 for after).\n\n        Raises:\n            ValueError: If the reference component is not found in the pipeline.\n        \"\"\"\n        ref_index = next(\n            (i for i, c in enumerate(self._components) if c.name == reference), None\n        )\n        if ref_index is None:\n            raise ValueError(f\"Reference component '{reference}' not found.\")\n\n        self._components.insert(ref_index + offset, component)\n\n    def remove(self, component_name: str) -&gt; None:\n        \"\"\"\n        Removes a component from the pipeline.\n\n        Args:\n            component_name (str): The name of the component to be removed.\n\n        Raises:\n            ValueError: If the component is not found in the pipeline.\n\n        Returns:\n            None\n\n        Logs:\n            DEBUG: When the component is successfully removed.\n            WARNING: If the component fails to be removed after attempting to do so.\n        \"\"\"\n        # Check if the component exists in the pipeline\n        if not any(c.name == component_name for c in self._components):\n            raise ValueError(f\"Component '{component_name}' not found in the pipeline.\")\n\n        # Remove the component from self.components\n        original_count = len(self._components)\n        self._components = [c for c in self._components if c.name != component_name]\n\n        # Remove the component from stages\n        for stage in self._stages.values():\n            stage[:] = [c for c in stage if c.__name__ != component_name]\n\n        # Validate that the component was removed\n        if len(self._components) == original_count or any(\n            c.__name__ == component_name\n            for stage in self._stages.values()\n            for c in stage\n        ):\n            logger.warning(\n                f\"Failed to remove component '{component_name}' from the pipeline.\"\n            )\n        logger.debug(\n            f\"Successfully removed component '{component_name}' from the pipeline.\"\n        )\n\n    def replace(\n        self,\n        old_component_name: str,\n        new_component: Union[\n            BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n        ],\n    ) -&gt; None:\n        \"\"\"\n        Replaces a component in the pipeline with a new component.\n\n        Args:\n            old_component_name (str): The name of the component to be replaced.\n            new_component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]):\n                The new component to replace the old component with.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the old component is not found in the pipeline.\n            ValueError: If the new component is not a BaseComponent or a callable.\n            ValueError: If the new component callable doesn't have the correct signature.\n\n        Logs:\n            DEBUG: When the component is successfully replaced.\n        \"\"\"\n\n        if isinstance(new_component, BaseComponent):\n            # It's a valid BaseComponent, no further checks needed\n            pass\n        elif callable(new_component):\n            sig = signature(new_component)\n            param = list(sig.parameters.values())[0]\n            if len(sig.parameters) != 1 or not issubclass(\n                param.annotation, DataContainer\n            ):\n                raise ValueError(\n                    \"New component callable must accept a single argument that is a subclass of DataContainer.\"\n                )\n        else:\n            raise ValueError(\"New component must be a BaseComponent or a callable.\")\n\n        old_component_found = False\n\n        # Replace in self.components\n        for i, c in enumerate(self._components):\n            if c.name == old_component_name:\n                self._components[i] = PipelineNode(\n                    func=new_component,\n                    name=old_component_name,\n                    position=c.position,\n                    reference=c.reference,\n                    stage=c.stage,\n                    dependencies=c.dependencies,\n                )\n                old_component_found = True\n\n        # Replace in self.stages\n        for stage in self._stages.values():\n            for i, c in enumerate(stage):\n                if getattr(c, \"name\", c.__name__) == old_component_name:\n                    stage[i] = new_component\n                    old_component_found = True\n\n        if not old_component_found:\n            raise ValueError(\n                f\"Component '{old_component_name}' not found in the pipeline.\"\n            )\n        else:\n            logger.debug(\n                f\"Successfully replaced component '{old_component_name}' in the pipeline.\"\n            )\n\n    def __call__(self, data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n        if self._built_pipeline is None:\n            self._built_pipeline = self.build()\n        return self._built_pipeline(data)\n\n    def build(self) -&gt; Callable:\n        \"\"\"\n        Builds and returns a pipeline function that applies a series of components to the input data.\n        Returns:\n            pipeline: A function that takes input data and applies the ordered components to it.\n        Raises:\n            ValueError: If a circular dependency is detected among the components.\n        \"\"\"\n\n        def resolve_dependencies():\n            resolved = []\n            unresolved = self._components.copy()\n\n            while unresolved:\n                for component in unresolved:\n                    if all(\n                        dep in [c.name for c in resolved]\n                        for dep in component.dependencies\n                    ):\n                        resolved.append(component)\n                        unresolved.remove(component)\n                        break\n                else:\n                    raise ValueError(\"Circular dependency detected\")\n\n            return [c.func for c in resolved]\n\n        ordered_components = resolve_dependencies()\n\n        def pipeline(data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n            if not isinstance(data, DataContainer):\n                data = DataContainer(data)\n\n            data = reduce(lambda d, comp: comp(d), ordered_components, data)\n\n            return data\n\n        if self._built_pipeline is not pipeline:\n            self._built_pipeline = pipeline\n\n        return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.stages","title":"<code>stages</code>  <code>property</code> <code>writable</code>","text":"<p>Returns a human-readable representation of the pipeline stages.</p>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.add_node","title":"<code>add_node(component=None, *, position='default', reference=None, stage=None, name=None, input_model=None, output_model=None, dependencies=[])</code>","text":"<p>Adds a component node to the pipeline.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to be added. It can be either a BaseComponent object or a callable function. Defaults to None.</p> <p> TYPE: <code>Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]</code> DEFAULT: <code>None</code> </p> <code>position</code> <p>The position at which the component should be added in the pipeline. Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\". Defaults to \"default\".</p> <p> TYPE: <code>PositionType</code> DEFAULT: <code>'default'</code> </p> <code>reference</code> <p>The name of the component after or before which the new component should be added. Only applicable when position is \"after\" or \"before\". Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>stage</code> <p>The stage to which the component belongs. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>The name of the component. Defaults to None, in which case the name of the function will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>input_model</code> <p>The input Pydantic model class for validating the input data. Defaults to None.</p> <p> TYPE: <code>Type[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>output_model</code> <p>The output Pydantic model class for validating the output data. Defaults to None.</p> <p> TYPE: <code>Type[BaseModel]</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>The list of component names that this component depends on. Defaults to an empty list.</p> <p> TYPE: <code>List[str]</code> DEFAULT: <code>[]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>The original component if component is None, otherwise the wrapper function.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def add_node(\n    self,\n    component: Union[\n        BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n    ] = None,\n    *,\n    position: PositionType = \"default\",\n    reference: str = None,\n    stage: str = None,\n    name: str = None,\n    input_model: Type[BaseModel] = None,\n    output_model: Type[BaseModel] = None,\n    dependencies: List[str] = [],\n) -&gt; None:\n    \"\"\"\n    Adds a component node to the pipeline.\n\n    Args:\n        component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]], optional):\n            The component to be added. It can be either a BaseComponent object or a callable function.\n            Defaults to None.\n        position (PositionType, optional):\n            The position at which the component should be added in the pipeline.\n            Valid values are \"default\", \"first\", \"last\", \"after\", and \"before\".\n            Defaults to \"default\".\n        reference (str, optional):\n            The name of the component after or before which the new component should be added.\n            Only applicable when position is \"after\" or \"before\".\n            Defaults to None.\n        stage (str, optional):\n            The stage to which the component belongs.\n            Defaults to None.\n        name (str, optional):\n            The name of the component.\n            Defaults to None, in which case the name of the function will be used.\n        input_model (Type[BaseModel], optional):\n            The input Pydantic model class for validating the input data.\n            Defaults to None.\n        output_model (Type[BaseModel], optional):\n            The output Pydantic model class for validating the output data.\n            Defaults to None.\n        dependencies (List[str], optional):\n            The list of component names that this component depends on.\n            Defaults to an empty list.\n\n    Returns:\n        The original component if component is None, otherwise the wrapper function.\n\n    \"\"\"\n\n    def wrapper(func):\n        def validated_component(data: DataContainer[T]) -&gt; DataContainer[T]:\n            # Validate input if input_model is provided\n            if input_model:\n                input_model(**data.__dict__)\n\n            # Run the component\n            result = func(data)\n\n            # Validate output if output_model is provided\n            if output_model:\n                output_model(**result.__dict__)\n\n            return result\n\n        component_func = (\n            validated_component if input_model or output_model else func\n        )\n        new_component = PipelineNode(\n            func=component_func,\n            position=position,\n            reference=reference,\n            stage=stage,\n            name=name\n            if name is not None\n            else (\n                component_func.__name__\n                if hasattr(component_func, \"__name__\")\n                else (\n                    component_func.__class__.__name__\n                    if hasattr(component_func, \"__class__\")\n                    else str(component_func)\n                )\n            ),\n            dependencies=dependencies,\n        )\n        try:\n            self._add_component_at_position(new_component, position, reference)\n        except Exception as e:\n            raise ValueError(f\"Error adding component: {str(e)}\")\n\n        if stage:\n            if stage not in self._stages:\n                self._stages[stage] = []\n            self._stages[stage].append(func)\n            logger.debug(\n                f\"Successfully added component '{new_component.name}' to stage '{stage}'.\"\n            )\n\n        return func\n\n    if component is None:\n        return wrapper\n    if callable(component):\n        return wrapper(component)\n    else:\n        raise ValueError(\"Component must be callable\")\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.build","title":"<code>build()</code>","text":"<p>Builds and returns a pipeline function that applies a series of components to the input data. Returns:     pipeline: A function that takes input data and applies the ordered components to it. Raises:     ValueError: If a circular dependency is detected among the components.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def build(self) -&gt; Callable:\n    \"\"\"\n    Builds and returns a pipeline function that applies a series of components to the input data.\n    Returns:\n        pipeline: A function that takes input data and applies the ordered components to it.\n    Raises:\n        ValueError: If a circular dependency is detected among the components.\n    \"\"\"\n\n    def resolve_dependencies():\n        resolved = []\n        unresolved = self._components.copy()\n\n        while unresolved:\n            for component in unresolved:\n                if all(\n                    dep in [c.name for c in resolved]\n                    for dep in component.dependencies\n                ):\n                    resolved.append(component)\n                    unresolved.remove(component)\n                    break\n            else:\n                raise ValueError(\"Circular dependency detected\")\n\n        return [c.func for c in resolved]\n\n    ordered_components = resolve_dependencies()\n\n    def pipeline(data: Union[T, DataContainer[T]]) -&gt; DataContainer[T]:\n        if not isinstance(data, DataContainer):\n            data = DataContainer(data)\n\n        data = reduce(lambda d, comp: comp(d), ordered_components, data)\n\n        return data\n\n    if self._built_pipeline is not pipeline:\n        self._built_pipeline = pipeline\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.configure_pipeline","title":"<code>configure_pipeline(model_config)</code>  <code>abstractmethod</code>","text":"<p>Configure the pipeline based on the provided model configuration.</p> <p>This method should be implemented by subclasses to add specific components and configure the pipeline according to the given model configuration. The configuration typically involves: 1. Adding model components based on the model source 2. Adding any additional processing nodes 3. Configuring the pipeline stages and execution order</p> PARAMETER DESCRIPTION <code>model_config</code> <p>Configuration object containing: - source: Model source (e.g. huggingface, spacy, langchain) - model: Model identifier or path - task: Optional task name (e.g. summarization, ner) - path: Optional local path to model files - kwargs: Additional model configuration parameters</p> <p> TYPE: <code>ModelConfig</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented by a subclass.</p> Example <p>def configure_pipeline(self, config: ModelConfig): ...     # Add model component ...     model = self.get_model_component(config) ...     self.add_node(model, stage=\"processing\") ... ...     # Add output formatting ...     self.add_node(OutputFormatter(), stage=\"formatting\")</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@abstractmethod\ndef configure_pipeline(self, model_config: ModelConfig) -&gt; None:\n    \"\"\"\n    Configure the pipeline based on the provided model configuration.\n\n    This method should be implemented by subclasses to add specific components\n    and configure the pipeline according to the given model configuration.\n    The configuration typically involves:\n    1. Adding model components based on the model source\n    2. Adding any additional processing nodes\n    3. Configuring the pipeline stages and execution order\n\n    Args:\n        model_config (ModelConfig): Configuration object containing:\n            - source: Model source (e.g. huggingface, spacy, langchain)\n            - model: Model identifier or path\n            - task: Optional task name (e.g. summarization, ner)\n            - path: Optional local path to model files\n            - kwargs: Additional model configuration parameters\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented by a subclass.\n\n    Example:\n        &gt;&gt;&gt; def configure_pipeline(self, config: ModelConfig):\n        ...     # Add model component\n        ...     model = self.get_model_component(config)\n        ...     self.add_node(model, stage=\"processing\")\n        ...\n        ...     # Add output formatting\n        ...     self.add_node(OutputFormatter(), stage=\"formatting\")\n    \"\"\"\n    raise NotImplementedError(\"This method must be implemented by subclasses.\")\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.from_local_model","title":"<code>from_local_model(path, source, task=None, template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load pipeline from a local model path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to local model files/directory</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>source</code> <p>Model source (e.g. \"huggingface\", \"spacy\")</p> <p> TYPE: <code>Union[str, ModelSource]</code> </p> <code>task</code> <p>Task identifier for the model. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template</code> <p>Optional template string for formatting model output.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Optional path to template file for formatting model output.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the model. e.g. temperature, max_length, etc.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If source is not a valid ModelSource.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load local HuggingFace model\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/my_summarizer\",\n...     source=\"huggingface\",\n...     task=\"summarization\",\n...     temperature=0.7\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load local SpaCy model\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/en_core_sci_md\",\n...     source=\"spacy\",\n...     disable=[\"parser\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load with output template\n&gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n&gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n...     \"models/gpt_model\",\n...     source=\"huggingface\",\n...     template=template\n... )\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef from_local_model(\n    cls,\n    path: Union[str, Path],\n    source: Union[str, ModelSource],\n    task: Optional[str] = None,\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"Load pipeline from a local model path.\n\n    Args:\n        path (Union[str, Path]): Path to local model files/directory\n        source (Union[str, ModelSource]): Model source (e.g. \"huggingface\", \"spacy\")\n        task (Optional[str]): Task identifier for the model. Defaults to None.\n        template (Optional[str]): Optional template string for formatting model output.\n        template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n        **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If source is not a valid ModelSource.\n\n    Examples:\n        &gt;&gt;&gt; # Load local HuggingFace model\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/my_summarizer\",\n        ...     source=\"huggingface\",\n        ...     task=\"summarization\",\n        ...     temperature=0.7\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load local SpaCy model\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/en_core_sci_md\",\n        ...     source=\"spacy\",\n        ...     disable=[\"parser\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load with output template\n        &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n        &gt;&gt;&gt; pipeline = Pipeline.from_local_model(\n        ...     \"models/gpt_model\",\n        ...     source=\"huggingface\",\n        ...     template=template\n        ... )\n    \"\"\"\n    pipeline = cls()\n    pipeline._configure_output_templates(template, template_path)\n\n    path = Path(path)\n    config = ModelConfig(\n        source=ModelSource(source.lower()),\n        model_id=path.name,\n        path=path,\n        task=task,\n        kwargs=kwargs,\n    )\n    pipeline._model_config = config\n    pipeline.configure_pipeline(config)\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.from_model_id","title":"<code>from_model_id(model_id, source='huggingface', task='text-generation', template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load pipeline from a model identifier.</p> PARAMETER DESCRIPTION <code>model_id</code> <p>Model identifier (e.g. HuggingFace model ID, SpaCy model name)</p> <p> TYPE: <code>str</code> </p> <code>source</code> <p>Model source. Defaults to \"huggingface\". Can be \"huggingface\", \"spacy\".</p> <p> TYPE: <code>Union[str, ModelSource]</code> DEFAULT: <code>'huggingface'</code> </p> <code>task</code> <p>Task identifier for the model. Defaults to \"text-generation\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'text-generation'</code> </p> <code>template</code> <p>Optional template string for formatting model output.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Optional path to template file for formatting model output.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the model. e.g. temperature, max_length, etc.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If source is not a valid ModelSource.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load HuggingFace model\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"facebook/bart-large-cnn\",\n...     task=\"summarization\",\n...     temperature=0.7\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load SpaCy model\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"en_core_sci_md\",\n...     source=\"spacy\",\n...     disable=[\"parser\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load with output template\n&gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n&gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n...     \"gpt-3.5-turbo\",\n...     source=\"huggingface\",\n...     template=template\n... )\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef from_model_id(\n    cls,\n    model_id: str,\n    source: Union[str, ModelSource] = \"huggingface\",\n    task: Optional[str] = \"text-generation\",\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"\n    Load pipeline from a model identifier.\n\n    Args:\n        model_id (str): Model identifier (e.g. HuggingFace model ID, SpaCy model name)\n        source (Union[str, ModelSource]): Model source. Defaults to \"huggingface\".\n            Can be \"huggingface\", \"spacy\".\n        task (Optional[str]): Task identifier for the model. Defaults to \"text-generation\".\n        template (Optional[str]): Optional template string for formatting model output.\n        template_path (Optional[Union[str, Path]]): Optional path to template file for formatting model output.\n        **kwargs: Additional configuration options passed to the model. e.g. temperature, max_length, etc.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If source is not a valid ModelSource.\n\n    Examples:\n        &gt;&gt;&gt; # Load HuggingFace model\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"facebook/bart-large-cnn\",\n        ...     task=\"summarization\",\n        ...     temperature=0.7\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load SpaCy model\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"en_core_sci_md\",\n        ...     source=\"spacy\",\n        ...     disable=[\"parser\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load with output template\n        &gt;&gt;&gt; template = '''{\"summary\": \"{{ model_output }}\"}'''\n        &gt;&gt;&gt; pipeline = Pipeline.from_model_id(\n        ...     \"gpt-3.5-turbo\",\n        ...     source=\"huggingface\",\n        ...     template=template\n        ... )\n    \"\"\"\n    pipeline = cls()\n    pipeline._configure_output_templates(template, template_path)\n\n    config = ModelConfig(\n        source=ModelSource(source.lower()),\n        model_id=model_id,\n        task=task,\n        kwargs=kwargs,\n    )\n    pipeline._model_config = config\n    pipeline.configure_pipeline(config)\n\n    return pipeline\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.load","title":"<code>load(pipeline, source, task='text-generation', template=None, template_path=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).</p> PARAMETER DESCRIPTION <code>pipeline</code> <p>A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)</p> <p> TYPE: <code>Callable</code> </p> <code>source</code> <p>Source of the pipeline. Can be \"langchain\" or \"huggingface\".</p> <p> TYPE: <code>str</code> </p> <code>task</code> <p>Task identifier used to retrieve model outputs. Defaults to \"text-generation\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'text-generation'</code> </p> <code>template</code> <p>Template string for formatting outputs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>template_path</code> <p>Path to template file. Defaults to None.</p> <p> TYPE: <code>Optional[Union[str, Path]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional configuration options passed to the pipeline.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePipeline</code> <p>Configured pipeline instance.</p> <p> TYPE: <code>BasePipeline</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If pipeline is not callable or source is invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Load LangChain pipeline\n&gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n&gt;&gt;&gt; from langchain_openai import ChatOpenAI\n&gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n&gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load HuggingFace pipeline\n&gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n&gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n&gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n&gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n&gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n</code></pre> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    pipeline: Callable,\n    source: str,\n    task: Optional[str] = \"text-generation\",\n    template: Optional[str] = None,\n    template_path: Optional[Union[str, Path]] = None,\n    **kwargs: Any,\n) -&gt; \"BasePipeline\":\n    \"\"\"\n    Load a pipeline from a pre-built pipeline object (e.g. LangChain chain or HuggingFace pipeline).\n\n    Args:\n        pipeline (Callable): A callable pipeline object (e.g. LangChain chain, HuggingFace pipeline)\n        source (str): Source of the pipeline. Can be \"langchain\" or \"huggingface\".\n        task (Optional[str]): Task identifier used to retrieve model outputs.\n            Defaults to \"text-generation\".\n        template (Optional[str]): Template string for formatting outputs.\n            Defaults to None.\n        template_path (Optional[Union[str, Path]]): Path to template file.\n            Defaults to None.\n        **kwargs: Additional configuration options passed to the pipeline.\n\n    Returns:\n        BasePipeline: Configured pipeline instance.\n\n    Raises:\n        ValueError: If pipeline is not callable or source is invalid.\n\n    Examples:\n        &gt;&gt;&gt; # Load LangChain pipeline\n        &gt;&gt;&gt; from langchain_core.prompts import ChatPromptTemplate\n        &gt;&gt;&gt; from langchain_openai import ChatOpenAI\n        &gt;&gt;&gt; chain = ChatPromptTemplate.from_template(\"What is {input}?\") | ChatOpenAI()\n        &gt;&gt;&gt; pipeline = Pipeline.load(chain, source=\"langchain\", temperature=0.7)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load HuggingFace pipeline\n        &gt;&gt;&gt; from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline\n        &gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n        &gt;&gt;&gt; model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n        &gt;&gt;&gt; pipe = pipeline(\"text-generation\", model=model, tokenizer=tokenizer, max_new_tokens=10)\n        &gt;&gt;&gt; pipeline = Pipeline.load(pipe, source=\"huggingface\")\n    \"\"\"\n    if not (hasattr(pipeline, \"__call__\") or hasattr(pipeline, \"invoke\")):\n        raise ValueError(\"Pipeline must be a callable object\")\n\n    # Validate source\n    source = source.lower()\n    if source not in [\"langchain\", \"huggingface\"]:\n        raise ValueError(\n            \"Source must be either 'langchain' or 'huggingface' for direct pipeline loading\"\n        )\n\n    # For HuggingFace pipelines, try to infer task if not provided\n    if source == \"huggingface\" and hasattr(pipeline, \"task\") and not task:\n        task = pipeline.task\n\n    instance = cls()\n    instance._configure_output_templates(template, template_path)\n\n    config = ModelConfig(\n        source=ModelSource(source),\n        pipeline_object=pipeline,\n        task=task,\n        kwargs=kwargs,\n    )\n\n    instance._model_config = config\n    instance.configure_pipeline(config)\n\n    return instance\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.remove","title":"<code>remove(component_name)</code>","text":"<p>Removes a component from the pipeline.</p> PARAMETER DESCRIPTION <code>component_name</code> <p>The name of the component to be removed.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the component is not found in the pipeline.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Logs <p>DEBUG: When the component is successfully removed. WARNING: If the component fails to be removed after attempting to do so.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def remove(self, component_name: str) -&gt; None:\n    \"\"\"\n    Removes a component from the pipeline.\n\n    Args:\n        component_name (str): The name of the component to be removed.\n\n    Raises:\n        ValueError: If the component is not found in the pipeline.\n\n    Returns:\n        None\n\n    Logs:\n        DEBUG: When the component is successfully removed.\n        WARNING: If the component fails to be removed after attempting to do so.\n    \"\"\"\n    # Check if the component exists in the pipeline\n    if not any(c.name == component_name for c in self._components):\n        raise ValueError(f\"Component '{component_name}' not found in the pipeline.\")\n\n    # Remove the component from self.components\n    original_count = len(self._components)\n    self._components = [c for c in self._components if c.name != component_name]\n\n    # Remove the component from stages\n    for stage in self._stages.values():\n        stage[:] = [c for c in stage if c.__name__ != component_name]\n\n    # Validate that the component was removed\n    if len(self._components) == original_count or any(\n        c.__name__ == component_name\n        for stage in self._stages.values()\n        for c in stage\n    ):\n        logger.warning(\n            f\"Failed to remove component '{component_name}' from the pipeline.\"\n        )\n    logger.debug(\n        f\"Successfully removed component '{component_name}' from the pipeline.\"\n    )\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.BasePipeline.replace","title":"<code>replace(old_component_name, new_component)</code>","text":"<p>Replaces a component in the pipeline with a new component.</p> PARAMETER DESCRIPTION <code>old_component_name</code> <p>The name of the component to be replaced.</p> <p> TYPE: <code>str</code> </p> <code>new_component</code> <p>The new component to replace the old component with.</p> <p> TYPE: <code>Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the old component is not found in the pipeline.</p> <code>ValueError</code> <p>If the new component is not a BaseComponent or a callable.</p> <code>ValueError</code> <p>If the new component callable doesn't have the correct signature.</p> Logs <p>DEBUG: When the component is successfully replaced.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def replace(\n    self,\n    old_component_name: str,\n    new_component: Union[\n        BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]\n    ],\n) -&gt; None:\n    \"\"\"\n    Replaces a component in the pipeline with a new component.\n\n    Args:\n        old_component_name (str): The name of the component to be replaced.\n        new_component (Union[BaseComponent[T], Callable[[DataContainer[T]], DataContainer[T]]]):\n            The new component to replace the old component with.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the old component is not found in the pipeline.\n        ValueError: If the new component is not a BaseComponent or a callable.\n        ValueError: If the new component callable doesn't have the correct signature.\n\n    Logs:\n        DEBUG: When the component is successfully replaced.\n    \"\"\"\n\n    if isinstance(new_component, BaseComponent):\n        # It's a valid BaseComponent, no further checks needed\n        pass\n    elif callable(new_component):\n        sig = signature(new_component)\n        param = list(sig.parameters.values())[0]\n        if len(sig.parameters) != 1 or not issubclass(\n            param.annotation, DataContainer\n        ):\n            raise ValueError(\n                \"New component callable must accept a single argument that is a subclass of DataContainer.\"\n            )\n    else:\n        raise ValueError(\"New component must be a BaseComponent or a callable.\")\n\n    old_component_found = False\n\n    # Replace in self.components\n    for i, c in enumerate(self._components):\n        if c.name == old_component_name:\n            self._components[i] = PipelineNode(\n                func=new_component,\n                name=old_component_name,\n                position=c.position,\n                reference=c.reference,\n                stage=c.stage,\n                dependencies=c.dependencies,\n            )\n            old_component_found = True\n\n    # Replace in self.stages\n    for stage in self._stages.values():\n        for i, c in enumerate(stage):\n            if getattr(c, \"name\", c.__name__) == old_component_name:\n                stage[i] = new_component\n                old_component_found = True\n\n    if not old_component_found:\n        raise ValueError(\n            f\"Component '{old_component_name}' not found in the pipeline.\"\n        )\n    else:\n        logger.debug(\n            f\"Successfully replaced component '{old_component_name}' in the pipeline.\"\n        )\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.ModelConfig","title":"<code>ModelConfig</code>  <code>dataclass</code>","text":"<p>Configuration for model initialization</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@dataclass\nclass ModelConfig:\n    \"\"\"Configuration for model initialization\"\"\"\n\n    source: ModelSource\n    model_id: Optional[str] = None\n    pipeline_object: Optional[Any] = None\n    task: Optional[str] = None\n    path: Optional[Path] = None\n    kwargs: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.ModelSource","title":"<code>ModelSource</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported model sources</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class ModelSource(Enum):\n    \"\"\"Enumeration of supported model sources\"\"\"\n\n    SPACY = \"spacy\"\n    HUGGINGFACE = \"huggingface\"\n    LANGCHAIN = \"langchain\"\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.Pipeline","title":"<code>Pipeline</code>","text":"<p>               Bases: <code>BasePipeline</code>, <code>Generic[T]</code></p> <p>Default Pipeline class for creating a basic data processing pipeline. This class inherits from BasePipeline and provides a default implementation of the configure_pipeline method, which does not add any specific components.</p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>class Pipeline(BasePipeline, Generic[T]):\n    \"\"\"\n    Default Pipeline class for creating a basic data processing pipeline.\n    This class inherits from BasePipeline and provides a default implementation\n    of the configure_pipeline method, which does not add any specific components.\n    \"\"\"\n\n    def configure_pipeline(self, model_path: str) -&gt; None:\n        \"\"\"\n        Configures the pipeline by adding components based on the provided model path.\n        This default implementation does not add any specific components.\n\n        Args:\n            model_path (str): The path to the model used for configuring the pipeline.\n        \"\"\"\n        # Default implementation: No specific components added\n        pass\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.Pipeline.configure_pipeline","title":"<code>configure_pipeline(model_path)</code>","text":"<p>Configures the pipeline by adding components based on the provided model path. This default implementation does not add any specific components.</p> PARAMETER DESCRIPTION <code>model_path</code> <p>The path to the model used for configuring the pipeline.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>def configure_pipeline(self, model_path: str) -&gt; None:\n    \"\"\"\n    Configures the pipeline by adding components based on the provided model path.\n    This default implementation does not add any specific components.\n\n    Args:\n        model_path (str): The path to the model used for configuring the pipeline.\n    \"\"\"\n    # Default implementation: No specific components added\n    pass\n</code></pre>"},{"location":"api/pipeline/#healthchain.pipeline.base.PipelineNode","title":"<code>PipelineNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Represents a node in a pipeline.</p> ATTRIBUTE DESCRIPTION <code>func</code> <p>The function to be applied to the data.</p> <p> TYPE: <code>Callable[[DataContainer[T]], DataContainer[T]]</code> </p> <code>position</code> <p>The position of the node in the pipeline. Defaults to \"default\".</p> <p> TYPE: <code>PositionType</code> </p> <code>reference</code> <p>The reference for the relative position of the node. Name should be the \"name\" attribute of another node. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>stage</code> <p>The stage of the node in the pipeline. Group nodes by stage e.g. \"preprocessing\". Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of the node. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>dependencies</code> <p>The list of dependencies for the node. Defaults to an empty list.</p> <p> TYPE: <code>List[str]</code> </p> Source code in <code>healthchain/pipeline/base.py</code> <pre><code>@dataclass\nclass PipelineNode(Generic[T]):\n    \"\"\"\n    Represents a node in a pipeline.\n\n    Attributes:\n        func (Callable[[DataContainer[T]], DataContainer[T]]): The function to be applied to the data.\n        position (PositionType, optional): The position of the node in the pipeline. Defaults to \"default\".\n        reference (str, optional): The reference for the relative position of the node. Name should be the \"name\" attribute of another node. Defaults to None.\n        stage (str, optional): The stage of the node in the pipeline. Group nodes by stage e.g. \"preprocessing\". Defaults to None.\n        name (str, optional): The name of the node. Defaults to None.\n        dependencies (List[str], optional): The list of dependencies for the node. Defaults to an empty list.\n    \"\"\"\n\n    func: Callable[[DataContainer[T]], DataContainer[T]]\n    position: PositionType = \"default\"\n    reference: str = None\n    stage: str = None\n    name: str = None\n    dependencies: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/sandbox/","title":"Sandbox Client","text":"<p>Simplified client for testing healthcare services with various data sources.</p> <p>This class provides an intuitive interface for: - Loading test datasets (MIMIC-on-FHIR, Synthea) - Generating synthetic FHIR data - Sending requests to healthcare services - Managing request/response lifecycle</p> <p>Examples:</p> <p>Load from dataset registry:</p> <pre><code>&gt;&gt;&gt; client = SandboxClient(\n...     url=\"http://localhost:8000/cds/cds-services/my-service\"\n... )\n&gt;&gt;&gt; client.load_from_registry(\"mimic-on-fhir\", sample_size=10)\n&gt;&gt;&gt; responses = client.send_requests()\n</code></pre> <p>Load CDA file from path:</p> <pre><code>&gt;&gt;&gt; client = SandboxClient(\n...     url=\"http://localhost:8000/notereader/?wsdl\",\n...     protocol=\"soap\"\n... )\n&gt;&gt;&gt; client.load_from_path(\"./data/clinical_note.xml\")\n&gt;&gt;&gt; responses = client.send_requests()\n</code></pre> <p>Generate data from free text:</p> <pre><code>&gt;&gt;&gt; client = SandboxClient(\n...     url=\"http://localhost:8000/cds/cds-services/discharge-summarizer\"\n... )\n&gt;&gt;&gt; client.load_free_text(\n...     csv_path=\"./data/notes.csv\",\n...     column_name=\"text\",\n...     workflow=\"encounter-discharge\"\n... )\n&gt;&gt;&gt; responses = client.send_requests()\n</code></pre> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>class SandboxClient:\n    \"\"\"\n    Simplified client for testing healthcare services with various data sources.\n\n    This class provides an intuitive interface for:\n    - Loading test datasets (MIMIC-on-FHIR, Synthea)\n    - Generating synthetic FHIR data\n    - Sending requests to healthcare services\n    - Managing request/response lifecycle\n\n    Examples:\n        Load from dataset registry:\n        &gt;&gt;&gt; client = SandboxClient(\n        ...     url=\"http://localhost:8000/cds/cds-services/my-service\"\n        ... )\n        &gt;&gt;&gt; client.load_from_registry(\"mimic-on-fhir\", sample_size=10)\n        &gt;&gt;&gt; responses = client.send_requests()\n\n        Load CDA file from path:\n        &gt;&gt;&gt; client = SandboxClient(\n        ...     url=\"http://localhost:8000/notereader/?wsdl\",\n        ...     protocol=\"soap\"\n        ... )\n        &gt;&gt;&gt; client.load_from_path(\"./data/clinical_note.xml\")\n        &gt;&gt;&gt; responses = client.send_requests()\n\n        Generate data from free text:\n        &gt;&gt;&gt; client = SandboxClient(\n        ...     url=\"http://localhost:8000/cds/cds-services/discharge-summarizer\"\n        ... )\n        &gt;&gt;&gt; client.load_free_text(\n        ...     csv_path=\"./data/notes.csv\",\n        ...     column_name=\"text\",\n        ...     workflow=\"encounter-discharge\"\n        ... )\n        &gt;&gt;&gt; responses = client.send_requests()\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        workflow: Union[Workflow, str],\n        protocol: Literal[\"rest\", \"soap\"] = \"rest\",\n        timeout: float = 10.0,\n    ):\n        \"\"\"\n        Initialize SandboxClient.\n\n        Args:\n            url: Full service URL (e.g., \"http://localhost:8000/cds/cds-services/my-service\")\n            workflow: Workflow specification (required) - determines request type and validation\n            protocol: Communication protocol - \"rest\" for CDS Hooks, \"soap\" for CDA\n            timeout: Request timeout in seconds\n\n        Raises:\n            ValueError: If url or workflow-protocol combination is invalid\n        \"\"\"\n        try:\n            self.url = httpx.URL(url)\n        except Exception as e:\n            raise ValueError(f\"Invalid URL: {str(e)}\")\n\n        self.workflow = Workflow(workflow) if isinstance(workflow, str) else workflow\n        self.protocol = ApiProtocol.soap if protocol == \"soap\" else ApiProtocol.rest\n        self.timeout = timeout\n\n        # Request/response management\n        self.requests: List[Union[CDSRequest, Any]] = []\n        self.responses: List[Dict] = []\n        self.sandbox_id = uuid.uuid4()\n\n        # Single validation point - fail fast on incompatible workflow-protocol\n        self._validate_workflow_protocol()\n\n        log.info(f\"Initialized SandboxClient {self.sandbox_id} for {self.url}\")\n\n    def _validate_workflow_protocol(self) -&gt; None:\n        \"\"\"\n        Validate workflow is compatible with protocol.\n\n        Raises:\n            ValueError: If workflow-protocol combination is invalid\n        \"\"\"\n        from healthchain.sandbox.workflows import UseCaseMapping\n\n        if self.protocol == ApiProtocol.soap:\n            # SOAP only works with ClinicalDocumentation workflows\n            soap_workflows = UseCaseMapping.ClinicalDocumentation.allowed_workflows\n            if self.workflow.value not in soap_workflows:\n                raise ValueError(\n                    f\"Workflow '{self.workflow.value}' is not compatible with SOAP protocol. \"\n                    f\"SOAP requires Clinical Documentation workflows: {soap_workflows}\"\n                )\n\n        elif self.protocol == ApiProtocol.rest:\n            # REST only works with CDS workflows\n            rest_workflows = UseCaseMapping.ClinicalDecisionSupport.allowed_workflows\n            if self.workflow.value not in rest_workflows:\n                raise ValueError(\n                    f\"Workflow '{self.workflow.value}' is not compatible with REST protocol. \"\n                    f\"REST requires CDS workflows: {rest_workflows}\"\n                )\n\n    def load_from_registry(\n        self,\n        source: str,\n        data_dir: str,\n        **kwargs: Any,\n    ) -&gt; \"SandboxClient\":\n        \"\"\"\n        Load data from the dataset registry.\n\n        Loads pre-configured datasets like MIMIC-on-FHIR, Synthea, or custom\n        registered datasets.\n\n        Args:\n            source: Dataset name (e.g., \"mimic-on-fhir\", \"synthea\")\n            data_dir: Path to the dataset directory\n            **kwargs: Dataset-specific parameters (e.g., resource_types, sample_size)\n\n        Returns:\n            Self for method chaining\n\n        Raises:\n            ValueError: If dataset not found in registry\n            FileNotFoundError: If data_dir doesn't exist\n\n        Examples:\n            Load MIMIC dataset:\n            &gt;&gt;&gt; client = SandboxClient(\n            ...     url=\"http://localhost:8000/cds/patient-view\",\n            ...     workflow=\"patient-view\",\n            ... )\n            &gt;&gt;&gt; client.load_from_registry(\n            ...     \"mimic-on-fhir\",\n            ...     data_dir=\"./data/mimic-fhir\",\n            ...     resource_types=[\"MimicMedication\"],\n            ...     sample_size=10\n            ... )\n        \"\"\"\n        from healthchain.sandbox.datasets import DatasetRegistry\n\n        log.info(f\"Loading dataset from registry: {source}\")\n        try:\n            loaded_data = DatasetRegistry.load(source, data_dir=data_dir, **kwargs)\n            self._construct_request(loaded_data)\n            log.info(f\"Loaded {source} dataset with {len(self.requests)} requests\")\n        except KeyError:\n            raise ValueError(\n                f\"Unknown dataset: {source}. \"\n                f\"Available datasets: {DatasetRegistry.list_datasets()}\"\n            )\n        return self\n\n    def load_from_path(\n        self,\n        path: Union[str, Path],\n        pattern: Optional[str] = None,\n    ) -&gt; \"SandboxClient\":\n        \"\"\"\n        Load data from a file or directory.\n\n        Supports single files or all matching files in a directory (with optional glob pattern).\n        For .xml (SOAP protocol) loads CDA; for .json (REST protocol) loads Prefetch.\n\n        Args:\n            path: File or directory path.\n            pattern: Glob pattern for files in directory (e.g., \"*.xml\").\n\n        Returns:\n            Self.\n\n        Raises:\n            FileNotFoundError: If path does not exist.\n            ValueError: If no matching files are found or if path is not file/dir.\n        \"\"\"\n\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f\"Path not found: {path}\")\n\n        # Collect files to process\n        files_to_load = []\n        if path.is_file():\n            files_to_load = [path]\n        elif path.is_dir():\n            pattern = pattern or \"*\"\n            files_to_load = list(path.glob(pattern))\n            if not files_to_load:\n                raise ValueError(\n                    f\"No files found matching pattern '{pattern}' in {path}\"\n                )\n        else:\n            raise ValueError(f\"Path must be a file or directory: {path}\")\n\n        log.info(f\"Loading {len(files_to_load)} file(s) from {path}\")\n\n        # Process each file\n        for file_path in files_to_load:\n            # Determine file type from extension\n            extension = file_path.suffix.lower()\n\n            if extension == \".xml\":\n                with open(file_path, \"r\") as f:\n                    xml_content = f.read()\n                self._construct_request(xml_content)\n                log.info(f\"Loaded CDA document from {file_path.name}\")\n\n            elif extension == \".json\":\n                with open(file_path, \"r\") as f:\n                    json_data = json.load(f)\n\n                try:\n                    self._construct_request(json_data)\n                    log.info(f\"Loaded prefetch data from {file_path.name}\")\n\n                except Exception as e:\n                    log.error(f\"Failed to parse {file_path} as prefetch data: {e}\")\n                    raise ValueError(\n                        f\"File {file_path} is not valid prefetch format. \"\n                        f\"Expected JSON with FHIR resources. \"\n                        f\"Error: {e}\"\n                    )\n            else:\n                log.warning(f\"Skipping unsupported file type: {file_path}\")\n\n        log.info(\n            f\"Loaded {len(self.requests)} requests from {len(files_to_load)} file(s)\"\n        )\n        return self\n\n    def load_free_text(\n        self,\n        csv_path: str,\n        column_name: str,\n        generate_synthetic: bool = True,\n        random_seed: Optional[int] = None,\n        **kwargs: Any,\n    ) -&gt; \"SandboxClient\":\n        \"\"\"\n        Load free-text notes from a CSV column and create FHIR DocumentReferences for CDS prefetch.\n        Optionally include synthetic FHIR resources based on the current workflow.\n\n        Args:\n            csv_path: Path to the CSV file\n            column_name: Name of the text column\n            generate_synthetic: Whether to add synthetic FHIR resources (default: True)\n            random_seed: Seed for reproducible results\n            **kwargs: Extra parameters for data generation\n\n        Returns:\n            self\n\n        Raises:\n            FileNotFoundError: If the CSV file does not exist\n            ValueError: If the column is not found\n        \"\"\"\n        from .generators import CdsDataGenerator\n\n        generator = CdsDataGenerator()\n        generator.set_workflow(self.workflow)\n\n        prefetch_data = generator.generate_prefetch(\n            random_seed=random_seed,\n            free_text_path=csv_path,\n            column_name=column_name,\n            generate_resources=generate_synthetic,\n            **kwargs,\n        )\n\n        self._construct_request(prefetch_data)\n\n        if generate_synthetic:\n            log.info(\n                f\"Generated {len(self.requests)} requests from free text with synthetic resources for workflow {self.workflow.value}\"\n            )\n        else:\n            log.info(\n                f\"Generated {len(self.requests)} requests from free text only (no synthetic resources)\"\n            )\n\n        return self\n\n    def _construct_request(self, data: Union[Dict[str, Any], Any]) -&gt; None:\n        \"\"\"\n        Convert data to request format and add to queue.\n\n        Args:\n            data: Data to convert (Dict for CDS prefetch, string for CDA)\n        \"\"\"\n        if self.protocol == ApiProtocol.rest:\n            constructor = CdsRequestConstructor()\n            request = constructor.construct_request(data, self.workflow)\n        elif self.protocol == ApiProtocol.soap:\n            constructor = ClinDocRequestConstructor()\n            request = constructor.construct_request(data, self.workflow)\n        else:\n            raise ValueError(f\"Unsupported protocol: {self.protocol}\")\n\n        self.requests.append(request)\n\n    def clear_requests(self) -&gt; \"SandboxClient\":\n        \"\"\"\n        Clear all queued requests.\n\n        Useful when you want to start fresh without creating a new client instance.\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        count = len(self.requests)\n        self.requests.clear()\n        log.info(f\"Cleared {count} queued request(s)\")\n\n        return self\n\n    def preview_requests(self, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get preview of queued requests without sending them.\n\n        Provides a summary view of what requests are queued, useful for debugging\n        and verifying data was loaded correctly before sending.\n\n        Args:\n            limit: Maximum number of requests to preview. If None, preview all.\n\n        Returns:\n            List of request summary dictionaries containing metadata\n        \"\"\"\n        requests = self.requests[:limit] if limit else self.requests\n        previews = []\n\n        for idx, req in enumerate(requests):\n            preview = {\n                \"index\": idx,\n                \"type\": req.__class__.__name__,\n                \"protocol\": self.protocol.value\n                if hasattr(self.protocol, \"value\")\n                else str(self.protocol),\n            }\n\n            # Add protocol-specific info\n            if self.protocol == ApiProtocol.rest and hasattr(req, \"hook\"):\n                preview[\"hook\"] = req.hook\n                preview[\"hookInstance\"] = getattr(req, \"hookInstance\", None)\n            elif self.protocol == ApiProtocol.soap:\n                preview[\"has_document\"] = hasattr(req, \"document\")\n\n            previews.append(preview)\n\n        return previews\n\n    def get_request_data(\n        self, format: Literal[\"dict\", \"json\"] = \"dict\"\n    ) -&gt; Union[List[Dict], str]:\n        \"\"\"\n        Get transformed request data for inspection.\n\n        Allows access to serialized request data for debugging or custom processing.\n        For direct access to Pydantic models, use the `requests` attribute:\n            &gt;&gt;&gt; for request in client.requests:\n            &gt;&gt;&gt;     print(request.model_dump())\n\n        Args:\n            format: Return format - \"dict\" for list of dictionaries,\n                   \"json\" for JSON string\n\n        Returns:\n            Request data in specified format\n\n        Raises:\n            ValueError: If format is not \"dict\" or \"json\"\n\n        Examples:\n            &gt;&gt;&gt; client.load_from_path(\"data.xml\")\n            &gt;&gt;&gt; # Access raw Pydantic models directly\n            &gt;&gt;&gt; for request in client.requests:\n            &gt;&gt;&gt;     print(request.model_dump(exclude_none=True))\n            &gt;&gt;&gt; # Get as dictionaries\n            &gt;&gt;&gt; dicts = client.get_request_data(\"dict\")\n            &gt;&gt;&gt; # Get as JSON string\n            &gt;&gt;&gt; json_str = client.get_request_data(\"json\")\n            &gt;&gt;&gt; print(json_str)\n        \"\"\"\n        if format == \"dict\":\n            result = []\n            for req in self.requests:\n                if hasattr(req, \"model_dump\"):\n                    result.append(req.model_dump(exclude_none=True))\n                elif hasattr(req, \"model_dump_xml\"):\n                    result.append({\"document\": req.model_dump_xml()})\n                else:\n                    result.append(req)\n            return result\n        elif format == \"json\":\n            return json.dumps(self.get_request_data(\"dict\"), indent=2)\n        else:\n            raise ValueError(\n                f\"Invalid format '{format}'. Must be 'dict' or 'json'. \"\n                f\"For raw Pydantic models, access the 'requests' attribute directly.\"\n            )\n\n    def send_requests(self) -&gt; List[Dict]:\n        \"\"\"\n        Send all queued requests to the service.\n\n        Returns:\n            List of response dictionaries\n        \"\"\"\n        if not self.requests:\n            raise RuntimeError(\n                \"No requests to send. Load data first using load_from_registry(), load_from_path(), or load_free_text()\"\n            )\n\n        log.info(f\"Sending {len(self.requests)} requests to {self.url}\")\n\n        with httpx.Client(follow_redirects=True) as client:\n            responses: List[Dict] = []\n            timeout = httpx.Timeout(self.timeout, read=None)\n\n            for request in self.requests:\n                try:\n                    if self.protocol == ApiProtocol.soap:\n                        headers = {\"Content-Type\": \"text/xml; charset=utf-8\"}\n                        response = client.post(\n                            url=str(self.url),\n                            data=request.document,\n                            headers=headers,\n                            timeout=timeout,\n                        )\n                        response.raise_for_status()\n                        response_model = CdaResponse(document=response.text)\n                        responses.append(response_model.model_dump_xml())\n                    else:\n                        # REST/CDS Hooks\n                        log.debug(f\"Making POST request to: {self.url}\")\n                        response = client.post(\n                            url=str(self.url),\n                            json=request.model_dump(exclude_none=True, mode=\"json\"),\n                            timeout=timeout,\n                        )\n                        response.raise_for_status()\n\n                        try:\n                            response_data = response.json()\n                            cds_response = CDSResponse(**response_data)\n                            responses.append(\n                                cds_response.model_dump(mode=\"json\", exclude_none=True)\n                            )\n                        except json.JSONDecodeError:\n                            log.error(\n                                f\"Invalid JSON response from {self.url}. \"\n                                f\"Response preview: {response.text[:200]}\"\n                            )\n                            responses.append({})\n                        except Exception:\n                            # Fallback to raw response if CDSResponse parsing fails\n                            responses.append(response_data)\n\n                except httpx.HTTPStatusError as exc:\n                    try:\n                        error_content = exc.response.json()\n                    except Exception:\n                        error_content = exc.response.text\n                    log.error(\n                        f\"Error response {exc.response.status_code} while requesting \"\n                        f\"{exc.request.url!r}: {error_content}\"\n                    )\n                    responses.append({})\n                except httpx.TimeoutException as exc:\n                    log.error(f\"Request to {exc.request.url!r} timed out!\")\n                    responses.append({})\n                except httpx.RequestError as exc:\n                    log.error(\n                        f\"An error occurred while requesting {exc.request.url!r}.\"\n                    )\n                    responses.append({})\n\n        self.responses = responses\n        log.info(f\"Received {len(responses)} responses\")\n\n        return responses\n\n    def save_results(\n        self,\n        directory: Union[str, Path] = \"./output/\",\n        save_request: bool = True,\n        save_response: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Save request and/or response data to disk.\n\n        Args:\n            directory: Directory to save data to (default: \"./output/\")\n            save_request: Whether to save request data (default: True)\n            save_response: Whether to save response data (default: True)\n        \"\"\"\n        if not self.responses and save_response:\n            raise RuntimeError(\n                \"No responses to save. Send requests first using send_requests()\"\n            )\n\n        save_dir = Path(directory)\n        extension = \"xml\" if self.protocol == ApiProtocol.soap else \"json\"\n\n        if save_request:\n            request_path = ensure_directory_exists(save_dir / \"requests\")\n            if self.protocol == ApiProtocol.soap:\n                request_data = [request.model_dump_xml() for request in self.requests]\n            else:\n                request_data = [\n                    request.model_dump(mode=\"json\", exclude_none=True)\n                    for request in self.requests\n                ]\n            save_data_to_directory(\n                request_data,\n                \"request\",\n                self.sandbox_id,\n                request_path,\n                extension,\n            )\n            log.info(f\"Saved request data at {request_path}/\")\n\n        if save_response:\n            response_path = ensure_directory_exists(save_dir / \"responses\")\n            save_data_to_directory(\n                self.responses,\n                \"response\",\n                self.sandbox_id,\n                response_path,\n                extension,\n            )\n            log.info(f\"Saved response data at {response_path}/\")\n\n    def get_status(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get current client status and statistics.\n\n        Returns:\n            Dictionary containing client status information\n        \"\"\"\n        return {\n            \"sandbox_id\": str(self.sandbox_id),\n            \"url\": str(self.url),\n            \"protocol\": self.protocol.value\n            if hasattr(self.protocol, \"value\")\n            else str(self.protocol),\n            \"workflow\": self.workflow.value if self.workflow else None,\n            \"requests_queued\": len(self.requests),\n            \"responses_received\": len(self.responses),\n        }\n\n    def __enter__(self) -&gt; \"SandboxClient\":\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"\n        Context manager exit - auto-save results if responses exist.\n\n        Only saves if no exception occurred and responses were generated.\n        \"\"\"\n        if self.responses and exc_type is None:\n            try:\n                self.save_results()\n                log.info(\"Auto-saved results on context exit\")\n            except Exception as e:\n                log.warning(f\"Failed to auto-save results: {e}\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of SandboxClient.\"\"\"\n        return (\n            f\"SandboxClient(url='{self.url}', \"\n            f\"protocol='{self.protocol.value if hasattr(self.protocol, 'value') else self.protocol}', \"\n            f\"requests={len(self.requests)})\"\n        )\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def __enter__(self) -&gt; \"SandboxClient\":\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit - auto-save results if responses exist.</p> <p>Only saves if no exception occurred and responses were generated.</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"\n    Context manager exit - auto-save results if responses exist.\n\n    Only saves if no exception occurred and responses were generated.\n    \"\"\"\n    if self.responses and exc_type is None:\n        try:\n            self.save_results()\n            log.info(\"Auto-saved results on context exit\")\n        except Exception as e:\n            log.warning(f\"Failed to auto-save results: {e}\")\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.__init__","title":"<code>__init__(url, workflow, protocol='rest', timeout=10.0)</code>","text":"<p>Initialize SandboxClient.</p> PARAMETER DESCRIPTION <code>url</code> <p>Full service URL (e.g., \"http://localhost:8000/cds/cds-services/my-service\")</p> <p> TYPE: <code>str</code> </p> <code>workflow</code> <p>Workflow specification (required) - determines request type and validation</p> <p> TYPE: <code>Union[Workflow, str]</code> </p> <code>protocol</code> <p>Communication protocol - \"rest\" for CDS Hooks, \"soap\" for CDA</p> <p> TYPE: <code>Literal['rest', 'soap']</code> DEFAULT: <code>'rest'</code> </p> <code>timeout</code> <p>Request timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>10.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If url or workflow-protocol combination is invalid</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    workflow: Union[Workflow, str],\n    protocol: Literal[\"rest\", \"soap\"] = \"rest\",\n    timeout: float = 10.0,\n):\n    \"\"\"\n    Initialize SandboxClient.\n\n    Args:\n        url: Full service URL (e.g., \"http://localhost:8000/cds/cds-services/my-service\")\n        workflow: Workflow specification (required) - determines request type and validation\n        protocol: Communication protocol - \"rest\" for CDS Hooks, \"soap\" for CDA\n        timeout: Request timeout in seconds\n\n    Raises:\n        ValueError: If url or workflow-protocol combination is invalid\n    \"\"\"\n    try:\n        self.url = httpx.URL(url)\n    except Exception as e:\n        raise ValueError(f\"Invalid URL: {str(e)}\")\n\n    self.workflow = Workflow(workflow) if isinstance(workflow, str) else workflow\n    self.protocol = ApiProtocol.soap if protocol == \"soap\" else ApiProtocol.rest\n    self.timeout = timeout\n\n    # Request/response management\n    self.requests: List[Union[CDSRequest, Any]] = []\n    self.responses: List[Dict] = []\n    self.sandbox_id = uuid.uuid4()\n\n    # Single validation point - fail fast on incompatible workflow-protocol\n    self._validate_workflow_protocol()\n\n    log.info(f\"Initialized SandboxClient {self.sandbox_id} for {self.url}\")\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of SandboxClient.</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of SandboxClient.\"\"\"\n    return (\n        f\"SandboxClient(url='{self.url}', \"\n        f\"protocol='{self.protocol.value if hasattr(self.protocol, 'value') else self.protocol}', \"\n        f\"requests={len(self.requests)})\"\n    )\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.clear_requests","title":"<code>clear_requests()</code>","text":"<p>Clear all queued requests.</p> <p>Useful when you want to start fresh without creating a new client instance.</p> RETURNS DESCRIPTION <code>SandboxClient</code> <p>Self for method chaining</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def clear_requests(self) -&gt; \"SandboxClient\":\n    \"\"\"\n    Clear all queued requests.\n\n    Useful when you want to start fresh without creating a new client instance.\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    count = len(self.requests)\n    self.requests.clear()\n    log.info(f\"Cleared {count} queued request(s)\")\n\n    return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.get_request_data","title":"<code>get_request_data(format='dict')</code>","text":"<p>Get transformed request data for inspection.</p> <p>Allows access to serialized request data for debugging or custom processing. For direct access to Pydantic models, use the <code>requests</code> attribute:     &gt;&gt;&gt; for request in client.requests:     &gt;&gt;&gt;     print(request.model_dump())</p> PARAMETER DESCRIPTION <code>format</code> <p>Return format - \"dict\" for list of dictionaries,    \"json\" for JSON string</p> <p> TYPE: <code>Literal['dict', 'json']</code> DEFAULT: <code>'dict'</code> </p> RETURNS DESCRIPTION <code>Union[List[Dict], str]</code> <p>Request data in specified format</p> RAISES DESCRIPTION <code>ValueError</code> <p>If format is not \"dict\" or \"json\"</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client.load_from_path(\"data.xml\")\n&gt;&gt;&gt; # Access raw Pydantic models directly\n&gt;&gt;&gt; for request in client.requests:\n&gt;&gt;&gt;     print(request.model_dump(exclude_none=True))\n&gt;&gt;&gt; # Get as dictionaries\n&gt;&gt;&gt; dicts = client.get_request_data(\"dict\")\n&gt;&gt;&gt; # Get as JSON string\n&gt;&gt;&gt; json_str = client.get_request_data(\"json\")\n&gt;&gt;&gt; print(json_str)\n</code></pre> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def get_request_data(\n    self, format: Literal[\"dict\", \"json\"] = \"dict\"\n) -&gt; Union[List[Dict], str]:\n    \"\"\"\n    Get transformed request data for inspection.\n\n    Allows access to serialized request data for debugging or custom processing.\n    For direct access to Pydantic models, use the `requests` attribute:\n        &gt;&gt;&gt; for request in client.requests:\n        &gt;&gt;&gt;     print(request.model_dump())\n\n    Args:\n        format: Return format - \"dict\" for list of dictionaries,\n               \"json\" for JSON string\n\n    Returns:\n        Request data in specified format\n\n    Raises:\n        ValueError: If format is not \"dict\" or \"json\"\n\n    Examples:\n        &gt;&gt;&gt; client.load_from_path(\"data.xml\")\n        &gt;&gt;&gt; # Access raw Pydantic models directly\n        &gt;&gt;&gt; for request in client.requests:\n        &gt;&gt;&gt;     print(request.model_dump(exclude_none=True))\n        &gt;&gt;&gt; # Get as dictionaries\n        &gt;&gt;&gt; dicts = client.get_request_data(\"dict\")\n        &gt;&gt;&gt; # Get as JSON string\n        &gt;&gt;&gt; json_str = client.get_request_data(\"json\")\n        &gt;&gt;&gt; print(json_str)\n    \"\"\"\n    if format == \"dict\":\n        result = []\n        for req in self.requests:\n            if hasattr(req, \"model_dump\"):\n                result.append(req.model_dump(exclude_none=True))\n            elif hasattr(req, \"model_dump_xml\"):\n                result.append({\"document\": req.model_dump_xml()})\n            else:\n                result.append(req)\n        return result\n    elif format == \"json\":\n        return json.dumps(self.get_request_data(\"dict\"), indent=2)\n    else:\n        raise ValueError(\n            f\"Invalid format '{format}'. Must be 'dict' or 'json'. \"\n            f\"For raw Pydantic models, access the 'requests' attribute directly.\"\n        )\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.get_status","title":"<code>get_status()</code>","text":"<p>Get current client status and statistics.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary containing client status information</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def get_status(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get current client status and statistics.\n\n    Returns:\n        Dictionary containing client status information\n    \"\"\"\n    return {\n        \"sandbox_id\": str(self.sandbox_id),\n        \"url\": str(self.url),\n        \"protocol\": self.protocol.value\n        if hasattr(self.protocol, \"value\")\n        else str(self.protocol),\n        \"workflow\": self.workflow.value if self.workflow else None,\n        \"requests_queued\": len(self.requests),\n        \"responses_received\": len(self.responses),\n    }\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.load_free_text","title":"<code>load_free_text(csv_path, column_name, generate_synthetic=True, random_seed=None, **kwargs)</code>","text":"<p>Load free-text notes from a CSV column and create FHIR DocumentReferences for CDS prefetch. Optionally include synthetic FHIR resources based on the current workflow.</p> PARAMETER DESCRIPTION <code>csv_path</code> <p>Path to the CSV file</p> <p> TYPE: <code>str</code> </p> <code>column_name</code> <p>Name of the text column</p> <p> TYPE: <code>str</code> </p> <code>generate_synthetic</code> <p>Whether to add synthetic FHIR resources (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>random_seed</code> <p>Seed for reproducible results</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Extra parameters for data generation</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>SandboxClient</code> <p>self</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the CSV file does not exist</p> <code>ValueError</code> <p>If the column is not found</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def load_free_text(\n    self,\n    csv_path: str,\n    column_name: str,\n    generate_synthetic: bool = True,\n    random_seed: Optional[int] = None,\n    **kwargs: Any,\n) -&gt; \"SandboxClient\":\n    \"\"\"\n    Load free-text notes from a CSV column and create FHIR DocumentReferences for CDS prefetch.\n    Optionally include synthetic FHIR resources based on the current workflow.\n\n    Args:\n        csv_path: Path to the CSV file\n        column_name: Name of the text column\n        generate_synthetic: Whether to add synthetic FHIR resources (default: True)\n        random_seed: Seed for reproducible results\n        **kwargs: Extra parameters for data generation\n\n    Returns:\n        self\n\n    Raises:\n        FileNotFoundError: If the CSV file does not exist\n        ValueError: If the column is not found\n    \"\"\"\n    from .generators import CdsDataGenerator\n\n    generator = CdsDataGenerator()\n    generator.set_workflow(self.workflow)\n\n    prefetch_data = generator.generate_prefetch(\n        random_seed=random_seed,\n        free_text_path=csv_path,\n        column_name=column_name,\n        generate_resources=generate_synthetic,\n        **kwargs,\n    )\n\n    self._construct_request(prefetch_data)\n\n    if generate_synthetic:\n        log.info(\n            f\"Generated {len(self.requests)} requests from free text with synthetic resources for workflow {self.workflow.value}\"\n        )\n    else:\n        log.info(\n            f\"Generated {len(self.requests)} requests from free text only (no synthetic resources)\"\n        )\n\n    return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.load_from_path","title":"<code>load_from_path(path, pattern=None)</code>","text":"<p>Load data from a file or directory.</p> <p>Supports single files or all matching files in a directory (with optional glob pattern). For .xml (SOAP protocol) loads CDA; for .json (REST protocol) loads Prefetch.</p> PARAMETER DESCRIPTION <code>path</code> <p>File or directory path.</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>pattern</code> <p>Glob pattern for files in directory (e.g., \"*.xml\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>SandboxClient</code> <p>Self.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If path does not exist.</p> <code>ValueError</code> <p>If no matching files are found or if path is not file/dir.</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def load_from_path(\n    self,\n    path: Union[str, Path],\n    pattern: Optional[str] = None,\n) -&gt; \"SandboxClient\":\n    \"\"\"\n    Load data from a file or directory.\n\n    Supports single files or all matching files in a directory (with optional glob pattern).\n    For .xml (SOAP protocol) loads CDA; for .json (REST protocol) loads Prefetch.\n\n    Args:\n        path: File or directory path.\n        pattern: Glob pattern for files in directory (e.g., \"*.xml\").\n\n    Returns:\n        Self.\n\n    Raises:\n        FileNotFoundError: If path does not exist.\n        ValueError: If no matching files are found or if path is not file/dir.\n    \"\"\"\n\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"Path not found: {path}\")\n\n    # Collect files to process\n    files_to_load = []\n    if path.is_file():\n        files_to_load = [path]\n    elif path.is_dir():\n        pattern = pattern or \"*\"\n        files_to_load = list(path.glob(pattern))\n        if not files_to_load:\n            raise ValueError(\n                f\"No files found matching pattern '{pattern}' in {path}\"\n            )\n    else:\n        raise ValueError(f\"Path must be a file or directory: {path}\")\n\n    log.info(f\"Loading {len(files_to_load)} file(s) from {path}\")\n\n    # Process each file\n    for file_path in files_to_load:\n        # Determine file type from extension\n        extension = file_path.suffix.lower()\n\n        if extension == \".xml\":\n            with open(file_path, \"r\") as f:\n                xml_content = f.read()\n            self._construct_request(xml_content)\n            log.info(f\"Loaded CDA document from {file_path.name}\")\n\n        elif extension == \".json\":\n            with open(file_path, \"r\") as f:\n                json_data = json.load(f)\n\n            try:\n                self._construct_request(json_data)\n                log.info(f\"Loaded prefetch data from {file_path.name}\")\n\n            except Exception as e:\n                log.error(f\"Failed to parse {file_path} as prefetch data: {e}\")\n                raise ValueError(\n                    f\"File {file_path} is not valid prefetch format. \"\n                    f\"Expected JSON with FHIR resources. \"\n                    f\"Error: {e}\"\n                )\n        else:\n            log.warning(f\"Skipping unsupported file type: {file_path}\")\n\n    log.info(\n        f\"Loaded {len(self.requests)} requests from {len(files_to_load)} file(s)\"\n    )\n    return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.load_from_registry","title":"<code>load_from_registry(source, data_dir, **kwargs)</code>","text":"<p>Load data from the dataset registry.</p> <p>Loads pre-configured datasets like MIMIC-on-FHIR, Synthea, or custom registered datasets.</p> PARAMETER DESCRIPTION <code>source</code> <p>Dataset name (e.g., \"mimic-on-fhir\", \"synthea\")</p> <p> TYPE: <code>str</code> </p> <code>data_dir</code> <p>Path to the dataset directory</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Dataset-specific parameters (e.g., resource_types, sample_size)</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>SandboxClient</code> <p>Self for method chaining</p> RAISES DESCRIPTION <code>ValueError</code> <p>If dataset not found in registry</p> <code>FileNotFoundError</code> <p>If data_dir doesn't exist</p> <p>Examples:</p> <p>Load MIMIC dataset:</p> <pre><code>&gt;&gt;&gt; client = SandboxClient(\n...     url=\"http://localhost:8000/cds/patient-view\",\n...     workflow=\"patient-view\",\n... )\n&gt;&gt;&gt; client.load_from_registry(\n...     \"mimic-on-fhir\",\n...     data_dir=\"./data/mimic-fhir\",\n...     resource_types=[\"MimicMedication\"],\n...     sample_size=10\n... )\n</code></pre> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def load_from_registry(\n    self,\n    source: str,\n    data_dir: str,\n    **kwargs: Any,\n) -&gt; \"SandboxClient\":\n    \"\"\"\n    Load data from the dataset registry.\n\n    Loads pre-configured datasets like MIMIC-on-FHIR, Synthea, or custom\n    registered datasets.\n\n    Args:\n        source: Dataset name (e.g., \"mimic-on-fhir\", \"synthea\")\n        data_dir: Path to the dataset directory\n        **kwargs: Dataset-specific parameters (e.g., resource_types, sample_size)\n\n    Returns:\n        Self for method chaining\n\n    Raises:\n        ValueError: If dataset not found in registry\n        FileNotFoundError: If data_dir doesn't exist\n\n    Examples:\n        Load MIMIC dataset:\n        &gt;&gt;&gt; client = SandboxClient(\n        ...     url=\"http://localhost:8000/cds/patient-view\",\n        ...     workflow=\"patient-view\",\n        ... )\n        &gt;&gt;&gt; client.load_from_registry(\n        ...     \"mimic-on-fhir\",\n        ...     data_dir=\"./data/mimic-fhir\",\n        ...     resource_types=[\"MimicMedication\"],\n        ...     sample_size=10\n        ... )\n    \"\"\"\n    from healthchain.sandbox.datasets import DatasetRegistry\n\n    log.info(f\"Loading dataset from registry: {source}\")\n    try:\n        loaded_data = DatasetRegistry.load(source, data_dir=data_dir, **kwargs)\n        self._construct_request(loaded_data)\n        log.info(f\"Loaded {source} dataset with {len(self.requests)} requests\")\n    except KeyError:\n        raise ValueError(\n            f\"Unknown dataset: {source}. \"\n            f\"Available datasets: {DatasetRegistry.list_datasets()}\"\n        )\n    return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.preview_requests","title":"<code>preview_requests(limit=None)</code>","text":"<p>Get preview of queued requests without sending them.</p> <p>Provides a summary view of what requests are queued, useful for debugging and verifying data was loaded correctly before sending.</p> PARAMETER DESCRIPTION <code>limit</code> <p>Maximum number of requests to preview. If None, preview all.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List of request summary dictionaries containing metadata</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def preview_requests(self, limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get preview of queued requests without sending them.\n\n    Provides a summary view of what requests are queued, useful for debugging\n    and verifying data was loaded correctly before sending.\n\n    Args:\n        limit: Maximum number of requests to preview. If None, preview all.\n\n    Returns:\n        List of request summary dictionaries containing metadata\n    \"\"\"\n    requests = self.requests[:limit] if limit else self.requests\n    previews = []\n\n    for idx, req in enumerate(requests):\n        preview = {\n            \"index\": idx,\n            \"type\": req.__class__.__name__,\n            \"protocol\": self.protocol.value\n            if hasattr(self.protocol, \"value\")\n            else str(self.protocol),\n        }\n\n        # Add protocol-specific info\n        if self.protocol == ApiProtocol.rest and hasattr(req, \"hook\"):\n            preview[\"hook\"] = req.hook\n            preview[\"hookInstance\"] = getattr(req, \"hookInstance\", None)\n        elif self.protocol == ApiProtocol.soap:\n            preview[\"has_document\"] = hasattr(req, \"document\")\n\n        previews.append(preview)\n\n    return previews\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.save_results","title":"<code>save_results(directory='./output/', save_request=True, save_response=True)</code>","text":"<p>Save request and/or response data to disk.</p> PARAMETER DESCRIPTION <code>directory</code> <p>Directory to save data to (default: \"./output/\")</p> <p> TYPE: <code>Union[str, Path]</code> DEFAULT: <code>'./output/'</code> </p> <code>save_request</code> <p>Whether to save request data (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>save_response</code> <p>Whether to save response data (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def save_results(\n    self,\n    directory: Union[str, Path] = \"./output/\",\n    save_request: bool = True,\n    save_response: bool = True,\n) -&gt; None:\n    \"\"\"\n    Save request and/or response data to disk.\n\n    Args:\n        directory: Directory to save data to (default: \"./output/\")\n        save_request: Whether to save request data (default: True)\n        save_response: Whether to save response data (default: True)\n    \"\"\"\n    if not self.responses and save_response:\n        raise RuntimeError(\n            \"No responses to save. Send requests first using send_requests()\"\n        )\n\n    save_dir = Path(directory)\n    extension = \"xml\" if self.protocol == ApiProtocol.soap else \"json\"\n\n    if save_request:\n        request_path = ensure_directory_exists(save_dir / \"requests\")\n        if self.protocol == ApiProtocol.soap:\n            request_data = [request.model_dump_xml() for request in self.requests]\n        else:\n            request_data = [\n                request.model_dump(mode=\"json\", exclude_none=True)\n                for request in self.requests\n            ]\n        save_data_to_directory(\n            request_data,\n            \"request\",\n            self.sandbox_id,\n            request_path,\n            extension,\n        )\n        log.info(f\"Saved request data at {request_path}/\")\n\n    if save_response:\n        response_path = ensure_directory_exists(save_dir / \"responses\")\n        save_data_to_directory(\n            self.responses,\n            \"response\",\n            self.sandbox_id,\n            response_path,\n            extension,\n        )\n        log.info(f\"Saved response data at {response_path}/\")\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.sandboxclient.SandboxClient.send_requests","title":"<code>send_requests()</code>","text":"<p>Send all queued requests to the service.</p> RETURNS DESCRIPTION <code>List[Dict]</code> <p>List of response dictionaries</p> Source code in <code>healthchain/sandbox/sandboxclient.py</code> <pre><code>def send_requests(self) -&gt; List[Dict]:\n    \"\"\"\n    Send all queued requests to the service.\n\n    Returns:\n        List of response dictionaries\n    \"\"\"\n    if not self.requests:\n        raise RuntimeError(\n            \"No requests to send. Load data first using load_from_registry(), load_from_path(), or load_free_text()\"\n        )\n\n    log.info(f\"Sending {len(self.requests)} requests to {self.url}\")\n\n    with httpx.Client(follow_redirects=True) as client:\n        responses: List[Dict] = []\n        timeout = httpx.Timeout(self.timeout, read=None)\n\n        for request in self.requests:\n            try:\n                if self.protocol == ApiProtocol.soap:\n                    headers = {\"Content-Type\": \"text/xml; charset=utf-8\"}\n                    response = client.post(\n                        url=str(self.url),\n                        data=request.document,\n                        headers=headers,\n                        timeout=timeout,\n                    )\n                    response.raise_for_status()\n                    response_model = CdaResponse(document=response.text)\n                    responses.append(response_model.model_dump_xml())\n                else:\n                    # REST/CDS Hooks\n                    log.debug(f\"Making POST request to: {self.url}\")\n                    response = client.post(\n                        url=str(self.url),\n                        json=request.model_dump(exclude_none=True, mode=\"json\"),\n                        timeout=timeout,\n                    )\n                    response.raise_for_status()\n\n                    try:\n                        response_data = response.json()\n                        cds_response = CDSResponse(**response_data)\n                        responses.append(\n                            cds_response.model_dump(mode=\"json\", exclude_none=True)\n                        )\n                    except json.JSONDecodeError:\n                        log.error(\n                            f\"Invalid JSON response from {self.url}. \"\n                            f\"Response preview: {response.text[:200]}\"\n                        )\n                        responses.append({})\n                    except Exception:\n                        # Fallback to raw response if CDSResponse parsing fails\n                        responses.append(response_data)\n\n            except httpx.HTTPStatusError as exc:\n                try:\n                    error_content = exc.response.json()\n                except Exception:\n                    error_content = exc.response.text\n                log.error(\n                    f\"Error response {exc.response.status_code} while requesting \"\n                    f\"{exc.request.url!r}: {error_content}\"\n                )\n                responses.append({})\n            except httpx.TimeoutException as exc:\n                log.error(f\"Request to {exc.request.url!r} timed out!\")\n                responses.append({})\n            except httpx.RequestError as exc:\n                log.error(\n                    f\"An error occurred while requesting {exc.request.url!r}.\"\n                )\n                responses.append({})\n\n    self.responses = responses\n    log.info(f\"Received {len(responses)} responses\")\n\n    return responses\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator","title":"<code>CdsDataGenerator</code>","text":"<p>Generates synthetic CDS (Clinical Decision Support) data for specified workflows.</p> <p>Uses registered generators to create FHIR resources (e.g., Patient, Encounter, Condition) according to workflow configuration. Can optionally include free text data from a CSV file as DocumentReference.</p> ATTRIBUTE DESCRIPTION <code>registry</code> <p>Maps generator names to classes.</p> <p> TYPE: <code>dict</code> </p> <code>mappings</code> <p>Maps workflows to required generators.</p> <p> TYPE: <code>dict</code> </p> <code>generated_data</code> <p>Most recently generated resources.</p> <p> TYPE: <code>Dict[str, Resource]</code> </p> <code>workflow</code> <p>Currently active workflow.</p> <p> TYPE: <code>str</code> </p> Example <p>generator = CdsDataGenerator() generator.set_workflow(\"encounter_discharge\") data = generator.generate_prefetch(random_seed=42)</p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>class CdsDataGenerator:\n    \"\"\"\n    Generates synthetic CDS (Clinical Decision Support) data for specified workflows.\n\n    Uses registered generators to create FHIR resources (e.g., Patient, Encounter, Condition) according to workflow configuration.\n    Can optionally include free text data from a CSV file as DocumentReference.\n\n    Attributes:\n        registry (dict): Maps generator names to classes.\n        mappings (dict): Maps workflows to required generators.\n        generated_data (Dict[str, Resource]): Most recently generated resources.\n        workflow (str): Currently active workflow.\n\n    Example:\n        &gt;&gt;&gt; generator = CdsDataGenerator()\n        &gt;&gt;&gt; generator.set_workflow(\"encounter_discharge\")\n        &gt;&gt;&gt; data = generator.generate_prefetch(random_seed=42)\n    \"\"\"\n\n    # TODO: Add ordering and logic so that patient/encounter IDs are passed to subsequent generators\n    # TODO: Some of the resources should be allowed to be multiplied\n\n    default_workflow_mappings = {\n        Workflow.encounter_discharge: [\n            {\"generator\": \"EncounterGenerator\"},\n            {\"generator\": \"ConditionGenerator\"},\n            {\"generator\": \"ProcedureGenerator\"},\n            {\"generator\": \"MedicationRequestGenerator\"},\n        ],\n        Workflow.patient_view: [\n            {\"generator\": \"PatientGenerator\"},\n            {\"generator\": \"EncounterGenerator\"},\n            {\"generator\": \"ConditionGenerator\"},\n        ],\n    }\n\n    def __init__(self):\n        self.registry = generator_registry\n        self.mappings = self.default_workflow_mappings\n        self.generated_data: Dict[str, Resource] = {}\n\n    def fetch_generator(self, generator_name: str) -&gt; Callable:\n        \"\"\"\n        Return the generator class by name from the registry.\n\n        Args:\n            generator_name (str): Name of the data generator.\n\n        Returns:\n            Callable: Generator class, or None if not found.\n\n        Example:\n            &gt;&gt;&gt; gen = CdsDataGenerator().fetch_generator(\"PatientGenerator\")\n        \"\"\"\n        return self.registry.get(generator_name)\n\n    def set_workflow(self, workflow: str) -&gt; None:\n        \"\"\"\n        Set the current workflow name to use for data generation.\n\n        Args:\n            workflow (str): Workflow name.\n        \"\"\"\n        self.workflow = workflow\n\n    def generate_prefetch(\n        self,\n        constraints: Optional[list] = None,\n        free_text_path: Optional[str] = None,\n        column_name: Optional[str] = None,\n        random_seed: Optional[int] = None,\n        generate_resources: bool = True,\n    ) -&gt; Dict[str, Resource]:\n        \"\"\"\n        Generate prefetch FHIR resources and/or DocumentReference.\n\n        Args:\n            constraints (Optional[list]): Constraints for resource generation.\n            free_text_path (Optional[str]): CSV file containing free text.\n            column_name (Optional[str]): CSV column for free text.\n            random_seed (Optional[int]): Random seed.\n            generate_resources (bool): If True, generate synthetic FHIR resources.\n\n        Returns:\n            Dict[str, Resource]: Generated resources keyed by resource type (lowercase), plus \"document\" if a free text entry is used.\n\n        Raises:\n            ValueError: If workflow is not recognized, or column name is missing.\n            FileNotFoundError: If free_text_path does not exist.\n        \"\"\"\n        prefetch = {}\n\n        if generate_resources:\n            if self.workflow not in self.mappings:\n                raise ValueError(f\"Workflow {self.workflow} not found in mappings\")\n\n            for resource in self.mappings[self.workflow]:\n                generator_name = resource[\"generator\"]\n                generator = self.fetch_generator(generator_name)\n                resource = generator.generate(\n                    constraints=constraints, random_seed=random_seed\n                )\n                prefetch[resource.__resource_type__.lower()] = resource\n\n        parsed_free_text = (\n            self.free_text_parser(free_text_path, column_name)\n            if free_text_path\n            else None\n        )\n        if parsed_free_text:\n            prefetch[\"document\"] = create_document_reference(\n                data=random.choice(parsed_free_text),\n                content_type=\"text/plain\",\n                status=\"current\",\n                description=\"Free text created by HealthChain CdsDataGenerator\",\n                attachment_title=\"Free text created by HealthChain CdsDataGenerator\",\n            )\n\n        self.generated_data = prefetch\n\n        return self.generated_data\n\n    def free_text_parser(self, path_to_csv: str, column_name: str) -&gt; List[str]:\n        \"\"\"\n        Read a column of free text from a CSV file.\n\n        Args:\n            path_to_csv (str): Path to CSV file.\n            column_name (str): Column name to extract.\n\n        Returns:\n            List[str]: Extracted text values.\n\n        Raises:\n            FileNotFoundError: If CSV file does not exist.\n            ValueError: If column_name is not provided.\n        \"\"\"\n        text_data = []\n\n        path = Path(path_to_csv)\n        if not path.is_file():\n            raise FileNotFoundError(\n                f\"The file {path_to_csv} does not exist or is not a file.\"\n            )\n\n        try:\n            with path.open(mode=\"r\", newline=\"\") as file:\n                reader = csv.DictReader(file)\n                if column_name is not None:\n                    for row in reader:\n                        text_data.append(row[column_name])\n                else:\n                    raise ValueError(\n                        \"Column name must be provided when header is True.\"\n                    )\n        except Exception as ex:\n            logger.error(f\"An error occurred: {ex}\")\n\n        return text_data\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator.fetch_generator","title":"<code>fetch_generator(generator_name)</code>","text":"<p>Return the generator class by name from the registry.</p> PARAMETER DESCRIPTION <code>generator_name</code> <p>Name of the data generator.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Generator class, or None if not found.</p> <p> TYPE: <code>Callable</code> </p> Example <p>gen = CdsDataGenerator().fetch_generator(\"PatientGenerator\")</p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>def fetch_generator(self, generator_name: str) -&gt; Callable:\n    \"\"\"\n    Return the generator class by name from the registry.\n\n    Args:\n        generator_name (str): Name of the data generator.\n\n    Returns:\n        Callable: Generator class, or None if not found.\n\n    Example:\n        &gt;&gt;&gt; gen = CdsDataGenerator().fetch_generator(\"PatientGenerator\")\n    \"\"\"\n    return self.registry.get(generator_name)\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator.free_text_parser","title":"<code>free_text_parser(path_to_csv, column_name)</code>","text":"<p>Read a column of free text from a CSV file.</p> PARAMETER DESCRIPTION <code>path_to_csv</code> <p>Path to CSV file.</p> <p> TYPE: <code>str</code> </p> <code>column_name</code> <p>Column name to extract.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List[str]: Extracted text values.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If CSV file does not exist.</p> <code>ValueError</code> <p>If column_name is not provided.</p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>def free_text_parser(self, path_to_csv: str, column_name: str) -&gt; List[str]:\n    \"\"\"\n    Read a column of free text from a CSV file.\n\n    Args:\n        path_to_csv (str): Path to CSV file.\n        column_name (str): Column name to extract.\n\n    Returns:\n        List[str]: Extracted text values.\n\n    Raises:\n        FileNotFoundError: If CSV file does not exist.\n        ValueError: If column_name is not provided.\n    \"\"\"\n    text_data = []\n\n    path = Path(path_to_csv)\n    if not path.is_file():\n        raise FileNotFoundError(\n            f\"The file {path_to_csv} does not exist or is not a file.\"\n        )\n\n    try:\n        with path.open(mode=\"r\", newline=\"\") as file:\n            reader = csv.DictReader(file)\n            if column_name is not None:\n                for row in reader:\n                    text_data.append(row[column_name])\n            else:\n                raise ValueError(\n                    \"Column name must be provided when header is True.\"\n                )\n    except Exception as ex:\n        logger.error(f\"An error occurred: {ex}\")\n\n    return text_data\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator.generate_prefetch","title":"<code>generate_prefetch(constraints=None, free_text_path=None, column_name=None, random_seed=None, generate_resources=True)</code>","text":"<p>Generate prefetch FHIR resources and/or DocumentReference.</p> PARAMETER DESCRIPTION <code>constraints</code> <p>Constraints for resource generation.</p> <p> TYPE: <code>Optional[list]</code> DEFAULT: <code>None</code> </p> <code>free_text_path</code> <p>CSV file containing free text.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>column_name</code> <p>CSV column for free text.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>random_seed</code> <p>Random seed.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>generate_resources</code> <p>If True, generate synthetic FHIR resources.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Dict[str, Resource]</code> <p>Dict[str, Resource]: Generated resources keyed by resource type (lowercase), plus \"document\" if a free text entry is used.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If workflow is not recognized, or column name is missing.</p> <code>FileNotFoundError</code> <p>If free_text_path does not exist.</p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>def generate_prefetch(\n    self,\n    constraints: Optional[list] = None,\n    free_text_path: Optional[str] = None,\n    column_name: Optional[str] = None,\n    random_seed: Optional[int] = None,\n    generate_resources: bool = True,\n) -&gt; Dict[str, Resource]:\n    \"\"\"\n    Generate prefetch FHIR resources and/or DocumentReference.\n\n    Args:\n        constraints (Optional[list]): Constraints for resource generation.\n        free_text_path (Optional[str]): CSV file containing free text.\n        column_name (Optional[str]): CSV column for free text.\n        random_seed (Optional[int]): Random seed.\n        generate_resources (bool): If True, generate synthetic FHIR resources.\n\n    Returns:\n        Dict[str, Resource]: Generated resources keyed by resource type (lowercase), plus \"document\" if a free text entry is used.\n\n    Raises:\n        ValueError: If workflow is not recognized, or column name is missing.\n        FileNotFoundError: If free_text_path does not exist.\n    \"\"\"\n    prefetch = {}\n\n    if generate_resources:\n        if self.workflow not in self.mappings:\n            raise ValueError(f\"Workflow {self.workflow} not found in mappings\")\n\n        for resource in self.mappings[self.workflow]:\n            generator_name = resource[\"generator\"]\n            generator = self.fetch_generator(generator_name)\n            resource = generator.generate(\n                constraints=constraints, random_seed=random_seed\n            )\n            prefetch[resource.__resource_type__.lower()] = resource\n\n    parsed_free_text = (\n        self.free_text_parser(free_text_path, column_name)\n        if free_text_path\n        else None\n    )\n    if parsed_free_text:\n        prefetch[\"document\"] = create_document_reference(\n            data=random.choice(parsed_free_text),\n            content_type=\"text/plain\",\n            status=\"current\",\n            description=\"Free text created by HealthChain CdsDataGenerator\",\n            attachment_title=\"Free text created by HealthChain CdsDataGenerator\",\n        )\n\n    self.generated_data = prefetch\n\n    return self.generated_data\n</code></pre>"},{"location":"api/sandbox/#healthchain.sandbox.generators.cdsdatagenerator.CdsDataGenerator.set_workflow","title":"<code>set_workflow(workflow)</code>","text":"<p>Set the current workflow name to use for data generation.</p> PARAMETER DESCRIPTION <code>workflow</code> <p>Workflow name.</p> <p> TYPE: <code>str</code> </p> Source code in <code>healthchain/sandbox/generators/cdsdatagenerator.py</code> <pre><code>def set_workflow(self, workflow: str) -&gt; None:\n    \"\"\"\n    Set the current workflow name to use for data generation.\n\n    Args:\n        workflow (str): Workflow name.\n    \"\"\"\n    self.workflow = workflow\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdsrequest.CDSRequest","title":"<code>CDSRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A model representing the data structure for a CDS service call, triggered by specific hooks within a healthcare application.</p> ATTRIBUTE DESCRIPTION <code>hook</code> <p>The hook that triggered this CDS Service call. For example, 'patient-view'.</p> <p> TYPE: <code>str</code> </p> <code>hookInstance</code> <p>A universally unique identifier for this particular hook call.</p> <p> TYPE: <code>UUID</code> </p> <code>fhirServer</code> <p>The base URL of the CDS Client's FHIR server. This field is required if <code>fhirAuthorization</code> is provided.</p> <p> TYPE: <code>HttpUrl</code> </p> <code>fhirAuthorization</code> <p>Optional authorization details providing a bearer access token for FHIR resources.</p> <p> TYPE: <code>Optional[FhirAuthorization]</code> </p> <code>context</code> <p>Hook-specific contextual data required by the CDS service.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>prefetch</code> <p>Optional FHIR data that was prefetched by the CDS Client.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> </p> <p>Documentation: https://cds-hooks.org/specification/current/#http-request_1</p> Source code in <code>healthchain/models/requests/cdsrequest.py</code> <pre><code>class CDSRequest(BaseModel):\n    \"\"\"\n    A model representing the data structure for a CDS service call, triggered by specific hooks\n    within a healthcare application.\n\n    Attributes:\n        hook (str): The hook that triggered this CDS Service call. For example, 'patient-view'.\n        hookInstance (UUID): A universally unique identifier for this particular hook call.\n        fhirServer (HttpUrl): The base URL of the CDS Client's FHIR server. This field is required if `fhirAuthorization` is provided.\n        fhirAuthorization (Optional[FhirAuthorization]): Optional authorization details providing a bearer access token for FHIR resources.\n        context (Dict[str, Any]): Hook-specific contextual data required by the CDS service.\n        prefetch (Optional[Dict[str, Any]]): Optional FHIR data that was prefetched by the CDS Client.\n\n    Documentation: https://cds-hooks.org/specification/current/#http-request_1\n    \"\"\"\n\n    hook: str\n    hookInstance: str = Field(default_factory=id_generator.generate_random_uuid)\n    context: BaseHookContext\n    fhirServer: Optional[HttpUrl] = None\n    fhirAuthorization: Optional[FHIRAuthorization] = (\n        None  # TODO: note this is required if fhirserver is given\n    )\n    prefetch: Optional[Dict[str, Any]] = None\n    extension: Optional[List[Dict[str, Any]]] = None\n\n    def model_dump(self, **kwargs):\n        \"\"\"\n        Model dump method to convert any nested datetime and byte objects to strings for readability.\n        This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571\n        For proper JSON serialization, should use model_dump_json() instead when issue is resolved.\n        \"\"\"\n\n        def convert_objects(obj):\n            if isinstance(obj, dict):\n                return {k: convert_objects(v) for k, v in obj.items()}\n            elif isinstance(obj, list):\n                return [convert_objects(i) for i in obj]\n            elif isinstance(obj, datetime):\n                return obj.astimezone().isoformat()\n            elif isinstance(obj, bytes):\n                return obj.decode(\"utf-8\")\n            return obj\n\n        dump = super().model_dump(**kwargs)\n        return convert_objects(dump)\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdsrequest.CDSRequest.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Model dump method to convert any nested datetime and byte objects to strings for readability. This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571 For proper JSON serialization, should use model_dump_json() instead when issue is resolved.</p> Source code in <code>healthchain/models/requests/cdsrequest.py</code> <pre><code>def model_dump(self, **kwargs):\n    \"\"\"\n    Model dump method to convert any nested datetime and byte objects to strings for readability.\n    This is also a workaround to this Pydantic V2 issue https://github.com/pydantic/pydantic/issues/9571\n    For proper JSON serialization, should use model_dump_json() instead when issue is resolved.\n    \"\"\"\n\n    def convert_objects(obj):\n        if isinstance(obj, dict):\n            return {k: convert_objects(v) for k, v in obj.items()}\n        elif isinstance(obj, list):\n            return [convert_objects(i) for i in obj]\n        elif isinstance(obj, datetime):\n            return obj.astimezone().isoformat()\n        elif isinstance(obj, bytes):\n            return obj.decode(\"utf-8\")\n        return obj\n\n    dump = super().model_dump(**kwargs)\n    return convert_objects(dump)\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Within a suggestion, all actions are logically AND'd together, such that a user selecting a suggestion selects all of the actions within it. When a suggestion contains multiple actions, the actions SHOULD be processed as per FHIR's rules for processing transactions with the CDS Client's fhirServer as the base url for the inferred full URL of the transaction bundle entries.</p> <p>https://cds-hooks.org/specification/current/#action</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Action(BaseModel):\n    \"\"\"\n    Within a suggestion, all actions are logically AND'd together, such that a user selecting a\n    suggestion selects all of the actions within it. When a suggestion contains multiple actions,\n    the actions SHOULD be processed as per FHIR's rules for processing transactions with the CDS\n    Client's fhirServer as the base url for the inferred full URL of the transaction bundle entries.\n\n    https://cds-hooks.org/specification/current/#action\n    \"\"\"\n\n    type: ActionTypeEnum\n    description: str\n    resource: Optional[Dict] = None\n    resourceId: Optional[str] = None\n\n    @model_validator(mode=\"after\")\n    def validate_action_type(self) -&gt; Self:\n        if self.type in [ActionTypeEnum.create, ActionTypeEnum.update]:\n            assert (\n                self.resource\n            ), f\"'resource' must be provided when type is '{self.type.value}'\"\n        else:\n            assert (\n                self.resourceId\n            ), f\"'resourceId' must be provided when type is '{self.type.value}'\"\n\n        return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.ActionTypeEnum","title":"<code>ActionTypeEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of action being performed</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class ActionTypeEnum(str, Enum):\n    \"\"\"\n    The type of action being performed\n    \"\"\"\n\n    create = \"create\"\n    update = \"update\"\n    delete = \"delete\"\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.CDSResponse","title":"<code>CDSResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the response from a CDS service.</p> <p>This class models the structure of a CDS Hooks response, which includes cards for displaying information or suggestions to the user, and optional system actions that can be executed automatically.</p> ATTRIBUTE DESCRIPTION <code>cards</code> <p>A list of Card objects to be displayed to the end user. Default is an empty list.</p> <p> TYPE: <code>List[Card]</code> </p> <code>systemActions</code> <p>A list of Action objects representing actions that the CDS Client should execute as part of performing the decision support requested. This field is optional.</p> <p> TYPE: <code>Optional[List[Action]]</code> </p> <p>For more information, see: https://cds-hooks.org/specification/current/#cds-service-response</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class CDSResponse(BaseModel):\n    \"\"\"\n    Represents the response from a CDS service.\n\n    This class models the structure of a CDS Hooks response, which includes\n    cards for displaying information or suggestions to the user, and optional\n    system actions that can be executed automatically.\n\n    Attributes:\n        cards (List[Card]): A list of Card objects to be displayed to the end user.\n            Default is an empty list.\n        systemActions (Optional[List[Action]]): A list of Action objects representing\n            actions that the CDS Client should execute as part of performing\n            the decision support requested. This field is optional.\n\n    For more information, see:\n    https://cds-hooks.org/specification/current/#cds-service-response\n    \"\"\"\n\n    cards: List[Card] = []\n    systemActions: Optional[List[Action]] = None\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Card","title":"<code>Card</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Cards can provide a combination of information (for reading), suggested actions (to be applied if a user selects them), and links (to launch an app if the user selects them). The CDS Client decides how to display cards, but this specification recommends displaying suggestions using buttons, and links using underlined text.</p> <p>https://cds-hooks.org/specification/current/#card-attributes</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Card(BaseModel):\n    \"\"\"\n    Cards can provide a combination of information (for reading), suggested actions\n    (to be applied if a user selects them), and links (to launch an app if the user selects them).\n    The CDS Client decides how to display cards, but this specification recommends displaying suggestions\n    using buttons, and links using underlined text.\n\n    https://cds-hooks.org/specification/current/#card-attributes\n    \"\"\"\n\n    summary: str = Field(..., max_length=140)\n    indicator: IndicatorEnum\n    source: Source\n    uuid: Optional[str] = None\n    detail: Optional[str] = None\n    suggestions: Optional[List[Suggestion]] = None\n    selectionBehavior: Optional[SelectionBehaviorEnum] = None\n    overrideReasons: Optional[List[SimpleCoding]] = None\n    links: Optional[List[Link]] = None\n\n    @model_validator(mode=\"after\")\n    def validate_suggestions(self) -&gt; Self:\n        if self.suggestions is not None:\n            assert self.selectionBehavior, f\"'selectionBehavior' must be given if 'suggestions' is present! Choose from {[v for v in SelectionBehaviorEnum.value]}\"\n        return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.IndicatorEnum","title":"<code>IndicatorEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Urgency/importance of what Card conveys. Allowed values, in order of increasing urgency, are: info, warning, critical. The CDS Client MAY use this field to help make UI display decisions such as sort order or coloring.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class IndicatorEnum(str, Enum):\n    \"\"\"\n    Urgency/importance of what Card conveys.\n    Allowed values, in order of increasing urgency, are: info, warning, critical.\n    The CDS Client MAY use this field to help make UI display decisions such as sort order or coloring.\n    \"\"\"\n\n    info = \"info\"\n    warning = \"warning\"\n    critical = \"critical\"\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Link","title":"<code>Link</code>","text":"<p>               Bases: <code>BaseModel</code></p> <ul> <li> <p>CDS Client support for appContext requires additional coordination with the authorization server that is not described or specified in CDS Hooks nor SMART.</p> </li> <li> <p>Autolaunchable is experimental</p> </li> </ul> <p>https://cds-hooks.org/specification/current/#link</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Link(BaseModel):\n    \"\"\"\n    * CDS Client support for appContext requires additional coordination with the authorization\n    server that is not described or specified in CDS Hooks nor SMART.\n\n    * Autolaunchable is experimental\n\n    https://cds-hooks.org/specification/current/#link\n    \"\"\"\n\n    label: str\n    url: HttpUrl\n    type: LinkTypeEnum\n    appContext: Optional[str] = None\n    autoLaunchable: Optional[bool]\n\n    @model_validator(mode=\"after\")\n    def validate_link(self) -&gt; Self:\n        if self.appContext:\n            assert (\n                self.type == LinkTypeEnum.smart\n            ), \"'type' must be 'smart' for appContext to be valued.\"\n\n        return self\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.LinkTypeEnum","title":"<code>LinkTypeEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of the given URL. There are two possible values for this field. A type of absolute indicates that the URL is absolute and should be treated as-is. A type of smart indicates that the URL is a SMART app launch URL and the CDS Client should ensure the SMART app launch URL is populated with the appropriate SMART launch parameters.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class LinkTypeEnum(str, Enum):\n    \"\"\"\n    The type of the given URL. There are two possible values for this field.\n    A type of absolute indicates that the URL is absolute and should be treated as-is.\n    A type of smart indicates that the URL is a SMART app launch URL and the CDS Client\n    should ensure the SMART app launch URL is populated with the appropriate SMART\n    launch parameters.\n    \"\"\"\n\n    absolute = \"absolute\"\n    smart = \"smart\"\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.SelectionBehaviorEnum","title":"<code>SelectionBehaviorEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Describes the intended selection behavior of the suggestions in the card. Allowed values are: at-most-one, indicating that the user may choose none or at most one of the suggestions; any, indicating that the end user may choose any number of suggestions including none of them and all of them. CDS Clients that do not understand the value MUST treat the card as an error.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class SelectionBehaviorEnum(str, Enum):\n    \"\"\"\n    Describes the intended selection behavior of the suggestions in the card.\n    Allowed values are: at-most-one, indicating that the user may choose none or\n    at most one of the suggestions; any, indicating that the end user may choose\n    any number of suggestions including none of them and all of them.\n    CDS Clients that do not understand the value MUST treat the card as an error.\n    \"\"\"\n\n    at_most_one = \"at-most-one\"\n    any = \"any\"\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.SimpleCoding","title":"<code>SimpleCoding</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The Coding data type captures the concept of a code. This coding type is a standalone data type in CDS Hooks modeled after a trimmed down version of the FHIR Coding data type.</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class SimpleCoding(BaseModel):\n    \"\"\"\n    The Coding data type captures the concept of a code. This coding type is a standalone data type\n    in CDS Hooks modeled after a trimmed down version of the FHIR Coding data type.\n    \"\"\"\n\n    code: str\n    system: str\n    display: Optional[str] = None\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Source","title":"<code>Source</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Grouping structure for the Source of the information displayed on this card. The source should be the primary source of guidance for the decision support Card represents.</p> <p>https://cds-hooks.org/specification/current/#source</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Source(BaseModel):\n    \"\"\"\n    Grouping structure for the Source of the information displayed on this card.\n    The source should be the primary source of guidance for the decision support Card represents.\n\n    https://cds-hooks.org/specification/current/#source\n    \"\"\"\n\n    label: str\n    url: Optional[HttpUrl] = None\n    icon: Optional[HttpUrl] = None\n    topic: Optional[SimpleCoding] = None\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdsresponse.Suggestion","title":"<code>Suggestion</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Allows a service to suggest a set of changes in the context of the current activity (e.g. changing the dose of a medication currently being prescribed, for the order-sign activity). If suggestions are present, selectionBehavior MUST also be provided.</p> <p>https://cds-hooks.org/specification/current/#suggestion</p> Source code in <code>healthchain/models/responses/cdsresponse.py</code> <pre><code>class Suggestion(BaseModel):\n    \"\"\"\n    Allows a service to suggest a set of changes in the context of the current activity\n    (e.g. changing the dose of a medication currently being prescribed, for the order-sign activity).\n    If suggestions are present, selectionBehavior MUST also be provided.\n\n    https://cds-hooks.org/specification/current/#suggestion\n    \"\"\"\n\n    label: str\n    uuid: Optional[str] = None\n    isRecommended: Optional[bool]\n    actions: Optional[List[Action]] = []\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdarequest.CdaRequest","title":"<code>CdaRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>class CdaRequest(BaseModel):\n    document: str\n    session_id: Optional[str] = None\n    work_type: Optional[str] = None\n    organization_id: Optional[str] = None\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Loads data from dict (xmltodict format)\n        \"\"\"\n        return cls(document=xmltodict.unparse(data))\n\n    def model_dump(self, *args, **kwargs) -&gt; Dict:\n        \"\"\"\n        Dumps document as dict with xmltodict\n        \"\"\"\n        return xmltodict.parse(self.document)\n\n    def model_dump_xml(self, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Decodes and dumps document as an xml string\n        \"\"\"\n        xml_dict = xmltodict.parse(self.document)\n        document = search_key(xml_dict, \"urn:Document\")\n        if document is None:\n            log.warning(\"Couldn't find document under namespace 'urn:Document\")\n            return \"\"\n\n        cda = base64.b64decode(document).decode(\"UTF-8\")\n\n        return cda\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdarequest.CdaRequest.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Loads data from dict (xmltodict format)</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Loads data from dict (xmltodict format)\n    \"\"\"\n    return cls(document=xmltodict.unparse(data))\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdarequest.CdaRequest.model_dump","title":"<code>model_dump(*args, **kwargs)</code>","text":"<p>Dumps document as dict with xmltodict</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; Dict:\n    \"\"\"\n    Dumps document as dict with xmltodict\n    \"\"\"\n    return xmltodict.parse(self.document)\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.requests.cdarequest.CdaRequest.model_dump_xml","title":"<code>model_dump_xml(*args, **kwargs)</code>","text":"<p>Decodes and dumps document as an xml string</p> Source code in <code>healthchain/models/requests/cdarequest.py</code> <pre><code>def model_dump_xml(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Decodes and dumps document as an xml string\n    \"\"\"\n    xml_dict = xmltodict.parse(self.document)\n    document = search_key(xml_dict, \"urn:Document\")\n    if document is None:\n        log.warning(\"Couldn't find document under namespace 'urn:Document\")\n        return \"\"\n\n    cda = base64.b64decode(document).decode(\"UTF-8\")\n\n    return cda\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdaresponse.CdaResponse","title":"<code>CdaResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>class CdaResponse(BaseModel):\n    document: str\n    error: Optional[str] = None\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Loads data from dict (xmltodict format)\n        \"\"\"\n        return cls(document=xmltodict.unparse(data))\n\n    def model_dump(self, *args, **kwargs) -&gt; Dict:\n        \"\"\"\n        Dumps document as dict with xmltodict\n        \"\"\"\n        return xmltodict.parse(self.document)\n\n    def model_dump_xml(self, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Decodes and dumps document as an xml string\n        \"\"\"\n        xml_dict = xmltodict.parse(self.document)\n        document = search_key(xml_dict, \"tns:Document\")\n        if document is None:\n            log.warning(\"Couldn't find document under namespace 'tns:Document\")\n            return \"\"\n\n        cda = base64.b64decode(document).decode(\"UTF-8\")\n\n        return cda\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdaresponse.CdaResponse.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Loads data from dict (xmltodict format)</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Loads data from dict (xmltodict format)\n    \"\"\"\n    return cls(document=xmltodict.unparse(data))\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdaresponse.CdaResponse.model_dump","title":"<code>model_dump(*args, **kwargs)</code>","text":"<p>Dumps document as dict with xmltodict</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; Dict:\n    \"\"\"\n    Dumps document as dict with xmltodict\n    \"\"\"\n    return xmltodict.parse(self.document)\n</code></pre>"},{"location":"api/sandbox/#healthchain.models.responses.cdaresponse.CdaResponse.model_dump_xml","title":"<code>model_dump_xml(*args, **kwargs)</code>","text":"<p>Decodes and dumps document as an xml string</p> Source code in <code>healthchain/models/responses/cdaresponse.py</code> <pre><code>def model_dump_xml(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Decodes and dumps document as an xml string\n    \"\"\"\n    xml_dict = xmltodict.parse(self.document)\n    document = search_key(xml_dict, \"tns:Document\")\n    if document is None:\n        log.warning(\"Couldn't find document under namespace 'tns:Document\")\n        return \"\"\n\n    cda = base64.b64decode(document).decode(\"UTF-8\")\n\n    return cda\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"community/","title":"Community","text":""},{"location":"community/#get-involved","title":"Get Involved","text":"<ul> <li>Discord: Join our Discord community for questions, discussions, and connecting with other users</li> <li>Office Hours: Weekly office hours every Thursday 4:30pm - 5:30pm GMT (join here)</li> <li>GitHub Discussions: For exploratory ideas and architecture discussions</li> <li>Contributing: See CONTRIBUTING.md for full guidelines</li> </ul>"},{"location":"community/#for-domain-experts-partners","title":"For Domain Experts &amp; Partners","text":"<p>If you have healthcare, FHIR, or security experience, we want your input! See the Contributing section for how to get fast-track review.</p> <p>For partnerships and integrations, email jenniferjiangkells@gmail.com.</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Hands-on, production-ready examples for building healthcare AI applications with HealthChain.</p> Filter: HealthTech GenAI ML Research Gateway Pipeline Interop FHIR CDS Hooks Sandbox Clear \ud83d\udea6 Working with FHIR Sandboxes      Spin up and access free Epic, Medplum, and other FHIR sandboxes for safe experimentation. Recommended first step before the other tutorials.    FHIR Sandbox \ud83d\udd2c Deploy ML Models: Real-Time Alerts &amp; Batch Screening      Deploy the same ML model two ways: CDS Hooks for point-of-care sepsis alerts, and FHIR Gateway for population-level batch screening with RiskAssessment resources.    ML Research Gateway CDS Hooks \ud83d\udd17 Multi-Source Patient Data Aggregation      Merge patient data from multiple FHIR sources (Epic, Cerner, etc.), deduplicate conditions, prove provenance, and handle cross-vendor errors. Foundation for RAG and analytics workflows.    GenAI Gateway FHIR \ud83e\uddfe Automate Clinical Coding &amp; FHIR Integration      Extract medical conditions from clinical documentation using AI, map to SNOMED CT codes, and sync as FHIR Condition resources for billing, analytics, and interoperability.    HealthTech Pipeline Interop \ud83d\udcdd Summarize Discharge Notes with CDS Hooks      Deploy a CDS Hooks-compliant service that listens for discharge events, auto-generates concise plain-language summaries, and delivers actionable clinical cards directly into the EHR workflow.    HealthTech Gateway CDS Hooks \ud83d\udd04 Convert Between Healthcare Data Formats      Convert between CDA, HL7v2, and FHIR formats using the interoperability engine. Handle bidirectional conversion for integrating legacy systems with modern FHIR applications.    HealthTech Interop FHIR    No cookbooks match the selected filters. Clear filters <p>What next?</p> <p>See the source code for each recipe, experiment with the sandboxes, and adapt the patterns for your projects!</p>"},{"location":"cookbook/clinical_coding/","title":"Build a NoteReader Service with FHIR Integration","text":"<p>Modernize Epic NoteReader's legacy SOAP interface by connecting it to a modern FHIR server, without disrupting existing CDI workflows. You'll extract SNOMED CT codes from clinical notes using NLP, write structured data to Medplum for analytics, and return CDA responses to Epic.</p> <p>Epic NoteReader CDI is a legacy CDA interface for clinical documentation improvement workflows. It's great because it's already embedded in existing EHR workflows and designed for third-party NLP integrations. The downside? Its legacy SOAP design limits modern analytics in FHIR. This tutorial shows you how to bridge that gap. Get the best of both worlds! Legacy workflows keep running while you unlock advanced analytics.</p> <p>Check out the full working example here.</p>"},{"location":"cookbook/clinical_coding/#how-it-works","title":"How It Works","text":"<p>A clinical note arrives from NoteReader as CDA XML \u2192 gets parsed and processed through scispacy \u2192 entities are linked to SNOMED CT codes \u2192 converted to FHIR Condition resources \u2192 written to both Medplum (modern FHIR) and back to Epic (legacy CDA).</p>"},{"location":"cookbook/clinical_coding/#setup","title":"Setup","text":""},{"location":"cookbook/clinical_coding/#install-dependencies","title":"Install Dependencies","text":"<p>We'll use scispacy for medical entity extraction. Install the required dependencies:</p> <pre><code>pip install healthchain scispacy python-dotenv\npip install https://s3-us-west-2.amazonaws.com/ai2-s2-scispacy/releases/v0.5.4/en_core_sci_sm-0.5.4.tar.gz\n</code></pre>"},{"location":"cookbook/clinical_coding/#download-sample-data","title":"Download Sample Data","text":"<p>Download the sample CDA file <code>notereader_cda.xml</code> into a <code>data/</code> folder in your project root using <code>wget</code>:</p> <pre><code>mkdir -p data\ncd data\nwget https://github.com/dotimplement/HealthChain/raw/main/cookbook/data/notereader_cda.xml\n</code></pre>"},{"location":"cookbook/clinical_coding/#configure-medplum-credentials","title":"Configure Medplum Credentials","text":"<p>Set up a Medplum account and obtain client credentials. See the FHIR Sandbox Setup Guide for detailed instructions.</p> <p>Once you have your Medplum credentials, configure them in a <code>.env</code> file:</p> <pre><code># .env file\nMEDPLUM_BASE_URL=https://api.medplum.com/fhir/R4\nMEDPLUM_CLIENT_ID=your_client_id\nMEDPLUM_CLIENT_SECRET=your_client_secret\nMEDPLUM_TOKEN_URL=https://api.medplum.com/oauth2/token\nMEDPLUM_SCOPE=openid\n</code></pre>"},{"location":"cookbook/clinical_coding/#add-the-cda-adapter","title":"Add the CDA Adapter","text":"<p>First we'll need to convert the incoming CDA XML to FHIR. The CdaAdapter enables round-trip conversion between CDA and FHIR using the InteropEngine for seamless legacy-to-modern data integration.</p> <pre><code>from healthchain.io import CdaAdapter\nfrom healthchain.engine import create_interop\n\n# Create an interop engine with default configuration\ninterop_engine = create_interop()\ncda_adapter = CdaAdapter(engine=interop_engine)\n\n# Parse the CDA document to a Document object\ndoc = cda_adapter.parse(request)\n\n# Access list of Condition resources in problem_list accessor\ndoc.fhir.problem_list\n\n# Format the Document object back to a CDA document\nresponse = cda_adapter.format(doc)\n</code></pre> <p>What this adapter does</p> <ul> <li>Parses CDA XML documents and extracts clinical text and coded data</li> <li>Stores text data in <code>doc.text</code></li> <li>Stores CDA XML as a DocumentReference resource in <code>doc.fhir.bundle</code></li> <li>Stores extracted Condition resources in <code>doc.fhir.problem_list</code></li> </ul>"},{"location":"cookbook/clinical_coding/#initialize-the-pipeline","title":"Initialize the Pipeline","text":"<p>Next we'll build our NLP processing pipeline. We'll use a MedicalCodingPipeline, which will run your specified NLP model on extracted text data out-of-the-box. To link extracted entities (e.g., \"chronic kidney disease\", \"asthma\") to standard clinical codes (e.g. SNOMED CT, ICD-10), we'll add a custom node to handle this.</p> <p>For this demo, we'll use a simple dictionary for the SNOMED CT mapping.</p> <pre><code>from healthchain.pipeline.medicalcodingpipeline import MedicalCodingPipeline\nfrom healthchain.io import Document\nfrom spacy.tokens import Span\n\n# Build FHIR-native ML pipeline with automatic problem extraction.\npipeline = MedicalCodingPipeline.from_model_id(\"en_core_sci_sm\", source=\"spacy\")\n\n# Add custom entity linking\n@pipeline.add_node(position=\"after\", reference=\"SpacyNLP\")\ndef link_entities(doc: Document) -&gt; Document:\n    \"\"\"\n    Add CUI codes to medical entities for problem extraction.\n    \"\"\"\n    if not Span.has_extension(\"cui\"):\n        Span.set_extension(\"cui\", default=None)\n\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    # Dummy medical concept mapping to SNOMED CT codes\n    medical_concepts = {\n        \"pneumonia\": \"233604007\",\n        \"type 2 diabetes mellitus\": \"44054006\",\n        \"congestive heart failure\": \"42343007\",\n        \"chronic kidney disease\": \"431855005\",\n        \"hypertension\": \"38341003\",\n        # Add more mappings as needed\n    }\n\n    for ent in spacy_doc.ents:\n        if ent.text.lower() in medical_concepts:\n            # Store as custom spacy attribute 'cui'\n            ent._.cui = medical_concepts[ent.text.lower()]\n\n    return doc\n</code></pre> <p>Note</p> <p>MedicalCodingPipeline automatically:</p> <ul> <li>Extracts medical entities using the <code>scispacy</code> model</li> <li>Converts NLP entities to FHIR <code>problem-list-item</code> Condition resources</li> </ul> <p>This is equivalent to constructing a pipeline with the following components manually:</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import SpacyNLP, FHIRProblemListExtractor\nfrom healthchain.io import Document\n\npipeline = Pipeline[Document]()\n\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_sci_sm\"))\npipeline.add_node(FHIRProblemListExtractor())\n</code></pre>"},{"location":"cookbook/clinical_coding/#set-up-fhir-gateway","title":"Set up FHIR Gateway","text":"<p>FHIR Gateways enable your app to connect to one or more external FHIR servers (like EHRs, registries, billing systems).</p> <p>Use <code>.add_source</code> to register a FHIR endpoint you want to connect to with its connection string; the gateway will automatically manage the authentication and routing.</p> <pre><code>from healthchain.gateway import FHIRGateway\nfrom healthchain.gateway.clients.fhir.base import FHIRAuthConfig\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Load configuration from environment variables\nconfig = FHIRAuthConfig.from_env(\"MEDPLUM\")\nMEDPLUM_URL = config.to_connection_string()\n\n# Initialize FHIR gateway and register external systems\nfhir_gateway = FHIRGateway()\nfhir_gateway.add_source(\"medplum\", MEDPLUM_URL)\n\n# You can add multiple FHIR sources:\n# fhir_gateway.add_source(\"ehr\", \"fhir://epic.example.com/fhir/R4/\")\n# fhir_gateway.add_source(\"registry\", \"fhir://registry.example.com/fhir/R4/\")\n</code></pre>"},{"location":"cookbook/clinical_coding/#set-up-the-notereader-service","title":"Set Up the NoteReader Service","text":"<p>Now let's set up the handler for NoteReaderService method <code>ProcessDocument</code>, which will be called by Epic NoteReader when it is triggered in the CDI workflow. This is where we will combine all our components: adapter, pipeline, and writing to our configured FHIR endpoint:</p> <pre><code>from healthchain.gateway import NoteReaderService\n\n# Create the NoteReader service\nnote_service = NoteReaderService()\n\n@note_service.method(\"ProcessDocument\")\ndef ai_coding_workflow(request: CdaRequest):\n    # Parse CDA document from legacy system\n    doc = cda_adapter.parse(request)\n\n    # Process through ML pipeline to extract medical entities\n    doc = pipeline(doc)\n\n    # Access the extracted FHIR resources\n    for condition in doc.fhir.problem_list:\n        # Add metadata for audit and provenance tracking\n        condition = add_provenance_metadata(\n            condition, source=\"epic-notereader\", tag_code=\"cdi\"\n        )\n        # Send to external FHIR server via gateway\n        fhir_gateway.create(condition, source=\"billing\")\n\n    # Return processed CDA response to the legacy system\n    cda_response = cda_adapter.format(doc)\n\n    return cda_response\n</code></pre>"},{"location":"cookbook/clinical_coding/#build-the-service","title":"Build the Service","text":"<p>Time to put it all together! Using HealthChainAPI, we can create a service with both the FHIR and NoteReader endpoints:</p> <pre><code>from healthchain.gateway import HealthChainAPI\n\n# Register services with the API gateway\napp = HealthChainAPI(title=\"Healthcare Integration Gateway\")\n\napp.register_gateway(fhir_gateway, path=\"/fhir\")\napp.register_service(note_service, path=\"/notereader\")\n</code></pre>"},{"location":"cookbook/clinical_coding/#test-with-sample-documents","title":"Test with Sample Documents","text":"<p>HealthChain provides a sandbox client utility which simulates the NoteReader workflow end-to-end. It loads your sample CDA document, sends it to your service via the configured endpoint, and saves the request/response exchange in an <code>output/</code> directory. This lets you test the complete integration locally before connecting to Epic.</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create sandbox client for SOAP/CDA testing\nclient = SandboxClient(\n    url=\"http://localhost:8000/notereader/ProcessDocument\",\n    workflow=\"sign-note-inpatient\",\n    protocol=\"soap\"\n)\n\n# Load sample CDA document\nclient.load_from_path(\"./data/notereader_cda.xml\")\n\n# Inspect CDA document before sending\n# for request in client.requests:\n#     print(request.document[:1000])  # View first 1000 chars of CDA XML\n</code></pre>"},{"location":"cookbook/clinical_coding/#run-the-complete-example","title":"Run the Complete Example","text":"<p>Now for the moment of truth! Start your service and run the sandbox to see the complete workflow in action.</p> <pre><code>import uvicorn\nimport threading\n\n# Start the API server in a separate thread\ndef start_api():\n    uvicorn.run(app, port=8000)\n\napi_thread = threading.Thread(target=start_api, daemon=True)\napi_thread.start()\n\n# Send requests and save responses with sandbox client\nclient.send_requests()\nclient.save_results(\"./output/\")\n</code></pre> <p>What happens when you run this</p> <ol> <li> <p>Service starts \u2013 <code>HealthChainAPI</code> launches two endpoints:</p> <ul> <li><code>/notereader/ProcessDocument</code>: SOAP endpoint for processing CDA documents</li> <li><code>/fhir</code>: REST API endpoint for FHIR operations (optional, for testing)</li> </ul> </li> <li> <p>Sandbox runs \u2013 Your test CDA document is:</p> <ul> <li>Wrapped in a SOAP envelope</li> <li>Sent to <code>/notereader/ProcessDocument</code></li> </ul> </li> <li> <p>Artifacts \u2013 Sandbox saves request/response XML files to the <code>output/</code> directory for inspection</p> </li> </ol>"},{"location":"cookbook/clinical_coding/#expected-output","title":"Expected Output","text":"<p>Our sample data contains the following note:</p> Test Note <pre><code>This 37 year old gentleman presented with a fever, cough and sore throat. He was diagnosed with a community acquired pneumonia, and started on co-amoxiclav. Unfortunately he developed anaphylaxis and was treated with resuscitation fluids and adrenaline but not hydrocortisone. He had refractory anaphylaxis and so was transferred to intensive care for intubation and ventilation. He then developed a \"ventilation associated pneumonia\", requiring meropenem. Once treated for his CAP and VAP he was stepped down to the ward. He was treated with haloperidol for a presumed 'delirium'. He improved medically, but deteriorated in terms of his psychiatric health, with depression, anxiety and paranoid schizophrenia. He was self-medicating with his own supply of Librium.\n\nHe has a past medical history of asthma and COPD but not cirrhosis.\n\nHe regularly takes penicillin, Ventolin and tiotropium inhalers, as well as an ACE inhibitor, beta blocker and calcium channel blocker.\n\nHe is allergic to all opiates, including morphine.\n\nHe has previously had a cholecystectomy and appendicectomy.\n\nPlan:\n- Discharge planning\n\nI reviewed the Resident's note and agree with the documented findings and plan of care.  The reason the patient is critically ill and the nature of the treatment and management provided by the teaching physician (me) to manage the critically ill patient is: as aove\n\nThe patient was critically ill during the time that I saw the patient. The Critical Care Time excluding procedures was 6 minutes.\n</code></pre> <p>So you should expect to see the following conditions extracted, which we have linked to SNOMED CT codes in our processing pipeline:</p> Condition SNOMED CT Code pneumonia 233604007 anaphylaxis 39579001 delirium 2776000 depression 35489007 asthma 195967001 COPD 13645005"},{"location":"cookbook/clinical_coding/#medplum-console","title":"Medplum Console","text":"<p>After running the example, go to Medplum to see your extracted conditions in action:</p> <ol> <li>Log in to your Medplum account</li> <li>Search and navigate to Condition resources in the search bar under the Medplum logo. You should see a list of all the Condition data you have in Medplum's FHIR server:</li> </ol> <p></p> <p>You should be able to interact with the resources you've just created in the Medplum web UI. Click on JSON to see the original data:</p> <p></p> <p>Example output: Condition FHIR resource</p> <pre><code>{\n  \"resourceType\": \"Condition\",\n  \"id\": \"e8105940-2714-4274-b693-03a09a76eeb8\",\n  \"meta\": {\n    \"lastUpdated\": \"2025-10-13T16:36:40.435Z\",\n    \"source\": \"urn:healthchain:source:epic-notereader\",\n    \"tag\": [\n      {\n        \"system\": \"https://dotimplement.github.io/HealthChain/fhir/tags\",\n        \"code\": \"cdi\",\n        \"display\": \"cdi\"\n      }\n    ],\n    \"versionId\": \"fd21c838-1fe6-45c9-84d7-00184338b8ee\",\n    \"author\": {\n      \"reference\": \"ClientApplication/01977d2b-244e-75ea-af98-0c35157e1a9b\",\n      \"display\": \"HealthChain Test Default Client\"\n    },\n    \"project\": \"01977d2b-243b-7476-b9eb-81a5298febbc\",\n    \"compartment\": [\n      {\n        \"reference\": \"Project/01977d2b-243b-7476-b9eb-81a5298febbc\"\n      }\n    ]\n  },\n  \"clinicalStatus\": {\n    \"coding\": [\n      {\n        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n        \"code\": \"active\",\n        \"display\": \"Active\"\n      }\n    ]\n  },\n  \"category\": [\n    {\n      \"coding\": [\n        {\n          \"system\": \"http://terminology.hl7.org/CodeSystem/condition-category\",\n          \"code\": \"problem-list-item\",\n          \"display\": \"Problem List Item\"\n        }\n      ]\n    }\n  ],\n  \"code\": {\n    \"coding\": [\n      {\n        \"system\": \"http://snomed.info/sct\",\n        \"code\": \"195967001\",\n        \"display\": \"asthma\"\n      }\n    ]\n  },\n  \"subject\": {\n    \"reference\": \"Patient/123\"\n  }\n}\n</code></pre>"},{"location":"cookbook/clinical_coding/#output-directory","title":"<code>/output</code> Directory","text":"<p>Check that the extracted conditions also exist in the CDA response sent back to our simulated Epic backend:</p> response.xml <p><pre><code>&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n    ...\n    &lt;component&gt;\n        &lt;structuredBody&gt;\n            ...\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"233604007\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Pneumonia\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"39579001\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Anaphylaxis\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"2776000\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Delirium\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"35489007\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Depressive disorder\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"195967001\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Asthma\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;act&gt;\n                    ...\n                    &lt;code code=\"13645005\" codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\" displayName=\"Chronic obstructive lung disease\" /&gt;\n                    ...\n                &lt;/act&gt;\n            &lt;/entry&gt;\n            ...\n        &lt;/structuredBody&gt;\n    &lt;/component&gt;\n    ...\n&lt;/ClinicalDocument&gt;\n</code></pre> Lines with only problem/condition <code>code</code> elements are shown within their parent structure; <code>...</code> is used to indicate omitted sections for clarity and brevity.</p> <p>Your extracted diagnoses are now available as structured FHIR resources, ready for analytics, reporting, or downstream processing, while Epic continues receiving the original CDA responses!</p>"},{"location":"cookbook/clinical_coding/#what-youve-built","title":"What You've Built","text":"<p>A clinical coding service that bridges legacy CDA systems with modern FHIR infrastructure:</p> <ul> <li>Legacy system integration - Processes CDA documents from Epic NoteReader workflows</li> <li>AI-powered extraction - Uses NLP to extract medical entities and map to SNOMED CT codes</li> <li>FHIR interoperability - Converts extracted conditions to FHIR resources and syncs with external servers</li> <li>Audit trail - Tracks provenance metadata for compliance and debugging</li> <li>Dual interface - Maintains CDA compatibility while enabling modern FHIR operations</li> </ul> <p>Use Cases</p> <ul> <li> <p>Clinical Documentation Improvement (CDI):   Automatically extract billable conditions from clinical notes and populate problem lists in real-time during clinician workflows.</p> </li> <li> <p>Terminology Harmonization:   Bridge legacy ICD-9 systems with modern SNOMED CT standards by processing historical CDA documents and creating FHIR-compliant problem lists.</p> </li> <li> <p>Research Data Extraction:   Extract structured condition data from unstructured clinical notes for cohort building and retrospective studies.</p> </li> </ul> <p>Next Steps</p> <ul> <li>Enhance entity linking: Replace the dictionary lookup with terminology servers or entity linking models for comprehensive medical terminology coverage.</li> <li>Add validation: Implement FHIR resource validation before sending to external servers.</li> <li>Expand to other workflows: Adapt the pattern for lab results, medications, or radiology reports.</li> <li>Build on it: Use the extracted conditions in the Data Aggregation example to combine with other FHIR sources.</li> </ul>"},{"location":"cookbook/discharge_summarizer/","title":"Build a CDS Hooks Service for Discharge Summarization","text":"<p>This example shows you how to build a CDS service that integrates with EHR systems. We'll automatically summarize discharge notes and return actionable recommendations using the CDS Hooks standard.</p> <p>Check out the full working example here!</p> <p> Illustrative Architecture - actual implementation may vary.</p>"},{"location":"cookbook/discharge_summarizer/#setup","title":"Setup","text":""},{"location":"cookbook/discharge_summarizer/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install healthchain python-dotenv\n</code></pre> <p>This example uses a Hugging Face model for the summarization task, so make sure you have a Hugging Face API token and set it as the <code>HUGGINGFACEHUB_API_TOKEN</code> environment variable.</p> <p>If you are using a chat model, make sure you have the necessary <code>langchain</code> packages installed.</p> <pre><code>pip install langchain langchain-huggingface\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#download-sample-data","title":"Download Sample Data","text":"<p>Download the sample data <code>discharge_notes.csv</code> into a <code>data/</code> folder in your project root using <code>wget</code>:</p> <pre><code>mkdir -p data\ncd data\nwget https://github.com/dotimplement/HealthChain/raw/main/cookbook/data/discharge_notes.csv\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#initialize-the-pipeline","title":"Initialize the pipeline","text":"<p>First, we'll create a summarization pipeline with domain-specific prompting for discharge workflows. You can choose between:</p> <ul> <li>Transformer models fine-tuned for clinical summarization (like <code>google/pegasus-xsum</code>)</li> <li>Large Language Models with custom clinical prompting (like <code>zephyr-7b-beta</code>)</li> </ul> <p>For LLM approaches, we'll use LangChain for better prompting.</p> Non-chat modelChat model <pre><code>from healthchain.pipeline import SummarizationPipeline\n\npipeline = SummarizationPipeline.from_model_id(\n  \"google/pegasus-xsum\", source=\"huggingface\", task=\"summarization\"\n  )\n</code></pre> <pre><code>from healthchain.pipeline import SummarizationPipeline\n\nfrom langchain_huggingface.llms import HuggingFaceEndpoint\nfrom langchain_huggingface import ChatHuggingFace\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\n\nhf = HuggingFaceEndpoint(\n    repo_id=\"deepseek-ai/DeepSeek-R1-0528\",\n    task=\"text-generation\",\n    max_new_tokens=512,\n    do_sample=False,\n    repetition_penalty=1.03,\n)\n\nmodel = ChatHuggingFace(llm=hf)\n\ntemplate = \"\"\"\nYou are a discharge planning assistant for hospital operations.\nProvide a concise, objective summary focusing on actionable items\nfor care coordination, including appointments, medications, and\nfollow-up instructions. Format as bullet points.\\n'''{text}'''\n\"\"\"\nprompt = PromptTemplate.from_template(template)\n\nchain = prompt | model | StrOutputParser()\n\npipeline = SummarizationPipeline.load(chain, source=\"langchain\")\n</code></pre> <p>The <code>SummarizationPipeline</code> automatically:</p> <ul> <li>Parses FHIR resources from CDS Hooks requests</li> <li>Extracts clinical text from discharge documents</li> <li>Formats outputs as CDS cards</li> </ul>"},{"location":"cookbook/discharge_summarizer/#add-the-cds-fhir-adapter","title":"Add the CDS FHIR Adapter","text":"<p>The CdsFhirAdapter converts between CDS Hooks requests and HealthChain's Document format. This makes it easy to work with FHIR data in CDS workflows.</p> <pre><code>from healthchain.io import CdsFhirAdapter\n\ncds_adapter = CdsFhirAdapter()\n\n# Parse the CDS request to a Document object\ncds_adapter.parse(request)\n\n# Format the Document object back to a CDS response\ncds_adapter.format(doc)\n</code></pre> <p>What this adapter does</p> <ul> <li>Parses FHIR resources from CDS Hooks requests</li> <li>Extracts text from DocumentReference resources</li> <li>Formats responses as CDS cards according to the CDS Hooks specification</li> </ul>"},{"location":"cookbook/discharge_summarizer/#set-up-the-cds-hook-handler","title":"Set Up the CDS Hook Handler","text":"<p>Create the CDS Hooks handler to receive discharge note requests, run the AI summarization pipeline, and return results as CDS cards.</p> <pre><code>from healthchain.gateway import CDSHooksService\nfrom healthchain.models import CDSRequest, CDSResponse\n\n# Initialize the CDS service\ncds_service = CDSHooksService()\n\n# Define the CDS service function\n@cds_service.hook(\"encounter-discharge\", id=\"discharge-summary\")\ndef handle_discharge_summary(request: CDSRequest) -&gt; CDSResponse:\n    \"\"\"Process discharge summaries with AI\"\"\"\n    # Parse CDS request to internal Document format\n    doc = cds_adapter.parse(request)\n\n    # Process through AI pipeline\n    processed_doc = pipeline(doc)\n\n    # Format response with CDS cards\n    response = cds_adapter.format(processed_doc)\n    return response\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#build-the-service","title":"Build the Service","text":"<p>Register the CDS service with HealthChainAPI to create REST endpoints:</p> <pre><code>from healthchain.gateway import HealthChainAPI\n\napp = HealthChainAPI(title=\"Discharge Summary CDS Service\")\napp.register_service(cds_service)\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#test-with-sample-data","title":"Test with Sample Data","text":"<p>HealthChain provides a sandbox client utility which simulates the CDS hooks workflow end-to-end. It loads your sample free text data and formats it into CDS requests, sends it to your service, and saves the request/response exchange in an <code>output/</code> directory. This lets you test the complete integration locally and inspect the inputs and outputs before connecting to a real EHR instance.</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create sandbox client for testing\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/discharge-summarizer\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load discharge notes from CSV and generate FHIR data\nclient.load_free_text(\n    csv_path=\"data/discharge_notes.csv\",\n    column_name=\"text\"\n)\n\n# Inspect requests before sending to verify data\n# for request in client.requests:\n#     print(request.prefetch.get('document'))  # Get DocumentReference\n</code></pre> <p>Learn More About Test Data Generation</p> <p>Read more about the test FHIR data generator for CDS hooks here</p>"},{"location":"cookbook/discharge_summarizer/#run-the-complete-example","title":"Run the Complete Example","text":"<p>Put it all together and run both the service and sandbox client:</p> <pre><code>import uvicorn\nimport threading\n\n# Start the API server in a separate thread\ndef start_api():\n    uvicorn.run(app, port=8000)\n\napi_thread = threading.Thread(target=start_api, daemon=True)\napi_thread.start()\n\n# Send requests and save responses with sandbox client\nclient.send_requests()\nclient.save_results(\"./output/\")\n</code></pre> <p>Service Endpoints</p> <p>Once running, your service will be available at:</p> <ul> <li>Service discovery: <code>http://localhost:8000/cds-services</code></li> <li>Discharge summary endpoint: <code>http://localhost:8000/cds-services/discharge-summary</code></li> </ul> Example CDS Response <pre><code>{\n  \"cards\": [\n    {\n      \"summary\": \"Discharge Transportation\",\n      \"indicator\": \"info\",\n      \"source\": {\n        \"label\": \"HealthChain Discharge Assistant\"\n      },\n      \"detail\": \"\u2022 Transport arranged for 11:00 HRs\\n\u2022 Requires bariatric ambulance and 2 crew members\\n\u2022 Confirmation number: TR-2024-001\"\n    },\n    {\n      \"summary\": \"Medication Management\",\n      \"indicator\": \"warning\",\n      \"source\": {\n        \"label\": \"HealthChain Discharge Assistant\"\n      },\n      \"detail\": \"\u2022 Discharge medications: Apixaban 5mg, Baclofen 20mg MR\\n\u2022 New anticoagulation card prepared\\n\u2022 Collection by daughter scheduled\"\n    }\n  ]\n}\n</code></pre>"},{"location":"cookbook/discharge_summarizer/#what-youve-built","title":"What You've Built","text":"<p>A CDS Hooks service for discharge workflows that integrates seamlessly with EHR systems:</p> <ul> <li>Standards-compliant - Implements the CDS Hooks specification for EHR interoperability</li> <li>AI-powered summarization - Processes discharge notes using transformer models or LLMs</li> <li>Actionable recommendations - Returns structured cards with discharge planning tasks</li> <li>Flexible pipeline - Supports both fine-tuned models and prompt-engineered LLMs</li> <li>Auto-discovery - Provides service discovery endpoint for EHR registration</li> </ul> <p>Use Cases</p> <ul> <li> <p>Discharge Planning Coordination   Automatically extract and highlight critical discharge tasks (appointments, medications, equipment needs) to reduce care coordination errors and readmissions.</p> </li> <li> <p>Clinical Decision Support   Provide real-time recommendations during discharge workflows, surfacing potential issues like medication interactions or missing follow-up appointments.</p> </li> <li> <p>Documentation Efficiency   Generate concise discharge summaries from lengthy clinical notes, saving clinicians time while ensuring all critical information is captured.</p> </li> </ul> <p>Next Steps</p> <ul> <li>Enhance prompts: Tune your clinical prompts to extract specific discharge criteria or care plan elements.</li> <li>Add validation: Implement checks for required discharge elements (medications, follow-ups, equipment).</li> <li>Multi-card support: Expand to generate separate cards for different discharge aspects (medication reconciliation, transportation, follow-up scheduling).</li> <li>Integrate with workflows: Deploy to Epic App Orchard or Cerner Code Console for production EHR integration.</li> </ul>"},{"location":"cookbook/format_conversion/","title":"Convert Between Healthcare Data Formats","text":"<p>Convert between CDA, HL7v2, and FHIR formats using HealthChain's interoperability engine. This recipe covers the most common conversion scenarios for integrating legacy healthcare systems with modern FHIR-based applications.</p> <p>The InteropEngine provides a unified interface for bidirectional format conversion, handling the complexity of mapping between different healthcare data standards.</p>"},{"location":"cookbook/format_conversion/#setup","title":"Setup","text":"<p>Install HealthChain:</p> <pre><code>pip install healthchain\n</code></pre> <p>Create an interoperability engine:</p> <pre><code>from healthchain.interop import create_interop, FormatType\nfrom pathlib import Path\nimport json\n\nengine = create_interop()\n</code></pre>"},{"location":"cookbook/format_conversion/#converting-cda-to-fhir","title":"Converting CDA to FHIR","text":"<p>Parse a CDA document and extract FHIR resources:</p> <pre><code>cda_xml = \"\"\"\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;templateId root=\"2.16.840.1.113883.10.20.22.1.2\"/&gt;\n  &lt;id root=\"2.16.840.1.113883.19.5.99999.1\"/&gt;\n  &lt;code code=\"34133-9\" displayName=\"Summarization of Episode Note\"\n        codeSystem=\"2.16.840.1.113883.6.1\" codeSystemName=\"LOINC\"/&gt;\n  &lt;title&gt;Example CDA Document&lt;/title&gt;\n  &lt;effectiveTime value=\"20150519\"/&gt;\n  &lt;confidentialityCode code=\"N\" codeSystem=\"2.16.840.1.113883.5.25\"/&gt;\n  &lt;languageCode code=\"en-US\"/&gt;\n  &lt;recordTarget&gt;\n    &lt;patientRole&gt;\n      &lt;id extension=\"12345\" root=\"2.16.840.1.113883.19.5.99999.2\"/&gt;\n      &lt;patient&gt;\n        &lt;name&gt;\n          &lt;given&gt;John&lt;/given&gt;\n          &lt;family&gt;Smith&lt;/family&gt;\n        &lt;/name&gt;\n        &lt;administrativeGenderCode code=\"M\" codeSystem=\"2.16.840.1.113883.5.1\"/&gt;\n        &lt;birthTime value=\"19701101\"/&gt;\n      &lt;/patient&gt;\n    &lt;/patientRole&gt;\n  &lt;/recordTarget&gt;\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.1.11\"/&gt;\n          &lt;code code=\"11450-4\" codeSystem=\"2.16.840.1.113883.6.1\"\n                displayName=\"Problem List\"/&gt;\n          &lt;title&gt;Problems&lt;/title&gt;\n          &lt;text&gt;Hypertension&lt;/text&gt;\n          &lt;entry&gt;\n            &lt;observation classCode=\"OBS\" moodCode=\"EVN\"&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.1.28\"/&gt;\n              &lt;templateId root=\"2.16.840.1.113883.10.20.1.54\"/&gt;\n              &lt;id root=\"2.16.840.1.113883.19.5.99999.3\"/&gt;\n              &lt;code code=\"64572001\" displayName=\"Hypertension\"\n                    codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"/&gt;\n              &lt;statusCode code=\"completed\"/&gt;\n              &lt;effectiveTime value=\"20180101\"/&gt;\n              &lt;value xsi:type=\"CD\" code=\"64572001\" displayName=\"Hypertension\"\n                     codeSystem=\"2.16.840.1.113883.6.96\" codeSystemName=\"SNOMED CT\"\n                     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"/&gt;\n            &lt;/observation&gt;\n          &lt;/entry&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n\"\"\"\n\n# Convert CDA to FHIR resources\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Inspect the results\nfor resource in fhir_resources:\n    print(f\"Resource Type: {resource.resource_type}\")\n    print(json.dumps(resource.dict(), indent=2))\n</code></pre>"},{"location":"cookbook/format_conversion/#converting-fhir-to-cda","title":"Converting FHIR to CDA","text":"<p>Generate a CDA document from FHIR resources:</p> <pre><code>from fhir.resources.condition import Condition\nfrom fhir.resources.patient import Patient\n\n# Create FHIR resources\npatient = Patient(\n    resourceType=\"Patient\",\n    id=\"patient-1\",\n    name=[{\"family\": \"Smith\", \"given\": [\"John\"]}],\n    gender=\"male\",\n    birthDate=\"1970-11-01\"\n)\n\ncondition = Condition(\n    resourceType=\"Condition\",\n    id=\"condition-1\",\n    subject={\"reference\": \"Patient/patient-1\"},\n    code={\n        \"coding\": [\n            {\n                \"system\": \"http://snomed.info/sct\",\n                \"code\": \"38341003\",\n                \"display\": \"Hypertension\"\n            }\n        ],\n        \"text\": \"Hypertension\"\n    },\n    clinicalStatus={\n        \"coding\": [\n            {\n                \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                \"code\": \"active\"\n            }\n        ]\n    },\n    verificationStatus={\n        \"coding\": [\n            {\n                \"system\": \"http://terminology.hl7.org/CodeSystem/condition-ver-status\",\n                \"code\": \"confirmed\"\n            }\n        ]\n    },\n    onsetDateTime=\"2018-01-01\"\n)\n\n# Convert to CDA\nresources = [patient, condition]\ncda_document = engine.from_fhir(resources, dest_format=FormatType.CDA)\n\nprint(cda_document)\n</code></pre>"},{"location":"cookbook/format_conversion/#converting-hl7v2-to-fhir","title":"Converting HL7v2 to FHIR","text":"<p>Parse an HL7v2 message and extract FHIR resources:</p> <pre><code>hl7v2_message = \"\"\"\nMSH|^~\\&amp;|EPIC|EPICADT|SMS|SMSADT|199912271408|CHARRIS|ADT^A01|1817457|D|2.5|\nPID|1||PATID1234^5^M11^ADT1^MR^GOOD HEALTH HOSPITAL~123456789^^^USSSA^SS||EVERYMAN^ADAM^A^III||19610615|M||C|2222 HOME STREET^^GREENSBORO^NC^27401-1020|GL|(555) 555-2004|(555)555-2004||S||PATID12345001^2^M10^ADT1^AN^A|444333333|987654^NC|\nNK1|1|NUCLEAR^NELDA^W|SPO||(555)555-3333||EC|||||||||||||||||||||||||\nPV1|1|I|2000^2012^01||||004777^ATTEND^AARON^A|||SUR||||ADM|A0|\n\"\"\"\n\n# Convert HL7v2 to FHIR resources\nfhir_resources = engine.to_fhir(hl7v2_message, src_format=FormatType.HL7V2)\n\nfor resource in fhir_resources:\n    print(f\"Resource Type: {resource.resource_type}\")\n    print(json.dumps(resource.dict(), indent=2))\n</code></pre>"},{"location":"cookbook/format_conversion/#converting-fhir-to-hl7v2","title":"Converting FHIR to HL7v2","text":"<p>Generate an HL7v2 message from FHIR resources:</p> <pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.encounter import Encounter\n\npatient = Patient(\n    resourceType=\"Patient\",\n    id=\"patient-1\",\n    name=[{\"family\": \"Everyman\", \"given\": [\"Adam\", \"A\"], \"suffix\": [\"III\"]}],\n    gender=\"male\",\n    birthDate=\"1961-06-15\",\n    identifier=[\n        {\n            \"system\": \"urn:oid:1.2.36.146.595.217.0.1\",\n            \"value\": \"PATID1234\"\n        }\n    ],\n    address=[\n        {\n            \"line\": [\"2222 Home Street\"],\n            \"city\": \"Greensboro\",\n            \"state\": \"NC\",\n            \"postalCode\": \"27401\"\n        }\n    ],\n    telecom=[\n        {\n            \"system\": \"phone\",\n            \"value\": \"(555) 555-2004\",\n            \"use\": \"home\"\n        }\n    ]\n)\n\nencounter = Encounter(\n    resourceType=\"Encounter\",\n    id=\"encounter-1\",\n    status=\"finished\",\n    class_fhir={\n        \"system\": \"http://terminology.hl7.org/CodeSystem/v3-ActCode\",\n        \"code\": \"IMP\",\n        \"display\": \"inpatient encounter\"\n    },\n    subject={\n        \"reference\": \"Patient/patient-1\"\n    }\n)\n\n# Convert to HL7v2\nresources = [patient, encounter]\nhl7v2_message = engine.from_fhir(resources, dest_format=FormatType.HL7V2)\n\nprint(hl7v2_message)\n</code></pre>"},{"location":"cookbook/format_conversion/#saving-results","title":"Saving Results","text":"<p>Save converted data to files:</p> <pre><code>output_dir = Path(\"./output\")\noutput_dir.mkdir(exist_ok=True)\n\n# Save FHIR resources as JSON\nfor resource in fhir_resources:\n    filename = f\"{resource.resource_type.lower()}_{resource.id}.json\"\n    with open(output_dir / filename, \"w\") as f:\n        json.dump(resource.dict(), f, indent=2)\n\n# Save CDA document as XML\nwith open(output_dir / \"document.xml\", \"w\") as f:\n    f.write(cda_document)\n\n# Save HL7v2 message\nwith open(output_dir / \"message.hl7\", \"w\") as f:\n    f.write(hl7v2_message)\n</code></pre>"},{"location":"cookbook/format_conversion/#next-steps","title":"Next Steps","text":"<ul> <li>InteropEngine documentation - Advanced configuration and customization</li> <li>Configuration guide - Custom templates and mappings</li> <li>CDA Adapter - Higher-level CDA integration with Document containers</li> </ul>"},{"location":"cookbook/ml_model_deployment/","title":"Deploy ML Models: Real-Time Alerts &amp; Batch Screening","text":"<p>You trained a model on CSVs. Now you need to deploy it against FHIR data from EHRs. This tutorial shows how to bridge that gap with two production patterns: real-time CDS Hooks alerts and batch FHIR Gateway screening\u2014both using the same model and a simple YAML schema that maps FHIR resources to your training features.</p> <p>Check out the full working examples:</p> <ul> <li>Real-time CDS Hooks</li> <li>Batch FHIR Gateway</li> </ul> <p></p>"},{"location":"cookbook/ml_model_deployment/#when-to-use-each-pattern","title":"When to Use Each Pattern","text":"Pattern Trigger Output Best For CDS Hooks Clinician opens chart Alert cards in EHR UI Point-of-care decision support FHIR Gateway Scheduled job / API call RiskAssessment resources Population screening, quality measures <p>Both patterns share the same trained model and feature extraction\u2014only the integration layer differs.</p>"},{"location":"cookbook/ml_model_deployment/#setup","title":"Setup","text":""},{"location":"cookbook/ml_model_deployment/#install-dependencies","title":"Install Dependencies","text":"<pre><code>pip install healthchain joblib xgboost scikit-learn python-dotenv\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#train-the-model-or-bring-your-own","title":"Train the Model (or Bring Your Own)","text":"<p>The cookbook includes a training script that builds an XGBoost classifier from MIMIC-IV data. From the project root:</p> <pre><code>cd scripts\npython sepsis_prediction_training.py\n</code></pre> <p>This script:</p> <ul> <li>Loads MIMIC-IV CSV tables (chartevents, labevents, patients, diagnoses)</li> <li>Extracts vitals features (heart rate, temperature, respiratory rate, WBC, lactate, creatinine, age, gender)</li> <li>Labels ICU stays with sepsis diagnoses (ICD-9/ICD-10)</li> <li>Trains Random Forest, XGBoost, and Logistic Regression models</li> <li>Saves the best model (by F1 score) to <code>scripts/models/sepsis_model.pkl</code></li> </ul> <p>After training, copy the model to the cookbook directory:</p> <pre><code>cp scripts/models/sepsis_model.pkl cookbook/models/\n</code></pre> <p>MIMIC-IV Demo Dataset</p> <p>The training script uses the MIMIC-IV Clinical Database Demo (~50MB, freely downloadable). Set the path:</p> <pre><code>export MIMIC_CSV_PATH=/path/to/mimic-iv-clinical-database-demo-2.2\n</code></pre> <p>*This is a quick-start workflow for demo purposes. Full MIMIC requires credentialed access. Most researchers use BigQuery or a PostgreSQL database.</p> <p>Using your own model? The pipeline is flexible\u2014just save any scikit-learn-compatible model as a pickle with this structure:</p> <pre><code>import joblib\n\nmodel_data = {\n    \"model\": your_trained_model,  # Must have .predict_proba()\n    \"metadata\": {\n        \"feature_names\": [\"heart_rate\", \"temperature\", ...],\n        \"metrics\": {\"optimal_threshold\": 0.5}\n    }\n}\njoblib.dump(model_data, \"cookbook/models/sepsis_model.pkl\")\n</code></pre> <p>The pipeline will work with any model that implements <code>predict_proba()</code> - XGBoost, Random Forest, LightGBM, or even PyTorch/TensorFlow models wrapped with a sklearn-compatible interface.</p>"},{"location":"cookbook/ml_model_deployment/#prepare-demo-patient-data","title":"Prepare Demo Patient Data","text":"<p>The two patterns have different data requirements:</p> Pattern Data Source What You Need CDS Hooks Local JSON files Download pre-extracted patients (quick start) FHIR Gateway FHIR server Upload patients to Medplum and get server-assigned IDs CDS Hooks Only (Quick Start)FHIR Gateway (Full Setup) <p>Download pre-extracted patient bundles\u2014these are already in the repo if you cloned it:</p> <pre><code>mkdir -p cookbook/data/mimic_demo_patients\ncd cookbook/data/mimic_demo_patients\nwget https://github.com/dotimplement/HealthChain/raw/main/cookbook/data/mimic_demo_patients/high_risk_patient.json\nwget https://github.com/dotimplement/HealthChain/raw/main/cookbook/data/mimic_demo_patients/moderate_risk_patient.json\nwget https://github.com/dotimplement/HealthChain/raw/main/cookbook/data/mimic_demo_patients/low_risk_patient.json\n</code></pre> <p>That's it! Skip to Pattern 1: CDS Hooks.</p> <p>The batch screening pattern queries patients from a FHIR server. This tutorial uses Medplum (a free, hosted FHIR server), but any FHIR R4-compliant API works - just swap the credentials.</p> <p>1. Configure FHIR Credentials</p> <p>Add Medplum credentials to your <code>.env</code> file. See FHIR Sandbox Setup for details:</p> <pre><code>MEDPLUM_BASE_URL=https://api.medplum.com/fhir/R4\nMEDPLUM_CLIENT_ID=your_client_id\nMEDPLUM_CLIENT_SECRET=your_client_secret\nMEDPLUM_TOKEN_URL=https://api.medplum.com/oauth2/token\nMEDPLUM_SCOPE=openid\n</code></pre> <p>2. Extract and Upload Demo Patients</p> <pre><code># Set MIMIC-on-FHIR path (or use --mimic flag)\nexport MIMIC_FHIR_PATH=/path/to/mimic-iv-on-fhir\n\n# Extract and upload to Medplum\ncd scripts\npython extract_mimic_demo_patients.py --minimal --upload\n</code></pre> <p>This script:</p> <ul> <li>Loads patient data from MIMIC-IV on FHIR</li> <li>Runs the sepsis model to find high/moderate/low risk patients</li> <li>Creates minimal FHIR bundles with only the observations needed</li> <li>Uploads them to your Medplum instance as transaction bundles</li> </ul> <p>3. Copy Patient IDs</p> <p>After upload, the script prints server-assigned patient IDs:</p> <pre><code>\u2713 Uploaded to Medplum!\n\nCopy this into sepsis_fhir_batch.py:\n\nDEMO_PATIENT_IDS = [\n    \"702e11e8-6d21-41dd-9b48-31715fdc0fb1\",  # high risk\n    \"3b0da7e9-0379-455a-8d35-bedd3a6ee459\",  # moderate risk\n    \"f490ceb4-6262-4f1e-8b72-5515e6c46741\",  # low risk\n]\n</code></pre> <p>Copy these IDs into the <code>DEMO_PATIENT_IDS</code> list in <code>sepsis_fhir_batch.py</code>.</p> <p>Generate More Patients</p> <p>The script has options for generating larger test sets:</p> <pre><code>python extract_mimic_demo_patients.py --help\n\n# Examples:\n--num-patients-per-risk 5   # 5 patients per risk level (15 total)\n--seed 123                   # Different random sample\n--minimal                    # Keep only latest observation per feature (~12KB each)\n</code></pre> <p>Alternative: Manual Upload</p> <p>If you prefer, run without <code>--upload</code> to generate bundle JSON files, then upload them manually via the Medplum \u2192 Batch page.</p> <p>Setup complete! You should now have:</p> <ul> <li>\u2705 A trained model at <code>cookbook/models/sepsis_model.pkl</code></li> <li>\u2705 Demo patient data (local JSON or uploaded to Medplum)</li> </ul> <p>If using the FHIR Gateway pattern, also confirm:</p> <ul> <li>\u2705 FHIR credentials in <code>.env</code></li> <li>\u2705 Patient IDs copied into <code>DEMO_PATIENT_IDS</code> in <code>sepsis_fhir_batch.py</code></li> </ul>"},{"location":"cookbook/ml_model_deployment/#the-shared-model-pipeline","title":"The Shared Model Pipeline","text":"<p>Both patterns reuse the same pipeline. Here's what you'll write:</p> <pre><code>def create_pipeline() -&gt; Pipeline[Dataset]:\n    pipeline = Pipeline[Dataset]()\n\n    @pipeline.add_node\n    def impute_missing(dataset: Dataset) -&gt; Dataset:\n        dataset.data = dataset.data.fillna(dataset.data.median(numeric_only=True))\n        return dataset\n\n    @pipeline.add_node\n    def run_inference(dataset: Dataset) -&gt; Dataset:\n        features = dataset.data[feature_names]\n        probabilities = model.predict_proba(features)[:, 1]\n        dataset.metadata[\"probabilities\"] = probabilities\n        return dataset\n\n    return pipeline\n</code></pre> <p>The pipeline operates on a <code>Dataset</code>, which you create from a FHIR bundle:</p> <pre><code>dataset = Dataset.from_fhir_bundle(bundle, schema=SCHEMA_PATH)\n</code></pre> <p>How does FHIR become a DataFrame? The schema maps FHIR resources to your training features:</p> <pre><code># sepsis_vitals.yaml (excerpt)\nfeatures:\n  heart_rate:\n    fhir_resource: Observation\n    code: \"220045\"  # MIMIC chartevents code\n  wbc:\n    fhir_resource: Observation\n    code: \"51301\"   # MIMIC labevents code\n  age:\n    fhir_resource: Patient\n    field: birthDate\n    transform: calculate_age\n</code></pre> <p>No FHIR parsing code needed\u2014define the mapping once, use it everywhere.</p> <p>Explore Interactively</p> <p>Step through the full flow in notebooks/fhir_ml_workflow.ipynb: FHIR bundle \u2192 Dataset \u2192 DataFrame \u2192 inference \u2192 RiskAssessment.</p> <p>Now let's see how this pipeline plugs into each deployment pattern.</p>"},{"location":"cookbook/ml_model_deployment/#pattern-1-real-time-cds-hooks-alerts","title":"Pattern 1: Real-Time CDS Hooks Alerts","text":"<p>Use CDS Hooks when you need instant alerts during clinical workflows. The EHR triggers your service and pushes patient data via prefetch\u2014no server queries needed.</p>"},{"location":"cookbook/ml_model_deployment/#how-it-works","title":"How It Works","text":"<pre><code>Clinician opens chart \u2192 EHR fires patient-view hook \u2192 Your service runs prediction \u2192 CDS card appears in EHR\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#set-up-the-cds-hook-handler","title":"Set Up the CDS Hook Handler","text":"<p>Create a CDSHooksService that listens for <code>patient-view</code> events:</p> <pre><code>from healthchain.gateway import CDSHooksService\nfrom healthchain.fhir import prefetch_to_bundle\nfrom healthchain.models import CDSRequest, CDSResponse\nfrom healthchain.models.responses.cdsresponse import Card\n\ncds = CDSHooksService()\n\n@cds.hook(\"patient-view\", id=\"sepsis-risk\")\ndef sepsis_alert(request: CDSRequest) -&gt; CDSResponse:\n    if not request.prefetch:\n        return CDSResponse(cards=[])\n\n    # FHIR prefetch \u2192 Dataset \u2192 Prediction\n    bundle = prefetch_to_bundle(request.prefetch)\n    dataset = Dataset.from_fhir_bundle(bundle, schema=SCHEMA_PATH)\n    result = pipeline(dataset)\n\n    # Generate alert card if risk is elevated\n    prob = float(result.metadata[\"probabilities\"][0])\n    risk = \"high\" if prob &gt; 0.7 else \"moderate\" if prob &gt; 0.4 else \"low\"\n\n    if risk in [\"high\", \"moderate\"]:\n        return CDSResponse(cards=[\n            Card(\n                summary=f\"Sepsis Risk: {risk.upper()} ({prob:.0%})\",\n                indicator=\"critical\" if risk == \"high\" else \"warning\",\n                detail=f\"Predicted sepsis risk: {risk.upper()}. Recommend workup.\",\n                source={\"label\": \"HealthChain Sepsis Predictor\"},\n            )\n        ])\n\n    return CDSResponse(cards=[])\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#build-the-service","title":"Build the Service","text":"<p>Register with HealthChainAPI:</p> <pre><code>app = HealthChainAPI(title=\"Sepsis CDS Hooks\")\napp.register_service(cds, path=\"/cds\")\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#test-with-sandbox-client","title":"Test with Sandbox Client","text":"<p>The SandboxClient simulates EHR requests using your demo patient files:</p> <pre><code>from healthchain.sandbox import SandboxClient\n\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/sepsis-risk\",\n    workflow=\"patient-view\",\n)\nclient.load_from_path(\"data/mimic_demo_patients\", pattern=\"*_patient.json\")\nresponses = client.send_requests()\nclient.save_results(save_request=True, save_response=True, directory=\"./output/\")\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#expected-output","title":"Expected Output","text":"<pre><code>Processed 3 requests\n  Patient 1: Sepsis Risk: HIGH (85%)\n  Patient 2: Sepsis Risk: MODERATE (52%)\n  Patient 3: Low risk (no alert)\n</code></pre> Example CDS Response <pre><code>{\n  \"cards\": [\n    {\n      \"summary\": \"Sepsis Risk: HIGH (85%)\",\n      \"indicator\": \"critical\",\n      \"source\": {\n        \"label\": \"HealthChain Sepsis Predictor\",\n        \"url\": \"https://www.sccm.org/SurvivingSepsisCampaign/Guidelines/Adult-Patients\"\n      },\n      \"detail\": \"**AI Guidance:**\\n- Predicted risk: **HIGH** (85%)\\n- Recommend sepsis workup and early intervention.\",\n      \"title\": \"Sepsis Alert (AI Prediction)\"\n    }\n  ]\n}\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#pattern-2-batch-fhir-gateway-screening","title":"Pattern 2: Batch FHIR Gateway Screening","text":"<p>Use the FHIR Gateway when you need to screen multiple patients from a FHIR server. Unlike CDS Hooks (ephemeral alerts), this pattern persists predictions back to the FHIR server as RiskAssessment resources, making them available for dashboards, reports, and downstream workflows.</p>"},{"location":"cookbook/ml_model_deployment/#how-it-works_1","title":"How It Works","text":"<pre><code>Query patients from FHIR server \u2192 Run predictions \u2192 Write RiskAssessment back to FHIR server\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#set-up-fhir-gateway","title":"Set Up FHIR Gateway","text":"<p>Configure the FHIRGateway with your FHIR source:</p> <pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.observation import Observation\nfrom healthchain.gateway import FHIRGateway\nfrom healthchain.gateway.clients.fhir.base import FHIRAuthConfig\nfrom healthchain.fhir import merge_bundles\n\ngateway = FHIRGateway()\nconfig = FHIRAuthConfig.from_env(\"MEDPLUM\")\ngateway.add_source(\"medplum\", config.to_connection_string())\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#screen-individual-patients","title":"Screen Individual Patients","text":"<p>Query patient data, run prediction, and write back a RiskAssessment resource:</p> <pre><code>def screen_patient(gateway: FHIRGateway, patient_id: str, source: str):\n    # Query patient + observations from FHIR server\n    patient_bundle = gateway.search(Patient, {\"_id\": patient_id}, source)\n    obs_bundle = gateway.search(Observation, {\"patient\": patient_id}, source)\n    bundle = merge_bundles([patient_bundle, obs_bundle])\n\n    # FHIR \u2192 Dataset \u2192 Prediction\n    dataset = Dataset.from_fhir_bundle(bundle, schema=SCHEMA_PATH)\n    result = pipeline(dataset)\n\n    # Convert to RiskAssessment and write back\n    for ra in result.to_risk_assessment(\n        outcome_code=\"A41.9\",\n        outcome_display=\"Sepsis\",\n        model_name=\"sepsis_xgboost_v1\",\n    ):\n        gateway.create(ra, source=source)\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#batch-screen-multiple-patients","title":"Batch Screen Multiple Patients","text":"<p>Loop over patient IDs and screen each one:</p> <pre><code>for patient_id in patient_ids:\n    screen_patient(gateway, patient_id, source=\"medplum\")\n</code></pre> <p>Demo vs Production</p> <p>This demo uses a fixed list of patient IDs. In production, you'd query for patients dynamically\u2014for example, ICU admissions in the last hour:</p> <pre><code># Find patients with recent ICU encounters\nencounters = gateway.search(\n    Encounter,\n    {\n        \"class\": \"IMP\",  # inpatient\n        \"location\": \"icu\",\n        \"date\": \"ge2024-01-01\",\n    },\n    source=\"ehr\"\n)\npatient_ids = [e.subject.reference.split(\"/\")[1] for e in encounters]\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#build-the-service_1","title":"Build the Service","text":"<pre><code>app = HealthChainAPI(title=\"Sepsis Batch Screening\")\napp.register_gateway(gateway, path=\"/fhir\")\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#expected-output_1","title":"Expected Output","text":"<p>After uploading demo patients to Medplum and running batch screening:</p> <p><pre><code>=== Screening patients from Medplum ===\n  702e11e8-6d21-41dd-9b48-31715fdc0fb1: HIGH (85%) \u2192 RiskAssessment/abc123\n  3b0da7e9-0379-455a-8d35-bedd3a6ee459: MODERATE (52%) \u2192 RiskAssessment/def456\n  f490ceb4-6262-4f1e-8b72-5515e6c46741: LOW (15%) \u2192 RiskAssessment/ghi789\n</code></pre> You should be able to see the RiskAssessment resources in the Medplum console (search for \"RiskAssessment\" in \"Resource Type\" search bar in top left corner)</p> Example RiskAssessment Resource <pre><code>{\n  \"resourceType\": \"RiskAssessment\",\n  \"id\": \"abc123\",\n  \"status\": \"final\",\n  \"subject\": {\n    \"reference\": \"Patient/702e11e8-6d21-41dd-9b48-31715fdc0fb1\"\n  },\n  \"method\": {\n    \"coding\": [{\n      \"system\": \"https://healthchain.io/models\",\n      \"code\": \"sepsis_xgboost_v1\",\n      \"display\": \"Sepsis XGBoost Model v1\"\n    }]\n  },\n  \"prediction\": [{\n    \"outcome\": {\n      \"coding\": [{\n        \"system\": \"http://hl7.org/fhir/sid/icd-10\",\n        \"code\": \"A41.9\",\n        \"display\": \"Sepsis\"\n      }]\n    },\n    \"probabilityDecimal\": 0.85,\n    \"qualitativeRisk\": {\n      \"coding\": [{\n        \"system\": \"http://terminology.hl7.org/CodeSystem/risk-probability\",\n        \"code\": \"high\",\n        \"display\": \"High likelihood\"\n      }]\n    }\n  }]\n}\n</code></pre>"},{"location":"cookbook/ml_model_deployment/#what-youve-built","title":"What You've Built","text":"<p>Two deployment patterns for the same ML model:</p> CDS Hooks FHIR Gateway Integration Event-driven (EHR pushes data) Pull-based (service queries server) Latency Real-time (&lt;1s) Batch (seconds to minutes) Output CDS Cards (ephemeral alerts) RiskAssessment (persisted resources) Scaling Per-patient on demand Parallel/scheduled batch jobs <p>Both patterns:</p> <ul> <li>Share the same model - Train once, deploy multiple ways</li> <li>Use YAML feature schemas - Declarative FHIR \u2192 features mapping</li> <li>Handle FHIR natively - No custom data wrangling per integration</li> </ul> <p>Use Cases</p> <p>CDS Hooks (Real-time)</p> <ul> <li>Sepsis early warning alerts when opening ICU patient charts</li> <li>Drug interaction warnings during medication ordering</li> <li>Clinical guideline reminders triggered by diagnosis codes</li> </ul> <p>FHIR Gateway (Batch)</p> <ul> <li>Nightly population health screening</li> <li>Quality measure calculation for reporting</li> <li>Research cohort identification</li> <li>Pre-visit risk stratification</li> </ul> <p>Next Steps</p> <ul> <li>Train your own model: Replace <code>sepsis_model.pkl</code> with your model; update the feature schema to match</li> <li>Add more features: Extend <code>sepsis_vitals.yaml</code> with lab values, medications, or other Observations</li> <li>Add more FHIR sources: The gateway supports multiple sources\u2014see the cookbook script for Epic sandbox configuration, or the FHIR Sandbox Setup guide</li> <li>Automate batch runs: Schedule screening jobs with cron, Airflow, or cloud schedulers; or use FHIR Subscriptions to trigger on new ICU admissions (PRs welcome!)</li> <li>Combine patterns: Use batch screening to identify high-risk patients, then enable CDS alerts for those patients</li> </ul>"},{"location":"cookbook/multi_ehr_aggregation/","title":"Multi-Source Patient Data Aggregation","text":"<p>This example shows you how to aggregate patient data from multiple FHIR sources and track data provenance: essential for building AI applications that train on diverse data, query multiple EHR vendors in RAG systems, or construct unified patient timelines from fragmented health records.</p> <p>Check out the full working example here!</p> <p> Illustrative Architecture - actual implementation may vary.</p>"},{"location":"cookbook/multi_ehr_aggregation/#setup","title":"Setup","text":"<pre><code>pip install healthchain python-dotenv\n</code></pre> <p>We'll use Epic's public FHIR sandbox. If you haven't set up Epic sandbox access yet, see the FHIR Sandbox Setup Guide for detailed instructions.</p> <p>Once you have your Epic credentials, configure them in a <code>.env</code> file:</p> <pre><code># .env file\nEPIC_BASE_URL=https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4\nEPIC_CLIENT_ID=your_non_production_client_id\nEPIC_CLIENT_SECRET_PATH=path/to/privatekey.pem\nEPIC_TOKEN_URL=https://fhir.epic.com/interconnect-fhir-oauth/oauth2/token\nEPIC_USE_JWT_ASSERTION=true\n</code></pre> <p>Load your Epic credentials from the <code>.env</code> file and create a connection string compatible with the FHIR gateway:</p> <pre><code>from healthchain.gateway.clients import FHIRAuthConfig\n\nconfig = FHIRAuthConfig.from_env(\"EPIC\")\nEPIC_URL = config.to_connection_string()\n</code></pre>"},{"location":"cookbook/multi_ehr_aggregation/#set-up-fhir-gateway","title":"Set Up FHIR Gateway","text":"<p>FHIR Gateways connect to external FHIR servers and handles authentication, connection pooling, and token refresh automatically. Add the Epic sandbox as a source:</p> <pre><code>from healthchain.gateway import FHIRGateway\n\ngateway = FHIRGateway()\ngateway.add_source(\"epic\", EPIC_URL)\n\n# Optional: Add Cerner's public sandbox (no auth required)\nCERNER_URL = \"fhir://fhir-open.cerner.com/r4/ec2458f2-1e24-41c8-b71b-0e701af7583d\"\ngateway.add_source(\"cerner\", CERNER_URL)\n\n# You can add more sources:\n# gateway.add_source(\"other source\", fhir://url)\n</code></pre> <p>Note</p> <p>Cerner's public sandbox patient cohort differs from Epic's. For demo/testing with sandboxes, expect incomplete aggregation if patient cohorts don't overlap - this is normal for the public test data.</p> <p>In production, you must perform your own patient identity matching (MPI/crosswalk) before aggregation.</p>"},{"location":"cookbook/multi_ehr_aggregation/#create-aggregation-handler","title":"Create Aggregation Handler","text":"<p>Define an aggregation handler that queries multiple FHIR sources for Condition resources.</p> <pre><code>from healthchain.fhir import merge_bundles\n\n@gateway.aggregate(Condition)\ndef get_unified_patient(patient_id: str, sources: List[str]) -&gt; Bundle:\n    \"\"\"Aggregate conditions from multiple FHIR sources with provenance tracking.\"\"\"\n    bundles = []\n    for source in sources:\n        try:\n            bundle = gateway.search(\n                Condition,\n                {\"patient\": patient_id},\n                source,\n                add_provenance=True,  # Track which EHR the data came from\n                provenance_tag=\"aggregated\",\n            )\n            bundles.append(bundle)\n        except Exception as e:\n            print(f\"Error from {source}: {e}\")\n            # Continue with partial data rather than fail completely\n\n    # Combine conditions across sources\n    merged_bundle = merge_bundles(bundles, deduplicate=True)\n    return merged_bundle\n</code></pre> <p>What this handler does</p> <ul> <li>Queries each configured FHIR source for patient conditions</li> <li>Adds Meta tags to track data provenance (which source each condition came from, preserves existing metadata)</li> <li>Handles errors gracefully \u2013 partial data is better than no data</li> <li>Deduplicates identical conditions across sources</li> </ul> Example FHIR Metadata <pre><code>{\n  \"resourceType\": \"Condition\",\n  \"id\": ...,\n  \"meta\": {\n    \"lastUpdated\": \"2025-10-10T15:23:50.167941Z\",  // Updated timestamp\n    \"source\": \"urn:healthchain:source:epic\",  // Adds source\n    \"tag\": [\n      {\n        \"system\": \"https://dotimplement.github.io/HealthChain/fhir/tags\",\n        \"code\": \"aggregated\",\n        \"display\": \"Aggregated\"\n      }  // Appends a custom HealthChain tag\n    ]\n  }\n  ...\n}\n</code></pre>"},{"location":"cookbook/multi_ehr_aggregation/#build-the-service","title":"Build the Service","text":"<p>Register the gateway with HealthChainAPI to create REST endpoints.</p> <pre><code>import uvicorn\nfrom healthchain.gateway import HealthChainAPI\n\napp = HealthChainAPI()\napp.register_gateway(gateway, path=\"/fhir\")\n\nuvicorn.run(app)\n</code></pre> <p>FHIR Endpoints Provided by the Service</p> <ul> <li><code>/fhir/*</code> - Standard FHIR operations (<code>read</code>, <code>search</code>, <code>create</code>, <code>update</code>)</li> <li><code>/fhir/metadata</code> - CapabilityStatement describing supported resources and operations</li> <li><code>/fhir/status</code> - Operational status and metadata for gateway</li> </ul>"},{"location":"cookbook/multi_ehr_aggregation/#add-processing-pipeline-optional","title":"Add Processing Pipeline (Optional)","text":"<p>For additional processing like terminology mapping or quality checks, create a Document Pipeline.</p> <p>Document pipelines are optimized for text and structured data processing, such as FHIR resources. When you initialize a Document with FHIR Bundle data, it automatically extracts and separates metadata resources from the clinical resources for easier inspection and error handling:</p> <pre><code># Initialize Document with a Bundle\ndoc = Document(data=merged_bundle)\n\n# OperationOutcomes are automatically extracted and available\ndoc.fhir.operation_outcomes  # List of OperationOutcome resources\n\n# Clinical resources remain in the bundle\ndoc.fhir.bundle              # Bundle with clinical resources\ndoc.fhir.problem_list        # List of Condition resources\ndoc.fhir.medication_list     # List of MedicationStatement resources\n</code></pre> <p>Add processing nodes using decorators:</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io.containers import Document\n\npipeline = Pipeline[Document]()\n\n@pipeline.add_node\ndef deduplicate(doc: Document) -&gt; Document:\n  ...\n\n@pipeline.add_node\ndef add_annotation(doc: Document) -&gt; Document:\n  ...\n\n# Apply the pipeline\ndoc = Document(data=merged_bundle)\ndoc = pipeline(doc)\n</code></pre> <p>Common Pipeline Uses</p> <ul> <li>Terminology mapping (ICD-10 \u2194 SNOMED CT)</li> <li>Data enrichment (risk scores, clinical decision support)</li> <li>Quality checks (validate completeness, flag inconsistencies)</li> <li>Consent filtering (apply patient consent rules)</li> </ul>"},{"location":"cookbook/multi_ehr_aggregation/#test-the-service","title":"Test the Service","text":"<p>To test aggregation, request <code>/fhir/aggregate/Condition/{patientId}</code> with the <code>sources</code> parameter (e.g., <code>epic,cerner</code>).</p> <p>Example uses Epic patient <code>eIXesllypH3M9tAA5WdJftQ3</code>; see Epic sandbox for more test patients.</p> cURLPython <pre><code>curl -X 'GET' \\\n  'http://127.0.0.1:8888/fhir/aggregate/Condition?id=eIXesllypH3M9tAA5WdJftQ3&amp;sources=epic&amp;sources=cerner' \\\n  -H 'accept: application/fhir+json'\n</code></pre> <pre><code>  import requests\n\n  url = \"http://127.0.0.1:8888/fhir/aggregate/Condition\"\n  params = {\n      \"id\": \"eIXesllypH3M9tAA5WdJftQ3\",\n      \"sources\": [\"epic\", \"cerner\"]\n  }\n  headers = {\n      \"accept\": \"application/fhir+json\"\n  }\n  response = requests.get(url, headers=headers, params=params)\n  print(response.json)\n</code></pre>"},{"location":"cookbook/multi_ehr_aggregation/#expected-outputs","title":"Expected Outputs","text":"<p>Example output when querying Linda Ross (Epic patient <code>eIXesllypH3M9tAA5WdJftQ3</code>):</p> <pre><code>\u2713 Patient: Ross, Linda Jane\n\u2713 Conditions retrieved: 2\n\nSample conditions:\n  \u2022 Moderate persistent asthma\n    Codes: ICD10-CM:J45.40, SNOMED:427295004, ICD9:493.90\n    Source: urn:healthchain:source:epic\n    Severity: Medium\n    Onset: 1999-03-08\n\n  \u2022 Bronchitis with asthma, acute\n    Codes: ICD10-CM:J20.9/J45.909, SNOMED:405944004, ICD9:466.0\n    Source: urn:healthchain:source:epic\n    Severity: High\n    Onset: 2019-05-24\n</code></pre> Aggregated Result: With provenance tags and pipeline processing <p>Sample Bundle with deduplicated Conditions aggregated from Epic and Cerner. Each includes source details (<code>meta.source</code>, <code>meta.tag</code>) and a pipeline-added <code>note</code>.</p> <pre><code>{\n  \"resourceType\": \"Bundle\",\n  \"type\": \"collection\",\n  \"entry\": [\n    {\n      \"resource\": {\n        \"resourceType\": \"Condition\",\n        \"id\": \"eOCME6XUbCLYmFlVf2l1G0w3\",\n        \"meta\": {\n          \"lastUpdated\": \"2025-10-10T15:23:50.167941Z\",  // Updated by HealthChain Gateway\n          \"source\": \"urn:healthchain:source:epic\",       // Added by HealthChain Gateway\n          \"tag\": [{\n            \"system\": \"https://dotimplement.github.io/HealthChain/fhir/tags\",\n            \"code\": \"aggregated\",\n            \"display\": \"Aggregated\"\n          }]  // Added by HealthChain Gateway\n        },\n        \"clinicalStatus\": { \"text\": \"Active\" },\n        \"severity\": { \"text\": \"Medium\" },\n        \"code\": {\n          \"coding\": [\n            {\n              \"system\": \"http://hl7.org/fhir/sid/icd-10-cm\",\n              \"code\": \"J45.40\",\n              \"display\": \"Moderate persistent asthma, uncomplicated\"\n            },\n            {\n              \"system\": \"http://snomed.info/sct\",\n              \"code\": \"427295004\",\n              \"display\": \"Moderate Persistent Asthma\"\n            },\n            {\n              \"system\": \"http://hl7.org/fhir/sid/icd-9-cm\",\n              \"code\": \"493.90\"\n            }\n          ],\n          \"text\": \"Moderate persistent asthma\"\n        },\n        \"subject\": {\n          \"reference\": \"Patient/eIXesllypH3M9tAA5WdJftQ3\",\n          \"display\": \"Ross, Linda Jane\"\n        },\n        \"onsetDateTime\": \"1999-03-08\",\n        \"note\": [{\n          \"text\": \"This resource has been processed by healthchain pipeline\"\n        }]  // Added by HealthChain Pipeline\n      }\n    },\n    {\n      \"resource\": {\n        \"resourceType\": \"Condition\",\n        \"id\": \"etZVq9vWdHQ4q0Y6INaFhig3\",\n        \"meta\": {\n          \"lastUpdated\": \"2025-10-10T15:23:50.168175Z\", // Updated by HealthChain Gateway\n          \"source\": \"urn:healthchain:source:epic\",      // Added by HealthChain Gateway\n          \"tag\": [{\n            \"system\": \"https://dotimplement.github.io/HealthChain/fhir/tags\",\n            \"code\": \"aggregated\"\n          }]  // Added by HealthChain Gateway\n        },\n        \"severity\": { \"text\": \"High\" },\n        \"code\": {\n          \"coding\": [\n            {\n              \"system\": \"http://hl7.org/fhir/sid/icd-10-cm\",\n              \"code\": \"J20.9\",\n              \"display\": \"Acute bronchitis, unspecified\"\n            },\n            {\n              \"system\": \"http://snomed.info/sct\",\n              \"code\": \"405944004\",\n              \"display\": \"Asthmatic Bronchitis\"\n            }\n          ],\n          \"text\": \"Bronchitis with asthma, acute\"\n        },\n        \"onsetDateTime\": \"2019-05-24\",\n        \"note\": [{\n          \"text\": \"This resource has been processed by healthchain pipeline\"\n        }]  // Added by HealthChain Pipeline\n      }\n    }\n  ]\n}\n</code></pre> OperationOutcome: Authorization warnings <p>You'll see this if you haven't authorized access to the correct FHIR resources when you set up your FHIR sandbox.</p> <pre><code>print([outcome.model_dump() for outcome in doc.fhir.operation_outcomes])\n</code></pre> <pre><code>{\n  \"resourceType\": \"OperationOutcome\",\n  \"meta\": {\n    \"source\": \"urn:healthchain:source:epic\"\n  },\n  \"issue\": [\n    {\n      \"severity\": \"warning\",\n      \"code\": \"suppressed\",\n      \"details\": {\n        \"coding\": [{\n          \"system\": \"urn:oid:1.2.840.114350.1.13.0.1.7.2.657369\",\n          \"code\": \"59204\"\n        }]\n      },\n      \"diagnostics\": \"Client not authorized for Condition - Encounter Diagnosis\"\n    },\n    {\n      \"severity\": \"warning\",\n      \"code\": \"suppressed\",\n      \"diagnostics\": \"Client not authorized for Condition - Health Concerns\"\n    },\n    {\n      \"severity\": \"warning\",\n      \"code\": \"suppressed\",\n      \"diagnostics\": \"Client not authorized for Condition - Medical History\"\n    }\n  ]\n}\n</code></pre> Expected Error Handling <p>You'll see this when querying a patient that doesn't exist in a source:</p> <pre><code>Error from cerner: [FHIR request failed: 400 - Unknown error]\nsearch &lt;class 'fhir.resources.condition.Condition'&gt; failed:\nResource could not be parsed or failed basic FHIR validation rules\n</code></pre>"},{"location":"cookbook/multi_ehr_aggregation/#what-youve-built","title":"What You've Built","text":"<p>A production-ready data aggregation service with:</p> <ul> <li>Multi-vendor support - Query Epic, Cerner, and other FHIR sources simultaneously</li> <li>Automatic provenance tracking - <code>meta.source</code> field shows which EHR each resource came from</li> <li>Error resilience - Handles missing patients, network failures, auth issues gracefully</li> <li>Deduplication - Merges identical conditions across sources</li> <li>Pipeline extensibility - Add custom processing for terminology mapping, NLP, or quality checks</li> </ul> <p>Use Cases</p> <ul> <li> <p>Data Harmonization: Use pipelines to normalize terminology (ICD-10 \u2194 SNOMED CT), validate completeness, and flag inconsistencies across sources. Combine with clinical NLP engines to extract and aggregate data from unstructured clinical notes alongside structured FHIR resources.</p> </li> <li> <p>RAG Systems: Build retrieval systems that search across multiple health systems. The aggregator provides the unified patient context LLMs need for clinical reasoning.</p> </li> <li> <p>Training Data for AI Models: Aggregate diverse patient data across EHR vendors for model training. Provenance tags enable stratified analysis (e.g., \"how does model performance vary by data source?\").</p> </li> </ul> <p>Next Steps</p> <ul> <li>Try another FHIR server: Set up a different FHIR server where you can upload the same test patients to multiple instances for true multi-source aggregation.</li> <li>Expand resource types: Change <code>Condition</code> to <code>MedicationStatement</code>, <code>Observation</code>, or <code>Procedure</code> to aggregate different data.</li> <li>Add processing: Extend the pipeline with terminology mapping, entity extraction, or quality checks.</li> <li>Build on it: Use aggregated data in the Clinical Coding tutorial or feed it to your LLM application.</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/","title":"Working with FHIR Sandboxes","text":"<p>This guide covers setting up access to public FHIR sandboxes for testing and development. These sandboxes provide free access to test data and realistic FHIR APIs without requiring production EHR credentials.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#epic-on-fhir-sandbox","title":"Epic on FHIR Sandbox","text":"<p>Epic provides a public testing sandbox with sample patients and resource specifications available for developing against their FHIR Server.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Free Epic on FHIR developer account: https://fhir.epic.com/</li> <li>No existing Epic customer account required (it only takes a minute)</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#step-1-create-an-app","title":"Step 1: Create an App","text":"<ol> <li>Log in to https://fhir.epic.com/</li> </ol> <ol> <li>Navigate to \"Build Apps\" \u2192 \"Create\"</li> </ol> <ol> <li>Fill out the application form:</li> <li>Application Name: Choose any descriptive name</li> <li>Application Type: Check \"Backend Systems\"</li> <li>FHIR APIs: Select the APIs you need (note the versions)</li> </ol>"},{"location":"cookbook/setup_fhir_sandboxes/#step-2-configure-oauth2-with-jwt-authentication","title":"Step 2: Configure OAuth2 with JWT Authentication","text":"<p>Epic uses OAuth2 with JWT assertion for authentication.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#generate-key-pair","title":"Generate Key Pair","text":"<p>Follow Epic's instructions to create a Public Private key pair for JWT signature:</p> <pre><code># Generate private key - make sure the key length is at least 2048 bits.\nopenssl genrsa -out privatekey.pem 2048\n\n# Export public key as base64 encoded X.509 certificate\nopenssl req -new -x509 -key privatekey.pem -out publickey509.pem -subj '/CN=myapp'\n</code></pre> <p>Where <code>/CN=myapp</code> is the subject name (e.g., your app name). The subject name doesn't have functional impact but is required for creating an X.509 certificate.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#register-public-key-via-jwks-url","title":"Register Public Key via JWKS URL","text":"<p>Epic now requires registering your public key via a JWKS (JSON Web Key Set) URL instead of direct file upload. For quick and dirty development/testing purposes, you can use ngrok to expose your JWKS server publicly.</p> <ol> <li> <p>Set up a JWKS server:    <pre><code># Ensure your .env has the private key path\n# EPIC_CLIENT_SECRET_PATH=path/to/privatekey.pem\n# EPIC_KEY_ID=healthchain-demo-key\n\npython scripts/serve_jwks.py\n</code></pre></p> </li> <li> <p>Get a free static domain from ngrok:</p> <ul> <li>Sign up at ngrok.com</li> <li>Claim your free static domain from the dashboard</li> <li>Example: <code>your-app.ngrok-free.app</code></li> </ul> </li> <li> <p>Expose your JWKS server:    <pre><code>ngrok http 9999 --domain=your-app.ngrok-free.app\n</code></pre></p> </li> <li> <p>Register in Epic App Orchard:</p> <ul> <li>In your Epic app configuration, locate the Non-Production JWK Set URL field</li> <li>Enter: <code>https://your-app.ngrok-free.app/.well-known/jwks.json</code></li> <li>Click Save</li> <li>Note down your Non-Production Client ID</li> </ul> </li> </ol> <p>The JWKS must be:</p> <ul> <li>Publicly accessible without authentication</li> <li>Served over HTTPS</li> <li>Stable (URL should not change)</li> </ul> <p></p>"},{"location":"cookbook/setup_fhir_sandboxes/#step-3-complete-app-setup","title":"Step 3: Complete App Setup","text":"<ol> <li>Fill out remaining required fields (description, etc.)</li> <li>Check to confirm terms of use</li> <li>Click Save &amp; Ready for Sandbox</li> </ol>"},{"location":"cookbook/setup_fhir_sandboxes/#step-4-configure-environment-variables","title":"Step 4: Configure Environment Variables","text":"<p>Create a <code>.env</code> file with your credentials:</p> <pre><code># .env file\nEPIC_BASE_URL=https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4\nEPIC_CLIENT_ID=your_non_production_client_id\nEPIC_CLIENT_SECRET_PATH=path/to/privatekey.pem\nEPIC_TOKEN_URL=https://fhir.epic.com/interconnect-fhir-oauth/oauth2/token\nEPIC_USE_JWT_ASSERTION=true\nEPIC_KEY_ID=healthchain-demo-key  # Must match the kid in your JWKS\n</code></pre> <p>Important: The <code>EPIC_KEY_ID</code> must match the Key ID (<code>kid</code>) you used when creating your JWKS. This allows Epic to identify which key to use for JWT verification.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#using-epic-sandbox-in-code","title":"Using Epic Sandbox in Code","text":"<pre><code>from healthchain.gateway.clients import FHIRAuthConfig\n\n# Load configuration from environment variables\nconfig = FHIRAuthConfig.from_env(\"EPIC\")\nEPIC_URL = config.to_connection_string()\n\n# Add to FHIR gateway\nfrom healthchain.gateway import FHIRGateway\n\ngateway = FHIRGateway()\ngateway.add_source(\"epic\", EPIC_URL)\n</code></pre>"},{"location":"cookbook/setup_fhir_sandboxes/#testing-your-connection","title":"Testing Your Connection","text":"<p>After configuration:</p> <pre><code>python scripts/check_epic_connection.py\n</code></pre> <p>This script will: 1. Load your Epic configuration 2. Create a JWT assertion with the <code>kid</code> header 3. Request an access token from Epic 4. Test a FHIR endpoint query</p>"},{"location":"cookbook/setup_fhir_sandboxes/#available-test-patients","title":"Available Test Patients","text":"<p>Epic provides sample test patients including:</p> <ul> <li>Derrick Lin - Patient ID: <code>eq081-VQEgP8drUUqCWzHfw3</code></li> <li>Linda Ross - Patient ID: <code>eIXesllypH3M9tAA5WdJftQ3</code></li> <li>Many others with various clinical scenarios</li> </ul> Troubleshooting (click to expand) <p>Token request fails after JWKS registration: - Wait 15-30 minutes for Epic to propagate changes - Verify your JWKS URL is publicly accessible (test in browser) - Check that <code>EPIC_KEY_ID</code> matches the <code>kid</code> in your JWKS - Ensure the ngrok tunnel is still running</p> <p>JWKS format errors: - Verify the JWKS structure at your URL matches Epic's requirements - Check that <code>n</code> and <code>e</code> are properly base64url encoded (no padding) - Algorithm should be RS384, RS256, or RS512</p>"},{"location":"cookbook/setup_fhir_sandboxes/#cerner-sandbox","title":"Cerner Sandbox","text":"<p>Cerner (now Oracle Health) provides both open and secure public sandboxes for the FHIR R4 APIs for Oracle Health Millennium Platform.</p> <p>The Open Sandbox is read-only. It does not require authentication and is handy for quick proof of concepts:</p> <p><pre><code>https://fhir-open.cerner.com/r4/ec2458f2-1e24-41c8-b71b-0e701af7583d/:resource[?:parameters]\n</code></pre> You can get an idea of patients available in the open sandbox by querying some common last names:</p> <pre><code>curl -i -H \"Accept: application/json+fhir\" \"https://fhir-open.cerner.com/r4/ec2458f2-1e24-41c8-b71b-0e701af7583d/Patient?family=smith\"\n</code></pre> <p>Documentation on Secure Sandbox coming soon.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#medplum","title":"Medplum","text":"<p>Medplum is an open-source healthcare platform that provides a compliant FHIR server. It's useful for testing with controlled data where you can upload your own test patients. Medplum uses standard OAuth2/OpenID authentication.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#prerequisites_1","title":"Prerequisites","text":"<ul> <li>Medplum account: Register here</li> <li>Free tier available</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#step-1-create-a-client-application","title":"Step 1: Create a Client Application","text":"<ol> <li>Log in to your Medplum account</li> <li>Navigate to Client Application:</li> <li>Option 1: Use this direct link: ClientApplication</li> <li>Option 2: Click the Medplum logo (top-left) and search for \"Client Application\" in the resources search bar</li> <li>Create a new Client</li> <li>Configure Access Policy if needed:</li> <li>Required for: Production deployments, multi-user environments, restricted data access</li> <li>Optional for: Sandbox testing with personal test data</li> <li>For production setup, see Medplum's access control documentation</li> </ol>"},{"location":"cookbook/setup_fhir_sandboxes/#step-2-get-credentials","title":"Step 2: Get Credentials","text":"<p>After creating the client:</p> <ol> <li>Note your Client ID</li> <li>Copy your Client Secret</li> </ol> <p></p>"},{"location":"cookbook/setup_fhir_sandboxes/#step-3-configure-environment-variables","title":"Step 3: Configure Environment Variables","text":"<p>Create a <code>.env</code> file with your credentials:</p> <pre><code># .env file\nMEDPLUM_BASE_URL=https://api.medplum.com/fhir/R4\nMEDPLUM_CLIENT_ID=your_client_id\nMEDPLUM_CLIENT_SECRET=your_client_secret\nMEDPLUM_TOKEN_URL=https://api.medplum.com/oauth2/token\nMEDPLUM_SCOPE=openid\n</code></pre>"},{"location":"cookbook/setup_fhir_sandboxes/#using-medplum-in-code","title":"Using Medplum in Code","text":"<pre><code>from healthchain.gateway import FHIRGateway\nfrom healthchain.gateway.clients import FHIRAuthConfig\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Load configuration from environment variables\nconfig = FHIRAuthConfig.from_env(\"MEDPLUM\")\nMEDPLUM_URL = config.to_connection_string()\n\n# Add to FHIR gateway\ngateway = FHIRGateway()\ngateway.add_source(\"medplum\", MEDPLUM_URL)\n</code></pre>"},{"location":"cookbook/setup_fhir_sandboxes/#benefits-of-medplum","title":"Benefits of Medplum","text":"<ul> <li>Full control: Upload your own test data</li> <li>FHIR R4 compliant: Complete FHIR API implementation</li> <li>Multi-source testing: Create multiple projects for different data sources</li> <li>Web interface: Browse and manage resources via UI</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#tips-for-multi-source-testing","title":"Tips for Multi-Source Testing","text":""},{"location":"cookbook/setup_fhir_sandboxes/#different-test-data","title":"Different Test Data","text":"<p>Public sandboxes (Epic, Cerner) contain different test patients. When testing multi-source aggregation:</p> <ul> <li>Expected behavior: Queries for patients not in a source should fail gracefully</li> <li>Production use: Map patient identifiers across systems or use sources sharing patient cohorts</li> <li>Controlled testing: Use Medplum where you can upload the same test patients to multiple instances</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#error-handling","title":"Error Handling","text":"<p>Your code should handle:</p> <ul> <li>Network issues or downtime</li> <li>Patient not found in specific sources</li> <li>Rate limiting</li> <li>Authorization failures</li> </ul>"},{"location":"cookbook/setup_fhir_sandboxes/#authentication","title":"Authentication","text":"Sandbox Auth Mechanism Epic OAuth2 with JWT assertion (backend) Medplum OAuth2 client credentials (Client Credentials Flow) <p>HealthChain's FHIRGateway handles these automatically via connection strings.</p>"},{"location":"cookbook/setup_fhir_sandboxes/#next-steps","title":"Next Steps","text":"<ul> <li>Return to your tutorial to continue with the specific use case</li> <li>See FHIR Gateway documentation for advanced configuration</li> <li>Check FHIR Resources documentation for working with different resource types</li> </ul>"},{"location":"reference/","title":"Welcome!","text":""},{"location":"reference/#core-components","title":"Core Components","text":"<ul> <li>Gateway: Connect to multiple healthcare systems and services.</li> <li>Pipeline: Build and manage processing pipelines for healthcare NLP and ML tasks.</li> <li>Sandbox: Test your pipelines in a simulated healthcare environment.</li> <li>Interoperability: Convert between healthcare data formats like FHIR, CDA, and HL7v2.</li> <li>Utilities: Additional tools for development and testing.</li> </ul>"},{"location":"reference/concepts/","title":"Core Concepts","text":"<p>HealthChain has three main components that work together to connect your AI applications to healthcare systems:</p> <ul> <li>Gateway: Connect to multiple healthcare systems with a single API.</li> <li>Pipelines: Easily build data processing pipelines for both clinical text and FHIR data.</li> <li>InteropEngine: Seamlessly convert between data formats like FHIR, HL7 CDA, and HL7v2.</li> </ul>"},{"location":"reference/concepts/#gateway","title":"Gateway","text":"<p>The HealthChainAPI provides a unified interface for connecting your AI application and models to multiple healthcare systems through a single API. It automatically handles FHIR API, CDS Hooks, and SOAP/CDA protocols with OAuth2 authentication.</p> <p>(Full Documentation on Gateway)</p> <pre><code>from healthchain.gateway import HealthChainAPI, FHIRGateway\nfrom fhir.resources.patient import Patient\n\n# Create your healthcare application\napp = HealthChainAPI(title=\"My Healthcare AI App\")\n\n# Connect to multiple FHIR servers\nfhir = FHIRGateway()\nfhir.add_source(\"epic\", \"fhir://fhir.epic.com/r4?client_id=...\")\nfhir.add_source(\"medplum\", \"fhir://api.medplum.com/fhir/R4/?client_id=...\")\n\n# Add AI transformations to FHIR data\n@fhir.transform(Patient)\ndef enhance_patient(id: str, source: str = None) -&gt; Patient:\n    patient = fhir.read(Patient, id, source)\n    # Your AI logic here\n    patient.active = True\n    fhir.update(patient, source)\n    return patient\n\n# Register and run\napp.register_gateway(fhir)\n\n# Available at: GET /fhir/transform/Patient/123?source=epic\n</code></pre>"},{"location":"reference/concepts/#pipeline","title":"Pipeline","text":"<p>HealthChain Pipelines provide a flexible way to build and manage processing pipelines for NLP and ML tasks that can easily integrate with electronic health record (EHR) systems.</p> <p>You can build pipelines with three different approaches:</p>"},{"location":"reference/concepts/#1-quick-inline-functions","title":"1. Quick Inline Functions","text":"<p>For quick experiments, start by picking the right Container when you initialize your pipeline (e.g. <code>Pipeline[Document]()</code> for clinical text).</p> <p>Containers make your pipeline FHIR-native by loading and transforming your data (free text, EHR resources, etc.) into structured FHIR-ready formats. Just add your processing functions with <code>@add_node</code>, compile with <code>.build()</code>, and your pipeline is ready to process FHIR data end-to-end.</p> <p>(Full Documentation on Containers)</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io import Document\nfrom healthchain.fhir import create_condition\n\npipeline = Pipeline[Document]()\n\n@pipeline.add_node\ndef extract_diabetes(doc: Document) -&gt; Document:\n    \"\"\"Adds a FHIR Condition for diabetes if mentioned in the text.\"\"\"\n    if \"diabetes\" in doc.text.lower():\n        condition = create_condition(\n            code=\"73211009\",\n            display=\"Diabetes mellitus\",\n        )\n        doc.fhir.problem_list.append(condition)\n\n    return doc\n\npipe = pipeline.build()\n\ndoc = Document(\"Patient has a history of diabetes.\")\ndoc = pipe(doc)\n\nprint(doc.fhir.problem_list)  # FHIR Condition\n</code></pre>"},{"location":"reference/concepts/#2-build-with-components-and-adapters","title":"2. Build With Components and Adapters","text":"<p>Components are reusable, stateful classes that encapsulate specific processing logic, model loading, or configuration for your pipeline. Use them to organize complex workflows, handle model state, or integrate third-party libraries with minimal setup.</p> <p>HealthChain provides a set of ready-to-use NLP Integrations for common clinical NLP and ML tasks, and you can easily implement your own.</p> <p>(Full Documentation on Components)</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import TextPreProcessor, SpacyNLP, TextPostProcessor\nfrom healthchain.io import Document\n\npipeline = Pipeline[Document]()\n\npipeline.add_node(TextPreProcessor())\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_sci_sm\"))\npipeline.add_node(TextPostProcessor())\n\npipe = pipeline.build()\n\ndoc = Document(\"Patient presents with hypertension.\")\noutput = pipe(doc)\n</code></pre> <p>You can process legacy healthcare data formats too. Adapters convert between healthcare formats like CDA and your pipeline \u2014 just parse, process, and format without worrying about low-level data conversion.</p> <p>(Full Documentation on Adapters)</p> <pre><code>from healthchain.io import CdaAdapter\nfrom healthchain.models import CdaRequest\n\n# Use adapter for format conversion\nadapter = CdaAdapter()\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\n\n# Parse, process, format\ndoc = adapter.parse(cda_request)\nprocessed_doc = pipe(doc)\noutput = adapter.format(processed_doc)\n</code></pre>"},{"location":"reference/concepts/#3-use-prebuilt-pipelines","title":"3. Use Prebuilt Pipelines","text":"<p>Prebuilt pipelines are the fastest way to jump into healthcare AI with minimal setup: just load and run. Each pipeline bundles best-practice components and models for common clinical tasks (like coding or summarization) and handles all FHIR/CDA conversion for you. Easily customize or extend pipelines by adding/removing components, or swap models as needed.</p> <p>(Full Documentation on Pipelines)</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\n# Or load from local model\npipeline = MedicalCodingPipeline.from_local_model(\"./path/to/model\", source=\"spacy\")\n\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\noutput = pipeline.process_request(cda_request)\n</code></pre>"},{"location":"reference/concepts/#interoperability","title":"Interoperability","text":"<p>The HealthChain Interoperability module provides tools for converting between different healthcare data formats, including FHIR, CDA, and HL7v2 messages.</p> <p>(Full Documentation on Interoperability Engine)</p> <pre><code>from healthchain.interop import create_interop, FormatType\n\n# Uses bundled configs - basic CDA \u2194 FHIR conversion\nengine = create_interop()\n\n# Load a CDA document\nwith open(\"tests/data/test_cda.xml\", \"r\") as f:\n    cda_xml = f.read()\n\n# Convert CDA XML to FHIR resources\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Convert FHIR resources back to CDA\ncda_document = engine.from_fhir(fhir_resources, dest_format=FormatType.CDA)\n</code></pre>"},{"location":"reference/concepts/#utilities","title":"Utilities","text":""},{"location":"reference/concepts/#sandbox-client","title":"Sandbox Client","text":"<p>Use SandboxClient to quickly test your app against real-world EHR scenarios like CDS Hooks or Clinical Documentation Improvement (CDI) workflows. Load test datasets, send requests to your service, and validate responses in a few lines of code.</p> <p>(Full Documentation on Sandbox)</p>"},{"location":"reference/concepts/#workflows","title":"Workflows","text":"<p>A workflow represents a specific event in an EHR system that triggers your service (e.g., <code>patient-view</code> when opening a patient chart, <code>encounter-discharge</code> when discharging a patient).</p> <p>Workflows determine the request structure, required FHIR resources, and validation rules. Different workflows are compatible with different protocols:</p> Workflow Type Protocol Example Workflows CDS Hooks REST <code>patient-view</code>, <code>order-select</code>, <code>order-sign</code>, <code>encounter-discharge</code> Clinical Documentation SOAP <code>sign-note-inpatient</code>, <code>sign-note-outpatient</code>"},{"location":"reference/concepts/#available-dataset-loaders","title":"Available Dataset Loaders","text":"<p>Dataset Loaders are shortcuts for loading common clinical test datasets from file. Currently available:</p> Dataset Key Description FHIR Version Source Download Link <code>mimic-on-fhir</code> MIMIC-IV on FHIR Demo Dataset R4 PhysioNet Project Download ZIP (49.5 MB) <code>synthea-patient</code> Synthea FHIR Patient Records R4 Synthea Downloads Download ZIP (100 Sample, 36 MB) <pre><code>from healthchain.sandbox import list_available_datasets\n\n# See all registered datasets with descriptions\ndatasets = list_available_datasets()\nprint(datasets)\n</code></pre>"},{"location":"reference/concepts/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.sandbox import SandboxClient\n\n# Initialize client with your service URL and workflow\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/encounter-discharge\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load test data from a registered dataset\nclient.load_from_registry(\n    \"synthea-patient\",\n    data_dir=\"./data/synthea\",\n    resource_types=[\"Condition\", \"DocumentReference\"],\n    sample_size=3\n)\n\n# Optionally inspect before sending\nclient.preview_requests()  # See what will be sent\nclient.get_status()        # Check client state\n\n# Send requests to your service\nresponses = client.send_requests()\n</code></pre> <p>For clinical documentation workflows using SOAP/CDA:</p> <pre><code># Use context manager for automatic result saving\nwith SandboxClient(\n    url=\"http://localhost:8000/notereader/ProcessDocument\",\n    workflow=\"sign-note-inpatient\",\n    protocol=\"soap\"\n) as client:\n    client.load_from_path(\"./cookbook/data/notereader_cda.xml\")\n    responses = client.send_requests()\n    # Results automatically saved to ./output/ on success\n</code></pre>"},{"location":"reference/concepts/#fhir-helpers","title":"FHIR Helpers","text":"<p>Use <code>healthchain.fhir</code> helpers to quickly create and manipulate FHIR resources (like <code>Condition</code>, <code>Observation</code>, etc.) in your code, ensuring they're standards-compliant with minimal boilerplate.</p> <p>(Full Documentation on FHIR Helpers)</p> <pre><code>from healthchain.fhir import create_condition\n\ncondition = create_condition(\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\",\n    subject=\"Patient/Foo\",\n    clinical_status=\"active\"\n)\n</code></pre>"},{"location":"reference/gateway/api/","title":"HealthChainAPI \ud83c\udfe5","text":"<p>The <code>HealthChainAPI</code> is your main application that coordinates all the different gateways and services.</p> <p>It's a FastAPI app under the hood, so you get all the benefits of FastAPI (automatic docs, type safety, performance) plus healthcare-specific features that makes it easier to work with healthcare data sources, such as FHIR APIs, CDS Hooks, and SOAP/CDA services.</p>"},{"location":"reference/gateway/api/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.gateway import HealthChainAPI, FHIRGateway\nimport uvicorn\n\n# Create your app\napp = HealthChainAPI(\n    title=\"My Healthcare App\",\n    description=\"AI-powered patient care\",\n)\n\n# Add a FHIR gateway\nfhir = FHIRGateway()\napp.register_gateway(fhir)\n\n# Run it (docs automatically available at /docs)\nif __name__ == \"__main__\":\n    uvicorn.run(app)\n</code></pre> <p>You can also register multiple services of different protocols:</p> <pre><code>from healthchain.gateway import (\n    HealthChainAPI, FHIRGateway,\n    CDSHooksService, NoteReaderService\n)\n\napp = HealthChainAPI()\n\n# Register everything you need\napp.register_gateway(FHIRGateway(), path=\"/fhir\")\napp.register_service(CDSHooksService(), path=\"/cds\")\napp.register_service(NoteReaderService(), path=\"/soap\")\n\n# Your API now handles:\n# /fhir/* - Patient data, observations, etc.\n# /cds/* - Real-time clinical alerts\n# /soap/* - Clinical document processing\n</code></pre>"},{"location":"reference/gateway/api/#default-endpoints","title":"Default Endpoints","text":"<p>The HealthChainAPI automatically provides several default endpoints:</p>"},{"location":"reference/gateway/api/#root-endpoint-get","title":"Root Endpoint: <code>GET /</code>","text":"<p>Returns basic API information and registered components.</p> <pre><code>{\n  \"name\": \"HealthChain API\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Healthcare Integration Platform\",\n  \"gateways\": [\"FHIRGateway\"],\n  \"services\": [\"CDSHooksService\", \"NoteReaderService\"]\n}\n</code></pre>"},{"location":"reference/gateway/api/#health-check-get-health","title":"Health Check: <code>GET /health</code>","text":"<p>Simple health check endpoint for monitoring.</p> <pre><code>{\n  \"status\": \"healthy\"\n}\n</code></pre>"},{"location":"reference/gateway/api/#gateway-status-get-gatewaystatus","title":"Gateway Status: <code>GET /gateway/status</code>","text":"<p>Comprehensive status of all registered gateways and services.</p> <pre><code>{\n  \"gateways\": {\n    \"FHIRGateway\": {\n      \"status\": \"active\",\n      \"sources\": [\"epic\", \"cerner\"],\n      \"connection_pool\": {...}\n    }\n  },\n  \"services\": {\n    \"CDSHooksService\": {\n      \"status\": \"active\",\n      \"hooks\": [\"patient-view\", \"order-select\"]\n    }\n  },\n  \"events\": {\n    \"enabled\": true,\n    \"dispatcher\": \"LocalEventDispatcher\"\n  }\n}\n</code></pre>"},{"location":"reference/gateway/api/#event-integration","title":"Event Integration","text":"<p>The HealthChainAPI coordinates events across all registered components. This is useful for auditing, workflow automation, and other use cases. For more information, see the Events page.</p> <pre><code>from healthchain.gateway.events.dispatcher import local_handler\n\napp = HealthChainAPI()\n\n# Register global event handler\n@local_handler.register(event_name=\"fhir.patient.read\")\nasync def log_patient_access(event):\n    event_name, payload = event\n    print(f\"Patient accessed: {payload['resource_id']}\")\n\n# Register handler for all events from specific component\n@local_handler.register(event_name=\"cdshooks.*\")\nasync def log_cds_events(event):\n    event_name, payload = event\n    print(f\"CDS Hook fired: {event_name}\")\n</code></pre>"},{"location":"reference/gateway/api/#dependencies-and-injection","title":"Dependencies and Injection","text":"<p>The HealthChainAPI provides dependency injection for accessing registered components.</p>"},{"location":"reference/gateway/api/#gateway-dependencies","title":"Gateway Dependencies","text":"<pre><code>from healthchain.gateway.api.dependencies import get_gateway\nfrom fastapi import Depends\n\n@app.get(\"/custom/patient/{id}\")\nasync def get_enhanced_patient(\n    id: str,\n    fhir: FHIRGateway = Depends(get_gateway(\"FHIRGateway\"))\n):\n    \"\"\"Custom endpoint using FHIR gateway dependency.\"\"\"\n    patient = await fhir.read(Patient, id)\n    return patient\n\n# Or get all gateways\nfrom healthchain.gateway.api.dependencies import get_all_gateways\n\n@app.get(\"/admin/gateways\")\nasync def list_gateways(\n    gateways: Dict[str, Any] = Depends(get_all_gateways)\n):\n    return {\"gateways\": list(gateways.keys())}\n</code></pre>"},{"location":"reference/gateway/api/#application-dependencies","title":"Application Dependencies","text":"<pre><code>from healthchain.gateway.api.dependencies import get_app\n\n@app.get(\"/admin/status\")\nasync def admin_status(\n    app_instance: HealthChainAPI = Depends(get_app)\n):\n    return {\n        \"gateways\": len(app_instance.gateways),\n        \"services\": len(app_instance.services),\n        \"events_enabled\": app_instance.enable_events\n    }\n</code></pre>"},{"location":"reference/gateway/api/#see-also","title":"See Also","text":"<ul> <li>FHIR Gateway: Complete FHIR operations reference</li> <li>CDS Hooks Service: Complete CDS Hooks service reference</li> <li>NoteReader Service: Complete NoteReader service reference</li> </ul>"},{"location":"reference/gateway/cdshooks/","title":"CDS Hooks Protocol","text":"<p>CDS Hooks is an HL7 published specification for clinical decision support that enables external services to provide real-time recommendations during clinical workflows.</p>"},{"location":"reference/gateway/cdshooks/#overview","title":"Overview","text":"<p>CDS hooks are triggered at specific events during a clinician's workflow in an electronic health record (EHR), such as when a patient record is opened or when an order is selected. The hooks communicate using FHIR (Fast Healthcare Interoperability Resources).</p> <p>CDS Hooks are unique in that they are real-time webhooks that are triggered by the EHR, not by external services. This makes them ideal for real-time clinical decision support and alerts, but also trickier to test and debug for a developer. They are also a relatively new standard, so not all EHRs support them yet.</p> When Where What you receive What you send back Common Use Cases Triggered at certain events during a clinician's workflow EHR The context of the event and FHIR resources that are requested by your service \"Cards\" displaying text, actionable suggestions, or links to launch a SMART app Allergy alerts, medication reconciliation, clinical decision support"},{"location":"reference/gateway/cdshooks/#healthchainapi-integration","title":"HealthChainAPI Integration","text":"<p>Use the <code>CDSHooksService</code> with HealthChainAPI to handle CDS Hooks workflows:</p> <pre><code>from healthchain.gateway import HealthChainAPI, CDSHooksService\nfrom healthchain.models import CDSRequest, CDSResponse\n\napp = HealthChainAPI()\ncds = CDSHooksService()\n\n@cds.hook(\"patient-view\", id=\"allergy-alerts\")\ndef check_allergies(request: CDSRequest) -&gt; CDSResponse:\n    # Your AI logic here\n    return CDSResponse(cards=[...])\n\napp.register_service(cds, path=\"/cds\")\n</code></pre>"},{"location":"reference/gateway/cdshooks/#supported-workflows","title":"Supported Workflows","text":"Workflow Name Description Trigger Status <code>patient-view</code> Triggered when a patient chart is opened Opening a patient's chart \u2705 <code>order-select</code> Triggered when a new order is selected Selecting a new order \u23f3 <code>order-sign</code> Triggered when orders are being signed Signing orders \u23f3 <code>encounter-discharge</code> Triggered when a patient is being discharged Discharging a patient \u2705"},{"location":"reference/gateway/cdshooks/#api-endpoints","title":"API Endpoints","text":"<p>When registered with HealthChainAPI, the following endpoints are automatically created:</p> Endpoint Method Function Description <code>/cds-services</code> GET Service Discovery Lists all available CDS services <code>/cds-services/{id}</code> POST Hook Execution Executes the specified CDS hook"},{"location":"reference/gateway/cdshooks/#requestresponse-format","title":"Request/Response Format","text":""},{"location":"reference/gateway/cdshooks/#cdsrequest-example","title":"CDSRequest Example","text":"<pre><code>{\n   \"hookInstance\": \"23f1a303-991f-4118-86c5-11d99a39222e\",\n   \"fhirServer\": \"https://fhir.example.org\",\n   \"hook\": \"patient-view\",\n   \"context\": {\n     \"patientId\": \"1288992\",\n     \"userId\": \"Practitioner/example\"\n    },\n   \"prefetch\": {\n      \"patientToGreet\": {\n        \"resourceType\": \"Patient\",\n        \"gender\": \"male\",\n        \"birthDate\": \"1925-12-23\",\n        \"id\": \"1288992\",\n        \"active\": true\n      }\n   }\n}\n</code></pre>"},{"location":"reference/gateway/cdshooks/#cdsresponse-example","title":"CDSResponse Example","text":"<pre><code>{\n  \"cards\": [{\n    \"summary\": \"Bilirubin: Based on the age of this patient consider overlaying bilirubin results\",\n    \"indicator\": \"info\",\n    \"detail\": \"The focus of this app is to reduce the incidence of severe hyperbilirubinemia...\",\n    \"source\": {\n      \"label\": \"Intermountain\",\n      \"url\": null\n    },\n    \"links\": [{\n      \"label\": \"Bilirubin SMART app\",\n      \"url\": \"https://example.com/launch\",\n      \"type\": \"smart\"\n    }]\n  }]\n}\n</code></pre>"},{"location":"reference/gateway/cdshooks/#supported-fhir-resources","title":"Supported FHIR Resources","text":"<ul> <li><code>Patient</code></li> <li><code>Encounter</code></li> <li><code>Procedure</code></li> <li><code>MedicationRequest</code></li> </ul> <p>For more information, see the official CDS Hooks documentation.</p>"},{"location":"reference/gateway/cdshooks/#advanced-workflow-example","title":"Advanced Workflow Example","text":"<p>This example demonstrates how to build a custom CDS Hooks workflow that performs advanced clinical analysis and generates tailored decision support cards. By combining adapters and a custom pipeline, you can process incoming FHIR data, apply your own logic (such as risk assessment), and return dynamic CDS cards to the EHR.</p> <pre><code>from healthchain.io import CdsFhirAdapter, Document\nfrom healthchain.pipeline import Pipeline\nfrom healthchain.pipeline.components import CdsCardCreator\nfrom healthchain.models import CDSRequest, CDSResponse\nfrom healthchain.gateway import HealthChainAPI, CDSHooksService\n\n# Build custom pipeline with analysis and card creation\npipeline = Pipeline([Document])\n\n@pipeline.add_node\ndef analyze_patient_data(doc: Document) -&gt; Document:\n    \"\"\"Custom function to analyze patient data and document content\"\"\"\n    # Access FHIR prefetch resources\n    patient = doc.fhir.get_prefetch_resources(\"patient\")\n    document_ref = doc.fhir.get_prefetch_resources(\"document\")\n\n    # Perform custom analysis\n    if patient:\n        age = 2024 - int(patient.birthDate[:4])  # Simple age calculation\n        if age &gt; 65:\n            doc._custom_analysis = {\"high_risk\": True, \"reason\": \"Age &gt; 65\"}\n        else:\n            doc._custom_analysis = {\"high_risk\": False}\n    return doc\n\n# Add card creator to format output\npipeline.add_node(CdsCardCreator(\n    template='{\"summary\": \"Risk Assessment\", \"detail\": \"Patient risk level: {{ high_risk }}\"}'\n))\n\npipe = pipeline.build()\n\n# Set up CDS service with custom workflow\napp = HealthChainAPI()\ncds = CDSHooksService()\n\n@cds.hook(\"encounter-discharge\", id=\"risk-assessment\")\ndef assess_patient_risk(request: CDSRequest) -&gt; CDSResponse:\n    # Use adapter for explicit format conversion\n    adapter = CdsFhirAdapter()\n\n    # Manual conversion with full document access\n    doc = adapter.parse(request)        # CDSRequest \u2192 Document\n    processed_doc = pipe(doc)           # Custom analysis + card creation\n\n    # Convert back to CDS response\n    return adapter.format(processed_doc)  # Document \u2192 CDSResponse\n\napp.register_service(cds, path=\"/cds\")\n</code></pre>"},{"location":"reference/gateway/events/","title":"Events","text":"<p>The FHIR Gateway emits events for all operations. The events are emitted using the <code>EventDispatcher</code>.</p> <p>Develoment Use Only</p> <p>This is a development feature and may change in future releases.</p>"},{"location":"reference/gateway/events/#event-system","title":"Event System","text":"<p>The FHIR Gateway uses the <code>EventDispatcher</code> to emit events.</p>"},{"location":"reference/gateway/events/#event-types","title":"Event Types","text":"<ul> <li><code>ehr.generic</code></li> <li><code>fhir.read</code></li> <li><code>fhir.search</code></li> <li><code>fhir.update</code></li> <li><code>fhir.delete</code></li> <li><code>fhir.create</code></li> <li><code>cds.patient.view</code></li> <li><code>cds.encounter.discharge</code></li> <li><code>cds.order.sign</code></li> <li><code>cds.order.select</code></li> <li><code>notereader.sign.note</code></li> <li><code>notereader.process.note</code></li> </ul>"},{"location":"reference/gateway/events/#automatic-events","title":"Automatic Events","text":"<p>The FHIR Gateway automatically emits events for all operations:</p> <pre><code>from healthchain.gateway.events.dispatcher import local_handler\n\n# Listen for FHIR read events\n@local_handler.register(event_name=\"fhir.read\")\nasync def audit_fhir_access(event):\n    event_name, payload = event\n    print(f\"FHIR Read: {payload['resource_type']}/{payload['resource_id']} from {payload.get('source', 'unknown')}\")\n\n# Listen for patient-specific events\n@local_handler.register(event_name=\"fhir.patient.*\")\nasync def track_patient_access(event):\n    event_name, payload = event\n    operation = event_name.split('.')[-1]  # read, create, update, delete\n    print(f\"Patient {operation}: {payload['resource_id']}\")\n</code></pre>"},{"location":"reference/gateway/events/#custom-event-creation","title":"Custom Event Creation","text":"<pre><code># Configure custom event creation\ndef custom_event_creator(operation, resource_type, resource_id, resource=None, source=None):\n    \"\"\"Create custom events with additional metadata.\"\"\"\n    return EHREvent(\n        event_type=EHREventType.FHIR_READ,\n        source_system=source or \"unknown\",\n        timestamp=datetime.now(),\n        payload={\n            \"operation\": operation,\n            \"resource_type\": resource_type,\n            \"resource_id\": resource_id,\n            \"user_id\": get_current_user_id(),  # Your auth system\n            \"session_id\": get_session_id(),\n            \"ip_address\": get_client_ip()\n        },\n        metadata={\n            \"compliance\": \"HIPAA\",\n            \"audit_required\": True\n        }\n    )\n\n# Apply to gateway\ngateway.events.set_event_creator(custom_event_creator)\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/","title":"FHIR Gateway","text":"<p>The FHIR Gateway provides a unified interface for connecting to multiple FHIR servers with automatic authentication, connection pooling, error handling, and simplified CRUD operations. It comes in two variants:</p> <ul> <li><code>FHIRGateway</code> - Synchronous FHIR client (<code>httpx.Client</code>)</li> <li><code>AsyncFHIRGateway</code> - Asynchronous FHIR client (<code>httpx.AsyncClient</code>)</li> </ul> <p>Both handle the complexity of managing multiple FHIR clients and provide a consistent API across different healthcare systems.</p> <p>Sync vs Async: When to Choose What</p> <p>Choose sync for: Getting started, interaction with legacy systems, simpler debugging - safe for most use cases</p> <p>Choose async for: High-throughput scenarios, concurrent requests, modern applications</p> <p>Key difference: Async version includes connection pooling and the <code>modify()</code> context manager for automatic resource saving.</p>"},{"location":"reference/gateway/fhir_gateway/#basic-usage","title":"Basic Usage","text":""},{"location":"reference/gateway/fhir_gateway/#synchronous-gateway","title":"Synchronous Gateway","text":"<pre><code>from healthchain.gateway import FHIRGateway\nfrom fhir.resources.patient import Patient\n\ngateway = FHIRGateway()\n\n# Connect to FHIR server\ngateway.add_source(\n    \"my_fhir_server\",\n    \"fhir://fhir.example.com/api/FHIR/R4/?client_id=your_app&amp;client_secret=secret&amp;token_url=https://fhir.example.com/oauth2/token\"\n)\n\nwith gateway:\n    # FHIR operations\n    patient = gateway.read(Patient, \"123\", \"my_fhir_server\")\n    print(f\"Patient: {patient.name[0].family}\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#asynchronous-gateway","title":"Asynchronous Gateway","text":"<pre><code>import asyncio\n\nfrom healthchain.gateway import AsyncFHIRGateway\nfrom fhir.resources.patient import Patient\n\ngateway = AsyncFHIRGateway()\n\n# Connect to FHIR server\ngateway.add_source(\n    \"my_fhir_server\",\n    \"fhir://fhir.example.com/api/FHIR/R4/?client_id=your_app&amp;client_secret=secret&amp;token_url=https://fhir.example.com/oauth2/token\"\n)\n\nasync with gateway:\n    # Fetch multiple resources concurrently\n    tasks = [\n        gateway.read(Patient, \"123\", \"my_fhir_server\"),\n        gateway.read(Patient, \"456\", \"my_fhir_server\"),\n        gateway.read(Patient, \"789\", \"my_fhir_server\")\n    ]\n    patients = await asyncio.gather(*tasks)\n\n    for patient in patients:\n        print(f\"Patient: {patient.name[0].family}\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#adding-sources","title":"Adding Sources \ud83c\udfe5","text":"<p>The gateway currently supports adding sources with OAuth2 authentication flow.</p> <pre><code># Epic Sandbox (JWT assertion)\ngateway.add_source(\n    \"epic\",\n    (\n        \"fhir://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4/\"\n        \"?client_id=your_app\"\n        \"&amp;client_secret_path=keys/private.pem\"\n        \"&amp;token_url=https://fhir.epic.com/interconnect-fhir-oauth/oauth2/token\"\n        \"&amp;use_jwt_assertion=true\"\n    )\n)\n\n# Medplum (Client Credentials)\ngateway.add_source(\n    \"medplum\",\n    (\n        \"fhir://api.medplum.com/fhir/R4/\"\n        \"?client_id=your_app\"\n        \"&amp;client_secret=secret\"\n        \"&amp;token_url=https://api.medplum.com/oauth2/token\"\n        \"&amp;scope=openid\"\n    )\n)\n</code></pre> <p>For more information on configuring specific FHIR servers</p> <p>Epic FHIR API:</p> <ul> <li>Epic on FHIR Documentation</li> <li>Epic OAuth2 Setup</li> <li>Test Patients in Epic Sandbox</li> <li>Useful Epic Sandbox Setup Guide</li> </ul> <p>Medplum FHIR API:</p> <ul> <li>Medplum app tutorial</li> <li>Medplum OAuth2 Client Credentials Setup</li> </ul> <p>General Resources:</p> <ul> <li>OAuth2</li> <li>FHIR RESTful API</li> <li>FHIR Specification</li> </ul>"},{"location":"reference/gateway/fhir_gateway/#connection-string-format","title":"Connection String Format","text":"<p>Connection strings use the <code>fhir://</code> scheme with query parameters:</p> <pre><code>fhir://hostname:port/path?param1=value1&amp;param2=value2\n</code></pre> <p>Required Parameters:</p> <ul> <li><code>client_id</code>: OAuth2 client ID</li> <li><code>token_url</code>: OAuth2 token endpoint</li> </ul> <p>Optional Parameters:</p> <ul> <li><code>client_secret</code>: OAuth2 client secret (for client credentials flow)</li> <li><code>client_secret_path</code>: Path to private key file (for JWT assertion)</li> <li><code>scope</code>: OAuth2 scope (default: \"<code>system/*.read system/*.write</code>\")</li> <li><code>use_jwt_assertion</code>: Use JWT assertion flow (default: false)</li> <li><code>audience</code>: Token audience (for some servers)</li> </ul>"},{"location":"reference/gateway/fhir_gateway/#fhir-operations","title":"FHIR Operations \ud83d\udd25","text":"<p>Note</p> <p>These examples assume you have already created and configured your gateway as shown in the Basic Usage section above.</p>"},{"location":"reference/gateway/fhir_gateway/#create-resources","title":"Create Resources","text":"<pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.humanname import HumanName\n\n# Create a new patient\npatient = Patient(\n    name=[HumanName(family=\"Smith\", given=[\"John\"])],\n    gender=\"male\",\n    birthDate=\"1990-01-01\"\n)\n\ncreated_patient = gateway.create(resource=patient, source=\"medplum\")\nprint(f\"Created patient with ID: {created_patient.id}\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#read-resources","title":"Read Resources","text":"<pre><code>from fhir.resources.patient import Patient\n\n# Read a specific patient (Derrick Lin, Epic Sandbox)\npatient = gateway.read(\n    resource_type=Patient,\n    fhir_id=\"eq081-VQEgP8drUUqCWzHfw3\",\n    source=\"epic\"\n)\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#update-resources","title":"Update Resources","text":"SyncAsync <pre><code>from fhir.resources.patient import Patient\n\n# Read, modify, and update (sync)\npatient = gateway.read(Patient, \"123\", \"medplum\")\npatient.name[0].family = \"Johnson\"\nupdated_patient = gateway.update(patient, \"medplum\")\n</code></pre> <pre><code>from fhir.resources.patient import Patient\n\n# Read, modify, and update (async)\npatient = await gateway.read(Patient, \"123\", \"medplum\")\npatient.name[0].family = \"Johnson\"\nupdated_patient = await gateway.update(patient, \"medplum\")\n\n# Using async context manager - automatically saves on exit\nasync with gateway.modify(Patient, \"123\", \"medplum\") as patient:\n    patient.active = True\n    patient.name[0].given = [\"Jane\"]\n    # Automatic save on exit\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#delete-resources","title":"Delete Resources","text":"<pre><code>from fhir.resources.patient import Patient\n\n# Delete a patient\nsuccess = gateway.delete(Patient, \"123\", \"medplum\")\nif success:\n    print(\"Patient deleted successfully\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#search-operations","title":"Search Operations","text":""},{"location":"reference/gateway/fhir_gateway/#basic-search","title":"Basic Search","text":"<pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.bundle import Bundle\n\n# Search by name\nsearch_params = {\"family\": \"Smith\", \"given\": \"John\"}\nresults: Bundle = gateway.search(Patient, search_params, \"epic\")\n\nfor entry in results.entry:\n    patient = entry.resource\n    print(f\"Found: {patient.name[0].family}, {patient.name[0].given[0]}\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#advanced-search","title":"Advanced Search","text":"<pre><code>from fhir.resources.patient import Patient\n\n# Complex search with multiple parameters\nsearch_params = {\n    \"birthdate\": \"1990-01-01\",\n    \"gender\": \"male\",\n    \"address-city\": \"Boston\",\n    \"_count\": 50,\n    \"_sort\": \"family\"\n}\n\nresults = gateway.search(Patient, search_params, \"epic\")\nprint(f\"Found {len(results.entry)} patients\")\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#transform-handlers","title":"Transform Handlers \ud83e\udd16","text":"<p>Transform handlers allow you to create custom API endpoints that process and enhance FHIR resources with additional logic, AI insights, or data transformations before returning them to clients. These handlers run before the response is sent, enabling real-time data enrichment and processing.</p> SyncAsync <pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.observation import Observation\n\n@fhir_gateway.transform(Patient)\ndef get_enhanced_patient_summary(id: str, source: str = None) -&gt; Patient:\n    \"\"\"Create enhanced patient summary with AI insights\"\"\"\n\n    # Read the patient\n    patient = fhir_gateway.read(Patient, id, source)\n\n    # Get lab results\n    lab_results = fhir_gateway.search(\n        resource_type=Observation,\n        search_params={\"patient\": id, \"category\": \"laboratory\"},\n        source=source\n    )\n    insights = nlp_pipeline.process(patient, lab_results)\n\n    # Add AI summary\n    patient.extension = patient.extension or []\n    patient.extension.append({\n        \"url\": \"http://healthchain.org/fhir/summary\",\n        \"valueString\": insights.summary\n    })\n\n    # Update the patient\n    fhir_gateway.update(patient, source)\n\n    return patient\n\n# The handler is automatically called via HTTP endpoint:\n# GET /fhir/transform/Patient/123?source=epic\n</code></pre> <pre><code>from fhir.resources.patient import Patient\nfrom fhir.resources.observation import Observation\n\n@fhir_gateway.transform(Patient)\nasync def get_enhanced_patient_summary(id: str, source: str = None) -&gt; Patient:\n\n    # Use the context manager to modify the patient\n    async with fhir_gateway.modify(Patient, id, source=source) as patient:\n        # Get lab results\n        lab_results = await fhir_gateway.search(\n            resource_type=Observation,\n            search_params={\"patient\": id, \"category\": \"laboratory\"},\n            source=source\n        )\n        insights = nlp_pipeline.process(patient, lab_results)\n\n        # Add AI summary\n        patient.extension = patient.extension or []\n        patient.extension.append({\n            \"url\": \"http://healthchain.org/fhir/summary\",\n            \"valueString\": insights.summary\n        })\n\n        return patient\n\n# The handler is automatically called via HTTP endpoint:\n# GET /fhir/transform/Patient/123?source=epic\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#aggregate-handlers","title":"Aggregate Handlers \ud83d\udd17","text":"<p>Aggregate handlers allow you to combine data from multiple FHIR sources into a single resource. This is useful for creating unified views across different EHR systems or consolidating patient data from various healthcare providers.</p> SyncAsync <pre><code>from fhir.resources.observation import Observation\nfrom fhir.resources.bundle import Bundle\n\n@gateway.aggregate(Observation)\ndef aggregate_vitals(patient_id: str, sources: list = None) -&gt; Bundle:\n    \"\"\"Aggregate vital signs from multiple sources.\"\"\"\n    sources = sources or [\"epic\", \"cerner\"]\n    all_observations = []\n\n    for source in sources:\n        try:\n            results = gateway.search(\n                Observation,\n                {\"patient\": patient_id, \"category\": \"vital-signs\"},\n                source\n            )\n            processed_observations = process_observations(results)\n            all_observations.append(processed_observations)\n        except Exception as e:\n            print(f\"Could not get vitals from {source}: {e}\")\n\n    return Bundle(type=\"searchset\", entry=[{\"resource\": obs} for obs in all_observations])\n\n# The handler is automatically called via HTTP endpoint:\n# GET /fhir/aggregate/Observation?patient_id=123&amp;sources=epic&amp;sources=cerner\n</code></pre> <pre><code>from fhir.resources.observation import Observation\nfrom fhir.resources.bundle import Bundle\n\n@gateway.aggregate(Observation)\nasync def aggregate_vitals(patient_id: str, sources: list = None) -&gt; Bundle:\n    \"\"\"Aggregate vital signs from multiple sources.\"\"\"\n    sources = sources or [\"epic\", \"cerner\"]\n    all_observations = []\n\n    for source in sources:\n        try:\n            results = await gateway.search(\n                Observation,\n                {\"patient\": patient_id, \"category\": \"vital-signs\"},\n                source\n            )\n            processed_observations = process_observations(results)\n            all_observations.append(processed_observations)\n        except Exception as e:\n            print(f\"Could not get vitals from {source}: {e}\")\n\n    return Bundle(type=\"searchset\", entry=[{\"resource\": obs} for obs in all_observations])\n\n# The handler is automatically called via HTTP endpoint:\n# GET /fhir/aggregate/Observation?patient_id=123&amp;sources=epic&amp;sources=cerner\n</code></pre>"},{"location":"reference/gateway/fhir_gateway/#server-capabilities","title":"Server Capabilities","text":"<ul> <li>GET <code>/fhir/metadata</code> - Returns FHIR-style <code>CapabilityStatement</code> of transform and aggregate endpoints</li> <li>GET <code>/fhir/status</code> - Returns Gateway status and connection health</li> </ul>"},{"location":"reference/gateway/fhir_gateway/#connection-pool-management-async-only","title":"Connection Pool Management (Async Only)","text":"<p>When you add a connection to a FHIR server, the async gateway will automatically add it to a connection pool to manage connections to FHIR servers.</p>"},{"location":"reference/gateway/fhir_gateway/#pool-configuration","title":"Pool Configuration","text":"<pre><code># Create gateway with optimized connection settings\ngateway = AsyncFHIRGateway(\n    max_connections=100,           # Total connections across all sources\n    max_keepalive_connections=20,  # Keep-alive connections per source\n    keepalive_expiry=30.0,         # Keep connections alive for 30 seconds\n)\n\n# Add multiple sources - they share the connection pool\ngateway.add_source(\"epic\", \"fhir://epic.org/...\")\ngateway.add_source(\"cerner\", \"fhir://cerner.org/...\")\ngateway.add_source(\"medplum\", \"fhir://medplum.com/...\")\n\nstats = gateway.get_pool_status()\nprint(stats)\n</code></pre>"},{"location":"reference/gateway/gateway/","title":"Gateway","text":"<p>The HealthChain Gateway module provides a secure integration layer for connecting your NLP/ML pipelines with multiple healthcare systems.</p> <p>It provides a unified interface for connecting to FHIR servers, CDS Hooks, and SOAP/CDA services and is designed to be used in conjunction with the HealthChainAPI to create a complete healthcare integration platform.</p>"},{"location":"reference/gateway/gateway/#features","title":"Features \ud83d\ude80","text":"<p>The Gateway handles the complex parts of healthcare integration:</p> <ul> <li>Multiple Protocols: Works with FHIR RESTful APIs, CDS Hooks, and Epic NoteReader CDI (SOAP/CDA service) out of the box</li> <li>Multi-Source: Context managers to work with data from multiple EHR systems and FHIR servers safely</li> <li>Smart Connections: Handles OAuth2.0 authentication, connection pooling, and automatic token refresh</li> <li>Event-Driven: Native asyncio support for real-time events, audit trails, and workflow automation</li> <li>Transform &amp; Aggregate: FastAPI-style declarative patterns to create endpoints for enhancing and combining data</li> <li>Developer-Friendly: Modern Python typing and validation support via fhir.resources (powered by Pydantic), protocol-based interfaces, and informative error messages</li> </ul>"},{"location":"reference/gateway/gateway/#key-components","title":"Key Components","text":"Component Description Use Case HealthChainAPI FastAPI app with gateway and service registration Main app that coordinates everything FHIRGateway Sync and async FHIR client with connection pooling and authentication Reading/writing patient data from EHRs (Epic, Cerner, etc.) or application FHIR servers (Medplum, Hapi etc.) CDSHooksService Clinical Decision Support hooks service Real-time alerts and recommendations NoteReaderService SOAP/CDA document processing service Processing clinical documents and notes Event System Event-driven integration Audit trails, workflow automation"},{"location":"reference/gateway/gateway/#basic-usage","title":"Basic Usage","text":"SyncAsync <pre><code>from healthchain.gateway import HealthChainAPI, FHIRGateway\nfrom fhir.resources.patient import Patient\n\n# Create the application\napp = HealthChainAPI()\n\n# Synchronous FHIR gateway\nfhir = FHIRGateway()\nfhir.add_source(\"epic\", \"fhir://epic.org/api/FHIR/R4?client_id=...\")\n\n@fhir.transform(Patient)\ndef enhance_patient(id: str, source: str = None) -&gt; Patient:\n    patient = fhir.read(Patient, id, source)\n    patient.active = True  # Your custom logic here\n    fhir.update(patient, source)\n    return patient\n\napp.register_gateway(fhir)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app)\n    # Default: http://127.0.0.1:8000/\n</code></pre> <pre><code>from healthchain.gateway import HealthChainAPI, AsyncFHIRGateway\nfrom fhir.resources.patient import Patient\n\n# Create the application\napp = HealthChainAPI()\n\n# Asynchronous FHIR gateway\nasync_fhir = AsyncFHIRGateway()\nasync_fhir.add_source(\"medplum\", \"fhir://api.medplum.com/fhir/R4/?client_id=...\")\n\n@async_fhir.transform(Patient)\nasync def enhance_patient_async(id: str, source: str = None) -&gt; Patient:\n    # modify is a context manager that allows you to modify the patient resource\n    async with async_fhir.modify(Patient, id, source) as patient:\n        patient.active = True  # Your custom logic here\n        return patient\n\napp.register_gateway(async_fhir)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app)\n</code></pre> <p>You can also register multiple services of different protocols:</p> <pre><code>from healthchain.gateway import (\n    HealthChainAPI, FHIRGateway,\n    CDSHooksService, NoteReaderService\n)\n\napp = HealthChainAPI()\n\n# FHIR for patient data\nfhir = FHIRGateway()\nfhir.add_source(\"epic\", \"fhir://fhir.epic.com/r4?...\")\n\n# CDS Hooks for real-time alerts\ncds = CDSHooksService()\n\n@cds.hook(\"patient-view\", id=\"allergy-alerts\")\ndef check_allergies(request):\n    # Your logic here\n    return {\"cards\": [...]}\n\n# SOAP for clinical documents\nnotes = NoteReaderService()\n\n@notes.method(\"ProcessDocument\")\ndef process_note(request):\n    # Your NLP pipeline here\n    return processed_document\n\n# Register everything\napp.register_gateway(fhir)\napp.register_service(cds)\napp.register_service(notes)\n</code></pre>"},{"location":"reference/gateway/gateway/#protocol-support","title":"Protocol Support","text":"Protocol Implementation Features FHIR API <code>FHIRGateway</code><code>AsyncFHIRGateway</code> FHIR-instance level CRUD operations - read, create, update, delete, search, register <code>transform</code> and <code>aggregate</code> handlers, connection pooling and authentication management CDS Hooks <code>CDSHooksService</code> Hook Registration, Service Discovery SOAP/CDA <code>NoteReaderService</code> Method Registration (<code>ProcessDocument</code>), SOAP Service Discovery (WSDL)"},{"location":"reference/gateway/soap_cda/","title":"SOAP/CDA Protocol","text":"<p>The SOAP/CDA protocol enables real-time Clinical Documentation Improvement (CDI) services. This implementation follows the Epic-integrated NoteReader CDI specification for analyzing clinical notes and extracting structured data.</p>"},{"location":"reference/gateway/soap_cda/#overview","title":"Overview","text":"<p>Clinical Documentation workflows communicate using CDA (Clinical Document Architecture). CDAs are standardized electronic documents for exchanging clinical information between different healthcare systems. They provide a common structure for capturing and sharing patient data like medical history, medications, and care plans between different healthcare systems and providers. Think of it as a collaborative Google Doc that you can add, amend, and remove entries from. CDA support is currently limited to Epic systems, but we plan to add support for other IHE SOAP/CDA services in the future.</p>"},{"location":"reference/gateway/soap_cda/#epic-notereader-cdi","title":"Epic NoteReader CDI","text":"<p>The Epic NoteReader CDI is a SOAP/CDA-based NLP service that extracts structured data from clinical notes. Like CDS Hooks, it operates in real-time and is triggered when a clinician opts into CDI functionality and signs or pends a note.</p> <p>The primary use case for Epic NoteReader is to convert free-text medical documentation into coded information that can be used for billing, quality reporting, continuity of care, and clinical decision support at the point-of-care (example).</p> When Where What you receive What you send back Triggered when a clinician opts in to CDI functionality and signs or pends a note EHR documentation modules (e.g. NoteReader in Epic) A CDA document containing continuity of care data and free-text clinical notes A CDA document with additional structured data extracted by your CDI service"},{"location":"reference/gateway/soap_cda/#cda-services","title":"CDA Services","text":"<p>CDA services facilitate the exchange of clinical information between different healthcare systems and are governed by the IHE standard. The Epic HIE (Health Information Exchange) platform is CareEverywhere.</p>"},{"location":"reference/gateway/soap_cda/#healthchainapi-integration","title":"HealthChainAPI Integration","text":"<p>Use the <code>NoteReaderService</code> with HealthChainAPI to handle SOAP/CDA workflows:</p> <pre><code>from healthchain.gateway import HealthChainAPI, NoteReaderService\nfrom healthchain.models import CdaRequest, CdaResponse\n\napp = HealthChainAPI()\nnotes = NoteReaderService()\n\n@notes.method(\"ProcessDocument\")\ndef process_note(request: CdaRequest) -&gt; CdaResponse:\n    # Your NLP pipeline here\n    processed_document = nlp_pipeline.process(request)\n    return processed_document\n\napp.register_service(notes, path=\"/soap\")\n</code></pre>"},{"location":"reference/gateway/soap_cda/#supported-workflows","title":"Supported Workflows","text":"Workflow Name Description Trigger Status <code>sign-note-inpatient</code> CDI processing for inpatient clinical notes Signing or pending a note in Epic inpatient setting \u2705 <code>sign-note-outpatient</code> CDI processing for outpatient clinical notes Signing or pending a note in Epic outpatient setting \u23f3 <p>Currently supports parsing of problems, medications, and allergies sections.</p>"},{"location":"reference/gateway/soap_cda/#api-endpoints","title":"API Endpoints","text":"<p>When registered with HealthChainAPI, the following endpoints are automatically created:</p> Endpoint Method Function Protocol <code>/notereader/</code> POST <code>process_notereader_document</code> SOAP <p>Note: NoteReader is a vendor-specific component (Epic). Different EHR vendors have varying support for third-party CDI services.</p>"},{"location":"reference/gateway/soap_cda/#requestresponse-format","title":"Request/Response Format","text":""},{"location":"reference/gateway/soap_cda/#cda-request-example","title":"CDA Request Example","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;typeId root=\"2.16.840.1.113883.1.3\" extension=\"POCD_HD000040\"/&gt;\n  &lt;templateId root=\"2.16.840.1.113883.10.20.22.1.2\"/&gt;\n  &lt;id root=\"2.16.840.1.113883.19.5.99999.1\"/&gt;\n  &lt;code code=\"34133-9\" displayName=\"Summarization of Episode Note\"\n        codeSystem=\"2.16.840.1.113883.6.1\" codeSystemName=\"LOINC\"/&gt;\n  &lt;title&gt;CDA Document with Problem List and Progress Note&lt;/title&gt;\n  &lt;effectiveTime value=\"20240712\"/&gt;\n  &lt;confidentialityCode code=\"N\" codeSystem=\"2.16.840.1.113883.5.25\"/&gt;\n  &lt;languageCode code=\"en-US\"/&gt;\n\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;!-- Problem List Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.5.1\"/&gt;\n          &lt;code code=\"11450-4\" codeSystem=\"2.16.840.1.113883.6.1\"\n                displayName=\"Problem List\"/&gt;\n          &lt;title&gt;Problems&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Hypertension&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;!-- Entry details... --&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n\n      &lt;!-- Progress Note Section --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.65\"/&gt;\n          &lt;code code=\"11506-3\" codeSystem=\"2.16.840.1.113883.6.1\"\n                displayName=\"Progress Note\"/&gt;\n          &lt;title&gt;Progress Note&lt;/title&gt;\n          &lt;text&gt;\n            &lt;paragraph&gt;Patient's blood pressure remains elevated.\n            Discussed lifestyle modifications and medication adherence.\n            Started Lisinopril 10 mg daily for hypertension management.&lt;/paragraph&gt;\n          &lt;/text&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n</code></pre>"},{"location":"reference/gateway/soap_cda/#cda-response-example","title":"CDA Response Example","text":"<p>The response includes additional structured sections extracted from the clinical text:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ClinicalDocument xmlns=\"urn:hl7-org:v3\"&gt;\n  &lt;!-- Header information same as request --&gt;\n\n  &lt;component&gt;\n    &lt;structuredBody&gt;\n      &lt;!-- Original sections plus extracted medications --&gt;\n      &lt;component&gt;\n        &lt;section&gt;\n          &lt;templateId root=\"2.16.840.1.113883.10.20.22.2.1.1\"/&gt;\n          &lt;code code=\"10160-0\" codeSystem=\"2.16.840.1.113883.6.1\"\n                displayName=\"History of medication use\"/&gt;\n          &lt;title&gt;Medications&lt;/title&gt;\n          &lt;text&gt;\n            &lt;list&gt;\n              &lt;item&gt;Lisinopril 10 mg oral tablet, once daily&lt;/item&gt;\n            &lt;/list&gt;\n          &lt;/text&gt;\n          &lt;!-- Structured medication entries extracted by AI... --&gt;\n        &lt;/section&gt;\n      &lt;/component&gt;\n    &lt;/structuredBody&gt;\n  &lt;/component&gt;\n&lt;/ClinicalDocument&gt;\n</code></pre>"},{"location":"reference/gateway/soap_cda/#supported-cda-sections","title":"Supported CDA Sections","text":"<ul> <li>Problems/Conditions: ICD-10/SNOMED CT coded diagnoses</li> <li>Medications: SNOMED CT/RxNorm coded medications with dosage and frequency</li> <li>Allergies: Allergen identification and reaction severity</li> <li>Progress Notes: Free-text clinical documentation</li> </ul>"},{"location":"reference/gateway/soap_cda/#data-flow","title":"Data Flow","text":"Stage Input Output Gateway Receives <code>CdaRequest</code> Processed by your service Gateway Returns Your processed result <code>CdaResponse</code> <p>You can use the CdaAdapter to handle conversion between CDA documents and HealthChain pipeline data containers.</p>"},{"location":"reference/interop/configuration/","title":"Configuration","text":"<p>The interoperability module uses a configuration system to control its behavior. This includes mappings between different healthcare data formats, validation rules, and environment-specific settings.</p>"},{"location":"reference/interop/configuration/#configuration-overview","title":"Configuration Overview","text":"<p>HealthChain works out-of-the-box with default configurations, but you can customize them for your specific needs.</p>"},{"location":"reference/interop/configuration/#default-usage","title":"Default Usage","text":"<pre><code>from healthchain.interop import create_interop\n\n# Uses bundled default configurations\nengine = create_interop()\n</code></pre>"},{"location":"reference/interop/configuration/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Use custom config directory\nengine = create_interop(config_dir=\"/path/to/custom/configs\")\n</code></pre>"},{"location":"reference/interop/configuration/#creating-custom-configs","title":"Creating Custom Configs","text":"<p>To create editable configuration templates:</p> <pre><code># Create customizable config templates\nhealthchain init-configs ./my_configs\n\n# Then use them in your code\nengine = create_interop(config_dir=\"./my_configs\")\n</code></pre> <p>This gives you editable copies of: - Templates: CDA \u2194 FHIR conversion templates - Mappings: Code system mappings (SNOMED, LOINC, etc.) - Validation: Schema validation rules - Environment settings: Development, testing, production configs</p>"},{"location":"reference/interop/configuration/#configuration-components","title":"Configuration Components","text":"Component Description <code>InteropConfigManager</code> Manages access to configuration files and values <code>defaults.yaml</code> Default configuration values for FHIR required fields <code>environments/</code> Environment-specific configuration values <code>interop/</code> Configuration for format specific settings (e.g. CDA, HL7v2) <code>mappings/</code> Mapping tables for codes, identifiers, and terminology systems <code>templates/</code> Templates for generating healthcare documents"},{"location":"reference/interop/configuration/#configuration-structure","title":"Configuration Structure","text":"<p>The configuration system uses <code>YAML</code> files with a hierarchical structure. The main configuration sections include:</p> <ul> <li><code>defaults</code>: Global default values</li> <li><code>cda</code>: Contains CDA specific configurations<ul> <li><code>sections</code>: Configuration for CDA document sections</li> <li><code>document</code>: Configuration for CDA document types</li> </ul> </li> <li><code>mappings</code>: Mappings between different terminology systems</li> <li><code>templates</code>: Template configuration</li> </ul>"},{"location":"reference/interop/configuration/#default-configuration","title":"Default Configuration","text":"<p>The default configuration is stored in <code>configs/defaults.yaml</code> and contains global settings and default fallback values for required fields in FHIR resources in the event that they are not provided in the source document.</p> <pre><code>defaults:\n  # Common defaults for all resources\n  common:\n    id_prefix: \"hc-\"\n    timestamp: \"%Y%m%d\"\n    reference_name: \"#{uuid}name\"\n    subject:\n      reference: \"Patient/example\"\n\n  # Resource-specific defaults\n  resources:\n    Condition:\n      clinicalStatus:\n        coding:\n          - system: \"http://terminology.hl7.org/CodeSystem/condition-clinical\"\n            code: \"unknown\"\n            display: \"Unknown\"\n    MedicationStatement:\n      status: \"unknown\"\n      medication:\n        concept:\n          coding:\n            - system: \"http://terminology.hl7.org/CodeSystem/v3-NullFlavor\"\n              code: \"UNK\"\n              display: \"Unknown\"\n</code></pre>"},{"location":"reference/interop/configuration/#cda-configurations","title":"CDA Configurations","text":"<p>CDA configurations primarily concern the extraction and rendering processes on the document and section level. While Templates are used to define the syntactic structure of the document, the YAML configurations are used to define the semantic content of the document structure, such as template IDs, status codes, and other metadata.</p> <p>Configs are loaded from the <code>configs/interop/cda/</code> directory and loaded in the <code>ConfigManager</code> with the folder and filenames as keys. e.g. given the following directory structure:</p> <p><pre><code>configs/\n  interop/\n    cda/\n      document/\n        ccd.yaml\n      sections/\n        problems.yaml\n</code></pre> The config will be loaded into the config manager under the key <code>cda.document.ccd</code> and <code>cda.sections.problems</code>.</p>"},{"location":"reference/interop/configuration/#example-document-configuration","title":"Example Document Configuration","text":"<pre><code># configs/interop/cda/document/ccd.yaml\n\n# Configured template names in templates/ directory (required)\ntemplates:\n  document: \"fhir_cda/document\"\n  section: \"fhir_cda/section\"\n\n# Basic document information\ncode:\n  code: \"34133-9\"\n  code_system: \"2.16.840.1.113883.6.1\"\n  code_system_name: \"LOINC\"\n  display: \"Summarization of Episode Note\"\nrealm_code: \"GB\"\ntype_id:\n  extension: \"POCD_HD000040\"\n  root: \"2.16.840.1.113883.1.3\"\ntemplate_id:\n  root: \"1.2.840.114350.1.72.1.51693\"\n# ...\n\n# Document structure\nstructure:\n  # Header configuration\n  header:\n    include_patient: false\n    include_author: false\n    include_custodian: false\n\n  # Body configuration\n  body:\n    structured_body: true\n    non_xml_body: false\n    include_sections:\n      - \"allergies\"\n      - \"medications\"\n      - \"problems\"\n</code></pre>"},{"location":"reference/interop/configuration/#example-section-configuration","title":"Example Section Configuration","text":"<pre><code># configs/interop/cda/sections/problems.yaml\n\n# Metadata for both extraction and rendering processes (required)\nresource: \"Condition\" # The FHIR resource this section maps to\nresource_template: \"cda_fhir/condition\" # The template to use for the FHIR resource rendering\nentry_template: \"fhir_cda/problem_entry\" # The template to use for the CDA section entry rendering\n\n# Section identifiers (used for extraction) (required)\nidentifiers:\n  template_id: \"2.16.840.1.113883.10.20.1.11\"\n  code: \"11450-4\"\n\n# Template configuration (used for rendering)\ntemplate:\n  act:\n    template_id:\n      - \"2.16.840.1.113883.10.20.1.27\"\n    status_code: \"completed\"\n    # ...\n</code></pre>"},{"location":"reference/interop/configuration/#mapping-tables","title":"Mapping Tables","text":"<p>Mapping tables are used to translate codes and identifiers between different terminology systems. These are stored in the <code>mappings/</code> directory.</p> <p>Example mapping table for coding systems:</p> <p><pre><code># mappings/cda_default/systems.yaml\nsystems:\n  \"http://snomed.info/sct\":\n    oid: \"2.16.840.1.113883.6.96\"\n    name: \"SNOMED CT\"\n\n  \"http://loinc.org\":\n    oid: \"2.16.840.1.113883.6.1\"\n    name: \"LOINC\"\n\n  \"http://www.nlm.nih.gov/research/umls/rxnorm\":\n    oid: \"2.16.840.1.113883.6.88\"\n    name: \"RxNorm\"\n</code></pre> (Full Documentation on Mappings)</p>"},{"location":"reference/interop/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>The configuration system supports different environments (development, testing, production) with environment-specific overrides. These are stored in the <code>environments/</code> directory. In development and subject to change.</p> <pre><code># environments/development.yaml\ndefaults:\n  common:\n    id_prefix: \"dev-\"     # Development-specific ID prefix\n    subject:\n      reference: \"Patient/Foo\"\n\n# environments/production.yaml\ndefaults:\n  common:\n    id_prefix: \"hc-\"      # Production ID prefix\n    subject:\n      reference: \"Patient/example\"\n</code></pre>"},{"location":"reference/interop/configuration/#using-the-configuration-manager","title":"Using the Configuration Manager","text":""},{"location":"reference/interop/configuration/#basic-configuration-access","title":"Basic Configuration Access","text":"<pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n# OR\nengine = create_interop(config_dir=\"custom_configs/\")\n\n# Get all configurations\nengine.config.get_configs()\n\n# Get a configuration value by dot notation\nid_prefix = engine.config.get_config_value(\"defaults.common.id_prefix\")\n\n# Set the environment (this reloads configuration from the specified environment)\nengine = create_interop(environment=\"production\")\n\n# Validation level is set during initialization or using set_validation_level\nengine = create_interop(validation_level=\"warn\")\n# OR\nengine.config.set_validation_level(\"strict\")\n\n# Set a runtime configuration override\nengine.config.set_config_value(\"cda.sections.problems.identifiers.code\", \"10160-0\")\n</code></pre>"},{"location":"reference/interop/configuration/#section-configuration","title":"Section Configuration","text":"<pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n\n# Get all section configurations\nsections = engine.config.get_cda_section_configs()\n\n# Get a specific section configuration\nproblems_config = engine.config.get_cda_section_configs(\"problems\")\n\n# Get section identifiers\ntemplate_id = problems_config[\"identifiers\"][\"template_id\"]\ncode = problems_config[\"identifiers\"][\"code\"]\n</code></pre>"},{"location":"reference/interop/configuration/#mapping-access","title":"Mapping Access","text":"<pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n\n# Get all mappings\nmappings = engine.config.get_mappings()\n\n# Get a specific mapping\nsystems = mappings.get(\"cda_fhir\", {}).get(\"systems\", {})\nsnomed = systems.get(\"http://snomed.info/sct\", {})\nsnomed_oid = snomed.get(\"oid\")  # \"2.16.840.1.113883.6.96\"\n</code></pre>"},{"location":"reference/interop/configuration/#configuration-precedence","title":"Configuration Precedence","text":"<p>Configuration values are loaded in order of precedence:</p> <ol> <li>Base configuration (defaults.yaml) - lowest precedence</li> <li>Environment configuration (environments/{env}.yaml) - overrides defaults</li> <li>Runtime overrides (via API) - highest precedence</li> </ol> <pre><code># Example: Override configuration at runtime\nengine = create_interop()\nengine.config.set_config_value(\"defaults.common.id_prefix\", \"custom-\")\n</code></pre>"},{"location":"reference/interop/configuration/#validation-levels","title":"Validation Levels","text":"<p>The configuration system supports different validation levels:</p> Level Description <code>strict</code> Raise exceptions for any configuration errors <code>warn</code> Log warnings for configuration errors but continue <code>ignore</code> Ignore configuration errors <pre><code>from healthchain.interop import create_interop\n\n# Create an engine with a specific validation level\nengine = create_interop(validation_level=\"warn\")\n\n# Change the validation level\nengine.config.set_validation_level(\"strict\")\n</code></pre>"},{"location":"reference/interop/engine/","title":"InteropEngine","text":"<p>The <code>InteropEngine</code> is the core component of the HealthChain interoperability module. It provides a unified interface for converting between different healthcare data formats.</p>"},{"location":"reference/interop/engine/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.interop import create_interop, FormatType\n\n# Create an interoperability engine\nengine = create_interop()\n\n# Convert CDA XML to FHIR resources\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Convert FHIR resources to CDA XML\ncda_xml = engine.from_fhir(fhir_resources, dest_format=FormatType.CDA)\n\n# Convert HL7v2 message to FHIR resources\nfhir_resources = engine.to_fhir(hl7v2_message, src_format=FormatType.HL7V2)\n</code></pre>"},{"location":"reference/interop/engine/#creating-an-engine","title":"Creating an Engine","text":"<p>The <code>create_interop()</code> function is the recommended way to create an engine instance:</p> <pre><code>from healthchain.interop import create_interop\n\n# Create with default configuration\nengine = create_interop()\n</code></pre>"},{"location":"reference/interop/engine/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Use custom config directory\nengine = create_interop(config_dir=\"/path/to/custom/configs\")\n\n# Create with custom validation level and environment\nengine = create_interop(validation_level=\"warn\", environment=\"production\")\n</code></pre> <p>\ud83d\udca1 Tip: To create editable configuration templates, run:</p> <p><pre><code>healthchain init-configs ./my_configs\n</code></pre> This will create a <code>my_configs</code> directory with editable default configuration templates.</p>"},{"location":"reference/interop/engine/#conversion-methods","title":"Conversion Methods","text":"<p>All conversions convert to and from FHIR.</p> Method Description <code>to_fhir(data, src_format)</code> Convert from source format to FHIR resources <code>from_fhir(resources, dest_format)</code> Convert from FHIR resources to destination format"},{"location":"reference/interop/engine/#converting-to-fhir","title":"Converting to FHIR","text":"<pre><code># From CDA\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# From HL7v2\nfhir_resources = engine.to_fhir(hl7v2_message, src_format=FormatType.HL7V2)\n</code></pre>"},{"location":"reference/interop/engine/#converting-from-fhir","title":"Converting from FHIR","text":"<pre><code># To CDA\ncda_xml = engine.from_fhir(fhir_resources, dest_format=FormatType.CDA)\n\n# To HL7v2\nhl7v2_message = engine.from_fhir(fhir_resources, dest_format=FormatType.HL7V2)\n</code></pre>"},{"location":"reference/interop/engine/#accessing-configuration","title":"Accessing Configuration","text":"<p>The engine provides direct access to the underlying configuration manager:</p> <pre><code># Access configuration directly\nengine.config.set_environment(\"production\")\nengine.config.set_validation_level(\"warn\")\nvalue = engine.config.get_config_value(\"cda.sections.problems.resource\")\n</code></pre>"},{"location":"reference/interop/engine/#custom-components","title":"Custom Components","text":"<p>You can register custom parsers and generators to extend the engine's capabilities. Note that registering a custom parser / generator for an existing format type will replace the default.</p> <pre><code>from healthchain.interop import FormatType\n\n# Register a custom parser\nengine.register_parser(FormatType.CDA, custom_parser)\n\n# Register a custom generator\nengine.register_generator(FormatType.FHIR, custom_generator)\n</code></pre>"},{"location":"reference/interop/engine/#advanced-configuration","title":"Advanced Configuration","text":"<p>For more information on the configuration options, see the Configuration page.</p>"},{"location":"reference/interop/experimental/","title":"Experimental Templates","text":"<p>This page tracks templates that are under development or have known issues. Use these at your own risk and please contribute fixes!</p>"},{"location":"reference/interop/experimental/#template-status","title":"Template Status","text":"Template Type Status Known Issues Location Problems \ud83d\udfe2 Basic Stable None, but not fully tested for edge cases Bundled in default configs Medications \ud83d\udfe2 Basic Stable None, but not fully tested for edge cases Bundled in default configs Notes \ud83d\udfe2 Basic Stable None, but not fully tested for edge cases, html tags are parsed as text Bundled in default configs Allergies \u26a0\ufe0f Experimental Clinical status parsing bugs, round-trip issues <code>dev-templates/allergies/</code>"},{"location":"reference/interop/experimental/#using-experimental-templates","title":"Using Experimental Templates","text":""},{"location":"reference/interop/experimental/#allergies-allergyintolerance","title":"Allergies (AllergyIntolerance)","text":"<p>Status: \u26a0\ufe0f Experimental - Known bugs prevent inclusion in bundled configs</p> <p>Known Issues: - Clinical status parsing has bugs (see integration test comments) - Round-trip conversion may not preserve all data correctly - Template logic is fragile and may fail with edge cases</p> <p>Location: <code>dev-templates/allergies/</code></p> <p>Usage:</p> <ol> <li> <p>Copy experimental files to your custom config:    <pre><code># After running: healthchain init-configs my_configs\ncp dev-templates/allergies/allergies.yaml my_configs/interop/cda/sections/\ncp dev-templates/allergies/allergy_*.liquid my_configs/templates/cda_fhir/\ncp dev-templates/allergies/allergy_*.liquid my_configs/templates/fhir_cda/\n</code></pre></p> </li> <li> <p>Enable in your CCD document config:    <pre><code># my_configs/interop/cda/document/ccd.yaml\nbody:\n  include_sections:\n    - \"allergies\"  # Add this line\n    - \"medications\"\n    - \"problems\"\n    - \"notes\"\n</code></pre></p> </li> <li> <p>Test thoroughly with your specific data before production use.</p> </li> </ol>"},{"location":"reference/interop/experimental/#contributing-template-fixes","title":"Contributing Template Fixes","text":"<p>We welcome contributions to improve experimental templates!</p>"},{"location":"reference/interop/experimental/#for-allergies","title":"For Allergies:","text":"<ul> <li>Clinical status mapping - The biggest issue is parsing clinical status from CDA observations</li> <li>Round-trip fidelity - Ensure CDA \u2192 FHIR \u2192 CDA preserves all important data</li> <li>Edge case handling - Make templates robust to various CDA structures</li> </ul>"},{"location":"reference/interop/experimental/#general-guidelines","title":"General Guidelines:","text":"<ol> <li>Test with real data - Use the example CDAs in <code>resources/</code> for testing</li> <li>Add comprehensive tests - Include both unit and integration tests</li> <li>Document limitations - Be clear about what your fix does/doesn't solve</li> <li>Follow template patterns - Keep consistent with existing stable templates</li> </ol>"},{"location":"reference/interop/experimental/#submitting-fixes","title":"Submitting Fixes:","text":"<ol> <li>Fix the templates in <code>dev-templates/</code></li> <li>Add/update tests to cover your changes</li> <li>Move stable templates to bundled configs in your PR</li> <li>Update this documentation</li> </ol>"},{"location":"reference/interop/experimental/#roadmap","title":"Roadmap","text":"<p>Next Priorities:</p> <ol> <li>\ud83c\udfaf Allergies stabilization - Fix clinical status parsing and round-trip issues</li> <li>\ud83d\udd2e Future sections - Procedures, Vital Signs, Lab Results</li> <li>\ud83d\udd27 Template tooling - Better validation and testing framework</li> </ol> <p>Want to help? Check our contribution guidelines and pick up one of these challenges!</p>"},{"location":"reference/interop/generators/","title":"Generators","text":"<p>Generators in the interoperability module are responsible for producing healthcare data in various formats from FHIR resources. The module includes built-in generators for common formats including CDA, HL7v2, and FHIR.</p> <p>The generators are largely configuration-driven, with rendering done using Liquid templates. We highly recommend that you read through the Templates and Configuration sections before using the generators!</p>"},{"location":"reference/interop/generators/#available-generators","title":"Available Generators","text":"Generator Description <code>CDAGenerator</code> Generates CDA XML documents from FHIR resources <code>FHIRGenerator</code> Generates FHIR JSON/XML from FHIR resources"},{"location":"reference/interop/generators/#cda-generator","title":"CDA Generator","text":"<p>The CDA Generator produces Clinical Document Architecture (CDA) XML documents from FHIR resources.</p>"},{"location":"reference/interop/generators/#usage-examples","title":"Usage Examples","text":"<pre><code>from healthchain.interop import create_interop, FormatType\nfrom healthchain.fhir import create_condition\n\n# Create an engine\nengine = create_interop()\n\n# Use the FHIR helper functions to create a condition resource\ncondition = create_condition(\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\",\n    subject=\"Patient/Foo\",\n    clinical_status=\"active\"\n)\n\n# Generate CDA from FHIR resources\ncda_xml = engine.from_fhir([condition], dest_format=FormatType.CDA)\n\n# Access the CDA generator directly (advanced use case)\ncda_generator = engine.cda_generator\ncda_xml = cda_generator.transform([condition])\n</code></pre>"},{"location":"reference/interop/generators/#fhir-generator","title":"FHIR Generator","text":"<p>The FHIR Generator transforms data from other formats into FHIR resources. It currently only supports transforming CDA documents into FHIR resources.</p>"},{"location":"reference/interop/generators/#usage-examples_1","title":"Usage Examples","text":"<pre><code>from healthchain.interop import create_interop, FormatType\n\n# Create an engine\nengine = create_interop()\n\n# CDA section entries in dictionary format (@ is used to represent XML attributes)\ncda_section_entries = {\n    \"problems\": {\n        \"act\": {\n            \"@classCode\": \"ACT\",\n            \"@moodCode\": \"EVN\"\n            ...\n        }\n    }\n}\n\n# Generate FHIR resources\nfhir_generator = engine.fhir_generator\nfhir_resources = fhir_generator.transform(cda_section_entries, src_format=FormatType.CDA)\n</code></pre> View full input data <p>The FHIR generator transforms this structure into a FHIR Condition resource by:</p> <ol> <li>Identifying the section type (\"problems\") from the dictionary key</li> <li>Looking up the corresponding FHIR resource type (\"Condition\") from configuration</li> <li>Extracting relevant data from the nested structure (codes, dates, statuses)</li> <li>Using templates to map specific fields to FHIR attributes</li> </ol> <pre><code>{\n  \"problems\": [{\n    'act': {\n      '@classCode': 'ACT',\n      '@moodCode': 'EVN',\n      'templateId': [\n        {'@root': '2.16.840.1.113883.10.20.1.27'},\n        {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5.1'},\n        {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5.2'},\n        {'@root': '2.16.840.1.113883.3.88.11.32.7'},\n        {'@root': '2.16.840.1.113883.3.88.11.83.7'}\n      ],\n      'id': {\n        '@extension': '51854-concern',\n        '@root': '1.2.840.114350.1.13.525.3.7.2.768076'\n      },\n      'code': {\n        '@nullFlavor': 'NA'\n      },\n      'text': {\n        'reference': {'@value': '#problem12'}\n      },\n      'statusCode': {\n        '@code': 'active'\n      },\n      'effectiveTime': {\n        'low': {'@value': '20210317'}\n      },\n      'entryRelationship': {\n        '@typeCode': 'SUBJ',\n        '@inversionInd': False,\n        'observation': {\n          '@classCode': 'OBS',\n          '@moodCode': 'EVN',\n          'templateId': [\n            {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5'},\n            {'@root': '2.16.840.1.113883.10.20.1.28'}\n          ],\n          'id': {\n            '@extension': '51854',\n            '@root': '1.2.840.114350.1.13.525.3.7.2.768076'\n          },\n          'code': {\n            '@code': '64572001',\n            '@codeSystem': '2.16.840.1.113883.6.96',\n            '@codeSystemName': 'SNOMED CT'\n          },\n          'text': {\n            'reference': {'@value': '#problem12name'}\n          },\n          'statusCode': {\n            '@code': 'completed'\n          },\n          'effectiveTime': {\n            'low': {'@value': '20190517'}\n          },\n          'value': {\n            '@code': '38341003',\n            '@codeSystem': '2.16.840.1.113883.6.96',\n            '@codeSystemName': 'SNOMED CT',\n            '@xsi:type': 'CD',\n            '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n            'originalText': {\n              'reference': {'@value': '#problem12name'}\n            }\n          },\n          'entryRelationship': {\n            '@typeCode': 'REFR',\n            '@inversionInd': False,\n            'observation': {\n              '@classCode': 'OBS',\n              '@moodCode': 'EVN',\n              'templateId': [\n                {'@root': '2.16.840.1.113883.10.20.1.50'},\n                {'@root': '2.16.840.1.113883.10.20.1.57'},\n                {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.1.1'}\n              ],\n              'code': {\n                '@code': '33999-4',\n                '@codeSystem': '2.16.840.1.113883.6.1',\n                '@displayName': 'Status'\n              },\n              'statusCode': {\n                '@code': 'completed'\n              },\n              'effectiveTime': {\n                'low': {'@value': '20190517'}\n              },\n              'value': {\n                '@code': '55561003',\n                '@codeSystem': '2.16.840.1.113883.6.96',\n                '@xsi:type': 'CE',\n                '@displayName': 'Active',\n                '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'\n              }\n            }\n          }\n        }\n      }\n    }\n  }]\n}\n</code></pre>"},{"location":"reference/interop/generators/#creating-a-custom-generator","title":"Creating a Custom Generator","text":"<p>You can create a custom generator by implementing a class that inherits from <code>BaseGenerator</code> and registering it with the engine (this will replace the default generator for the format type):</p> <pre><code>from healthchain.interop import create_interop, FormatType\nfrom healthchain.interop.config_manager import InteropConfigManager\nfrom healthchain.interop.template_registry import TemplateRegistry\nfrom healthchain.interop.generators import BaseGenerator\n\nfrom typing import List\nfrom fhir.resources.resource import Resource\n\n\nclass CustomGenerator(BaseGenerator):\n    def __init__(self, config: InteropConfigManager, templates: TemplateRegistry):\n        super().__init__(config, templates)\n\n    def transform(self, resources: List[Resource], **kwargs) -&gt; str:\n        # Generate output from FHIR resources\n        return \"Custom output format\"\n\n# Register the custom generator with the engine\nengine = create_interop()\nengine.register_generator(FormatType.CDA, CustomGenerator(engine.config, engine.template_registry))\n</code></pre>"},{"location":"reference/interop/interop/","title":"Interoperability Engine","text":"<p>The HealthChain Interop Engine provides a robust and customizable framework for converting between different HL7 healthcare data formats, including:</p> <ul> <li>FHIR</li> <li>CDA</li> <li>HL7v2 (Coming soon)</li> </ul>"},{"location":"reference/interop/interop/#architecture","title":"Architecture","text":"<p>The interoperability module is built around a central <code>InteropEngine</code> that coordinates format conversion through specialized parsers and generators:</p> <pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 InteropEngine \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502                 \u2502                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Parsers      \u2502 \u2502 Templates \u2502 \u2502     Generators    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                 \u2502                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   - CDA Parser    \u2502 \u2502 Registry  \u2502 \u2502   - CDA Generator \u2502\n\u2502   - HL7v2 Parser  \u2502 \u2502 Renderer  \u2502 \u2502  - FHIR Generator \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 - HL7v2 Generator \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/interop/interop/#key-components","title":"Key Components","text":"Component Description InteropEngine Core engine that manages the conversion process Templates Liquid-based template system for customizing output syntactic generation Mappings Mappings between different terminology systems Configuration Configuration system for controlling engine behavior and template variations Parsers Components for parsing different healthcare formats Generators Components for generating output in different formats"},{"location":"reference/interop/interop/#basic-usage","title":"Basic Usage","text":"<p>FHIR serves as the de facto modern data standard in HealthChain and in the world of healthcare more broadly, therefore everything converts to and from FHIR resources.</p> <p>The main conversion methods are (hold on to your hats):</p> <ul> <li><code>.to_fhir()</code> - Convert a source format to FHIR resources</li> <li><code>.from_fhir()</code> - Convert FHIR resources to a destination format</li> </ul> <pre><code>from healthchain.interop import create_interop, FormatType\n\n# Create an interoperability engine\nengine = create_interop()\n\n# Convert CDA XML to FHIR resources\nwith open('patient_ccd.xml', 'r') as f:\n    cda_xml = f.read()\n\nfhir_resources = engine.to_fhir(cda_xml, src_format=\"cda\")\n\n# Convert FHIR resources back to CDA\ncda_document = engine.from_fhir(fhir_resources, dest_format=\"cda\")\n</code></pre>"},{"location":"reference/interop/interop/#custom-configs","title":"Custom Configs","text":"<p>The default templates that come with the package are limited to problems, medications, and notes and are meant for basic testing and prototyping. Use the <code>healthchain init-configs</code> command to create editable configuration templates:</p> <pre><code># Create editable configuration templates\nhealthchain init-configs ./my_configs\n</code></pre> <p>Then use the <code>config_dir</code> parameter to specify the path to your custom configs:</p> <pre><code># Use your customized configs\nengine = create_interop(config_dir=\"./my_configs\")\n\n# Now you can customize:\n# \u2022 Add experimental features (allergies, procedures)\n# \u2022 Modify terminology mappings (SNOMED, LOINC codes)\n# \u2022 Customize templates for your organization's CDA format\n# \u2022 Configure validation rules and environments\n</code></pre>"},{"location":"reference/interop/interop/#customization-points","title":"Customization Points","text":"<p>The interoperability module is designed with extensibility at its core. You can customize and extend the framework in several ways:</p>"},{"location":"reference/interop/interop/#custom-parsers","title":"Custom Parsers","text":"<p>Parsers convert source formats (CDA or HL7v2) into mapped dictionaries that can be processed by generators:</p> <pre><code># Register a custom parser with the engine\nengine.register_parser(FormatType.CDA, CustomCDAParser(engine.config))\n</code></pre> <p>For detailed implementation examples, see Creating a Custom Parser.</p>"},{"location":"reference/interop/interop/#custom-generators","title":"Custom Generators","text":"<p>Generators transform mapped dictionaries into target formats:</p> <pre><code># Register a custom generator with the engine\nengine.register_generator(FormatType.CDA,\n                         CustomCDAGenerator(engine.config, engine.template_registry))\n</code></pre> <p>For detailed implementation examples, see Creating a Custom Generator.</p>"},{"location":"reference/interop/interop/#environment-configuration","title":"Environment Configuration","text":"<p>You can customize the engine's behavior for different environments:</p> <pre><code># Create an engine with specific environment settings\nengine = create_interop(\n    config_dir=Path(\"/path/to/custom/configs\"),\n    validation_level=\"warn\",  # Options: strict, warn, ignore\n    environment=\"production\"  # Options: development, testing, production\n)\n\n# Change environment settings after creation\nengine.config.set_environment(\"testing\")\nengine.config.set_validation_level(\"strict\")\n\n# Access environment-specific configuration\nid_prefix = engine.config.get_config_value(\"defaults.common.id_prefix\")\n</code></pre> <p>Environment-specific configurations are loaded from the <code>environments/</code> directory and can override default settings for different deployment scenarios.</p>"},{"location":"reference/interop/interop/#template-customization","title":"Template Customization","text":"<p>The template system uses Liquid templates to generate output formats. You can:</p> <ol> <li>Override existing templates by placing custom versions in the configured template directory</li> <li>Add new templates for custom formats or content types</li> <li>Extend the template system with custom logic via filters</li> </ol> <p>For more details on extending the system, check out the Templates and Configuration pages.</p>"},{"location":"reference/interop/mappings/","title":"Mappings","text":"<p>Mapping tables are used to translate between different healthcare terminology systems, code sets, and formats. These mappings are essential for semantic interoperability between CDA, HL7v2, and FHIR formats where the same concept may be represented differently.</p>"},{"location":"reference/interop/mappings/#mapping-types","title":"Mapping Types","text":"<p>The system supports several types of mappings:</p> Mapping Type Description Example Code Systems Maps between URI-based systems (FHIR) and OID-based systems (CDA) SNOMED CT: <code>http://snomed.info/sct</code> \u2194 <code>2.16.840.1.113883.6.96</code> Status Codes Maps status codes between formats <code>active</code> \u2194 <code>55561003</code> Severity Codes Maps severity designations between formats <code>moderate</code> \u2194 <code>6736007</code>"},{"location":"reference/interop/mappings/#mapping-directory-structure","title":"Mapping Directory Structure","text":"<p>Mappings are stored in YAML files in the <code>configs/mappings/</code> directory, organized by the formats they translate between:</p> <pre><code>configs/mappings/\n\u251c\u2500\u2500 cda_fhir/\n\u2502   \u251c\u2500\u2500 systems.yaml\n\u2502   \u251c\u2500\u2500 status_codes.yaml\n\u2502   \u2514\u2500\u2500 severity_codes.yaml\n\u251c\u2500\u2500 hl7v2_fhir/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"reference/interop/mappings/#mapping-file-format","title":"Mapping File Format","text":""},{"location":"reference/interop/mappings/#code-systems-mapping","title":"Code Systems Mapping","text":"<p>The <code>systems.yaml</code> file maps between FHIR URI-based code systems and CDA OID-based systems:</p> <pre><code># mappings/cda_fhir/systems.yaml\nsystems:\n  \"http://snomed.info/sct\":\n    oid: \"2.16.840.1.113883.6.96\"\n    name: \"SNOMED CT\"\n\n  \"http://loinc.org\":\n    oid: \"2.16.840.1.113883.6.1\"\n    name: \"LOINC\"\n\n  \"http://www.nlm.nih.gov/research/umls/rxnorm\":\n    oid: \"2.16.840.1.113883.6.88\"\n    name: \"RxNorm\"\n</code></pre>"},{"location":"reference/interop/mappings/#status-codes-mapping","title":"Status Codes Mapping","text":"<p>The <code>status_codes.yaml</code> file maps between different formats' status codes:</p> <pre><code># mappings/cda_fhir/status_codes.yaml\n# Clinical status codes (CDA to FHIR)\n\"55561003\":\n  code: \"active\"\n  display: \"Active\"\n\n\"73425007\":\n  code: \"inactive\"\n  display: \"Inactive\"\n\n\"413322009\":\n  code: \"resolved\"\n  display: \"Resolved\"\n</code></pre>"},{"location":"reference/interop/mappings/#severity-codes-mapping","title":"Severity Codes Mapping","text":"<p>The <code>severity_codes.yaml</code> file maps severity designations between formats:</p> <pre><code># mappings/cda_fhir/severity_codes.yaml\n# Allergy and reaction severity codes (CDA to FHIR)\n\"255604002\":  # Mild (SNOMED CT)\n  code: \"mild\"\n  display: \"Mild\"\n\n\"6736007\":  # Moderate (SNOMED CT)\n  code: \"moderate\"\n  display: \"Moderate\"\n\n\"24484000\":  # Severe (SNOMED CT)\n  code: \"severe\"\n  display: \"Severe\"\n</code></pre>"},{"location":"reference/interop/mappings/#using-mappings","title":"Using Mappings","text":"<p>The <code>InteropEngine</code> automatically loads and applies mappings during the conversion process. You can also access mappings directly through the configuration manager:</p> <pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n\n# Get all mappings\nmappings = engine.config.get_mappings()\n\n# Access specific mapping\nsystems = mappings.get(\"cda_fhir\", {}).get(\"systems\", {})\nsnomed = systems.get(\"http://snomed.info/sct\", {})\nsnomed_oid = snomed.get(\"oid\")  # \"2.16.840.1.113883.6.96\"\n</code></pre>"},{"location":"reference/interop/mappings/#template-filters-for-mappings","title":"Template Filters for Mappings","text":"<p>The mapping system provides several Liquid template filters to help with code translation:</p> Filter Description Example Usage <code>map_system</code> Maps between CDA and FHIR code systems <code>{{ \"http://snomed.info/sct\" | map_system: 'fhir_to_cda' }}</code> <code>map_status</code> Maps between CDA and FHIR status codes <code>{{ \"active\" | map_status: 'fhir_to_cda' }}</code> <code>map_severity</code> Maps between CDA and FHIR severity codes <code>{{ \"moderate\" | map_severity: 'fhir_to_cda' }}</code> <p>Example in a template:</p> <pre><code>{\n  \"code\": {\n    \"@codeSystem\": \"{{ resource.code.coding[0].system | map_system: 'fhir_to_cda' }}\",\n    \"@code\": \"{{ resource.code.coding[0].code }}\"\n  }\n}\n</code></pre>"},{"location":"reference/interop/mappings/#adding-custom-mappings","title":"Adding Custom Mappings","text":"<p>To add new mappings:</p> <ol> <li>Create or modify the appropriate YAML file in the <code>configs/mappings/</code> directory</li> <li>Follow the structure of existing mapping files</li> <li>The changes will be automatically loaded the next time the <code>InteropEngine</code> is initialized</li> </ol> <p>For more complex mapping needs, you can create custom mapping filters:</p> <pre><code>def custom_map_filter(value, mappings, direction=\"fhir_to_cda\"):\n    # Custom mapping logic here\n    return mapped_value\n\n# Register with the template registry\nengine.template_registry.add_filter(\"custom_map\", custom_map_filter)\n</code></pre>"},{"location":"reference/interop/mappings/#related-documentation","title":"Related Documentation","text":"<ul> <li>Configuration Management</li> <li>Templates</li> <li>Custom Filters</li> </ul>"},{"location":"reference/interop/parsers/","title":"Parsers","text":"<p>Parsers are responsible for extracting structured data from various healthcare document formats. The module includes built-in parsers for common formats like CDA and HL7v2.</p>"},{"location":"reference/interop/parsers/#available-parsers","title":"Available Parsers","text":"Parser Description <code>CDAParser</code> Parses CDA XML documents into structured data <code>HL7v2Parser</code> Parses HL7v2 messages into structured data"},{"location":"reference/interop/parsers/#cda-parser","title":"CDA Parser","text":"<p>The CDA Parser extracts data from Clinical Document Architecture (CDA) XML documents based on configured section identifiers.</p> <p>Internally, it uses xmltodict to parse the XML into a dictionary, validates the dictionary with Pydantic, and then maps each entry to the section keys. See Working with xmltodict in HealthChain for more details.</p> <p>Each extracted entry should be mapped to the name of the corresponding configuration file, which will be used as the <code>section_key</code>. The configuration file contains information about the section identifiers that are used to extract the correct section entries.</p> <p>The input data should be in the format <code>{&lt;section_key&gt;}: {&lt;section_entries&gt;}</code>.</p> <p>(Full Documentation on Configuration)</p>"},{"location":"reference/interop/parsers/#usage-examples","title":"Usage Examples","text":"<pre><code>from healthchain.interop import create_interop, FormatType\n\n# Create an engine\nengine = create_interop()\n\n# Parse a CDA document directly to FHIR\nwith open(\"tests/data/test_cda.xml\", \"r\") as f:\n    cda_xml = f.read()\n\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n\n# Access the CDA parser directly (advanced use case)\ncda_parser = engine.cda_parser\nsections = cda_parser.parse_document(cda_xml)\n\n# Extract problems section data\nproblems = sections.get(\"problems\", [])\n# parsed CDA section entry in xmltodict format - note that '@' is used to access attributes\n# {\n#   \"act\": {\n#     \"@classCode\": \"ACT\",\n#     \"@moodCode\": \"EVN\",\n#     ...\n#   }\n# }\n</code></pre> View full parsed output <p>This data structure represents a problem (condition) entry from a CDA document, containing:</p> <ul> <li>A problem act with template IDs and status</li> <li>An observation with clinical details (SNOMED code 38341003 - Hypertension)</li> <li>Status information (Active)</li> <li>Dates (onset date: May 17, 2019)</li> </ul> <p>Note how the original XML structure is preserved in dictionary format with '@' used to denote attributes:</p> <pre><code>[{\n  'act': {\n    '@classCode': 'ACT',\n    '@moodCode': 'EVN',\n    'templateId': [\n      {'@root': '2.16.840.1.113883.10.20.1.27'},\n      {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5.1'},\n      {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5.2'},\n      {'@root': '2.16.840.1.113883.3.88.11.32.7'},\n      {'@root': '2.16.840.1.113883.3.88.11.83.7'}\n    ],\n    'id': {\n      '@extension': '51854-concern',\n      '@root': '1.2.840.114350.1.13.525.3.7.2.768076'\n    },\n    'code': {\n      '@nullFlavor': 'NA'\n    },\n    'text': {\n      'reference': {'@value': '#problem12'}\n    },\n    'statusCode': {\n      '@code': 'active'\n    },\n    'effectiveTime': {\n      'low': {'@value': '20210317'}\n    },\n    'entryRelationship': {\n      '@typeCode': 'SUBJ',\n      '@inversionInd': False,\n      'observation': {\n        '@classCode': 'OBS',\n        '@moodCode': 'EVN',\n        'templateId': [\n          {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.5'},\n          {'@root': '2.16.840.1.113883.10.20.1.28'}\n        ],\n        'id': {\n          '@extension': '51854',\n          '@root': '1.2.840.114350.1.13.525.3.7.2.768076'\n        },\n        'code': {\n          '@code': '64572001',\n          '@codeSystem': '2.16.840.1.113883.6.96',\n          '@codeSystemName': 'SNOMED CT'\n        },\n        'text': {\n          'reference': {'@value': '#problem12name'}\n        },\n        'statusCode': {\n          '@code': 'completed'\n        },\n        'effectiveTime': {\n          'low': {'@value': '20190517'}\n        },\n        'value': {\n          '@code': '38341003',\n          '@codeSystem': '2.16.840.1.113883.6.96',\n          '@codeSystemName': 'SNOMED CT',\n          '@xsi:type': 'CD',\n          '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n          'originalText': {\n            'reference': {'@value': '#problem12name'}\n          }\n        },\n        'entryRelationship': {\n          '@typeCode': 'REFR',\n          '@inversionInd': False,\n          'observation': {\n            '@classCode': 'OBS',\n            '@moodCode': 'EVN',\n            'templateId': [\n              {'@root': '2.16.840.1.113883.10.20.1.50'},\n              {'@root': '2.16.840.1.113883.10.20.1.57'},\n              {'@root': '1.3.6.1.4.1.19376.1.5.3.1.4.1.1'}\n            ],\n            'code': {\n              '@code': '33999-4',\n              '@codeSystem': '2.16.840.1.113883.6.1',\n              '@displayName': 'Status'\n            },\n            'statusCode': {\n              '@code': 'completed'\n            },\n            'effectiveTime': {\n              'low': {'@value': '20190517'}\n            },\n            'value': {\n              '@code': '55561003',\n              '@codeSystem': '2.16.840.1.113883.6.96',\n              '@xsi:type': 'CE',\n              '@displayName': 'Active',\n              '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'\n            }\n          }\n        }\n      }\n    }\n  }\n}]\n</code></pre>"},{"location":"reference/interop/parsers/#section-configuration","title":"Section Configuration","text":"<p>Sections make up the structure of a CDA document. The CDA parser uses <code>identifiers</code> in the section configuration file to determine which sections to extract and map to FHIR resources. Each section is identified by a template ID, code, or both:</p> <pre><code># Example section configuration\ncda:\n  sections:\n    problems:\n      identifiers:\n        template_id: \"2.16.840.1.113883.10.20.1.11\"\n        code: \"11450-4\"\n      resource: \"Condition\"\n</code></pre>"},{"location":"reference/interop/parsers/#creating-a-custom-parser","title":"Creating a Custom Parser","text":"<p>You can create a custom parser by implementing a class that inherits from <code>BaseParser</code> and registering it with the engine (this will replace the default parser for the format type):</p> <pre><code>from healthchain.interop import create_interop, FormatType\nfrom healthchain.interop.config_manager import InteropConfigManager\nfrom healthchain.interop.parsers.base import BaseParser\n\nclass CustomParser(BaseParser):\n    def __init__(self, config: InteropConfigManager):\n        super().__init__(config)\n\n    def from_string(self, data: str) -&gt; dict:\n        # Parse the document and return structured data\n        return {\"structured_data\": \"example\"}\n\n# Register the custom parser with the engine\nengine = create_interop()\nengine.register_parser(FormatType.CDA, CustomParser(engine.config))\n</code></pre>"},{"location":"reference/interop/templates/","title":"Templates","text":"<p>The HealthChain interoperability module uses a template system based on Liquid, an open-source templating language to generate healthcare data in various formats. This allows for flexible and customizable document generation on a syntactic level.</p>"},{"location":"reference/interop/templates/#template-directory-structure","title":"Template Directory Structure","text":"<p>Templates are stored in the <code>configs/templates</code> directory by default. The directory structure follows a convention based on format and resource type:</p> <p><pre><code>templates/\n\u251c\u2500\u2500 cda_fhir/\n\u2502   \u251c\u2500\u2500 document.liquid\n\u2502   \u251c\u2500\u2500 section.liquid\n\u2502   \u251c\u2500\u2500 problem_entry.liquid\n\u2502   \u251c\u2500\u2500 medication_entry.liquid\n\u2502   \u2514\u2500\u2500 allergy_entry.liquid\n\u251c\u2500\u2500 cda_fhir/\n\u2502   \u251c\u2500\u2500 condition.liquid\n\u2502   \u251c\u2500\u2500 medication_statement.liquid\n\u2502   \u2514\u2500\u2500 allergy_intolerance.liquid\n\u251c\u2500\u2500 hl7v2_fhir/\n\u2502   \u251c\u2500\u2500 adt_a01.liquid\n\u2502   \u251c\u2500\u2500 oru_r01.liquid\n\u2502   \u2514\u2500\u2500 obx_r01.liquid\n\u251c\u2500\u2500 fhir_hl7v2/\n\u2502   \u251c\u2500\u2500 patient_adt.liquid\n\u2502   \u251c\u2500\u2500 encounter_adt.liquid\n\u2502   \u2514\u2500\u2500 observation_oru.liquid\n</code></pre> Templates can be accessed through the <code>TemplateRegistry</code>:</p> <ol> <li>Using their full path within the template directory without extension as a key: <code>cda_fhir/document</code></li> <li>Using just their stem name as a key: <code>document</code></li> </ol> <p>Using full paths is recommended for clarity and to avoid confusion when templates with the same filename exist in different directories. However, both methods will work as long as template names are unique across all directories and matches the template name in the configuration files.</p>"},{"location":"reference/interop/templates/#default-templates","title":"Default Templates","text":"<p>HealthChain provides default templates for the transformation of Problems, Medications, and Notes sections in a Continuity of Care (CCD) CDA to FHIR and the reverse. They are configured to work out of the box with the default configuration and the example CDAs here.</p> <p>You are welcome to modify these templates at your own discretion or use them as a starting reference point for your writing your own templates. Always verify that templates work for your use case.</p> <p>Note: Some templates are experimental and not included in the default configs. See Experimental Templates for details on templates under development.</p> CDA Section FHIR Resource Problems Condition Medications MedicationStatement Notes DocumentReference <p>CDA to FHIR templates:</p> CDA Section Default Template Problems <code>fhir_cda/problem_entry.liquid</code> Medications <code>fhir_cda/medication_entry.liquid</code> Notes <code>fhir_cda/note_entry.liquid</code> <p>FHIR to CDA templates:</p> Resource Type Default Template Condition <code>cda_fhir/condition.liquid</code> MedicationStatement <code>cda_fhir/medication_statement.liquid</code> DocumentReference <code>cda_fhir/document_reference.liquid</code>"},{"location":"reference/interop/templates/#template-format","title":"Template Format","text":"<p>Templates use Python Liquid syntax with additional custom filters provided by the interoperability module. Note that HealthChain uses xmltodict to parse and unparse XML documents into dictionaries and vice versa, therefore templates should be written in JSON format that is compatible with <code>xmltodict</code>. For more information, see the Working with xmltodict in HealthChain guide (it's not that bad, I promise).</p> <p>Example template for a CDA to FHIR conversion:</p> <pre><code>{\n  \"act\": {\n    \"@classCode\": \"ACT\",\n    \"@moodCode\": \"EVN\",\n    \"templateId\": [\n    {% for template_id in config.template.act.template_id %}\n      {\"@root\": \"{{template_id}}\"} {% if forloop.last != true %},{% endif %}\n    {% endfor %}\n    ],\n    {% if resource.id %}\n    \"id\": {\"@root\": \"{{ resource.id }}\"},\n    {% endif %}\n    \"code\": {\"@nullFlavor\": \"NA\"},\n    \"statusCode\": {\n      \"@code\": \"{{ config.template.act.status_code }}\"\n    }\n  }\n}\n</code></pre>"},{"location":"reference/interop/templates/#using-the-template-system","title":"Using the Template System","text":""},{"location":"reference/interop/templates/#interoperability-engine-api","title":"Interoperability Engine API","text":"<p>The Interoperability Engine API provides a high-level interface (<code>.to_fhir()</code> and <code>.from_fhir()</code>) for transforming healthcare data between different formats using templates.</p> <pre><code>from healthchain.interop import create_interop, FormatType\nfrom healthchain.fhir import create_condition\n\n# Create an engine\nengine = create_interop()\n\n# Create a FHIR resource\ncondition = create_condition(\n  code=\"38341003\",\n  system=\"http://snomed.info/sct\",\n  display=\"Hypertension\",\n  subject=\"Patient/123\",\n  clinical_status=\"active\"\n)\n\n# Generate CDA from FHIR resources\ncda_xml = engine.from_fhir([condition], dest_format=FormatType.CDA)\n\n# Generate FHIR from CDA\nfhir_resources = engine.to_fhir(cda_xml, src_format=FormatType.CDA)\n</code></pre>"},{"location":"reference/interop/templates/#direct-template-access-advanced","title":"Direct Template Access (Advanced)","text":"<p>For advanced use cases, you can access the template system directly:</p> <pre><code>from healthchain.interop import create_interop\n\n# Create an engine\nengine = create_interop()\n\n# Access the template registry\nregistry = engine.template_registry\n\n# Get a template by name\ntemplate = registry.get_template(\"cda_fhir/condition\")\n</code></pre>"},{"location":"reference/interop/templates/#creating-custom-templates","title":"Creating Custom Templates","text":"<p>To create a custom template:</p> <ol> <li>Create a new file in the appropriate template directory. Use a descriptive name for the template, e.g. <code>cda_fhir/procedure.liquid</code>.</li> <li>Create a template using Python Liquid syntax with available filters if needed.</li> <li>Access source data properties using dot notation. (e.g. <code>entry.act.id</code>)</li> <li>Access configuration values (see Configuration) using the <code>config</code> object.</li> </ol> <p>For example, to create a custom template to transform a CDA section into a FHIR Procedure resource:</p> <pre><code>&lt;!-- configs/templates/cda_fhir/procedure.liquid --&gt;\n{\n  \"procedure\": {\n    \"@classCode\": \"PROC\",\n    \"@moodCode\": \"EVN\",\n    \"templateId\": {\n      \"@root\": \"2.16.840.1.113883.10.20.1.29\"\n    },\n    \"id\": {\n      \"@root\": \"{{ entry.act.id | generate_id }}\"\n    },\n    \"code\": {\n      \"@code\": \"{{ entry.act.entryRelationship.observation.value['@code'] }}\",\n      \"@displayName\": \"{{ entry.act.entryRelationship.observation.value['@displayName'] }}\",\n      \"@codeSystem\": \"{{ entry.act.entryRelationship.observation.value['@codeSystem'] | map_system: 'fhir_to_cda' }}\",\n    },\n    \"statusCode\": {\n      \"@code\": \"{{ entry.act.statusCode['@code'] | map_status: 'fhir_to_cda' }}\"\n    },\n    \"effectiveTime\": {\n      \"@value\": \"{{ entry.act.effectiveTime['@value'] | format_date }}\"\n    },\n    {% if entry.act.performer %}\n    \"performer\": {\n      \"assignedEntity\": {\n        \"id\": {\n          \"@root\": \"{{ entry.act.performer[0].actor.reference }}\"\n        }\n      }\n    }\n    {% endif %}\n  }\n}\n</code></pre>"},{"location":"reference/interop/templates/#custom-template-filters","title":"Custom Template Filters","text":"<p>The template system provides several custom filters for common healthcare document transformation tasks:</p> Filter Description <code>map_system</code> Maps between CDA and FHIR code systems <code>map_status</code> Maps between CDA and FHIR status codes <code>map_severity</code> Maps between CDA and FHIR severity codes <code>format_date</code> Formats a date in the correct format for the output document <code>format_timestamp</code> Formats a timestamp or uses current time <code>generate_id</code> Generates an ID or uses provided value <code>to_json</code> Converts object to JSON string <code>extract_effective_period</code> Extracts effective period data from CDA effectiveTime elements <code>extract_effective_timing</code> Extracts timing data from effectiveTime elements <code>extract_clinical_status</code> Extracts clinical status from an observation <code>clean_empty</code> Recursively removes empty values from dictionaries and lists <code>to_base64</code> Encodes text to base64 <code>from_base64</code> Decodes base64 to text <code>xmldict_to_html</code> Converts xmltodict format to HTML string"},{"location":"reference/interop/templates/#using-filters","title":"Using Filters","text":"<p><pre><code>&lt;!-- Map a system --&gt;\n{{ resource.code.coding[0].system | map_system: 'fhir_to_cda' }}\n\n&lt;!-- Base64 encoding and decoding --&gt;\n{{ \"Hello World\" | to_base64 }}\n&lt;!-- Outputs: SGVsbG8gV29ybGQ= --&gt;\n\n{{ \"SGVsbG8gV29ybGQ=\" | from_base64 }}\n&lt;!-- Outputs: Hello World --&gt;\n\n&lt;!-- Convert XML dictionary to HTML --&gt;\n{% assign xml_dict = {'div': {'p': 'Hello', '@class': 'note'}} %}\n{{ xml_dict | xmldict_to_html }}\n&lt;!-- Outputs: &lt;div&gt;&lt;p class=\"note\"&gt;Hello&lt;/p&gt;&lt;/div&gt; --&gt;\n</code></pre> For more information on using filters, see Liquid's official documentation.</p>"},{"location":"reference/interop/templates/#adding-custom-filters","title":"Adding Custom Filters","text":"<p>You can add custom filters to the template system:</p> <pre><code>from healthchain.interop import create_interop\n\ndef custom_filter(value):\n    return f\"CUSTOM:{value}\"\n\n# Create an engine\nengine = create_interop()\n\n# Add a custom filter\nengine.template_registry.add_filter(\"custom\", custom_filter)\n</code></pre>"},{"location":"reference/interop/xmltodict/","title":"Working with xmltodict in HealthChain","text":"<p>The HealthChain interoperability engine uses xmltodict to convert between XML and Python dictionaries. This guide explains key conventions to be aware of when working with the parsed data.</p> <p>Why use <code>xmltodict</code>? You say, Why not use the <code>lxml</code> or <code>xml.etree.ElementTree</code> or some other decent library so you can work on the XML tree directly?</p> <p>There are two main reasons:</p> <ul> <li> <p>HealthChain uses Pydantic models for validation and type checking extensively, which works best with JSON-able data. We wanted to keep everything in modern Python ecosystem whilst still being able to work with XML, which is still a very common format in healthcare</p> </li> <li> <p>Developer experience: it's just easier to work with JSON than XML trees in Python \ud83e\udd37\u200d\u2640\ufe0f</p> </li> </ul> <p>The flow roughly looks like this:</p> <pre><code>XML \u2194 Dictionary with @ prefixes \u2194 Pydantic Model\n</code></pre> <p>Still with me? Cool. Let's dive into the key conventions to be aware of when working with the parsed data.</p>"},{"location":"reference/interop/xmltodict/#key-conventions","title":"Key Conventions","text":""},{"location":"reference/interop/xmltodict/#attribute-prefixes","title":"Attribute Prefixes","text":"<p>XML attributes are prefixed with <code>@</code>: <pre><code>&lt;code code=\"55607006\" displayName=\"Problem\"/&gt;\n</code></pre> becomes: <pre><code>{\n    \"code\": {\n        \"@code\": \"55607006\",\n        \"@displayName\": \"Problem\"\n    }\n}\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#text-content","title":"Text Content","text":"<p>Text content of elements is represented with <code>#text</code>: <pre><code>&lt;displayName&gt;Hypertension&lt;/displayName&gt;\n</code></pre> becomes: <pre><code>{\n    \"displayName\": \"Hypertension\"\n}\n</code></pre> or for mixed content: <pre><code>&lt;text&gt;Some &lt;b&gt;bold&lt;/b&gt; text&lt;/text&gt;\n</code></pre> becomes: <pre><code>{\n    \"text\": {\n        \"#text\": \"Some  text\",\n        \"b\": \"bold\"\n    }\n}\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#lists-vs-single-items","title":"Lists vs Single Items","text":"<p>A collection of elements with the same name becomes a list: <pre><code>&lt;component&gt;\n  &lt;section&gt;...&lt;/section&gt;\n&lt;/component&gt;\n&lt;component&gt;\n  &lt;section&gt;...&lt;/section&gt;\n&lt;/component&gt;\n</code></pre> becomes: <pre><code>{\n    \"component\": [\n        {\"section\": {...}},\n        {\"section\": {...}}\n    ]\n}\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#force-list-parameter","title":"Force List Parameter","text":"<p>When parsing, you can force certain elements to always be lists even when there's only one: <pre><code>xmltodict.parse(xml_string, force_list=('component', 'entry'))\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#namespaces","title":"Namespaces","text":"<p>Namespaces are included in element names: <pre><code>&lt;ns1:element xmlns:ns1=\"http://example.org\"&gt;value&lt;/ns1:element&gt;\n</code></pre> becomes: <pre><code>{\n    \"ns1:element\": {\n        \"@xmlns:ns1\": \"http://example.org\",\n        \"#text\": \"value\"\n    }\n}\n</code></pre></p>"},{"location":"reference/interop/xmltodict/#tips-for-working-with-cda-documents","title":"Tips for Working with CDA Documents","text":"<ul> <li>Remember to use the <code>@</code> prefix for attributes</li> <li>Always check if an element might be a list before accessing it directly</li> <li>In Liquid, use <code>['string']</code> to access attributes with <code>@</code> prefixes. e.g. <code>act.entry.code['@code']</code></li> <li>When generating XML, make sure to include required namespaces</li> </ul>"},{"location":"reference/io/adapters/adapters/","title":"Adapters","text":"<p>Adapters handle conversion between healthcare data formats (CDA, FHIR) and HealthChain's internal <code>Document</code> objects. They enable clean separation between ML processing logic and healthcare format handling, making your pipelines more maintainable and testable.</p> <p>Unlike the legacy connector pattern, adapters are used explicitly and provide clear control over data flow.</p>"},{"location":"reference/io/adapters/adapters/#available-adapters","title":"Available adapters","text":"<p>Adapters parse data from specific healthcare formats into FHIR resources and store them in a <code>Document</code> container for processing.</p> <p>(Document API Reference)</p> Adapter Input Format Output Format FHIR Resources Document Access CdaAdapter <code>CdaRequest</code> <code>CdaResponse</code> DocumentReference <code>Document.text</code>, <code>Document.fhir.problem_list</code>, <code>Document.fhir.medication_list</code>, <code>Document.fhir.allergy_list</code> CdsFhirAdapter <code>CDSRequest</code> <code>CDSResponse</code> Any FHIR Resource <code>Document.fhir.get_prefetch_resources()</code>"},{"location":"reference/io/adapters/adapters/#use-cases","title":"Use Cases","text":"<p>Each adapter is designed for specific healthcare integration scenarios.</p> Adapter Use Case Protocol <code>CdaAdapter</code> Clinical Documentation SOAP/CDA <code>CdsFhirAdapter</code> Clinical Decision Support CDS Hooks/FHIR"},{"location":"reference/io/adapters/adapters/#usage-patterns","title":"Usage Patterns","text":""},{"location":"reference/io/adapters/adapters/#1-simple-end-to-end-processing","title":"1. Simple End-to-End Processing","text":"<p>Use prebuilt pipelines with the <code>process_request()</code> method for straightforward workflows:</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\npipeline = MedicalCodingPipeline.from_model_id(\"en_core_sci_sm\", source=\"spacy\")\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\n\n# Adapter used internally\nresponse = pipeline.process_request(cda_request)\n</code></pre>"},{"location":"reference/io/adapters/adapters/#2-manual-adapter-control-document-access","title":"2. Manual Adapter Control (Document Access)","text":"<p>Use adapters <code>parse()</code> and <code>format()</code> methods directly when you need access to the intermediate <code>Document</code> object:</p> <pre><code>from healthchain.io import CdaAdapter\nfrom healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\npipeline = MedicalCodingPipeline.from_model_id(\"en_core_sci_sm\", source=\"spacy\")\nadapter = CdaAdapter()\n\ncda_request = CdaRequest(document=\"&lt;CDA XML content&gt;\")\n\n# Manual adapter control\ndoc = adapter.parse(cda_request)      # CdaRequest \u2192 Document\ndoc = pipeline(doc)                   # Document \u2192 Document (pure ML)\n\n# Access extracted clinical data\nprint(f\"Problems: {doc.fhir.problem_list}\")\nprint(f\"Medications: {doc.fhir.medication_list}\")\nprint(f\"Allergies: {doc.fhir.allergy_list}\")\n\n# Convert back to healthcare format\nresponse = adapter.format(doc)        # Document \u2192 CdaResponse\n</code></pre> <p>For more details on the Document container, see Document.</p>"},{"location":"reference/io/adapters/adapters/#adapter-configuration","title":"Adapter Configuration","text":""},{"location":"reference/io/adapters/adapters/#custom-interop-engine","title":"Custom Interop Engine","text":"<p>Both CDA and CDS adapters can be configured with custom interoperability engines. By default, the adapter uses the built-in InteropEngine with default CDA templates.</p> <p><pre><code>from healthchain.io import CdaAdapter\nfrom healthchain.interop import create_interop\n\n# Custom engine with specific configuration\ncustom_engine = create_interop(config_dir=\"/path/to/custom/config\")\nadapter = CdaAdapter(engine=custom_engine)\n</code></pre> For more information on the InteropEngine, see the InteropEngine documentation.</p>"},{"location":"reference/io/adapters/cdaadapter/","title":"CDA Adapter","text":"<p>The <code>CdaAdapter</code> handles conversion between CDA (Clinical Document Architecture) documents and HealthChain's internal <code>Document</code> objects. It parses CDA documents to extract free-text notes and structured clinical data into FHIR resources, and can convert processed Documents back into annotated CDA format.</p> <p>This adapter is particularly useful for clinical documentation improvement (CDI) workflows where documents need to be processed with ML models and updated with additional structured data.</p> <p>(Full Documentation on Clinical Documentation)</p>"},{"location":"reference/io/adapters/cdaadapter/#input-and-output","title":"Input and Output","text":"Input Output Document Access CdaRequest CdaResponse <code>Document.fhir.problem_list</code>, <code>Document.fhir.medication_list</code>, <code>Document.text</code>"},{"location":"reference/io/adapters/cdaadapter/#document-data-access","title":"Document Data Access","text":"<p>Data parsed from the CDA document is converted into FHIR resources and stored in the <code>Document.fhir</code> attribute. The adapter supports the following CDA section to FHIR resource mappings:</p> CDA Section FHIR Resource Document.fhir Attribute Problem List Condition <code>Document.fhir.problem_list</code> Medication List MedicationStatement <code>Document.fhir.medication_list</code> Clinical Notes DocumentReference <code>Document.text</code> + <code>Document.fhir.bundle</code> <p>All FHIR resources are Pydantic models, so you can access them using the <code>model_dump()</code> method:</p> <pre><code># Access structured clinical data\nfor condition in doc.fhir.problem_list:\n    print(condition.model_dump())\n\n# Access free-text content\nprint(f\"Clinical notes: {doc.text}\")\n</code></pre>"},{"location":"reference/io/adapters/cdsfhiradapter/","title":"CDS FHIR Adapter","text":"<p>The <code>CdsFhirAdapter</code> handles conversion between CDS Hooks requests/responses and HealthChain's internal <code>Document</code> objects. It processes FHIR data in the context of Clinical Decision Support (CDS) services, following the CDS Hooks specification.</p> <p>This adapter is specifically designed for building CDS services that receive FHIR data through prefetch and return clinical decision cards.</p> <p>(Full Documentation on Clinical Decision Support)</p>"},{"location":"reference/io/adapters/cdsfhiradapter/#input-and-output","title":"Input and Output","text":"Input Output Document Access CDSRequest CDSResponse <code>Document.fhir.get_prefetch_resources()</code>, <code>Document.cds.cards</code>"},{"location":"reference/io/adapters/cdsfhiradapter/#document-data-access","title":"Document Data Access","text":""},{"location":"reference/io/adapters/cdsfhiradapter/#fhir-prefetch-resources","title":"FHIR Prefetch Resources","text":"<p>Data from the CDS request's <code>prefetch</code> field is stored in the <code>Document.fhir.prefetch_resources</code> attribute as a dictionary mapping prefetch keys to FHIR resources:</p> <pre><code># After processing with adapter.parse()\ndoc = adapter.parse(cds_request)\n\n# Access prefetch resources by key\npatient = doc.fhir.get_prefetch_resources(\"patient\")\nconditions = doc.fhir.get_prefetch_resources(\"condition\")\ndocument_ref = doc.fhir.get_prefetch_resources(\"document\")\n\n# Access all prefetch resources\nall_resources = doc.fhir.prefetch_resources\nfor key, resource in all_resources.items():\n    print(f\"Resource '{key}': {resource.resourceType}\")\n</code></pre>"},{"location":"reference/io/adapters/cdsfhiradapter/#cds-cards","title":"CDS Cards","text":"<p>Generated CDS cards are stored in the <code>Document.cds.cards</code> attribute:</p> <pre><code># After ML processing\nfor card in processed_doc.cds.cards:\n    print(f\"Summary: {card.summary}\")\n    print(f\"Indicator: {card.indicator}\")\n    print(f\"Detail: {card.detail}\")\n    print(f\"Source: {card.source}\")\n</code></pre>"},{"location":"reference/io/adapters/cdsfhiradapter/#document-text-extraction","title":"Document Text Extraction","text":"<p>When the prefetch contains a <code>DocumentReference</code> resource, the adapter automatically extracts the document content and stores it in <code>Document.text</code>:</p> <pre><code># If prefetch contains document with base64 content\ncds_request = CDSRequest(\n    prefetch={\n        \"document\": {\n            \"resourceType\": \"DocumentReference\",\n            \"content\": [{\n                \"attachment\": {\n                    \"contentType\": \"text/plain\",\n                    \"data\": \"UGF0aWVudCBkaXNjaGFyZ2Ugbm90ZXM=\"  # base64 encoded\n                }\n            }]\n        }\n    }\n)\n\ndoc = adapter.parse(cds_request)\nprint(doc.text)  # \"Patient discharge notes\" (decoded)\n</code></pre>"},{"location":"reference/io/containers/containers/","title":"Containers","text":"<p>The <code>healthchain.io.containers</code> module provides FHIR-native containers for healthcare data processing. These containers handle the complexities of clinical data formats while providing a clean Python interface for NLP/ML pipelines.</p>"},{"location":"reference/io/containers/containers/#available-containers","title":"Available Containers","text":"Container Purpose Use Cases Document Clinical text + FHIR resources Clinical notes, discharge summaries, CDS workflows Dataset ML-ready features from FHIR Model training/inference, feature engineering"},{"location":"reference/io/containers/containers/#datacontainer","title":"DataContainer \ud83d\udce6","text":"<p><code>DataContainer</code> is a generic base class for storing data of any type. It provides serialization methods that other containers inherit.</p> <pre><code>from healthchain.io.containers import DataContainer\n\n# Create a DataContainer with string data\ncontainer = DataContainer(\"Some data\")\n\n# Convert to dictionary and JSON\ndata_dict = container.to_dict()\ndata_json = container.to_json()\n\n# Create from dictionary or JSON\ncontainer_from_dict = DataContainer.from_dict(data_dict)\ncontainer_from_json = DataContainer.from_json(data_json)\n</code></pre>"},{"location":"reference/io/containers/dataset/","title":"Dataset \ud83d\udcca","text":"<p>The <code>Dataset</code> is a pandas DataFrame wrapper designed for healthcare ML workflows: it extracts ML-ready features from FHIR Bundles using schemas, validates data types, and converts model predictions back into clinical decision support resources (RiskAssessment).</p>"},{"location":"reference/io/containers/dataset/#usage","title":"Usage","text":"<p>The two most helpful methods in the <code>Dataset</code> class are:</p> <ul> <li><code>from_fhir_bundle()</code>: Extract ML-ready features from a FHIR Bundle using a feature schema.</li> <li><code>to_risk_assessment()</code>: Convert model predictions into FHIR RiskAssessment resources for clinical consumption.</li> </ul> <p>Feature Schemas</p> <p>Define features once in YAML and reuse across training, validation, and inference. See FHIR Feature Mapper for schema details.</p> <pre><code>from healthchain.io.containers import Dataset\n\n# 1. Extract ML features from a FHIR Bundle using a feature schema\ndataset = Dataset.from_fhir_bundle(bundle, schema=\"path/to/schema.yaml\")\n\n# 2. Inspect the features as a pandas DataFrame\nprint(dataset.data.head())\nprint(\"Columns:\", dataset.columns)\n\n# 3. Validate the dataset against the schema (checks for missing/invalid fields)\nvalidation_result = dataset.validate(schema=\"path/to/schema.yaml\")\nprint(\"Validation Result:\", validation_result)\n\n# 4. Run inference using your ML model and store in metadata\ndataset.metadata[\"predictions\"] = model.predict(dataset.data)\ndataset.metadata[\"probabilities\"] = model.predict_proba(dataset.data)[:, 1]\n\n# 5. Convert predictions to FHIR RiskAssessment resources for downstream use\nrisk_assessments = dataset.to_risk_assessment(\n    outcome_code=\"A41.9\",\n    outcome_display=\"Sepsis, unspecified\",\n    model_name=\"SepsisRiskModel\",\n    model_version=\"1.0\"\n)\n</code></pre> <p>This workflow lets you convert FHIR healthcare data into DataFrames for ML, and then easily package predictions as standardized FHIR artifacts.</p> Example RiskAssessment Output <pre><code>{\n    \"resourceType\": \"RiskAssessment\",\n    \"id\": \"hc-a1b2c3d4\",\n    \"status\": \"final\",\n    \"subject\": {\n        \"reference\": \"Patient/123\"\n    },\n    \"method\": {\n        \"coding\": [{\n            \"system\": \"https://healthchain.github.io/ml-models\",\n            \"code\": \"RandomForestClassifier\",\n            \"display\": \"RandomForestClassifier v2.1\"\n        }]\n    },\n    \"prediction\": [{\n        \"outcome\": {\n            \"coding\": [{\n                \"system\": \"http://hl7.org/fhir/sid/icd-10\",\n                \"code\": \"A41.9\",\n                \"display\": \"Sepsis, unspecified\"\n            }]\n        },\n        \"probabilityDecimal\": 0.85,\n        \"qualitativeRisk\": {\n            \"coding\": [{\n                \"system\": \"http://terminology.hl7.org/CodeSystem/risk-probability\",\n                \"code\": \"high\",\n                \"display\": \"High Risk\"\n            }]\n        }\n    }],\n    \"note\": [{\n        \"text\": \"ML prediction: Positive (probability: 85.00%, risk: high)\"\n    }]\n}\n</code></pre>"},{"location":"reference/io/containers/dataset/#properties-and-methods","title":"Properties and Methods","text":"<p>Common Dataset operations:</p> <pre><code># Metadata\nprint(dataset.columns)           # List of feature names\nprint(dataset.row_count())       # Number of samples\nprint(dataset.column_count())    # Number of features\nprint(dataset.describe())        # Summary statistics\n\n# Data access\ndf = dataset.data                # Underlying pandas DataFrame\ndtypes = dataset.dtypes          # Feature data types\n\n# Data manipulation\ndataset.remove_column('temp_feature')  # Drop a feature\n</code></pre>"},{"location":"reference/io/containers/dataset/#resource-documentation","title":"Resource Documentation","text":"<ul> <li>FHIR RiskAssessment</li> <li>FHIR Observation</li> </ul>"},{"location":"reference/io/containers/dataset/#api-reference","title":"API Reference","text":"<p>See the Dataset API Reference for detailed class documentation.</p>"},{"location":"reference/io/containers/document/","title":"Document \ud83d\udcc4","text":"<p>The <code>Document</code> class is a container for working with both clinical text and structured healthcare data. It natively manages FHIR resources, runs NLP over raw notes, tracks clinical document relationships, stores decision support outputs, and holds LLM model predictions.</p> <p>Use Document containers for clinical notes, discharge summaries, patient records, and any healthcare data that combines text with structured FHIR resources.</p>"},{"location":"reference/io/containers/document/#usage","title":"Usage","text":"<p>The main things you'll do with <code>Document</code>:</p> <ul> <li>Store and update clinical notes and FHIR Bundles</li> <li>Extract and manipulate diagnoses, meds, allergies, and documents</li> <li>Run NLP to extract entities or embeddings from text</li> <li>Generate &amp; store CDS Hooks cards (recommendations, alerts)</li> <li>Attach model predictions for downstream use</li> </ul>"},{"location":"reference/io/containers/document/#api-overview","title":"API Overview","text":"<p>Document has four key components (all accessible as attributes):</p> Attribute For <code>doc.fhir</code> FHIR management\u2014Clinical lists, Bundles, DocReference, patient info <code>doc.nlp</code> NLP features\u2014entities, tokens, embeddings <code>doc.cds</code> Decision support\u2014recommendation cards, actions <code>doc.models</code> ML/LLM outputs\u2014store/retrieve predictions, generations"},{"location":"reference/io/containers/document/#fhir-data-docfhir","title":"FHIR Data (<code>doc.fhir</code>)","text":"<ul> <li>Automatic FHIR Bundle creation and management</li> <li>Resource type validation</li> <li>Easy access to clinical data lists (e.g., problems, medications, allergies)</li> <li>OperationOutcome and Provenance resources automatically extracted and accessible as <code>doc.fhir.operation_outcomes</code> and <code>doc.fhir.provenances</code> (removed from main bundle)</li> </ul> <p>Convenience Accessors</p> Attribute Description <code>patient</code> First Patient resource in the bundle (or <code>None</code>) <code>patients</code> List of Patient resources <code>problem_list</code> List of Condition resources (diagnoses, problems) <code>medication_list</code> List of MedicationStatement resources <code>allergy_list</code> List of AllergyIntolerance resources <p>Document Reference Management</p> <ul> <li>Document relationship tracking (parent/child/sibling)</li> <li>Attachment handling with base64 encoding</li> <li>Document family retrieval</li> </ul> <p>CDS Support</p> <ul> <li>Support for CDS Hooks prefetch resources</li> <li>Resource indexing by type</li> </ul> <pre><code>from healthchain.io import Document\nfrom healthchain.fhir import (\n    create_condition,\n    create_document_reference,\n)\n\n# Initialize with clinical text from EHR\ndoc = Document(\"Patient presents with uncontrolled hypertension and Type 2 diabetes\")\n\n# Build problem list with SNOMED CT codes\ndoc.fhir.problem_list = [\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"38341003\",\n        display=\"Hypertension\"\n    ),\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"44054006\",\n        display=\"Type 2 diabetes mellitus\"\n    )\n]\n\n# Track document versions and amendments\ninitial_note = create_document_reference(\n    data=\"Initial assessment: Patient presents with chest pain\",\n    content_type=\"text/plain\",\n    description=\"Initial ED note\"\n)\ninitial_id = doc.fhir.add_document_reference(initial_note)\n\n# Add amended note\namended_note = create_document_reference(\n    data=\"Amended: Patient presents with chest pain, ruling out cardiac etiology\",\n    content_type=\"text/plain\",\n    description=\"Amended ED note\"\n)\namended_id = doc.fhir.add_document_reference(\n    amended_note,\n    parent_id=initial_id,\n    relationship_type=\"replaces\"\n)\n\n# Retrieve document history for audit trail\nfamily = doc.fhir.get_document_reference_family(amended_id)\nprint(f\"Original note: {family['parents'][0].description}\")\n\n\n# Handle errors and track data provenance\nif doc.fhir.operation_outcomes:\n    for outcome in doc.fhir.operation_outcomes:\n        print(f\"Warning: {outcome.issue[0].diagnostics}\")\n\n# Access patient demographics\nif doc.fhir.patient:\n    print(f\"Patient: {doc.fhir.patient.name[0].given[0]} {doc.fhir.patient.name[0].family}\")\n\n# Prepare data for CDS Hooks integration\nprefetch = {\n    \"Condition\": doc.fhir.problem_list,\n    \"MedicationStatement\": doc.fhir.medication_list,\n}\ndoc.fhir.prefetch_resources = prefetch\n\n# CDS service can query prefetch data\nconditions = doc.fhir.get_prefetch_resources(\"Condition\")\nprint(f\"Active conditions: {len(conditions)}\")\n</code></pre>"},{"location":"reference/io/containers/document/#nlp-docnlp","title":"NLP (<code>doc.nlp</code>)","text":"<ul> <li>Medical text features: tokens, entities (<code>get_entities()</code>), embeddings (<code>get_embeddings()</code>)</li> <li>Direct spaCy doc access, fast word counting</li> </ul> <pre><code># Extract medical concepts from clinical note\ndoc = Document(\"Patient diagnosed with pneumonia, started on azithromycin\")\n\n# Get medical entities\nentities = doc.nlp.get_entities()\nfor entity in entities:\n    print(f\"{entity.text}: {entity.label_}\")  # \"pneumonia: CONDITION\"\n\n# Access full spaCy document for custom processing\nspacy_doc = doc.nlp.get_spacy_doc()\nfor ent in spacy_doc.ents:\n    if hasattr(ent._, \"cui\"):\n        print(f\"{ent.text} -&gt; SNOMED: {ent._.cui}\")\n</code></pre>"},{"location":"reference/io/containers/document/#clinical-decision-support-doccds","title":"Clinical Decision Support (<code>doc.cds</code>)","text":"<ul> <li><code>cards</code>: Clinical recommendation cards displayed in EHR workflows</li> <li><code>actions</code>: Suggested interventions (orders, referrals, documentation)</li> </ul> <pre><code>from healthchain.models import Card, Action\n\n# Generate clinical alert\ndoc.cds.cards = [\n    Card(\n        summary=\"Drug interaction detected\",\n        indicator=\"critical\",\n        detail=\"Warfarin + NSAIDs: Increased bleeding risk\",\n        source={\"label\": \"Clinical Decision Support\"},\n    )\n]\n\n# Suggest action\ndoc.cds.actions = [\n    Action(\n        type=\"create\",\n        description=\"Order CBC to monitor platelets\",\n        resource={\n            \"resourceType\": \"ServiceRequest\",\n            \"code\": {\"text\": \"Complete Blood Count\"}\n        }\n    )\n]\n</code></pre>"},{"location":"reference/io/containers/document/#llm-model-outputs-docmodels","title":"LLM Model Outputs (<code>doc.models</code>)","text":"<ul> <li><code>get_output(model_name, task)</code>: Retrieve model predictions by name and task</li> <li><code>get_generated_text(model_name, task)</code>: Extract generated text from LLMs</li> <li>Supports Hugging Face, LangChain, spaCy, and custom models</li> </ul> <pre><code># Store classification results\ndoc.models.add_output(\n    model_name=\"clinical_classifier\",\n    task=\"diagnosis_prediction\",\n    output={\"prediction\": \"diabetes\", \"confidence\": 0.95}\n)\n\n# Store LLM summary\ndoc.models.add_output(\n    model_name=\"gpt4\",\n    task=\"summarization\",\n    output=\"Patient presents with classic diabetic symptoms...\"\n)\n\n# Retrieve outputs\ndiagnosis = doc.models.get_output(\"clinical_classifier\", \"diagnosis_prediction\")\nsummary = doc.models.get_generated_text(\"gpt4\", \"summarization\")\n</code></pre>"},{"location":"reference/io/containers/document/#properties-and-methods","title":"Properties and Methods","text":"<pre><code># FHIR access\nprint(doc.fhir.problem_list)\nprint(doc.fhir.patient)\n\n# NLP\ntokens = doc.nlp.get_tokens()\nents = doc.nlp.get_entities()\n\n# Clinical decision support\ncards = doc.cds.cards\n\n# Model outputs\ndoc.models.add_output(\"my_model\", \"task\", output={\"foo\": \"bar\"})\nprint(doc.models.get_output(\"my_model\", \"task\"))\n</code></pre>"},{"location":"reference/io/containers/document/#resource-docs","title":"Resource Docs","text":"<ul> <li>FHIR Bundle</li> <li>FHIR Condition</li> <li>FHIR DocumentReference</li> </ul>"},{"location":"reference/io/containers/document/#api-reference","title":"API Reference","text":"<p>See Document API Reference for full details.</p>"},{"location":"reference/io/mappers/fhir_feature/","title":"FHIR Feature Mapper","text":"<p>The <code>FHIRFeatureMapper</code> allows you to easily extract relevant features from FHIR Bundles based on a declarative schema. This makes it simple to generate ML-ready DataFrames for downstream analysis and modeling.</p>"},{"location":"reference/io/mappers/fhir_feature/#overview","title":"Overview","text":"<p>The mapper uses feature schemas\u2014YAML configs that define which clinical data to extract and how to transform it. This enables:</p> <ul> <li>Declarative mapping: Define features in YAML, not code</li> <li>Reproducible pipelines: Same schema = same features across train/test/prod</li> <li>Built-in validation: Type checking catches mismatches before inference</li> <li>FHIR-native: Works with any EHR's FHIR Bundle</li> </ul>"},{"location":"reference/io/mappers/fhir_feature/#usage","title":"Usage","text":"<p>Write a YAML file specifying which FHIR resources and codes to extract, desired data types, and any transformations:</p> <pre><code>name: sepsis_prediction_features\nversion: \"1.0\"\ndescription: Feature schema for sepsis risk model\n\n# Optional: Control how patient age is calculated\nmetadata:\n  age_calculation: event_date        # Calculate age at event time\n  event_date_source: Observation     # Use earliest observation date\n  event_date_strategy: earliest\n\nfeatures:\n  # Vital signs from Observations\n  heart_rate:\n    fhir_resource: Observation\n    code: \"220045\"                   # MIMIC-IV itemID\n    code_system: http://mimic.mit.edu/fhir/mimic/CodeSystem/mimic-chartevents-d-items\n    display: Heart Rate\n    unit: bpm\n    dtype: float64\n    required: true\n\n  # Demographics from Patient resource\n  age:\n    fhir_resource: Patient\n    field: birthDate             # Extract this field\n    transform: calculate_age     # Apply this transformation\n    dtype: int64\n    required: true\n</code></pre>"},{"location":"reference/io/mappers/fhir_feature/#standalone-use","title":"Standalone Use","text":"<p>In most cases you should use the Dataset API to automatically load your schema and extract features. It's the easiest and most robust workflow.</p> <p>For advanced usage, you can load a schema and use the <code>FHIRFeatureMapper</code> directly for more control:</p> <pre><code>from healthchain.io.mappers import FHIRFeatureMapper\nfrom healthchain.io.containers import FeatureSchema\n\n# Manually load your YAML feature schema\nschema = FeatureSchema.from_yaml(\"configs/features/my_model.yaml\")\n\n# Create the feature mapper with your schema\nmapper = FHIRFeatureMapper(schema)\n\n# Extract features from a FHIR Bundle\nfeatures_df = mapper.map(bundle, aggregation=\"mean\")\n\nprint(features_df.head())\n# (Optional) Access patient references\npatient_refs = features_df[\"patient_ref\"].tolist()\n</code></pre>"},{"location":"reference/io/mappers/fhir_feature/#aggregation-strategies","title":"Aggregation Strategies","text":"<p>When a patient has multiple observations for the same code (e.g., multiple temperature readings), specify how to aggregate them:</p> <pre><code># Take the mean of all values\ndataset = Dataset.from_fhir_bundle(bundle, schema, aggregation=\"mean\")\n\n# Use the most recent value\ndataset = Dataset.from_fhir_bundle(bundle, schema, aggregation=\"last\")\n\n# Other options: \"median\", \"max\", \"min\"\n</code></pre>"},{"location":"reference/io/mappers/fhir_feature/#multiple-code-systems","title":"Multiple Code Systems","text":"<p>Different EHRs use different code systems. You can map the same clinical concept across systems:</p> <pre><code># LOINC code for heart rate (standard)\nheart_rate_loinc:\n  fhir_resource: Observation\n  code: \"8867-4\"\n  code_system: http://loinc.org\n  display: Heart Rate\n  dtype: float64\n\n# MIMIC-IV internal code\nheart_rate_mimic:\n  fhir_resource: Observation\n  code: \"220045\"\n  code_system: http://mimic.mit.edu/fhir/mimic/CodeSystem/mimic-chartevents-d-items\n  display: Heart Rate\n  dtype: float64\n</code></pre> <p>Then in your code, merge as needed:</p> <pre><code>df = dataset.data\n# Combine both columns, preferring LOINC\ndf['heart_rate'] = df['heart_rate_loinc'].fillna(df['heart_rate_mimic'])\n</code></pre>"},{"location":"reference/io/mappers/fhir_feature/#validation-and-error-handling","title":"Validation and Error Handling","text":"<p>Check that incoming data matches your training schema:</p> <pre><code>from healthchain.io.containers import FeatureSchema\n\nschema = FeatureSchema.from_yaml(\"configs/features/my_model.yaml\")\nresult = dataset.validate(schema, raise_on_error=False)\n</code></pre>"},{"location":"reference/io/mappers/fhir_feature/#related-documentation","title":"Related Documentation","text":"<ul> <li>Dataset Container - Complete Dataset API reference</li> <li>Mappers Overview - Other mapper types</li> <li>FHIR Helpers - Creating FHIR resources</li> </ul>"},{"location":"reference/io/mappers/mappers/","title":"Mappers","text":"<p>Mappers transform data between different healthcare formats and structures. They enable standardized data conversion workflows while maintaining clinical semantics and validation.</p>"},{"location":"reference/io/mappers/mappers/#available-mappers","title":"Available Mappers","text":"Mapper Source Format Target Format Primary Use Case FHIRFeatureMapper FHIR Bundle pandas DataFrame Extract ML-ready features from FHIR resources"},{"location":"reference/io/mappers/mappers/#future-mappers-planned","title":"Future Mappers (Planned)","text":"<ul> <li>FHIR-to-FHIR Mapper: Transform between FHIR resource types</li> <li>FHIR-to-OMOP Mapper: Convert between FHIR and OMOP Common Data Model</li> </ul>"},{"location":"reference/io/mappers/mappers/#related-documentation","title":"Related Documentation","text":"<ul> <li>Containers - Data containers that use mappers</li> <li>Dataset - Uses FHIRFeatureMapper for feature extraction</li> <li>Adapters - Convert between healthcare protocols</li> </ul>"},{"location":"reference/pipeline/pipeline/","title":"Pipeline","text":"<p>HealthChain pipelines help you quickly build data processing workflows that integrate seamlessly with EHR systems. They support healthcare formats like FHIR out of the box and include built-in NLP to process free-text and structured clinical data\u2014so you can focus on AI, not integration hassles.</p> <p>Choose from prebuilt pipelines tailored to standard clinical workflows, or build custom pipelines for your own applications. Both approaches ensure production-ready interoperability and make it easy to adapt pipelines for any healthcare use case.</p>"},{"location":"reference/pipeline/pipeline/#prebuilt","title":"Prebuilt \ud83d\udce6","text":"<p>HealthChain comes with a set of end-to-end pipeline implementations of common healthcare data processing tasks.</p> <p>These prebuilt pipelines handle FHIR conversion, validation, and EHR integration for you. They work out-of-the-box with Adapters and Gateways, supporting CDS Hooks, NoteReader CDI, and FHIR APIs. They're great for a quick setup to build more complex integrations on top of.</p> Pipeline Container Use Case Description Example Application MedicalCodingPipeline <code>Document</code> Clinical Documentation Processes clinical notes into FHIR Condition resources with standard medical codes Automated ICD-10/SNOMED CT coding for billing and CDI workflows SummarizationPipeline <code>Document</code> Clinical Decision Support Generates clinical summaries as CDS Hooks cards for EHR integration Real-time discharge summaries in Epic or Cerner workflows <p>When you load your data into a prebuilt pipeline, it receives and returns request and response data ready to send to EHR integration points:</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\nfrom healthchain.models import CdaRequest\n\n# Load from a pipeline object\npipeline = MedicalCodingPipeline.load(pipeline_object)\n\n# Simple end-to-end processing\ncda_request = CdaRequest(document=\"&lt;Clinical Document&gt;\")\ncda_response = pipeline.process_request(cda_request)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#customizing-prebuilt-pipelines","title":"Customizing Prebuilt Pipelines","text":"<p>To customize a prebuilt pipeline, you can use the pipeline management methods to add, remove, and replace components.</p> <p>If you need more control and don't mind writing more code, you can subclass <code>BasePipeline</code> and implement your own pipeline logic.</p> <p>(BasePipeline API Reference)</p>"},{"location":"reference/pipeline/pipeline/#nlp-integrations","title":"NLP Integrations","text":"<p>HealthChain integrates directly with popular NLP libraries like spaCy, HuggingFace Transformers, and LangChain. Easily add advanced NLP models and components into your pipelines to power state-of-the-art healthcare AI workflows.</p> <p>(Full Documentation on NLP Integrations)</p> <pre><code>from healthchain.pipeline import MedicalCodingPipeline\n\n#\u00a0Load from Hugging Face\npipeline = MedicalCodingPipeline.from_model_id(\n    'blaze999/Medical-NER', task=\"token-classification\", source=\"huggingface\"\n)\n# Load from local model files\npipeline = MedicalCodingPipeline.from_local_model(\n    '/path/to/model', source=\"spacy\"\n)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#freestyle","title":"Freestyle \ud83d\udd7a","text":"<p>Containers are at the core of HealthChain pipelines: they define your data type and flow through each pipeline step, just like spaCy's <code>Doc</code>.</p> <p>Specify the container (e.g. Document or Dataset) when creating your pipeline (<code>Pipeline[Document]()</code>). Each node processes and returns the container, enabling smooth, type-safe, modular workflows and direct FHIR conversion.</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io.containers import Document\n\npipeline = Pipeline[Document]()\n</code></pre> <p>To use a built pipeline, compile it by running <code>.build()</code>. This will return a compiled pipeline that you can run on your data.</p> <pre><code># Compile the pipeline to create a callable object\npipe = pipeline.build()\n\n# Create a Document with your clinical text and run it through the pipeline\ndoc = pipe(Document(\"Patient is diagnosed with diabetes\"))\n\n# Print the extracted problem list items\nprint(doc.fhir.problem_list)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#adding-nodes","title":"Adding Nodes","text":"<p>There are three types of nodes you can add to your pipeline with the method <code>.add_node()</code>:</p> <ul> <li>Inline Functions</li> <li>Components</li> <li>Custom Components</li> </ul>"},{"location":"reference/pipeline/pipeline/#inline-functions","title":"Inline Functions","text":"<p>Inline functions are simple functions that process Document containers. Use them for custom clinical logic without creating full components.</p> <pre><code>from spacy.tokens import Span\n\n@pipeline.add_node\ndef link_snomed_codes(doc: Document) -&gt; Document:\n    \"\"\"Map medical entities to SNOMED CT codes.\"\"\"\n    if not Span.has_extension(\"cui\"):\n        Span.set_extension(\"cui\", default=None)\n\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    # Map clinical terms to SNOMED CT\n    snomed_mapping = {\n        \"hypertension\": \"38341003\",\n        \"diabetes\": \"73211009\",\n        \"pneumonia\": \"233604007\",\n    }\n\n    for ent in spacy_doc.ents:\n        if ent.text.lower() in snomed_mapping:\n            ent._.cui = snomed_mapping[ent.text.lower()]\n\n    return doc\n\n# Equivalent to:\npipeline.add_node(link_snomed_codes)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#components","title":"Components","text":"<p>Components are pre-configured building blocks for common clinical NLP tasks. They handle FHIR conversion, entity extraction, and CDS formatting automatically.</p> <p>See the full list at the Components page.</p> <pre><code>from healthchain.pipeline.components import SpacyNLP, FHIRProblemListExtractor\n\n# Add medical NLP processing\nnlp = SpacyNLP.from_model_id(\"en_core_sci_sm\")\npipeline.add_node(nlp)\n\n# Extract FHIR Condition resources from entities\nextractor = FHIRProblemListExtractor()\npipeline.add_node(extractor)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#custom-components","title":"Custom Components","text":"<p>Custom components implement the <code>BaseComponent</code> interface for reusable clinical processing logic.</p> <pre><code>from healthchain.pipeline import BaseComponent\nfrom healthchain.fhir import create_condition\n\nclass ClinicalEntityLinker(BaseComponent):\n    \"\"\"Links extracted entities to standard medical terminologies.\"\"\"\n\n    def __init__(self, terminology_service_url: str):\n        super().__init__()\n        self.terminology_url = terminology_service_url\n\n    def __call__(self, doc: Document) -&gt; Document:\n        \"\"\"Convert medical entities to FHIR Conditions.\"\"\"\n        spacy_doc = doc.nlp.get_spacy_doc()\n\n        for ent in spacy_doc.ents:\n            if ent._.cui:  # Has SNOMED CT code\n                condition = create_condition(\n                    subject=f\"Patient/{doc.patient_id}\",\n                    code=ent._.cui,\n                    display=ent.text\n                )\n                doc.fhir.problem_list.append(condition)\n\n        return doc\n\n# Add to pipeline\nlinker = ClinicalEntityLinker(terminology_service_url=\"https://terminology.hl7.org/\")\npipeline.add_node(linker)\n</code></pre> <p>(BaseComponent API Reference)</p>"},{"location":"reference/pipeline/pipeline/#pipeline-management","title":"Pipeline Management \ud83d\udd28","text":""},{"location":"reference/pipeline/pipeline/#adding","title":"Adding","text":"<p>Use <code>.add_node()</code> to add a component to the pipeline. By default, the component will be added to the end of the pipeline and named as the function name provided.</p> <p>You can specify the position of the component using the <code>position</code> parameter. Available positions are:</p> <ul> <li><code>\"first\"</code></li> <li><code>\"last\"</code></li> <li><code>\"default\"</code></li> <li><code>\"after\"</code></li> <li><code>\"before\"</code></li> </ul> <p>When using <code>\"after\"</code> or <code>\"before\"</code>, you must also specify the <code>reference</code> parameter with the name of the node you want to add the component after or before.</p> <p>You can also specify the <code>stage</code> parameter to add the component to a specific stage group of the pipeline.</p> <pre><code>@pipeline.add_node(position=\"after\", reference=\"SpacyNLP\", stage=\"entity_linking\")\ndef link_snomed_codes(doc: Document) -&gt; Document:\n    \"\"\"Add SNOMED CT codes to extracted medical entities.\"\"\"\n    spacy_doc = doc.nlp.get_spacy_doc()\n    snomed_mapping = {\n        \"hypertension\": \"38341003\",\n        \"diabetes\": \"73211009\",\n    }\n    for ent in spacy_doc.ents:\n        if ent.text.lower() in snomed_mapping:\n            ent._.cui = snomed_mapping[ent.text.lower()]\n    return doc\n</code></pre> <p>You can specify dependencies between components using the <code>dependencies</code> parameter. This is useful if you want to ensure that a component is run after another component.</p> <pre><code>@pipeline.add_node(dependencies=[\"SpacyNLP\"])\ndef extract_medications(doc: Document) -&gt; Document:\n    \"\"\"Extract medication entities and convert to FHIR MedicationStatements.\"\"\"\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    for ent in spacy_doc.ents:\n        if ent.label_ == \"MEDICATION\":\n            # Create FHIR MedicationStatement\n            med_statement = create_medication_statement(\n                subject=f\"Patient/{doc.patient_id}\",\n                code=ent._.cui if hasattr(ent._, \"cui\") else None,\n                display=ent.text\n            )\n            doc.fhir.medication_list.append(med_statement)\n\n    return doc\n</code></pre>"},{"location":"reference/pipeline/pipeline/#removing","title":"Removing","text":"<p>Use <code>.remove()</code> to remove a component from the pipeline.</p> <pre><code>pipeline.remove(\"link_snomed_codes\")\n</code></pre>"},{"location":"reference/pipeline/pipeline/#replacing","title":"Replacing","text":"<p>Use <code>.replace()</code> to replace a component in the pipeline.</p> <pre><code>def enhanced_entity_linking(doc: Document) -&gt; Document:\n    \"\"\"Enhanced entity linking with external terminology service.\"\"\"\n    spacy_doc = doc.nlp.get_spacy_doc()\n\n    for ent in spacy_doc.ents:\n        # Call external terminology service for validation\n        validated_code = terminology_service.validate(ent.text)\n        if validated_code:\n            ent._.cui = validated_code\n\n    return doc\n\n# Replace basic linking with enhanced version\npipeline.replace(\"link_snomed_codes\", enhanced_entity_linking)\n</code></pre>"},{"location":"reference/pipeline/pipeline/#inspecting-the-pipeline","title":"Inspecting the Pipeline","text":"<pre><code>print(pipeline)\nprint(pipeline.stages)\n\n# [\"SpacyNLP\", \"ClinicalEntityLinker\", \"FHIRProblemListExtractor\"]\n# preprocessing:\n#   - SpacyNLP\n# entity_linking:\n#   - ClinicalEntityLinker\n# fhir_conversion:\n#   - FHIRProblemListExtractor\n</code></pre>"},{"location":"reference/pipeline/pipeline/#working-with-healthcare-data-formats","title":"Working with Healthcare Data Formats \ud83d\udd04","text":"<p>Adapters let you easily convert between healthcare formats (CDA, FHIR, CDS Hooks) and HealthChain Documents. Keep your ML pipeline format-agnostic while always getting FHIR-ready outputs.</p> <p>(Full Documentation on Adapters)</p> <pre><code>from healthchain.io import CdaAdapter, Document\n\nadapter = CdaAdapter()\n\n# Parse healthcare data into Document\ndoc = adapter.parse(cda_request)\n\n# Process with pure pipeline\nprocessed_doc = pipeline(doc)\n\n# Convert back to healthcare format\nresponse = adapter.format(processed_doc)\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/","title":"CdsCardCreator","text":"<p>The <code>CdsCardCreator</code> is a pipeline component that creates CDS Hooks cards from either model outputs or static content. These cards can be displayed in Electronic Health Record (EHR) systems as part of clinical decision support workflows.</p>"},{"location":"reference/pipeline/components/cdscardcreator/#overview","title":"Overview","text":"<p>The component takes text input and formats it into standardized CDS Hooks cards using <code>Jinja2</code> templates. It can create cards from:</p> <ol> <li>Model-generated text stored in a document's model outputs container</li> <li>Static content provided during initialization</li> </ol>"},{"location":"reference/pipeline/components/cdscardcreator/#usage","title":"Usage","text":""},{"location":"reference/pipeline/components/cdscardcreator/#basic-usage-with-model-output","title":"Basic Usage with Model Output","text":"<pre><code>from healthchain.pipeline.components import CdsCardCreator\n\n# Create cards from model output\ncreator = CdsCardCreator(source=\"huggingface\", task=\"summarization\")\ndoc = creator(doc)  # Creates cards from model output\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#using-static-content","title":"Using Static Content","text":"<pre><code># Create cards with static content\ncreator = CdsCardCreator(static_content=\"Static card message\")\ndoc = creator(doc)  # Creates card with static content\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#custom-template","title":"Custom Template","text":"<pre><code># Create cards with custom template\ntemplate = '''\n{\n    \"summary\": \"Warning heading!\",\n    \"indicator\": \"warning\",\n    \"source\": {{ default_source | tojson }},\n    \"detail\": \"{{ model_output }}\"\n}\n'''\n\ncreator = CdsCardCreator(\n    template=template,\n    source=\"langchain\",\n    task=\"chat\",\n    delimiter=\"\\n\"\n)\ndoc = creator(doc)  # Creates cards split by newlines\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#configuration-options","title":"Configuration Options","text":"Parameter Type Description <code>template</code> <code>str</code> Optional Jinja2 template string for card creation <code>template_path</code> <code>str</code> or <code>Path</code> Optional path to a Jinja2 template file <code>static_content</code> <code>str</code> Optional static text to use instead of model output <code>source</code> <code>str</code> Source framework to get model output from (e.g. \"huggingface\") <code>task</code> <code>str</code> Task name to get model output from (e.g. \"summarization\") <code>delimiter</code> <code>str</code> Optional string to split model output into multiple cards <code>default_source</code> <code>Dict[str, Any]</code> Default source info for cards. Defaults to <code>{\"label\": \"Card Generated by HealthChain\"}</code>"},{"location":"reference/pipeline/components/cdscardcreator/#card-template-format","title":"Card Template Format","text":"<p>The default template creates an info card with the following structure:</p> <pre><code>{\n    \"summary\": \"{{ model_output[:140] }}\",\n    \"indicator\": \"info\",\n    \"source\": {{ default_source | tojson }},\n    \"detail\": \"{{ model_output }}\"\n}\n</code></pre> <p>Available template variables: - <code>model_output</code>: The text content to display in the card - <code>default_source</code>: Source information dictionary</p>"},{"location":"reference/pipeline/components/cdscardcreator/#card-properties","title":"Card Properties","text":"<p>The created cards have the following properties:</p> <ul> <li><code>summary</code>: Brief description (max 140 characters)</li> <li><code>indicator</code>: Card urgency level (\"info\", \"warning\", \"critical\")</li> <li><code>source</code>: Source information object</li> <li><code>detail</code>: Full text content</li> <li><code>suggestions</code>: Optional suggested actions</li> <li><code>selectionBehavior</code>: Optional selection behavior</li> <li><code>overrideReasons</code>: Optional override reasons</li> <li><code>links</code>: Optional external links</li> </ul>"},{"location":"reference/pipeline/components/cdscardcreator/#integration-with-summarizationpipeline","title":"Integration with SummarizationPipeline","text":"<p>The CdsCardCreator can be used as part of a larger pipeline:</p> <pre><code>from healthchain.pipeline import SummarizationPipeline\nfrom healthchain.pipeline.components import CdsCardCreator\n\npipeline = SummarizationPipeline()\npipeline.add_component(CdsCardCreator(\n    source=\"huggingface\",\n    task=\"summarization\",\n    template_path=\"path/to/template.json\",\n    delimiter=\"\\n\"\n))\n</code></pre>"},{"location":"reference/pipeline/components/cdscardcreator/#related-documentation","title":"Related Documentation","text":"<ul> <li>CDS Hooks Specification</li> <li>Clinical Decision Support Documentation</li> </ul>"},{"location":"reference/pipeline/components/components/","title":"Component","text":"<p>Components are the building blocks of the healthchain pipeline. They are designed to process data in a consistent manner, allowing for easy composition and reusability.</p>"},{"location":"reference/pipeline/components/components/#available-components","title":"Available Components","text":"Component Description Methods <code>TextPreprocessor</code> Handles text preprocessing tasks <code>tokenizer</code>: Specifies the tokenization method (e.g., <code>\"basic\"</code> or <code>\"spacy\"</code>)  <code>lowercase</code>: Converts text to lowercase if <code>True</code> <code>remove_punctuation</code>: Removes punctuation if <code>True</code> <code>standardize_spaces</code>: Standardizes spaces if <code>True</code> <code>regex</code>: List of custom regex patterns and replacements <code>TextPostProcessor</code> Handles text postprocessing tasks <code>postcoordination_lookup</code>: Dictionary for entity refinement lookups CdsCardCreator Formats model outputs into CDS cards for clinical decision support <code>create_card</code>: Creates a CDS card FHIRProblemListExtractor Extracts entities with medical codes and creates FHIR Condition resources with the problem_list extension <code>__call__</code>: Extracts the problem list"},{"location":"reference/pipeline/components/components/#creating-custom-components","title":"Creating Custom Components","text":"<p>You can create your own custom components by extending the <code>BaseComponent</code> class and implementing the <code>__call__</code> method.</p> <pre><code>from healthchain.pipeline.base import BaseComponent\n\nclass MyCustomComponent(BaseComponent):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def __call__(self, data):\n        # Your custom processing logic here\n        return data\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/","title":"FHIRProblemListExtractor","text":"<p>The <code>FHIRProblemListExtractor</code> is a pipeline component that automatically extracts NLP annotations and formats them into FHIR Condition resources with the the category <code>problem-list-item</code> and the status <code>active</code>.</p>"},{"location":"reference/pipeline/components/fhirproblemextractor/#usage","title":"Usage","text":""},{"location":"reference/pipeline/components/fhirproblemextractor/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.pipeline.components import FHIRProblemListExtractor\n\n# Extract conditions with default settings\nextractor = FHIRProblemListExtractor()\ndoc = extractor(doc)  # Extracts from NLP entities stored in document's .nlp.entities or spaCy doc\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#configuration-options","title":"Configuration Options","text":"<pre><code># Use SNOMED CT codes\nextractor = FHIRProblemListExtractor(\n    patient_ref=\"Patient/456\",  # optional, defaults to \"Patient/123\"\n    code_attribute=\"snomed_id\", # optional, defaults to \"cui\"\n    coding_system=\"http://snomed.info/sct\" # optional, defaults to \"http://snomed.info/sct\"\n)\n\n# Use ICD-10 codes\nextractor = FHIRProblemListExtractor(\n    patient_ref=\"Patient/456\",\n    code_attribute=\"icd10\",\n    coding_system=\"http://hl7.org/fhir/sid/icd-10\"\n)\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#entity-extraction","title":"Entity Extraction","text":"<p>The component extracts entities from the document's NLP annotations.</p>"},{"location":"reference/pipeline/components/fhirproblemextractor/#spacy-entities","title":"spaCy Entities","text":"<p>Extracts from spaCy entities with extension attributes:</p> <pre><code># spaCy entity with CUI code\nent._.cui = \"C0015967\"  # Extracted automatically\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#generic-nlp-entities","title":"Generic NLP Entities","text":"<p>Works with any NLP framework via generic entity dictionaries: <pre><code>entities = [\n    {\"text\": \"fever\", \"cui\": \"C0015967\"},\n    {\"text\": \"hypertension\", \"snomed_id\": \"38341003\"}\n]\n</code></pre></p>"},{"location":"reference/pipeline/components/fhirproblemextractor/#fhir-condition-creation","title":"FHIR Condition Creation","text":"<p>Example of a FHIR Condition resource created by the component:</p> <pre><code>{\n  \"resourceType\": \"Condition\",\n  \"id\": \"hc-0aa85ff7-5e40-472b-a676-cb3df83d8313\",\n  \"clinicalStatus\": {\n    \"coding\": [\n      {\n        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n        \"code\": \"active\",\n        \"display\": \"Active\"\n      }\n    ]\n  },\n  \"code\": {\n    \"coding\": [\n      {\n        \"system\": \"http://snomed.info/sct\",\n        \"code\": \"C0242429\",  # extracted from doc entity\n        \"display\": \"sore throat\"  # extracted from doc entity\n      }\n    ]\n  },\n  \"subject\": {\n    \"reference\": \"Patient/123\"\n  }\n}\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#medicalcodingpipeline-integration","title":"MedicalCodingPipeline Integration","text":"<pre><code>from healthchain.pipeline import MedicalCodingPipeline\n\n# Automatic problem extraction\npipeline = MedicalCodingPipeline(\n    extract_problems=True,\n    patient_ref=\"Patient/456\",\n    code_attribute=\"cui\"\n)\n</code></pre>"},{"location":"reference/pipeline/components/fhirproblemextractor/#related-documentation","title":"Related Documentation","text":"<ul> <li>FHIR Condition Resources</li> <li>Medical Coding Pipeline</li> <li>Document Container</li> </ul>"},{"location":"reference/pipeline/integrations/integrations/","title":"NLP Integrations","text":"<p>This document provides an overview of the integration components available in the HealthChain package. These components allow you to easily incorporate popular NLP libraries into your HealthChain pipelines.</p>"},{"location":"reference/pipeline/integrations/integrations/#table-of-contents","title":"Table of Contents","text":"<ol> <li>SpacyNLP</li> <li>HFTransformer</li> <li>LangChainLLM</li> </ol>"},{"location":"reference/pipeline/integrations/integrations/#installation-requirements","title":"Installation Requirements","text":"<p>Before utilizing the integration components, it is important to note that the required third-party libraries are not included in HealthChain's default installation. This design decision was made to:</p> <ul> <li>Maintain a lean and flexible core package</li> <li>Allow users to selectively install only the necessary dependencies</li> <li>Avoid potential version conflicts with other packages in your environment</li> </ul> <p>To use these integrations, you will need to manually install the corresponding libraries using <code>pip</code>.</p> <pre><code>pip install spacy\npython -m spacy download en_core_web_sm  # or another desired model\npip install transformers\npip install langchain\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#spacynlp","title":"SpacyNLP","text":"<p>The <code>SpacyNLP</code> component allows you to integrate spaCy models into your HealthChain pipeline. There are two ways to initialize this component:</p> <ol> <li> <p>Using a pre-configured spaCy <code>Language</code> object:    <pre><code>import spacy\nfrom healthchain.pipeline.components.integrations import SpacyNLP\n\nnlp = spacy.load(\"en_core_web_sm\")\nspacy_component = SpacyNLP(nlp)\n</code></pre></p> </li> <li> <p>Using the factory method with a model identifier or path to a custom local model:    <pre><code>from healthchain.pipeline.components.integrations import SpacyNLP\n\n# Using a standard spaCy model\nspacy_component = SpacyNLP.from_model_id(\n   \"en_core_web_sm\",\n   disable=[\"parser\"]  # kwargs passed to spacy.load()\n)\n\n# Using a custom local model\nspacy_component = SpacyNLP.from_model_id(\"/path/to/your/model\")\n</code></pre></p> </li> </ol> <p>Choose the appropriate model based on your specific needs - standard models for general text, custom-trained models for domain-specific tasks, or specialized models like scispaCy for biomedical text analysis.</p> <pre><code># Using scispaCy models for biomedical text (requires: pip install scispacy)\nspacy_component = SpacyNLP.from_model_id(\"en_core_sci_sm\")\n</code></pre> <p>The component will process documents using spaCy and store the spaCy Doc object in the document's <code>nlp</code> annotations. It can be accessed using the <code>Document.nlp.get_spacy_doc()</code> method.</p>"},{"location":"reference/pipeline/integrations/integrations/#example","title":"Example","text":"<pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import SpacyNLP\n\npipeline = Pipeline()\npipeline.add_node(SpacyNLP.from_model_id(\"en_core_web_sm\"))\n\ndoc = Document(\"This is a test sentence.\")\nprocessed_doc = pipeline(doc)\n\n# Access spaCy annotations\nspacy_doc = processed_doc.nlp.get_spacy_doc()\nfor token in spacy_doc:\n    print(f\"Token: {token.text}, POS: {token.pos_}, Lemma: {token.lemma_}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#hftransformer","title":"HFTransformer","text":"<p>The <code>HFTransformer</code> integrates HuggingFace <code>transformers</code> models into your HealthChain pipeline. Models can be browsed on the HuggingFace website.</p> <p>HuggingFace offers models for a wide range of different tasks, and while not all of these have been thoroughly tested for HealthChain compatibility, we expect that all NLP models and tasks should be compatible. If you have an issues integrating any models please raise an issue on our Github homepage!</p> <p>There are two ways to initialize this component:</p> <ol> <li> <p>Using a pre-configured HuggingFace pipeline:    <pre><code>from transformers import pipeline, AutoTokenizer, AutoModelForCausalLM\nfrom healthchain.pipeline.components.integrations import HFTransformer\n\nmodel_id = \"gpt2\"\ntokenizer = AutoTokenizer.from_pretrained(model_id)\nmodel = AutoModelForCausalLM.from_pretrained(model_id)\npipe = pipeline(\n   \"text-generation\",\n   model=model,\n   tokenizer=tokenizer,\n   max_new_tokens=10\n)\n\nhuggingface_component = HFTransformer(pipe)\n</code></pre></p> </li> <li> <p>Using the factory method with a model identifier:    <pre><code>from healthchain.pipeline.components.integrations import HFTransformer\n\nhuggingface_component = HFTransformer.from_model_id(\n    model=\"facebook/bart-large-cnn\",\n    task=\"summarization\",\n    max_length=130,  # kwargs passed to pipeline()\n    min_length=30,\n    do_sample=False\n)\n</code></pre></p> </li> </ol> <p>The factory method requires the following arguments:</p> <ul> <li><code>task</code> (str): The NLP task to perform (e.g., \"sentiment-analysis\", \"named-entity-recognition\").</li> <li><code>model</code> (str): The name or path of the Hugging Face model to use.</li> <li><code>**kwargs**</code>: Additional keyword arguments passed to the <code>pipeline()</code> function.</li> </ul> <p>This component applies the specified Hugging Face model to the input document and stores the output in the HealthChain <code>Document.models</code>.</p> <p>It can be accessed using the <code>Document.models.get_output()</code> method with the key <code>\"huggingface\"</code> and the task name.</p>"},{"location":"reference/pipeline/integrations/integrations/#example_1","title":"Example","text":"<pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import HFTransformer\n\npipeline = Pipeline()\npipeline.add_node(HFTransformer.from_model_id(\n   task=\"sentiment-analysis\",\n   model=\"distilbert-base-uncased-finetuned-sst-2-english\"\n   )\n)\n\ndoc = Document(\"I love using HealthChain for my NLP projects!\")\nprocessed_doc = pipeline(doc)\n\n# Access Hugging Face output\nsentiment_result = processed_doc.models.get_output(\n   \"huggingface\", \"sentiment-analysis\"\n)\n\nprint(f\"Sentiment: {sentiment_result}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#langchainllm","title":"LangChainLLM","text":"<p>The <code>LangChainLLM</code> allows you to integrate LangChain chains into your HealthChain pipeline.</p> <pre><code>from langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\nfrom healthchain.pipeline.components.integrations import LangChainLLM\n\n# Let's create a simple FakeListLLM for demonstration\nfake_llm = FakeListLLM(responses=[\"This is a great summary!\"])\n\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\n\n# Create the component\nlangchain_component = LangChainLLM(\n    chain=chain,\n    task=\"chat\",\n    temperature=0.7  # Optional kwargs passed to invoke()\n)\n</code></pre> <p>The component requires the following arguments:</p> <ul> <li><code>chain</code>: A LangChain chain object to be executed within the pipeline.</li> <li><code>task</code>: The key to store the output in <code>Document.models</code>.</li> <li><code>**kwargs**</code>: Additional keyword arguments passed to the <code>invoke()</code> method.</li> </ul> <p>This component runs the specified LangChain chain on the input document's text and stores the output in the HealthChain <code>Document.models</code>.</p> <p>It can be accessed using the <code>Document.models.get_output()</code> method with the key <code>\"langchain\"</code> and the task name.</p>"},{"location":"reference/pipeline/integrations/integrations/#example_2","title":"Example","text":"<pre><code>from langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\nfrom healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import LangChainLLM\n\n# Set up LangChain with a FakeListLLM\nfake_llm = FakeListLLM(\n    responses=[\"HealthChain integrates NLP libraries for easy pipeline creation.\"]\n)\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\n\n# Set up your HealthChain pipeline\npipeline = Pipeline()\npipeline.add_node(LangChainLLM(chain=chain, task=\"summarization\"))\n\n# Let's summarize something\ndoc = Document(\n    \"HealthChain is a powerful package for building NLP pipelines. It integrates seamlessly with popular libraries like spaCy, Hugging Face Transformers, and LangChain, allowing users to create complex NLP workflows with ease.\"\n)\nprocessed_doc = pipeline(doc)\n\n# What summary did we get?\nsummary = processed_doc.models.get_output(\"langchain\", \"summarization\")\nprint(f\"Summary: {summary}\")\n</code></pre>"},{"location":"reference/pipeline/integrations/integrations/#combining-components","title":"Combining Components","text":"<p>You can easily combine multiple integration components in a single HealthChain pipeline:</p> <pre><code>from healthchain.io.containers import Document\nfrom healthchain.pipeline.base import Pipeline\nfrom healthchain.pipeline.components.integrations import (\n    SpacyNLP,\n    HFTransformer,\n    LangChainLLM,\n)\n\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain.llms import FakeListLLM\n\n# Set up our components\nspacy_component = SpacyNLP.from_model_id(\"en_core_web_sm\")\nhuggingface_component = HFTransformer.from_model_id(\n    model=\"distilbert-base-uncased-finetuned-sst-2-english\",\n    task=\"sentiment-analysis\",\n)\n\n# Set up LangChain with a FakeListLLM\nfake_llm = FakeListLLM(responses=[\"HealthChain: Powerful NLP pipeline builder.\"])\n# Define the prompt template\nprompt = PromptTemplate.from_template(\"Summarize the following text: {text}\")\n# Create the LCEL chain\nchain = prompt | fake_llm | StrOutputParser()\nlangchain_component = LangChainLLM(chain=chain, task=\"summarization\")\n\n# Build our pipeline\npipeline = Pipeline()\npipeline.add_node(spacy_component)\npipeline.add_node(huggingface_component)\npipeline.add_node(langchain_component)\npipeline.build()\n\n# Process a document\ndoc = Document(\"HealthChain makes it easy to build powerful NLP pipelines!\")\nprocessed_doc = pipeline(doc)\n\n# Let's see what we got!\nspacy_doc = processed_doc.nlp.get_spacy_doc()\nsentiment = processed_doc.models.get_output(\"huggingface\", \"sentiment-analysis\")\nsummary = processed_doc.models.get_output(\"langchain\", \"summarization\")\n\nprint(f\"Tokens: {[token.text for token in spacy_doc]}\")\nprint(f\"Sentiment: {sentiment}\")\nprint(f\"Summary: {summary}\")\n</code></pre> <p>This documentation provides an overview of the integration components available in HealthChain. For more detailed information on each library, please refer to their respective documentation:</p> <ul> <li>spaCy Documentation</li> <li>Hugging Face Transformers Documentation</li> <li>LangChain Documentation</li> </ul>"},{"location":"reference/pipeline/prebuilt_pipelines/medicalcoding/","title":"MedicalCodingPipeline","text":"<p>Full documentation coming soon!</p>"},{"location":"reference/pipeline/prebuilt_pipelines/summarization/","title":"SummarizationPipeline","text":"<p>Full documentation coming soon! Check out this cookbook example for now.</p>"},{"location":"reference/utilities/data_generator/","title":"Data Generator","text":"<p>Healthcare systems use standardized data formats, but each hospital or clinic configures their data differently. This creates challenges when building applications that need to work across multiple healthcare systems.</p> <p>The data generator creates test data that matches the structure and format expected by Electronic Health Record (EHR) systems. It's designed for testing your applications, not for research studies that need realistic patient populations.</p> <p>According to the UK ONS synthetic data classification, HealthChain generates \"level 1: synthetic structural data\" - data that follows the correct format but contains fictional information.</p> <p></p>"},{"location":"reference/utilities/data_generator/#cds-data-generator","title":"CDS Data Generator","text":"<p>The <code>.generate_prefetch()</code> method will return a dictionary of resources. Each key in the dictionary corresponds to a FHIR resource type, and the value is a list of FHIR resources or a Bundle of that type. For more information, check out the CDS Hooks documentation.</p> <p>For each workflow, a pre-configured list of FHIR resources is randomly generated and placed in the <code>prefetch</code> field of a <code>CDSRequest</code>.</p> <p>Current implemented workflows:</p> Workflow Implementation Completeness Generated Synthetic Resources patient-view <code>Patient</code>, <code>Encounter</code> (Future: <code>MedicationStatement</code>, <code>AllergyIntolerance</code>) encounter-discharge <code>Patient</code>, <code>Encounter</code>, <code>Procedure</code>, <code>MedicationRequest</code>, Optional <code>DocumentReference</code> order-sign  Partial Future: <code>MedicationRequest</code>, <code>ProcedureRequest</code>, <code>ServiceRequest</code> order-select  Partial Future: <code>MedicationRequest</code>, <code>ProcedureRequest</code>, <code>ServiceRequest</code> <p>For more information on CDS workflows, see the CDS Hooks Protocol documentation.</p> <p>You can use the data generator with <code>SandboxClient.load_free_text()</code> or standalone:</p> With SandboxClientStandalone <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create client\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\"\n)\n\n# Generate FHIR data from clinical notes\nclient.load_free_text(\n    csv_path=\"./data/discharge_notes.csv\",\n    column_name=\"text\",\n    random_seed=42\n)\n\nresponses = client.send_requests()\n</code></pre> <pre><code>from healthchain.sandbox.generators import CdsDataGenerator\nfrom healthchain.sandbox.workflows import Workflow\n\n# Initialize data generator\ndata_generator = CdsDataGenerator()\n\n# Generate FHIR resources for use case workflow\ndata_generator.set_workflow(Workflow.encounter_discharge)\nprefetch = data_generator.generate_prefetch()\n\nprint(prefetch.model_dump())\n\n# {\n#    \"prefetch\": {\n#        \"encounter\":\n#            {\n#              \"resourceType\": ...\n#            }\n#    }\n#}\n</code></pre>"},{"location":"reference/utilities/data_generator/#loading-free-text","title":"Loading free-text","text":"<p>You can specify the <code>free_text_csv</code> field of the <code>.generate_prefetch()</code> method to load in free-text sources into the data generator, e.g. discharge summaries. This will wrap the text into a FHIR DocumentReference resource (N.B. currently we place the text directly in the resource attachment, although it is technically supposed to be base64 encoded).</p> <p>A random text document from the <code>csv</code> file will be picked for each generation.</p> <pre><code># Load free text into a DocumentResource FHIR resource\ndata = data_generator.generate_prefetch(free_text_csv=\"./dir/to/csv/file\")\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/","title":"FHIR Utilities","text":"<p>The <code>fhir</code> module provides a set of helper functions to make it easier for you to work with FHIR resources.</p>"},{"location":"reference/utilities/fhir_helpers/#fhir-version-support","title":"FHIR Version Support","text":"<p>HealthChain supports multiple FHIR versions: R5 (default), R4B, and STU3. All resource creation and helper functions accept an optional <code>version</code> parameter.</p>"},{"location":"reference/utilities/fhir_helpers/#supported-versions","title":"Supported Versions","text":"Version Description Package Path R5 FHIR Release 5 (default) <code>fhir.resources.*</code> R4B FHIR R4B (Ballot) <code>fhir.resources.R4B.*</code> STU3 FHIR STU3 <code>fhir.resources.STU3.*</code>"},{"location":"reference/utilities/fhir_helpers/#basic-usage","title":"Basic Usage","text":"<pre><code>from healthchain.fhir import (\n    FHIRVersion,\n    get_fhir_resource,\n    set_default_version,\n    fhir_version_context,\n    convert_resource,\n    create_condition,\n)\n\n# Get a resource class for a specific version\nPatient_R4B = get_fhir_resource(\"Patient\", \"R4B\")\nPatient_R5 = get_fhir_resource(\"Patient\", FHIRVersion.R5)\n\n# Create resources with a specific version\ncondition_r4b = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\",\n    version=\"R4B\"  # Creates R4B Condition\n)\n\n# Set the default version for the session\nset_default_version(\"R4B\")\n\n# Use context manager for temporary version changes\nwith fhir_version_context(\"STU3\"):\n    # All resources created here use STU3\n    condition = create_condition(subject=\"Patient/123\", code=\"123\")\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#version-conversion","title":"Version Conversion","text":"<p>Convert resources between FHIR versions using <code>convert_resource()</code>:</p> <pre><code>from healthchain.fhir import get_fhir_resource, convert_resource\n\n# Create an R5 Patient\nPatient_R5 = get_fhir_resource(\"Patient\")\npatient_r5 = Patient_R5(id=\"test-123\", gender=\"male\")\n\n# Convert to R4B\npatient_r4b = convert_resource(patient_r5, \"R4B\")\nprint(patient_r4b.__class__.__module__)  # fhir.resources.R4B.patient\n</code></pre> <p>Version Conversion Limitations</p> <p>The <code>convert_resource()</code> function uses a serialize/deserialize approach. Field mappings between FHIR versions may not be 1:1 - some fields may be added, removed, or renamed between versions. Complex resources with version-specific fields may require manual handling.</p>"},{"location":"reference/utilities/fhir_helpers/#version-detection","title":"Version Detection","text":"<p>Detect the FHIR version of an existing resource:</p> <pre><code>from healthchain.fhir import get_resource_version, get_fhir_resource\n\nPatient_R4B = get_fhir_resource(\"Patient\", \"R4B\")\npatient = Patient_R4B(id=\"123\")\n\nversion = get_resource_version(patient)\nprint(version)  # FHIRVersion.R4B\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#api-reference","title":"API Reference","text":"Function Description <code>get_fhir_resource(name, version)</code> Get a resource class for a specific version <code>get_default_version()</code> Get the current default FHIR version <code>set_default_version(version)</code> Set the global default FHIR version <code>reset_default_version()</code> Reset to library default (R5) <code>fhir_version_context(version)</code> Context manager for temporary version changes <code>convert_resource(resource, version)</code> Convert a resource to a different version <code>get_resource_version(resource)</code> Detect the version of an existing resource"},{"location":"reference/utilities/fhir_helpers/#resource-creation","title":"Resource Creation","text":"<p>FHIR is the modern de facto standard for storing and exchanging healthcare data, but working with FHIR resources can often involve complex and nested JSON structures with required and optional fields that vary between contexts.</p> <p>Creating FHIR resources can involve a lot of boilerplate code, validation errors and manual comparison with FHIR specifications.</p> <p>For example, as an ML practitioner, you may only care about extracting and inserting certain codes and texts within a FHIR resource. If you want to locate the SNOMED CT code for a medication, you may have to do something headache-inducing like:</p> <pre><code>medication_statement = {\n    \"resourceType\": \"MedicationStatement\",\n    \"status\": \"active\",  # required\n    \"medication\": {  # required\n        \"concept\": {\n            \"coding\": [\n                {\n                    \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                    \"code\": \"1049221\",\n                    \"display\": \"Acetaminophen 325 MG Oral Tablet\",\n                }\n            ]\n        }\n    },\n    \"subject\": {  # required\n        \"reference\": \"Patient/example\"\n    },\n}\n\nmedication_statement[\"medication\"][\"concept\"][\"coding\"][0][\"code\"]\nmedication_statement[\"medication\"][\"concept\"][\"coding\"][0][\"display\"]\n</code></pre> <p>Sensible Defaults for Resource Creation</p> <p>The <code>fhir</code> <code>create_*</code> functions create FHIR resources with sensible defaults, automatically setting:   - A reference ID prefixed by \"<code>hc-</code>\"   - A status of \"<code>active</code>\" (or equivalent)   - A creation date where necessary</p> <p>You can modify and manipulate these resources as you would any other Pydantic object after their creation.</p> <p>Validation of FHIR Resources</p> <p>Internally, HealthChain uses fhir.resources to validate FHIR resources, which is powered by Pydantic V2. These helpers create minimal valid FHIR objects to help you get started easily.  ALWAYS check that the sensible defaults fit your needs, and validate your resource!</p>"},{"location":"reference/utilities/fhir_helpers/#overview","title":"Overview","text":"Resource Type Required Fields Sensible Defaults Common Use Cases Condition \u2022 <code>clinicalStatus</code>\u2022 <code>subject</code> \u2022 <code>clinicalStatus</code>: \"active\"\u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Recording diagnoses\u2022 Problem list items\u2022 Active conditions MedicationStatement \u2022 <code>subject</code>\u2022 <code>status</code>\u2022 <code>medication</code> \u2022 <code>status</code>: \"recorded\"\u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Current medications\u2022 Medication history\u2022 Prescribed medications AllergyIntolerance \u2022 <code>patient</code> \u2022 <code>id</code>: auto-generated with \"hc-\" prefix \u2022 Allergies\u2022 Intolerances\u2022 Adverse reactions DocumentReference \u2022 <code>type</code> \u2022 <code>status</code>: \"current\"\u2022 <code>date</code>: UTC now\u2022 <code>description</code>: default text\u2022 <code>content.attachment.title</code>: default text \u2022 Clinical notes\u2022 Lab reports\u2022 Imaging reports"},{"location":"reference/utilities/fhir_helpers/#create_condition","title":"create_condition()","text":"<p>Creates a new Condition resource.</p> <p>Required fields</p> <ul> <li>clinicalStatus</li> <li>subject</li> </ul> <p>Sensible Defaults</p> <p><code>clinicalStatus</code> is set to \"<code>active</code>\"</p> <pre><code>from healthchain.fhir import create_condition\n\n# Create a condition representing hypertension\ncondition = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\",\n)\n\n# Create an R4B condition\ncondition_r4b = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\",\n    version=\"R4B\",  # Optional: specify FHIR version\n)\n\n# Output the created resource\nprint(condition.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"Condition\",\n    \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n    \"clinicalStatus\": {\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n        }]\n    },\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"38341003\",\n            \"display\": \"Hypertension\"\n        }]\n    },\n    \"subject\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_medication_statement","title":"create_medication_statement()","text":"<p>Creates a new MedicationStatement resource.</p> <p>Required fields</p> <ul> <li>subject</li> <li>status</li> <li>medication</li> </ul> <p>Sensible Defaults</p> <p><code>status</code> is set to \"<code>recorded</code>\"</p> <pre><code>from healthchain.fhir import create_medication_statement\n\n# Create a medication statement for Acetaminophen\nmedication = create_medication_statement(\n    subject=\"Patient/123\",\n    code=\"1049221\",\n    display=\"Acetaminophen 325 MG Oral Tablet\",\n    system=\"http://www.nlm.nih.gov/research/umls/rxnorm\",\n)\n\n# Output the created resource\nprint(medication.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"MedicationStatement\",\n    \"id\": \"hc-86a26eba-63f9-4017-b7b2-5b36f9bad5f1\",\n    \"status\": \"recorded\",\n    \"medication\": {\n        \"concept\": {\n            \"coding\": [{\n                \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                \"code\": \"1049221\",\n                \"display\": \"Acetaminophen 325 MG Oral Tablet\"\n            }]\n        }\n    },\n    \"subject\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_allergy_intolerance","title":"create_allergy_intolerance()","text":"<p>Creates a new AllergyIntolerance resource.</p> <p>Required fields</p> <ul> <li>patient</li> </ul> <p>Sensible Defaults</p> <p>None (besides the auto-generated id)</p> <pre><code>from healthchain.fhir import create_allergy_intolerance\n\n# Create an allergy intolerance record\nallergy = create_allergy_intolerance(\n    patient=\"Patient/123\",\n    code=\"418038007\",\n    display=\"Propensity to adverse reactions to substance\",\n    system=\"http://snomed.info/sct\"\n)\n\n# Output the created resource\nprint(allergy.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"AllergyIntolerance\",\n    \"id\": \"hc-65edab39-d90b-477b-bdb5-a173b21efd44\",\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"418038007\",\n            \"display\": \"Propensity to adverse reactions to substance\"\n        }]\n    },\n    \"patient\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#create_document_reference","title":"create_document_reference()","text":"<p>Creates a new DocumentReference resource. Handles base64 encoding of the attachment data.</p> <p>Required fields</p> <ul> <li>type</li> </ul> <p>Sensible Defaults</p> <ul> <li><code>type</code> is set to \"<code>collection</code>\"</li> <li><code>status</code> is set to \"<code>current</code>\"</li> <li><code>date</code> is set to the current UTC timestamp</li> <li><code>description</code> is set to \"<code>DocumentReference created by HealthChain</code>\"</li> <li><code>content[0].attachment.title</code> is set to \"<code>Attachment created by HealthChain</code>\"</li> </ul> <pre><code>from healthchain.fhir import create_document_reference\n\n# Create a document reference with a simple text attachment\ndoc_ref = create_document_reference(\n    data=\"Hello World\",\n    content_type=\"text/plain\",\n    description=\"A simple text document\"\n)\n\n# Output the created resource\nprint(doc_ref.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"DocumentReference\",\n    \"id\": \"hc-60fcfdad-9617-4557-88d8-8c8db9b9fe70\",\n    \"status\": \"current\",\n    \"date\": \"2025-02-28T14:55:33+00:00\",\n    \"description\": \"A simple text document\",\n    \"content\": [{\n        \"attachment\": {\n            \"contentType\": \"text/plain\",\n            \"data\": \"SGVsbG8gV29ybGQ=\",\n            \"title\": \"Attachment created by HealthChain\",\n            \"creation\": \"2025-02-28T14:55:33+00:00\"\n        }\n    }]\n}\n</code></pre> View Decoded Content <pre><code>Hello World\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#utilities","title":"Utilities","text":""},{"location":"reference/utilities/fhir_helpers/#set_problem_list_item_category","title":"set_problem_list_item_category()","text":"<p>Sets the category of a Condition resource to \"<code>problem-list-item</code>\".</p> <pre><code>from healthchain.fhir import set_problem_list_item_category, create_condition\n\n# Create a condition and set it as a problem list item\nproblem_list_item = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\"\n)\n\nset_problem_list_item_category(problem_list_item)\n\n# Output the modified resource\nprint(problem_list_item.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"Condition\",\n    \"id\": \"hc-3d5f62e7-729b-4da1-936c-e8e16e5a9358\",\n    \"clinicalStatus\": {\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n        }]\n    },\n    \"category\": [{\n        \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-category\",\n            \"code\": \"problem-list-item\",\n            \"display\": \"Problem List Item\"\n        }]\n    }],\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"38341003\",\n            \"display\": \"Hypertension\"\n        }]\n    },\n    \"subject\": {\n        \"reference\": \"Patient/123\"\n    }\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#read_content_attachment","title":"read_content_attachment()","text":"<p>Reads attachments from a DocumentReference in a human-readable format.</p> <pre><code>from healthchain.fhir import read_content_attachment\n\nattachments = read_content_attachment(document_reference)\n# Returns a list of dictionaries containing:\n# [\n#     {\n#         \"data\": \"Hello World\",\n#         \"metadata\": {\n#             \"content_type\": \"text/plain\",\n#             \"title\": \"My Document\",\n#             \"creation\": datetime.datetime(2025, 2, 28, 15, 27, 55, tzinfo=TzInfo(UTC)),\n#         },\n#     }\n# ]\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#bundle-operations","title":"Bundle Operations","text":"<p>FHIR Bundles are containers that can hold multiple FHIR resources together. They are commonly used to group related resources or to send/receive multiple resources in a single request.</p> <p>The bundle operations make it easy to:</p> <ul> <li>Create and manage bundles</li> <li>Add or update resources within bundles</li> <li>Retrieve specific resource types from bundles</li> <li>Work with multiple resource types in a single bundle</li> </ul>"},{"location":"reference/utilities/fhir_helpers/#create_bundle","title":"create_bundle()","text":"<p>Creates a new Bundle resource.</p> <p>Required field</p> <ul> <li>type</li> </ul> <p>Sensible Defaults</p> <p><code>type</code> is set to \"<code>collection</code>\"</p> <pre><code>from healthchain.fhir import create_bundle\n\n# Create an empty bundle\nbundle = create_bundle(bundle_type=\"collection\")\n\n# Output the created resource\nprint(bundle.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": []\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#add_resource","title":"add_resource()","text":"<p>Adds a single resource to a Bundle.</p> <pre><code>from healthchain.fhir import add_resource, create_condition, create_bundle\n\n# Create a condition to add to the bundle\ncondition = create_condition(\n    subject=\"Patient/123\",\n    code=\"38341003\",\n    display=\"Hypertension\"\n)\n\n# Create a bundle and add the condition\nbundle = create_bundle()\nadd_resource(bundle, condition)\n\n# Output the modified bundle\nprint(bundle.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [{\n        \"resource\": {\n            \"resourceType\": \"Condition\",\n            \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n            \"clinicalStatus\": {\n                \"coding\": [{\n                    \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                    \"code\": \"active\",\n                    \"display\": \"Active\"\n                }]\n            },\n            \"code\": {\n                \"coding\": [{\n                    \"system\": \"http://snomed.info/sct\",\n                    \"code\": \"38341003\",\n                    \"display\": \"Hypertension\"\n                }]\n            },\n            \"subject\": {\n                \"reference\": \"Patient/123\"\n            }\n        }\n    }]\n}\n</code></pre> Field Descriptions Field Required Description <code>entry</code> - Array of resources in the bundle <code>entry[].resource</code> \u2713 The FHIR resource being added <code>entry[].fullUrl</code> - Optional full URL for the resource"},{"location":"reference/utilities/fhir_helpers/#get_resources","title":"get_resources()","text":"<p>Retrieves all resources of a specific type from a Bundle.</p> <pre><code>from healthchain.fhir import get_resources\n\n# Get all conditions in the bundle\nconditions = get_resources(bundle, \"Condition\")\n\n# Or using the resource type directly\nfrom fhir.resources.condition import Condition\nconditions = get_resources(bundle, Condition)\n\nfor condition in conditions:\n    print(f\"Found condition: {condition.code.coding[0].display}\")\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#set_resources","title":"set_resources()","text":"<p>Sets or updates resources of a specific type in a Bundle.</p> <pre><code>from healthchain.fhir import set_resources, create_condition\n\n# Create some conditions\nconditions = [\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"38341003\",\n        display=\"Hypertension\"\n    ),\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"44054006\",\n        display=\"Diabetes\"\n    )\n]\n\n# Replace all existing conditions with new ones\nset_resources(bundle, conditions, \"Condition\", replace=True)\n\n# Or append new conditions to existing ones\nset_resources(bundle, conditions, \"Condition\", replace=False)\n</code></pre> Bundle with Multiple Conditions <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"38341003\",\n                        \"display\": \"Hypertension\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-9876fedc-ba98-7654-3210-fedcba987654\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"44054006\",\n                        \"display\": \"Diabetes\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#merge_bundles","title":"merge_bundles()","text":"<p>Merges multiple FHIR Bundle resources into a single bundle.</p> <ul> <li>Resources from each bundle are combined into a single output bundle of <code>type: collection</code>.</li> <li>All entries from all input bundles will appear in the resulting bundle's <code>entry</code> array.</li> <li>If bundles have the same resource (e.g. matching <code>id</code> or identical resources), they will all be included unless you handle duplicates before/after calling <code>merge_bundles</code>.</li> </ul> <pre><code>from healthchain.fhir import merge_bundles, create_bundle, create_condition\n\n# Create two bundles with different resources\nbundle1 = create_bundle()\nadd_resource(bundle1, create_condition(\n    subject=\"Patient/123\", code=\"38341003\", display=\"Hypertension\"\n))\nbundle2 = create_bundle()\nadd_resource(bundle2, create_condition(\n    subject=\"Patient/123\", code=\"44054006\", display=\"Diabetes\"\n))\n\n# Merge the bundles together\nmerged = merge_bundles(bundle1, bundle2)\n\n# Output the merged bundle\nprint(merged.model_dump())\n</code></pre> Example Output JSON <pre><code>{\n  \"resourceType\": \"Bundle\",\n  \"type\": \"collection\",\n  \"entry\": [\n    {\n      \"resource\": {\n        \"resourceType\": \"Condition\",\n        \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n        \"clinicalStatus\": {\n          \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n          }]\n        },\n        \"code\": {\n          \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"38341003\",\n            \"display\": \"Hypertension\"\n          }]\n        },\n        \"subject\": { \"reference\": \"Patient/123\" }\n      }\n    },\n    {\n      \"resource\": {\n        \"resourceType\": \"Condition\",\n        \"id\": \"hc-9876fedc-ba98-7654-3210-fedcba987654\",\n        \"clinicalStatus\": {\n          \"coding\": [{\n            \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n            \"code\": \"active\",\n            \"display\": \"Active\"\n          }]\n        },\n        \"code\": {\n          \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"44054006\",\n            \"display\": \"Diabetes\"\n          }]\n        },\n        \"subject\": { \"reference\": \"Patient/123\" }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"reference/utilities/fhir_helpers/#common-patterns","title":"Common Patterns","text":""},{"location":"reference/utilities/fhir_helpers/#working-with-multiple-resource-types","title":"Working with Multiple Resource Types","text":"<p>This example shows how to work with multiple types of FHIR resources in a single bundle.</p> <pre><code>from healthchain.fhir import (\n    create_bundle,\n    create_condition,\n    create_medication_statement,\n    create_allergy_intolerance,\n    get_resources,\n    set_resources,\n)\n\n# Create a bundle to hold patient data\nbundle = create_bundle()\n\n# Add conditions (diagnoses)\nconditions = [\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"38341003\",\n        display=\"Hypertension\"\n    ),\n    create_condition(\n        subject=\"Patient/123\",\n        code=\"44054006\",\n        display=\"Diabetes\"\n    )\n]\nset_resources(bundle, conditions, \"Condition\")\n\n# Add medications\nmedications = [\n    create_medication_statement(\n        subject=\"Patient/123\",\n        code=\"1049221\",\n        display=\"Acetaminophen 325 MG\"\n    )\n]\nset_resources(bundle, medications, \"MedicationStatement\")\n\n# Add allergies\nallergies = [\n    create_allergy_intolerance(\n        patient=\"Patient/123\",\n        code=\"418038007\",\n        display=\"Penicillin allergy\"\n    )\n]\nset_resources(bundle, allergies, \"AllergyIntolerance\")\n\n# Later, retrieve resources by type\nconditions = get_resources(bundle, \"Condition\")\nmedications = get_resources(bundle, \"MedicationStatement\")\nallergies = get_resources(bundle, \"AllergyIntolerance\")\n</code></pre> Complete Bundle Example Output <pre><code>{\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-3117bdce-bfab-4d71-968b-1ded900882ca\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"38341003\",\n                        \"display\": \"Hypertension\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"Condition\",\n                \"id\": \"hc-9876fedc-ba98-7654-3210-fedcba987654\",\n                \"clinicalStatus\": {\n                    \"coding\": [{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/condition-clinical\",\n                        \"code\": \"active\",\n                        \"display\": \"Active\"\n                    }]\n                },\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"44054006\",\n                        \"display\": \"Diabetes\"\n                    }]\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"MedicationStatement\",\n                \"id\": \"hc-86a26eba-63f9-4017-b7b2-5b36f9bad5f1\",\n                \"status\": \"recorded\",\n                \"medication\": {\n                    \"concept\": {\n                        \"coding\": [{\n                            \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                            \"code\": \"1049221\",\n                            \"display\": \"Acetaminophen 325 MG\"\n                        }]\n                    }\n                },\n                \"subject\": {\"reference\": \"Patient/123\"}\n            }\n        },\n        {\n            \"resource\": {\n                \"resourceType\": \"AllergyIntolerance\",\n                \"id\": \"hc-65edab39-d90b-477b-bdb5-a173b21efd44\",\n                \"code\": {\n                    \"coding\": [{\n                        \"system\": \"http://snomed.info/sct\",\n                        \"code\": \"418038007\",\n                        \"display\": \"Penicillin allergy\"\n                    }]\n                },\n                \"patient\": {\"reference\": \"Patient/123\"}\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/utilities/sandbox/","title":"Sandbox Client","text":"<p>The sandbox client provides a simplified interface for testing and validating your applications in realistic healthcare contexts. Use <code>SandboxClient</code> to quickly spin up demos and test with various data sources and workflows.</p>"},{"location":"reference/utilities/sandbox/#quick-example","title":"Quick Example","text":"<p>Test CDS Hooks workflows with synthetic data:</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create client with full service URL and workflow\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load data and send requests\nclient.load_from_registry(\n    \"synthea-patient\",\n    data_dir=\"./data/synthea\",\n    resource_types=[\"Condition\", \"MedicationStatement\"],\n    sample_size=5\n    )\nresponses = client.send_requests()\n</code></pre>"},{"location":"reference/utilities/sandbox/#sandboxclient","title":"SandboxClient","text":""},{"location":"reference/utilities/sandbox/#initializing","title":"Initializing","text":"<pre><code>from healthchain.sandbox import SandboxClient\n\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\",  # Required\n    protocol=\"rest\",  # \"rest\" for CDS Hooks, \"soap\" for CDA\n    timeout=10.0\n)\n</code></pre>"},{"location":"reference/utilities/sandbox/#workflow-protocol-compatibility","title":"Workflow-Protocol Compatibility","text":"<p>The client validates workflow-protocol combinations at initialization:</p> Protocol Compatible Workflows REST <code>patient-view</code>, <code>encounter-discharge</code>, <code>order-select</code>, <code>order-sign</code> SOAP <code>sign-note-inpatient</code>, <code>sign-note-outpatient</code>"},{"location":"reference/utilities/sandbox/#loading-data","title":"Loading Data","text":"From RegistryFrom FilesFrom Free Text CSV <pre><code># Load from pre-configured datasets\nclient.load_from_registry(\n    \"mimic-on-fhir\",\n    data_dir=\"./data/mimic-fhir\",\n    resource_types=[\"MimicMedication\"],\n    sample_size=10\n)\n\n# Available datasets: \"mimic-on-fhir\", \"synthea-patient\"\n</code></pre> <pre><code># Load single file\nclient.load_from_path(\"./data/clinical_note.xml\")\n\n# Load directory with glob pattern\nclient.load_from_path(\"./data/cda_files/\", pattern=\"*.xml\")\n</code></pre> <pre><code># Generate synthetic FHIR from clinical notes\nclient.load_free_text(\n    csv_path=\"./data/discharge_notes.csv\",\n    column_name=\"text\",\n    generate_synthetic=True,  # Include synthetic FHIR resources\n    random_seed=42\n)\n</code></pre> <p>See Data Generator for more details on <code>.load_free_text()</code> <code>generate_synthetic</code> field.</p>"},{"location":"reference/utilities/sandbox/#dataset-registry","title":"Dataset Registry","text":"<p>HealthChain provides two pre-configured dataset loaders for testing common FHIR test datasets with CDS Hooks workflows. Download the datasets and use <code>.load_from_registry()</code> to load from your local directory.</p>"},{"location":"reference/utilities/sandbox/#overview","title":"Overview","text":"Dataset &amp; Description FHIR Version Type File Format Source Download Link MIMIC-on-FHIR: MIMIC-IV on FHIR Demo Dataset R4 Real de-identified <code>.ndjson.gz</code> per resource type PhysioNet Project Download ZIP Synthea: Synthea FHIR Patient Records (100 Sample) R4 Synthetic <code>.json</code> Bundle per patient Synthea Downloads Download ZIP"},{"location":"reference/utilities/sandbox/#mimic-on-fhir-loader","title":"MIMIC-on-FHIR Loader","text":"<p>Real-world, de-identified FHIR R4 data from Beth Israel Deaconess Medical Center. Suitable for testing with real-world data distributions and clinical patterns</p> <p>Full Dataset</p> <p>The MIMIC-on-FHIR demo dataset is open access and contains about 100 patients. Access to the full dataset requires PhysioNet credentialed access.</p>"},{"location":"reference/utilities/sandbox/#directory-structure","title":"Directory Structure","text":"<pre><code>data_dir/\n\u2514\u2500\u2500 fhir/\n    \u251c\u2500\u2500 MimicMedication.ndjson.gz\n    \u251c\u2500\u2500 MimicCondition.ndjson.gz\n    \u251c\u2500\u2500 MimicObservation.ndjson.gz\n    \u2514\u2500\u2500 ... (other resource types)\n</code></pre>"},{"location":"reference/utilities/sandbox/#usage","title":"Usage","text":"BasicWith SamplingDirect Loader for ML Workflows <pre><code>client.load_from_registry(\n    \"mimic-on-fhir\",\n    data_dir=\"./data/mimic-iv-fhir\",\n    resource_types=[\"MimicMedication\", \"MimicCondition\"]\n)\n</code></pre> <pre><code># Load random sample for faster testing\nclient.load_from_registry(\n    \"mimic-on-fhir\",\n    data_dir=\"./data/mimic-iv-fhir\",\n    resource_types=[\"MimicMedication\", \"MimicObservation\"],\n    sample_size=5,  # 5 resources per type\n    random_seed=42   # Reproducible sampling\n)\n</code></pre> <pre><code># Use loader directly for ML pipelines (faster, no validation)\nfrom healthchain.sandbox.loaders import MimicOnFHIRLoader\nfrom healthchain.io import Dataset\n\nloader = MimicOnFHIRLoader()\n\n# as_dict=True: Returns single bundle dict (fast, no FHIR validation)\n# Suitable for ML feature extraction workflows\nbundle = loader.load(\n    data_dir=\"./data/mimic-iv-fhir\",\n    resource_types=[\"MimicObservationChartevents\", \"MimicPatient\"],\n    as_dict=True\n)\n\n# Convert to DataFrame for ML\ndataset = Dataset.from_fhir_bundle(\n    bundle,\n    schema=\"healthchain/configs/features/sepsis_vitals.yaml\"\n)\ndf = dataset.data\n\n# as_dict=False (default): Returns Dict[str, Bundle]\n# Validated Bundle objects grouped by resource type (for CDS Hooks)\nbundles = loader.load(\n    data_dir=\"./data/mimic-iv-fhir\",\n    resource_types=[\"MimicMedication\", \"MimicCondition\"]\n)\n# Use bundles[\"medicationstatement\"] and bundles[\"condition\"]\n</code></pre>"},{"location":"reference/utilities/sandbox/#synthea-loader","title":"Synthea Loader","text":"<p>Synthetic patient data generated by Synthea, containing realistic FHIR Bundles (typically 100-500 resources per patient). Ideal for single-patient workflows that require diverse data scenarios.</p> <p>Getting Synthea Data</p> <p>Generate synthetic patients using Synthea or download sample data from their releases. Each patient Bundle is self-contained with all clinical history.</p>"},{"location":"reference/utilities/sandbox/#directory-structure_1","title":"Directory Structure","text":"<pre><code>data_dir/\n\u251c\u2500\u2500 FirstName123_LastName456_uuid.json\n\u251c\u2500\u2500 FirstName789_LastName012_uuid.json\n\u2514\u2500\u2500 ... (one .json file per patient)\n</code></pre>"},{"location":"reference/utilities/sandbox/#usage_1","title":"Usage","text":"First Patient (Quick Demo)By Patient IDWith Resource Filtering <pre><code># Automatically loads first .json file found\nclient.load_from_registry(\n    \"synthea-patient\",\n    data_dir=\"./synthea_sample_data_fhir_latest\"\n    resource_type=[\"Condition\"],  # Finds all Condition resources, loads all if not specified\n)\n</code></pre> <pre><code>client.load_from_registry(\n    \"synthea-patient\",\n    data_dir=\"./synthea_sample_data_fhir_latest\",\n    patient_id=\"a969c177-a995-7b89-7b6d-885214dfa253\",\n    resource_type=[\"Condition\"],\n)\n</code></pre> <pre><code># Load specific resource types with sampling\nclient.load_from_registry(\n    \"synthea-patient\",\n    data_dir=\"./synthea_sample_data_fhir_latest\",\n    patient_id=\"a969c177-a995-7b89-7b6d-885214dfa253\",\n    resource_types=[\"Condition\", \"MedicationRequest\", \"Observation\"],\n    sample_size=5,  # 5 resources per type\n    random_seed=42,\n)\n</code></pre>"},{"location":"reference/utilities/sandbox/#request-inspection-and-debugging","title":"Request Inspection and Debugging","text":"<p>Before sending requests to your service, you can inspect and verify the queued data using several debugging methods. These are particularly useful for troubleshooting data loading issues or verifying request structure.</p>"},{"location":"reference/utilities/sandbox/#preview-requests","title":"Preview Requests","text":"<p>Get a high-level summary of queued requests without retrieving full payloads:</p> <pre><code># Preview all queued requests\npreviews = client.preview_requests()\n\n# Preview first 3 requests only\npreviews = client.preview_requests(limit=3)\nprint(previews)\n\n# [{'index': 0, 'type': 'CdaRequest', 'protocol': 'SOAP', 'has_document': True}]\n</code></pre>"},{"location":"reference/utilities/sandbox/#get-request-data","title":"Get Request Data","text":"<p>Access the full request data in different formats for detailed inspection:</p> <pre><code># Access raw Pydantic models directly\nfor request in client.requests:\n    print(f\"Prefetch keys: {request.prefetch.keys()}\")\n    print(request.model_dump())\n\n# Get as list of dictionaries (for serialization)\nrequests_dict = client.get_request_data(format=\"dict\")\nprint(requests_dict[0].keys())  # See available fields\n\n# Get as JSON string (for saving or logging)\nrequests_json = client.get_request_data(format=\"json\")\nwith open(\"debug_requests.json\", \"w\") as f:\n    f.write(requests_json)\n</code></pre>"},{"location":"reference/utilities/sandbox/#check-client-status","title":"Check Client Status","text":"<p>Get the current state of your sandbox client:</p> <pre><code>status = client.get_status()\nprint(status)\n\n# {\n#     \"sandbox_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n#     \"url\": \"http://localhost:8000/cds/cds-services/my-service\",\n#     \"protocol\": \"rest\",\n#     \"workflow\": \"encounter-discharge\",\n#     \"requests_queued\": 5,\n#     \"responses_received\": 0\n# }\n</code></pre>"},{"location":"reference/utilities/sandbox/#clear-and-reload","title":"Clear and Reload","text":"<p>Reset the request queue to start fresh without creating a new client:</p> <pre><code># Clear all queued requests\nclient.clear_requests()\n\n# Load new data\nclient.load_from_path(\"./different_data.json\")\n\n# Verify new queue\nstatus = client.get_status()\nprint(f\"New queue size: {status['requests_queued']}\")\n</code></pre> Example Debugging Workflow <pre><code>from healthchain.sandbox import SandboxClient\n\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/discharge-summary\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load data\nclient.load_free_text(\"data/notes.csv\", column_name=\"text\")\n\n# Debug before sending\nprint(\"=== Client Status ===\")\nprint(client.get_status())\n\nprint(\"\\n=== Request Previews ===\")\nfor preview in client.preview_requests(limit=2):\n    print(f\"Request {preview['index']}: {preview['type']}\")\n\nprint(\"\\n=== Inspecting First Request ===\")\nfirst_request = client.requests[0]\nprint(f\"Hook: {first_request.hook}\")\nprint(f\"Context: {first_request.context}\")\nprint(f\"Prefetch keys: {first_request.prefetch.keys()}\")\nprint(f\"Example DocumentReference: {first_request.prefetch['document'].model_dump()}\")\n\n# If everything looks good, send\nresponses = client.send_requests()\n</code></pre>"},{"location":"reference/utilities/sandbox/#sending-requests","title":"Sending Requests","text":"<pre><code># Send all queued requests\nresponses = client.send_requests()\n\n# Save results to disk\nclient.save_results(\"./output/\")\n\n# Get client status\nstatus = client.get_status()\nprint(status)\n# {\n#     \"sandbox_id\": \"...\",\n#     \"url\": \"http://localhost:8000/cds/...\",\n#     \"protocol\": \"rest\",\n#     \"workflow\": \"encounter-discharge\",\n#     \"requests_queued\": 5,\n#     \"responses_received\": 5\n# }\n</code></pre>"},{"location":"reference/utilities/sandbox/#complete-examples","title":"Complete Examples","text":"CDS Hooks TestClinical Documentation TestFree Text CSV <pre><code>from healthchain.sandbox import SandboxClient\n\n# Initialize client for CDS Hooks workflow\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/sepsis-alert\",\n    workflow=\"patient-view\"\n)\n\n# Load MIMIC-on-FHIR data\nclient.load_from_registry(\n    \"mimic-on-fhir\",\n    data_dir=\"./data/mimic-iv-fhir\",\n    resource_types=[\"MimicConditionED\"],\n    sample_size=5\n)\n\n# Optional: Inspect before sending\n# client.preview_requests()\n# client.get_status()\n\n# Send requests and save results\nresponses = client.send_requests()\nclient.save_results(\"./output/\")\n</code></pre> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Initialize client for SOAP/CDA workflow\nclient = SandboxClient(\n    url=\"http://localhost:8000/notereader/ProcessDocument/\",\n    workflow=\"sign-note-inpatient\",\n    protocol=\"soap\"\n)\n\n# Load CDA documents from directory\nclient.load_from_path(\"./data/cda_files/\", pattern=\"*.xml\")\n\n# Optional: Inspect before sending\n# client.preview_requests()\n\n# Send requests and save results\nresponses = client.send_requests()\nclient.save_results(\"./output/\")\n</code></pre> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Initialize client for CDS workflow\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\"\n)\n\n# Load and generate FHIR from clinical notes\nclient.load_free_text(\n    csv_path=\"./data/discharge_notes.csv\",\n    column_name=\"text\",\n    generate_synthetic=True  # Adds synthetic data\n)\n\n# Optional: Inspect generated data\n# requests = client.get_request_data(format=\"dict\")\n# print(requests[0]['prefetch'].keys())\n\n# Send requests\nresponses = client.send_requests()\n</code></pre>"},{"location":"reference/utilities/sandbox/#advanced-usage","title":"Advanced Usage","text":"<p><code>SandboxClient</code> supports method chaining and context manager patterns for more concise code.</p>"},{"location":"reference/utilities/sandbox/#method-chaining","title":"Method Chaining","text":"<p>All data loading methods return <code>self</code>, enabling fluent method chaining:</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Chain initialization, loading, and sending\nresponses = (\n    SandboxClient(\n        url=\"http://localhost:8000/cds/cds-services/my-service\",\n        workflow=\"encounter-discharge\"\n    )\n    .load_from_registry(\n        \"synthea-patient\",\n        data_dir=\"./data/synthea\",\n        sample_size=5\n    )\n    .send_requests()\n)\n</code></pre>"},{"location":"reference/utilities/sandbox/#context-manager","title":"Context Manager","text":"<p>Use the context manager for automatic result saving on successful completion:</p> <pre><code># Auto-save results to ./output/ on successful exit\nwith SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/my-service\",\n    workflow=\"encounter-discharge\"\n) as client:\n    client.load_free_text(\n        csv_path=\"./data/notes.csv\",\n        column_name=\"text\"\n    )\n    responses = client.send_requests()\n    # Results automatically saved on successful exit\n</code></pre>"},{"location":"reference/utilities/sandbox/#migration-guide","title":"Migration Guide","text":"<p>Decorator Pattern Deprecated</p> <p>The <code>@hc.sandbox</code> and <code>@hc.ehr</code> decorators with <code>ClinicalDecisionSupport</code> and <code>ClinicalDocumentation</code> base classes are deprecated. Use <code>SandboxClient</code> instead.</p> <p>Before:</p> <pre><code>@hc.sandbox\nclass TestCDS(ClinicalDecisionSupport):\n    @hc.ehr(workflow=\"patient-view\")\n    def load_data(self):\n        return prefetch_data\n</code></pre> <p>After:</p> <pre><code>client = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/my-service\",\n    workflow=\"patient-view\"\n)\nclient.load_from_registry(\n    \"synthea-patient\",\n    data_dir=\"./data/synthea\",\n    resource_types=[\"Condition\", \"Observation\"],\n    sample_size=10\n)\nresponses = client.send_requests()\n</code></pre>"},{"location":"rfcs/000-template/","title":"000 template","text":"<p>This template is meant to be a starting point; feel free to remove any sections that you can't really fill out just yet. </p>"},{"location":"rfcs/000-template/#rfc-nnn","title":"RFC NNN:  <ul> <li>Author:  <li>Status: Draft | In Review | Accepted | Rejected | Superseded</li> <li>Created:  <li>Related Issue(s): # <li>Related Discussion(s):","text":""},{"location":"rfcs/000-template/#1-summary","title":"1. Summary","text":"<p>One or two paragraphs describing the problem and the proposed solution at a high level, focused on HealthChain\u2019s goals and users.</p>"},{"location":"rfcs/000-template/#2-problem-statement","title":"2. Problem statement","text":"<ul> <li>What problem are we trying to solve?</li> <li>Who is affected (e.g. API consumers, operators, patients, integrators)?</li> <li>Why is this important now?</li> </ul> <p>Include any relevant context, such as existing limitations or incidents.</p>"},{"location":"rfcs/000-template/#3-goals-and-non-goals","title":"3. Goals and non-goals","text":""},{"location":"rfcs/000-template/#goals","title":"Goals","text":"<ul> <li>Clear, concrete goals this RFC aims to achieve.</li> </ul>"},{"location":"rfcs/000-template/#non-goals","title":"Non-goals","text":"<ul> <li>Things that are explicitly out of scope for this change to avoid scope creep.</li> </ul>"},{"location":"rfcs/000-template/#4-background-and-context","title":"4. Background and context","text":"<p>Summarize relevant existing behavior, architecture, and constraints in HealthChain. Link to code, docs, or external standards (e.g. FHIR, SMART on FHIR, OIDC) that inform the design.</p>"},{"location":"rfcs/000-template/#5-proposed-design","title":"5. Proposed design","text":"<p>Describe the proposed solution in enough detail that another contributor could implement it:</p> <ul> <li>High-level architecture and data flow.</li> <li>Responsibilities of each component (e.g. Gateway, services, auth provider).</li> <li>API and contract changes (endpoints, request/response shapes, error handling).</li> <li>Configuration and operational considerations.</li> </ul> <p>Diagrams are welcome but optional.</p>"},{"location":"rfcs/000-template/#6-alternatives-considered","title":"6. Alternatives considered","text":"<p>List alternative approaches that were considered and briefly explain why they were not chosen. This helps future readers understand trade-offs and avoid rehashing old discussions.</p>"},{"location":"rfcs/000-template/#7-security-privacy-and-compliance","title":"7. Security, privacy, and compliance","text":"<p>Explain the impact on:</p> <ul> <li>Authentication and authorization behavior.</li> <li>Data confidentiality, integrity, and availability.</li> <li>Regulatory or standards alignment (e.g. healthcare-specific concerns if applicable).</li> </ul> <p>Call out new risks and how they are mitigated.</p>"},{"location":"rfcs/000-template/#8-migration-and-rollout-plan","title":"8. Migration and rollout plan","text":"<ul> <li>How will this be rolled out (flags, gradual rollout, big-bang)?</li> <li>How will existing deployments migrate, if applicable?</li> <li>How will rollback work if something goes wrong?</li> </ul>"},{"location":"rfcs/000-template/#9-testing-and-observability","title":"9. Testing and observability","text":"<ul> <li>What tests are required (unit, integration, e2e)?</li> <li>Any new metrics, logs, or traces needed to operate this change?</li> </ul>"},{"location":"rfcs/000-template/#10-open-questions","title":"10. Open questions","text":"<p>List any open questions that need to be answered before accepting the RFC, or things to be resolved during implementation.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Learn HealthChain through hands-on, step-by-step tutorials. Each tutorial is designed to teach core concepts while building something practical.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"tutorials/#clinicalflow-tutorial","title":"ClinicalFlow Tutorial","text":"<p>Build a Clinical Decision Support Service</p> <p>The ClinicalFlow tutorial teaches you how to build a CDS service that integrates with EHR systems. You'll learn HealthChain's core concepts by building a real application. Healthcare knowledge is helpful but not required - the tutorials explain all the concepts as you go.</p> <ul> <li>Level: Beginner to Intermediate</li> <li>Prerequisites: Python basics, familiarity with REST APIs</li> </ul> <p> Start the ClinicalFlow Tutorial</p>"},{"location":"tutorials/clinicalflow/","title":"ClinicalFlow Tutorial","text":"<p>Build your first Clinical Decision Support (CDS) service with HealthChain.</p>"},{"location":"tutorials/clinicalflow/#the-scenario","title":"The Scenario","text":"<p>You're a HealthTech engineer at a hospital. The clinical informatics team needs a service that:</p> <ol> <li>Receives patient context when a physician opens a chart</li> <li>Analyzes existing conditions and medications</li> <li>Returns actionable alerts for potential drug interactions or care gaps</li> </ol> <p>Doing this in practice has a number of pain points:</p> <ul> <li>Complex protocol requirements - CDS Hooks and FHIR have strict specifications that take weeks to implement correctly</li> <li>Fragmented EHR data - Patient information comes in different formats across systems, requiring custom parsing logic</li> <li>No easy testing path - Validating your service against realistic clinical scenarios typically requires access to live EHR systems</li> <li>Integration boilerplate - Writing the HTTP endpoints, request validation, and response formatting is repetitive but error-prone</li> </ul> <p>HealthChain handles all of this for you, so you can focus on the clinical logic that matters.</p> <p>By the end of this tutorial, you'll have a working CDS Hooks service that integrates with EHR systems like Epic.</p>"},{"location":"tutorials/clinicalflow/#what-youll-build","title":"What You'll Build","text":"<p>We'll build a Pipeline that processes clinical text from an EHR and a Service that wraps around it to return Clinical Alert Cards.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   EHR System    \u2502\u2500\u2500\u2500\u2500\u2500&gt;\u2502  Your CDS       \u2502\u2500\u2500\u2500\u2500\u2500&gt;\u2502  Clinical       \u2502\n\u2502   (Epic, etc.)  \u2502      \u2502  Service        \u2502      \u2502  Alert Cards    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                        \u2502\n        \u2502                        \u2502\n        \u25bc                        \u25bc\n   Patient context          NLP Pipeline\n   (FHIR resources)         (HealthChain)\n</code></pre> <p>Throughout this tutorial, we'll use the same sample patient - John Smith with hypertension and diabetes - so you can see how data flows from FHIR resources through your pipeline to clinical alerts.</p>"},{"location":"tutorials/clinicalflow/#what-youll-learn","title":"What You'll Learn","text":"Step What You'll Learn Setup Install dependencies, create project structure FHIR Basics Understand FHIR resources and how they flow into CDS Hooks requests Build Pipeline Create an NLP pipeline that extracts conditions from clinical text Create Gateway Expose your pipeline as a CDS Hooks service that EHRs can call Test with Sandbox Validate with sample patient data (simulating what Epic would send) Next Steps Production deployment and extending your service"},{"location":"tutorials/clinicalflow/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+ installed</li> <li>Basic Python knowledge (functions, classes, imports)</li> <li>REST API familiarity (HTTP methods, JSON)</li> <li>Healthcare knowledge is helpful but not required</li> </ul>"},{"location":"tutorials/clinicalflow/#ready","title":"Ready?","text":"<p>Let's start by setting up your project.</p>"},{"location":"tutorials/clinicalflow/fhir-basics/","title":"FHIR Basics","text":"<p>Understand the healthcare data format you'll work with in HealthChain.</p>"},{"location":"tutorials/clinicalflow/fhir-basics/#what-is-fhir","title":"What is FHIR?","text":"<p>FHIR (Fast Healthcare Interoperability Resources) is the modern standard for exchanging healthcare data. Think of it as \"JSON for healthcare\" - structured, standardized data that EHR systems like Epic and Cerner use.</p>"},{"location":"tutorials/clinicalflow/fhir-basics/#key-resources-for-cds","title":"Key Resources for CDS","text":"<p>For our ClinicalFlow service, we'll work with three main FHIR resources:</p>"},{"location":"tutorials/clinicalflow/fhir-basics/#patient","title":"Patient","text":"<p>Identifies who the patient is:</p> <pre><code>{\n  \"resourceType\": \"Patient\",\n  \"id\": \"example-patient\",\n  \"name\": [{\"given\": [\"John\"], \"family\": \"Smith\"}],\n  \"birthDate\": \"1970-01-15\",\n  \"gender\": \"male\"\n}\n</code></pre>"},{"location":"tutorials/clinicalflow/fhir-basics/#condition","title":"Condition","text":"<p>Records diagnoses and health problems:</p> <pre><code>{\n  \"resourceType\": \"Condition\",\n  \"id\": \"example-condition\",\n  \"code\": {\n    \"coding\": [{\n      \"system\": \"http://snomed.info/sct\",\n      \"code\": \"38341003\",\n      \"display\": \"Hypertension\"\n    }]\n  },\n  \"subject\": {\"reference\": \"Patient/example-patient\"},\n  \"clinicalStatus\": {\n    \"coding\": [{\"code\": \"active\"}]\n  }\n}\n</code></pre>"},{"location":"tutorials/clinicalflow/fhir-basics/#medicationstatement","title":"MedicationStatement","text":"<p>Tracks what medications a patient is taking:</p> <pre><code>{\n  \"resourceType\": \"MedicationStatement\",\n  \"id\": \"example-med\",\n  \"medicationCodeableConcept\": {\n    \"coding\": [{\n      \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n      \"code\": \"197361\",\n      \"display\": \"Lisinopril 10 MG\"\n    }]\n  },\n  \"subject\": {\"reference\": \"Patient/example-patient\"},\n  \"status\": \"active\"\n}\n</code></pre>"},{"location":"tutorials/clinicalflow/fhir-basics/#working-with-fhir-in-healthchain","title":"Working with FHIR in HealthChain","text":"<p>HealthChain provides utilities to work with FHIR resources easily:</p> <pre><code>from healthchain.fhir import create_condition, create_patient\nfrom fhir.resources.patient import Patient\n\n# Create a patient with basic demographics\n# Note: create_patient generates an auto-prefixed ID (e.g., \"hc-abc123\")\npatient = create_patient(\n    gender=\"male\",\n    birth_date=\"1970-01-15\",\n    identifier=\"MRN-12345\"  # Optional patient identifier (e.g., MRN)\n)\n\n# Create a condition linked to the patient\n# The 'subject' parameter is required and references the patient\ncondition = create_condition(\n    subject=f\"Patient/{patient.id}\",  # Reference to the patient\n    code=\"38341003\",\n    display=\"Hypertension\",\n    system=\"http://snomed.info/sct\"\n)\n\nprint(f\"Created patient with ID: {patient.id}\")\nprint(f\"With condition: {condition.code.coding[0].display}\")\n</code></pre> FHIR Versions in HealthChain <p>HealthChain uses FHIR R5 as the default version. However, STU3 and R4B are also supported for compatibility with different EHR systems.</p> <p>You can specify the version when working with FHIR resources, and HealthChain provides utilities for converting between versions when needed.</p> <p>For more details on version handling, see the FHIR utilities reference.</p>"},{"location":"tutorials/clinicalflow/fhir-basics/#fhir-bundles","title":"FHIR Bundles","text":"<p>When an EHR sends patient context, it often comes as a Bundle - a collection of related resources:</p> <pre><code>from fhir.resources.bundle import Bundle\n\n# A bundle might contain a patient, their conditions, and medications\nbundle_data = {\n    \"resourceType\": \"Bundle\",\n    \"type\": \"collection\",\n    \"entry\": [\n        {\"resource\": patient.model_dump()},\n        {\"resource\": condition.model_dump()}\n    ]\n}\n\nbundle = Bundle(**bundle_data)\nprint(f\"Bundle contains {len(bundle.entry)} resources\")\n</code></pre>"},{"location":"tutorials/clinicalflow/fhir-basics/#the-document-container","title":"The Document Container","text":"<p>HealthChain's <code>Document</code> container bridges clinical text and FHIR data:</p> <pre><code>from healthchain.io import Document\n\n# Create a document with clinical text\ndoc = Document(\n    \"Patient presents with chest pain and shortness of breath. \"\n    \"History of hypertension and diabetes.\"\n)\n\n# The document can hold FHIR data extracted from text\nprint(f\"Document text: {doc.text[:50]}...\")\n\n# After NLP processing, the document will contain:\n# - Extracted entities\n# - Generated FHIR resources\n# - Problem lists, medications, etc.\n</code></pre>"},{"location":"tutorials/clinicalflow/fhir-basics/#how-fhir-flows-into-cds-hooks","title":"How FHIR Flows into CDS Hooks","text":"<p>When an EHR like Epic calls your CDS service, it sends a CDS Hooks request containing patient data. The FHIR resources you just learned about arrive in the <code>prefetch</code> field:</p> <pre><code>{\n  \"hookInstance\": \"abc-123-def-456\",\n  \"hook\": \"patient-view\",\n  \"context\": {\n    \"userId\": \"Practitioner/dr-smith\",\n    \"patientId\": \"patient-001\"\n  },\n  \"prefetch\": {\n    \"patient\": {\n      \"resourceType\": \"Patient\",\n      \"id\": \"patient-001\",\n      \"name\": [{\"given\": [\"John\"], \"family\": \"Smith\"}],\n      \"birthDate\": \"1970-01-15\",\n      \"gender\": \"male\"\n    },\n    \"conditions\": {\n      \"resourceType\": \"Bundle\",\n      \"type\": \"searchset\",\n      \"entry\": [\n        {\n          \"resource\": {\n            \"resourceType\": \"Condition\",\n            \"id\": \"condition-hypertension\",\n            \"code\": {\n              \"coding\": [{\n                \"system\": \"http://snomed.info/sct\",\n                \"code\": \"38341003\",\n                \"display\": \"Hypertension\"\n              }]\n            },\n            \"subject\": {\"reference\": \"Patient/patient-001\"},\n            \"clinicalStatus\": {\"coding\": [{\"code\": \"active\"}]}\n          }\n        },\n        {\n          \"resource\": {\n            \"resourceType\": \"Condition\",\n            \"id\": \"condition-diabetes\",\n            \"code\": {\n              \"coding\": [{\n                \"system\": \"http://snomed.info/sct\",\n                \"code\": \"73211009\",\n                \"display\": \"Diabetes mellitus\"\n              }]\n            },\n            \"subject\": {\"reference\": \"Patient/patient-001\"},\n            \"clinicalStatus\": {\"coding\": [{\"code\": \"active\"}]}\n          }\n        }\n      ]\n    },\n    \"note\": \"Patient is a 65-year-old male presenting with chest pain and shortness of breath. History includes hypertension and diabetes, both well-controlled on current medications.\"\n  }\n}\n</code></pre> <p>This is the complete picture:</p> <ol> <li><code>context</code> - Tells you who triggered the hook (the practitioner) and which patient</li> <li><code>prefetch.patient</code> - The Patient resource with demographics</li> <li><code>prefetch.conditions</code> - A Bundle of the patient's active conditions</li> <li><code>prefetch.note</code> - Clinical text your NLP pipeline will process</li> </ol> <p>Your CDS service receives this request, processes the data, and returns clinical alert cards. We'll use this same sample data throughout the tutorial for testing.</p>"},{"location":"tutorials/clinicalflow/fhir-basics/#whats-next","title":"What's Next","text":"<p>Now that you understand FHIR basics and how data flows into CDS, let's build a pipeline that processes clinical text and extracts structured data.</p>"},{"location":"tutorials/clinicalflow/gateway/","title":"Create Gateway","text":"<p>Expose your pipeline as a CDS Hooks service that EHRs can call.</p>"},{"location":"tutorials/clinicalflow/gateway/#what-is-cds-hooks","title":"What is CDS Hooks?","text":"<p>CDS Hooks is a standard for integrating clinical decision support with EHR systems. When a clinician performs an action (like opening a patient chart), the EHR calls your CDS service, and you return helpful information as \"cards.\"</p> <p>The flow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Clinician  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502    EHR      \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502  Your CDS   \u2502\n\u2502  opens      \u2502         \u2502  (Epic,     \u2502  HTTP   \u2502  Service    \u2502\n\u2502  chart      \u2502         \u2502   Cerner)   \u2502  POST   \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502                       \u2502\n                               \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n                               \u2502    CDS Cards          \u2502\n                               \u25bc\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502  Display    \u2502\n                        \u2502  alerts to  \u2502\n                        \u2502  clinician  \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tutorials/clinicalflow/gateway/#create-the-cds-service","title":"Create the CDS Service","text":"<p>Create a file called <code>app.py</code>. This imports the pipeline you created in the previous step:</p> <pre><code>from healthchain.gateway import HealthChainAPI, CDSHooksService\nfrom healthchain.io import Document\nfrom healthchain.models.requests.cdsrequest import CDSRequest\nfrom healthchain.models.responses.cdsresponse import CDSResponse, Card\nfrom pipeline import create_clinical_pipeline\n\n# Initialize the HealthChain API\napp = HealthChainAPI(title=\"ClinicalFlow CDS Service\")\n\n# Create your pipeline\nnlp = create_clinical_pipeline()\n\n# Create a CDS Hooks service\ncds_service = CDSHooksService()\n\n# Register a hook handler using the decorator\n@cds_service.hook(\n    \"patient-view\",  # Hook type: triggers when a clinician views a patient\n    id=\"patient-alerts\",\n    title=\"Clinical Alert Service\",\n    description=\"Analyzes patient data and returns relevant clinical alerts\",\n)\ndef patient_alerts(request: CDSRequest) -&gt; CDSResponse:\n    \"\"\"\n    Process patient context and return CDS cards.\n\n    Args:\n        request: CDSRequest containing context and prefetch data\n    \"\"\"\n    cards = []\n\n    # Get patient conditions from prefetch (if available)\n    prefetch = request.prefetch or {}\n    conditions = prefetch.get(\"conditions\", [])\n\n    # If we have clinical notes, process them\n    if clinical_note := prefetch.get(\"note\"):\n        doc = Document(clinical_note)\n        result = nlp(doc)\n\n        # Create cards for each extracted condition\n        for entity in result.nlp.get_entities():\n            cards.append(Card(\n                summary=f\"Condition detected: {entity['display']}\",\n                detail=f\"SNOMED code: {entity['code']}\",\n                indicator=\"info\",\n                source={\"label\": \"ClinicalFlow\", \"url\": \"https://healthchain.dev\"}\n            ))\n\n    # Check for drug interaction alerts\n    if len(conditions) &gt; 2:\n        cards.append(Card(\n            summary=\"Multiple active conditions\",\n            detail=f\"Patient has {len(conditions)} active conditions. Review for potential interactions.\",\n            indicator=\"warning\",\n            source={\"label\": \"ClinicalFlow\"}\n        ))\n\n    return CDSResponse(cards=cards)\n\n\n# Register the CDS service with the app\napp.include_router(cds_service)\n\n# Run the server\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"tutorials/clinicalflow/gateway/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"tutorials/clinicalflow/gateway/#the-cds_servicehook-decorator","title":"The <code>@cds_service.hook</code> Decorator","text":"<p>This decorator registers your function as a CDS Hooks handler:</p> <ul> <li>First argument: The hook type (e.g., <code>patient-view</code>, <code>order-select</code>)</li> <li><code>id</code>: Unique identifier for this service endpoint</li> <li><code>title</code>: Human-readable name</li> <li><code>description</code>: What the service does</li> </ul>"},{"location":"tutorials/clinicalflow/gateway/#cds-cards","title":"CDS Cards","text":"<p>Cards are the responses you return to the EHR. Each card has:</p> Field Description <code>summary</code> Brief message shown to clinician <code>detail</code> Additional information (optional) <code>indicator</code> Urgency: <code>info</code>, <code>warning</code>, or <code>critical</code> <code>source</code> Attribution for the recommendation"},{"location":"tutorials/clinicalflow/gateway/#run-the-service","title":"Run the Service","text":"<p>Start your CDS service:</p> uvpip <pre><code>uv run python app.py\n</code></pre> <pre><code>python app.py\n</code></pre> <p>Your service is now running at <code>http://localhost:8000</code>.</p>"},{"location":"tutorials/clinicalflow/gateway/#test-the-endpoints","title":"Test the Endpoints","text":""},{"location":"tutorials/clinicalflow/gateway/#discovery-endpoint","title":"Discovery Endpoint","text":"<p>CDS Hooks services must provide a discovery endpoint. Test it:</p> <pre><code>curl http://localhost:8000/cds/cds-discovery\n</code></pre> <p>Response:</p> <pre><code>{\n  \"services\": [\n    {\n      \"id\": \"patient-alerts\",\n      \"title\": \"Clinical Alert Service\",\n      \"description\": \"Analyzes patient data and returns relevant clinical alerts\",\n      \"hook\": \"patient-view\"\n    }\n  ]\n}\n</code></pre>"},{"location":"tutorials/clinicalflow/gateway/#service-endpoint","title":"Service Endpoint","text":"<p>Test calling your service:</p> <pre><code>curl -X POST http://localhost:8000/cds/cds-services/patient-alerts \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"hookInstance\": \"test-123\",\n    \"hook\": \"patient-view\",\n    \"context\": {\n      \"patientId\": \"patient-001\",\n      \"userId\": \"doctor-001\"\n    },\n    \"prefetch\": {\n      \"note\": \"Patient presents with chest pain and hypertension.\"\n    }\n  }'\n</code></pre>"},{"location":"tutorials/clinicalflow/gateway/#interactive-api-docs","title":"Interactive API Docs","text":"<p>HealthChain generates OpenAPI documentation. Visit:</p> <ul> <li>Swagger UI: <code>http://localhost:8000/docs</code></li> <li>ReDoc: <code>http://localhost:8000/redoc</code></li> </ul>"},{"location":"tutorials/clinicalflow/gateway/#whats-next","title":"What's Next","text":"<p>Your CDS service is running! Now let's test it properly with realistic patient data using HealthChain's sandbox.</p>"},{"location":"tutorials/clinicalflow/next-steps/","title":"Next Steps","text":"<p>You've built a working CDS service. Here's how to take it further.</p>"},{"location":"tutorials/clinicalflow/next-steps/#what-youve-accomplished","title":"What You've Accomplished","text":"<p>In this tutorial, you:</p> <ul> <li>Set up a HealthChain development environment</li> <li>Learned FHIR basics (Patient, Condition, MedicationStatement)</li> <li>Built an NLP pipeline with Document containers</li> <li>Created a CDS Hooks gateway service</li> <li>Tested with the sandbox and synthetic data</li> </ul>"},{"location":"tutorials/clinicalflow/next-steps/#what-to-do-next","title":"What to Do Next","text":""},{"location":"tutorials/clinicalflow/next-steps/#improve-the-nlp","title":"Improve the NLP","text":"<p>The NLP was hard coded in our example but HealthChain has simple pipeline integrations for spacy, huggingface and Langchain. Try to replace keyword matching with trained models.</p>"},{"location":"tutorials/clinicalflow/next-steps/#add-fhir-output","title":"Add FHIR Output","text":"<p>Convert extracted entities to FHIR resources:</p> <pre><code>from healthchain.pipeline.components import FHIRProblemListExtractor\n\npipeline.add_node(FHIRProblemListExtractor())\n\n# Now doc.fhir.problem_list contains FHIR Condition resources\n</code></pre>"},{"location":"tutorials/clinicalflow/next-steps/#learn-more","title":"Learn More","text":"<p>Explore HealthChain's cookbook documentation, we have a variety of cookbooks that will let you build upon the basics from this tutorial.</p>"},{"location":"tutorials/clinicalflow/next-steps/#congratulations","title":"Congratulations!","text":"<p>You've completed the ClinicalFlow tutorial. You now have the foundation to build production-ready healthcare AI applications with HealthChain.</p>"},{"location":"tutorials/clinicalflow/pipeline/","title":"Build Pipeline","text":"<p>Create an NLP pipeline to process clinical text and extract structured data.</p>"},{"location":"tutorials/clinicalflow/pipeline/#what-is-a-pipeline","title":"What is a Pipeline?","text":"<p>A Pipeline in HealthChain is a sequence of processing steps that transform input data. For clinical NLP, pipelines typically:</p> <ol> <li>Take clinical text as input</li> <li>Process it through NLP models</li> <li>Extract entities (conditions, medications, etc.)</li> <li>Output structured FHIR resources</li> </ol>"},{"location":"tutorials/clinicalflow/pipeline/#create-your-pipeline","title":"Create Your Pipeline","text":"<p>Create a file called <code>pipeline.py</code>:</p> <pre><code>from healthchain.pipeline import Pipeline\nfrom healthchain.io import Document\n\ndef create_clinical_pipeline():\n    \"\"\"Create a pipeline for processing clinical notes.\"\"\"\n\n    # Initialize pipeline with Document as the data container\n    pipeline = Pipeline[Document]()\n\n    # Add a simple text preprocessing component\n    @pipeline.add_node\n    def preprocess(doc: Document) -&gt; Document:\n        \"\"\"Clean and normalize clinical text.\"\"\"\n        # Remove extra whitespace\n        doc.text = \" \".join(doc.text.split())\n        return doc\n\n    # Add a clinical entity extraction component\n    @pipeline.add_node\n    def extract_conditions(doc: Document) -&gt; Document:\n        \"\"\"Extract condition mentions from text.\"\"\"\n        # Simple keyword-based extraction for this tutorial\n        # In production, you'd use a trained NLP model\n        condition_keywords = {\n            \"hypertension\": (\"38341003\", \"Hypertension\"),\n            \"diabetes\": (\"73211009\", \"Diabetes mellitus\"),\n            \"chest pain\": (\"29857009\", \"Chest pain\"),\n            \"shortness of breath\": (\"267036007\", \"Dyspnea\"),\n        }\n\n        text_lower = doc.text.lower()\n        extracted = []\n\n        for keyword, (code, display) in condition_keywords.items():\n            if keyword in text_lower:\n                extracted.append({\n                    \"text\": keyword,\n                    \"code\": code,\n                    \"display\": display,\n                    \"system\": \"http://snomed.info/sct\"\n                })\n\n        # Store extracted conditions in document's NLP annotations\n        doc.nlp.set_entities(extracted)\n        return doc\n\n    return pipeline.build()\n</code></pre>"},{"location":"tutorials/clinicalflow/pipeline/#using-the-pipeline","title":"Using the Pipeline","text":"<p>Create a file called <code>test_pipeline.py</code> to test your pipeline:</p> <pre><code>from pipeline import create_clinical_pipeline\nfrom healthchain.io import Document\n\n# Create the pipeline\nnlp = create_clinical_pipeline()\n\n# Process a clinical note\ndoc = Document(\n    \"Patient is a 65-year-old male presenting with chest pain \"\n    \"and shortness of breath. History includes hypertension \"\n    \"and diabetes, both well-controlled on current medications.\"\n)\n\n# Run the pipeline\nresult = nlp(doc)\n\n# Check extracted entities\nprint(\"Extracted conditions:\")\nfor entity in result.nlp.get_entities():\n    print(f\"  - {entity['display']} (SNOMED: {entity['code']})\")\n</code></pre> <p>Run it:</p> uvpip <pre><code>uv run python test_pipeline.py\n</code></pre> <pre><code>python test_pipeline.py\n</code></pre> <p>Expected output:</p> <pre><code>Extracted conditions:\n  - Hypertension (SNOMED: 38341003)\n  - Diabetes mellitus (SNOMED: 73211009)\n  - Chest pain (SNOMED: 29857009)\n  - Dyspnea (SNOMED: 267036007)\n</code></pre>"},{"location":"tutorials/clinicalflow/pipeline/#pipeline-architecture","title":"Pipeline Architecture","text":"<p>Your pipeline now follows this flow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Clinical   \u2502\u2500\u2500\u2500\u2500&gt;\u2502  Preprocess \u2502\u2500\u2500\u2500\u2500&gt;\u2502  Extract    \u2502\n\u2502  Text       \u2502     \u2502  Text       \u2502     \u2502  Conditions \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                               \u2502\n                                               \u25bc\n                                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                        \u2502  Document   \u2502\n                                        \u2502  + Entities \u2502\n                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tutorials/clinicalflow/pipeline/#whats-next","title":"What's Next","text":"<p>Now that you have a working pipeline, let's create a Gateway to expose it as a CDS Hooks service. Don't worry if these terms don't make sense, all will be explained on the next page!</p>"},{"location":"tutorials/clinicalflow/setup/","title":"Setup","text":"<p>Get your development environment ready for building the ClinicalFlow service.</p>"},{"location":"tutorials/clinicalflow/setup/#install-healthchain","title":"Install HealthChain","text":"<p>Create a new project directory:</p> <pre><code>mkdir clinicalflow\ncd clinicalflow\n</code></pre>"},{"location":"tutorials/clinicalflow/setup/#option-1-using-uv-recommended","title":"Option 1: Using uv (Recommended)","text":"<p>uv is a fast Python package manager. If you don't have it installed, you can install it by following the instructions here.</p> <p>Then initialize a project and install HealthChain:</p> <pre><code>uv init\nuv add healthchain\n</code></pre>"},{"location":"tutorials/clinicalflow/setup/#option-2-using-pip-with-a-virtual-environment","title":"Option 2: Using pip with a virtual environment","text":"<p>If you prefer using pip, create and activate a virtual environment first:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npip install healthchain\n</code></pre> <p>All the code running examples in this tutorial will show both the uv and pip versions of the commands. These are typically the same up to a factor of adding <code>uv run</code> at the beginning of the command.</p>"},{"location":"tutorials/clinicalflow/setup/#verify-installation","title":"Verify Installation","text":"<p>Create a file called <code>check_install.py</code>:</p> <pre><code>import healthchain\nfrom healthchain.io import Document\n\n# Test creating a simple document\ndoc = Document(\"Patient has a history of hypertension.\")\nprint(f\"Created document with {len(doc.text)} characters\")\n</code></pre> <p>Run it:</p> uvpip <pre><code>uv run python check_install.py\n</code></pre> <pre><code>python check_install.py\n</code></pre> <p>You should see the following output:</p> <pre><code>Created document with 38 characters\n</code></pre>"},{"location":"tutorials/clinicalflow/setup/#whats-next","title":"What's Next","text":"<p>Now that your environment is set up, let's learn about FHIR basics - the healthcare data format you'll be working with.</p>"},{"location":"tutorials/clinicalflow/testing/","title":"Test with Sandbox","text":"<p>Validate your CDS service with realistic patient data using HealthChain's sandbox.</p>"},{"location":"tutorials/clinicalflow/testing/#what-is-the-sandbox","title":"What is the Sandbox?","text":"<p>The Sandbox simulates what an EHR like Epic does - it sends CDS Hooks requests to your service with patient data. Instead of connecting to a real EHR (which requires authentication, network access, and real patients), the sandbox lets you:</p> <ul> <li>Load test data from files or generate synthetic patients</li> <li>Send CDS Hooks requests to your service (just like Epic would)</li> <li>Collect and analyze the responses</li> </ul> <p>Think of it as a \"fake EHR\" for development and testing.</p>"},{"location":"tutorials/clinicalflow/testing/#prepare-test-data","title":"Prepare Test Data","text":"<p>First, create sample data that matches what an EHR would send. This is the same CDS Hooks request format we saw in FHIR Basics.</p> <p>Create a <code>data</code> directory:</p> <pre><code>mkdir data\n</code></pre> <p>Create <code>data/test_request.json</code> - this is a complete CDS Hooks request:</p> <pre><code>{\n  \"hookInstance\": \"test-instance-001\",\n  \"hook\": \"patient-view\",\n  \"context\": {\n    \"userId\": \"Practitioner/dr-smith\",\n    \"patientId\": \"patient-001\"\n  },\n  \"prefetch\": {\n    \"patient\": {\n      \"resourceType\": \"Patient\",\n      \"id\": \"patient-001\",\n      \"name\": [{\"given\": [\"John\"], \"family\": \"Smith\"}],\n      \"birthDate\": \"1970-01-15\",\n      \"gender\": \"male\"\n    },\n    \"conditions\": {\n      \"resourceType\": \"Bundle\",\n      \"type\": \"searchset\",\n      \"entry\": [\n        {\n          \"resource\": {\n            \"resourceType\": \"Condition\",\n            \"id\": \"condition-hypertension\",\n            \"code\": {\n              \"coding\": [{\n                \"system\": \"http://snomed.info/sct\",\n                \"code\": \"38341003\",\n                \"display\": \"Hypertension\"\n              }]\n            },\n            \"subject\": {\"reference\": \"Patient/patient-001\"},\n            \"clinicalStatus\": {\"coding\": [{\"code\": \"active\"}]}\n          }\n        },\n        {\n          \"resource\": {\n            \"resourceType\": \"Condition\",\n            \"id\": \"condition-diabetes\",\n            \"code\": {\n              \"coding\": [{\n                \"system\": \"http://snomed.info/sct\",\n                \"code\": \"73211009\",\n                \"display\": \"Diabetes mellitus\"\n              }]\n            },\n            \"subject\": {\"reference\": \"Patient/patient-001\"},\n            \"clinicalStatus\": {\"coding\": [{\"code\": \"active\"}]}\n          }\n        }\n      ]\n    },\n    \"note\": \"Patient is a 65-year-old male presenting with chest pain and shortness of breath. History includes hypertension and diabetes, both well-controlled on current medications.\"\n  }\n}\n</code></pre> <p>This sample includes:</p> <ul> <li>Patient demographics - John Smith, born 1970</li> <li>Two conditions - Hypertension and Diabetes (matching what our pipeline recognizes)</li> <li>Clinical note - Free text that our NLP pipeline will process</li> </ul>"},{"location":"tutorials/clinicalflow/testing/#quick-test-with-curl","title":"Quick Test with curl","text":"<p>The fastest way to test is with the sample data directly. With your service running, send the request:</p> <pre><code>curl -X POST http://localhost:8000/cds/cds-services/patient-alerts \\\n  -H \"Content-Type: application/json\" \\\n  -d @data/test_request.json\n</code></pre> <p>You should see a response with cards for the detected conditions.</p>"},{"location":"tutorials/clinicalflow/testing/#create-a-test-script","title":"Create a Test Script","text":"<p>For more control, create <code>test_service.py</code>:</p> <pre><code>import json\nimport requests\n\n# Load the test request\nwith open(\"./data/test_request.json\") as f:\n    request_data = json.load(f)\n\n# Send to your CDS service\nresponse = requests.post(\n    \"http://localhost:8000/cds/cds-services/patient-alerts\",\n    json=request_data\n)\n\n# Analyze the response\nresult = response.json()\ncards = result.get(\"cards\", [])\n\nprint(f\"Cards returned: {len(cards)}\")\nfor card in cards:\n    indicator = card.get(\"indicator\", \"info\").upper()\n    summary = card.get(\"summary\")\n    print(f\"  [{indicator}] {summary}\")\n</code></pre>"},{"location":"tutorials/clinicalflow/testing/#run-the-test","title":"Run the Test","text":"<p>Make sure your service is running in one terminal:</p> uvpip <pre><code>uv run python app.py\n</code></pre> <pre><code>python app.py\n</code></pre> <p>Then in another terminal, run the test:</p> uvpip <pre><code>uv run python test_service.py\n</code></pre> <pre><code>python test_service.py\n</code></pre> <p>Expected output:</p> <pre><code>Cards returned: 4\n  [INFO] Condition detected: Hypertension\n  [INFO] Condition detected: Diabetes mellitus\n  [INFO] Condition detected: Chest pain\n  [INFO] Condition detected: Dyspnea\n  [WARNING] Multiple active conditions\n</code></pre> <p>The pipeline extracted four conditions from the clinical note text - exactly what we built it to do.</p>"},{"location":"tutorials/clinicalflow/testing/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorials/clinicalflow/testing/#batch-testing-with-sandboxclient","title":"Batch Testing with SandboxClient","text":"<p>For testing with multiple patients or larger datasets, use the <code>SandboxClient</code>:</p> <pre><code>from healthchain.sandbox import SandboxClient\n\n# Create a client pointing to your service\nclient = SandboxClient(\n    url=\"http://localhost:8000/cds/cds-services/patient-alerts\",\n    workflow=\"patient-view\"\n)\n\n# Load FHIR bundles - SandboxClient converts them to CDS requests\nclient.load_from_path(\"./data/bundles/\", pattern=\"*.json\")\n\n# Send all requests and collect responses\nresponses = client.send_requests()\n\n# Analyze results\nprint(f\"Tested {len(responses)} patients\")\nfor i, response in enumerate(responses):\n    cards = response.get(\"cards\", [])\n    print(f\"  Patient {i + 1}: {len(cards)} cards\")\n</code></pre>"},{"location":"tutorials/clinicalflow/testing/#save-test-results","title":"Save Test Results","text":"<p>Save results for reporting or debugging:</p> <pre><code># Save responses to files\nclient.save_results(\n    directory=\"./output/\",\n    save_request=True,\n    save_response=True\n)\n</code></pre>"},{"location":"tutorials/clinicalflow/testing/#preview-requests-before-sending","title":"Preview Requests Before Sending","text":"<p>Inspect what will be sent without actually calling the service:</p> <pre><code># Preview queued requests\npreviews = client.preview_requests(limit=5)\nfor preview in previews:\n    print(f\"Request {preview['index']}: {preview['hook']}\")\n\n# Get full request data\nrequest_data = client.get_request_data(format=\"dict\")\n</code></pre>"},{"location":"tutorials/clinicalflow/testing/#whats-next","title":"What's Next","text":"<p>Your service is tested and working! Learn about production deployment and extending your CDS service.</p>"}]}